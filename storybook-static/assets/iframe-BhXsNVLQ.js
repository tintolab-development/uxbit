var kq = Object.defineProperty;
var Dq = (e, t, r) =>
  t in e ? kq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r);
var Be = (e, t, r) => Dq(e, typeof t != 'symbol' ? t + '' : t, r);
(function () {
  const t = document.createElement('link').relList;
  if (t && t.supports && t.supports('modulepreload')) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) n(o);
  new MutationObserver((o) => {
    for (const i of o)
      if (i.type === 'childList')
        for (const a of i.addedNodes) a.tagName === 'LINK' && a.rel === 'modulepreload' && n(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function r(o) {
    const i = {};
    return (
      o.integrity && (i.integrity = o.integrity),
      o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy),
      o.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : o.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    );
  }
  function n(o) {
    if (o.ep) return;
    o.ep = !0;
    const i = r(o);
    fetch(o.href, i);
  }
})();
var Tu = {},
  Lq = Object.create,
  yl = Object.defineProperty,
  Fq = Object.getOwnPropertyDescriptor,
  Ev = Object.getOwnPropertyNames,
  Bq = Object.getPrototypeOf,
  Jq = Object.prototype.hasOwnProperty,
  s = (e, t) => yl(e, 'name', { value: t, configurable: !0 }),
  Li = ((e) =>
    typeof require < 'u'
      ? require
      : typeof Proxy < 'u'
        ? new Proxy(e, { get: (t, r) => (typeof require < 'u' ? require : t)[r] })
        : e)(function (e) {
    if (typeof require < 'u') return require.apply(this, arguments);
    throw Error('Dynamic require of "' + e + '" is not supported');
  }),
  B = (e, t) =>
    function () {
      return (t || (0, e[Ev(e)[0]])((t = { exports: {} }).exports, t), t.exports);
    },
  St = (e, t) => {
    for (var r in t) yl(e, r, { get: t[r], enumerable: !0 });
  },
  Uq = (e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let o of Ev(t))
        !Jq.call(e, o) &&
          o !== r &&
          yl(e, o, { get: () => t[o], enumerable: !(n = Fq(t, o)) || n.enumerable });
    return e;
  },
  Ge = (e, t, r) => (
    (r = e != null ? Lq(Bq(e)) : {}),
    Uq(t || !e || !e.__esModule ? yl(r, 'default', { value: e, enumerable: !0 }) : r, e)
  ),
  Vq = B({
    '../node_modules/@ngard/tiny-isequal/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.isEqual = (function () {
          var t = Object.prototype.toString,
            r = Object.getPrototypeOf,
            n = Object.getOwnPropertySymbols
              ? function (o) {
                  return Object.keys(o).concat(Object.getOwnPropertySymbols(o));
                }
              : Object.keys;
          return function (o, i) {
            return s(function a(c, d, u) {
              var p,
                f,
                m,
                h = t.call(c),
                g = t.call(d);
              if (c === d) return !0;
              if (c == null || d == null) return !1;
              if (u.indexOf(c) > -1 && u.indexOf(d) > -1) return !0;
              if (
                (u.push(c, d),
                h != g ||
                  ((p = n(c)),
                  (f = n(d)),
                  p.length != f.length ||
                    p.some(function (v) {
                      return !a(c[v], d[v], u);
                    })))
              )
                return !1;
              switch (h.slice(8, -1)) {
                case 'Symbol':
                  return c.valueOf() == d.valueOf();
                case 'Date':
                case 'Number':
                  return +c == +d || (+c != +c && +d != +d);
                case 'RegExp':
                case 'Function':
                case 'String':
                case 'Boolean':
                  return '' + c == '' + d;
                case 'Set':
                case 'Map':
                  ((p = c.entries()), (f = d.entries()));
                  do if (!a((m = p.next()).value, f.next().value, u)) return !1;
                  while (!m.done);
                  return !0;
                case 'ArrayBuffer':
                  ((c = new Uint8Array(c)), (d = new Uint8Array(d)));
                case 'DataView':
                  ((c = new Uint8Array(c.buffer)), (d = new Uint8Array(d.buffer)));
                case 'Float32Array':
                case 'Float64Array':
                case 'Int8Array':
                case 'Int16Array':
                case 'Int32Array':
                case 'Uint8Array':
                case 'Uint16Array':
                case 'Uint32Array':
                case 'Uint8ClampedArray':
                case 'Arguments':
                case 'Array':
                  if (c.length != d.length) return !1;
                  for (m = 0; m < c.length; m++)
                    if ((m in c || m in d) && (m in c != m in d || !a(c[m], d[m], u))) return !1;
                  return !0;
                case 'Object':
                  return a(r(c), r(d), u);
                default:
                  return !1;
              }
            }, 'n')(o, i, []);
          };
        })()));
    },
  }),
  Hq = B({
    '../node_modules/min-indent/index.js'(e, t) {
      t.exports = (r) => {
        const n = r.match(/^[ \t]*(?=\S)/gm);
        return n ? n.reduce((o, i) => Math.min(o, i.length), 1 / 0) : 0;
      };
    },
  }),
  zq = B({
    '../node_modules/strip-indent/index.js'(e, t) {
      var r = Hq();
      t.exports = (n) => {
        const o = r(n);
        if (o === 0) return n;
        const i = new RegExp(`^[ \\t]{${o}}`, 'gm');
        return n.replace(i, '');
      };
    },
  }),
  Gq = B({
    '../node_modules/indent-string/index.js'(e, t) {
      t.exports = (r, n = 1, o) => {
        if (((o = { indent: ' ', includeEmptyLines: !1, ...o }), typeof r != 'string'))
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof r}\``);
        if (typeof n != 'number')
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof n}\``);
        if (typeof o.indent != 'string')
          throw new TypeError(
            `Expected \`options.indent\` to be a \`string\`, got \`${typeof o.indent}\``,
          );
        if (n === 0) return r;
        const i = o.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return r.replace(i, o.indent.repeat(n));
      };
    },
  }),
  wv = B({
    '../node_modules/redent/index.js'(e, t) {
      var r = zq(),
        n = Gq();
      t.exports = (o, i = 0, a) => n(r(o), i, a);
    },
  }),
  Wq = B({
    '../node_modules/aria-query/lib/util/iteratorProxy.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      function t() {
        var r = this,
          n = 0,
          o = {
            '@@iterator': s(function () {
              return o;
            }, 'iterator'),
            next: s(function () {
              if (n < r.length) {
                var a = r[n];
                return ((n = n + 1), { done: !1, value: a });
              } else return { done: !0 };
            }, 'next'),
          };
        return o;
      }
      (s(t, 'iteratorProxy'), (e.default = t));
    },
  }),
  gi = B({
    '../node_modules/aria-query/lib/util/iterationDecorator.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = o));
      var t = r(Wq());
      function r(i) {
        return i && i.__esModule ? i : { default: i };
      }
      s(r, '_interopRequireDefault');
      function n(i) {
        '@babel/helpers - typeof';
        return (
          (n =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (a) {
                  return typeof a;
                }
              : function (a) {
                  return a &&
                    typeof Symbol == 'function' &&
                    a.constructor === Symbol &&
                    a !== Symbol.prototype
                    ? 'symbol'
                    : typeof a;
                }),
          n(i)
        );
      }
      s(n, '_typeof');
      function o(i, a) {
        return (
          typeof Symbol == 'function' &&
            n(Symbol.iterator) === 'symbol' &&
            Object.defineProperty(i, Symbol.iterator, { value: t.default.bind(a) }),
          i
        );
      }
      s(o, 'iterationDecorator');
    },
  }),
  Kq = B({
    '../node_modules/aria-query/lib/ariaPropsMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = r(gi());
      function r(f) {
        return f && f.__esModule ? f : { default: f };
      }
      s(r, '_interopRequireDefault');
      function n(f, m) {
        return d(f) || c(f, m) || i(f, m) || o();
      }
      s(n, '_slicedToArray');
      function o() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(o, '_nonIterableRest');
      function i(f, m) {
        if (f) {
          if (typeof f == 'string') return a(f, m);
          var h = {}.toString.call(f).slice(8, -1);
          return (
            h === 'Object' && f.constructor && (h = f.constructor.name),
            h === 'Map' || h === 'Set'
              ? Array.from(f)
              : h === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)
                ? a(f, m)
                : void 0
          );
        }
      }
      s(i, '_unsupportedIterableToArray');
      function a(f, m) {
        (m == null || m > f.length) && (m = f.length);
        for (var h = 0, g = Array(m); h < m; h++) g[h] = f[h];
        return g;
      }
      s(a, '_arrayLikeToArray');
      function c(f, m) {
        var h = f == null ? null : (typeof Symbol < 'u' && f[Symbol.iterator]) || f['@@iterator'];
        if (h != null) {
          var g,
            v,
            E,
            b,
            S = [],
            R = !0,
            I = !1;
          try {
            if (((E = (h = h.call(f)).next), m === 0)) {
              if (Object(h) !== h) return;
              R = !1;
            } else for (; !(R = (g = E.call(h)).done) && (S.push(g.value), S.length !== m); R = !0);
          } catch (q) {
            ((I = !0), (v = q));
          } finally {
            try {
              if (!R && h.return != null && ((b = h.return()), Object(b) !== b)) return;
            } finally {
              if (I) throw v;
            }
          }
          return S;
        }
      }
      s(c, '_iterableToArrayLimit');
      function d(f) {
        if (Array.isArray(f)) return f;
      }
      s(d, '_arrayWithHoles');
      var u = [
          ['aria-activedescendant', { type: 'id' }],
          ['aria-atomic', { type: 'boolean' }],
          ['aria-autocomplete', { type: 'token', values: ['inline', 'list', 'both', 'none'] }],
          ['aria-braillelabel', { type: 'string' }],
          ['aria-brailleroledescription', { type: 'string' }],
          ['aria-busy', { type: 'boolean' }],
          ['aria-checked', { type: 'tristate' }],
          ['aria-colcount', { type: 'integer' }],
          ['aria-colindex', { type: 'integer' }],
          ['aria-colspan', { type: 'integer' }],
          ['aria-controls', { type: 'idlist' }],
          [
            'aria-current',
            { type: 'token', values: ['page', 'step', 'location', 'date', 'time', !0, !1] },
          ],
          ['aria-describedby', { type: 'idlist' }],
          ['aria-description', { type: 'string' }],
          ['aria-details', { type: 'id' }],
          ['aria-disabled', { type: 'boolean' }],
          [
            'aria-dropeffect',
            { type: 'tokenlist', values: ['copy', 'execute', 'link', 'move', 'none', 'popup'] },
          ],
          ['aria-errormessage', { type: 'id' }],
          ['aria-expanded', { type: 'boolean', allowundefined: !0 }],
          ['aria-flowto', { type: 'idlist' }],
          ['aria-grabbed', { type: 'boolean', allowundefined: !0 }],
          [
            'aria-haspopup',
            { type: 'token', values: [!1, !0, 'menu', 'listbox', 'tree', 'grid', 'dialog'] },
          ],
          ['aria-hidden', { type: 'boolean', allowundefined: !0 }],
          ['aria-invalid', { type: 'token', values: ['grammar', !1, 'spelling', !0] }],
          ['aria-keyshortcuts', { type: 'string' }],
          ['aria-label', { type: 'string' }],
          ['aria-labelledby', { type: 'idlist' }],
          ['aria-level', { type: 'integer' }],
          ['aria-live', { type: 'token', values: ['assertive', 'off', 'polite'] }],
          ['aria-modal', { type: 'boolean' }],
          ['aria-multiline', { type: 'boolean' }],
          ['aria-multiselectable', { type: 'boolean' }],
          ['aria-orientation', { type: 'token', values: ['vertical', 'undefined', 'horizontal'] }],
          ['aria-owns', { type: 'idlist' }],
          ['aria-placeholder', { type: 'string' }],
          ['aria-posinset', { type: 'integer' }],
          ['aria-pressed', { type: 'tristate' }],
          ['aria-readonly', { type: 'boolean' }],
          [
            'aria-relevant',
            { type: 'tokenlist', values: ['additions', 'all', 'removals', 'text'] },
          ],
          ['aria-required', { type: 'boolean' }],
          ['aria-roledescription', { type: 'string' }],
          ['aria-rowcount', { type: 'integer' }],
          ['aria-rowindex', { type: 'integer' }],
          ['aria-rowspan', { type: 'integer' }],
          ['aria-selected', { type: 'boolean', allowundefined: !0 }],
          ['aria-setsize', { type: 'integer' }],
          ['aria-sort', { type: 'token', values: ['ascending', 'descending', 'none', 'other'] }],
          ['aria-valuemax', { type: 'number' }],
          ['aria-valuemin', { type: 'number' }],
          ['aria-valuenow', { type: 'number' }],
          ['aria-valuetext', { type: 'string' }],
        ],
        p = {
          entries: s(function () {
            return u;
          }, 'entries'),
          forEach: s(function (m) {
            for (
              var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                g = 0,
                v = u;
              g < v.length;
              g++
            ) {
              var E = n(v[g], 2),
                b = E[0],
                S = E[1];
              m.call(h, S, b, u);
            }
          }, 'forEach'),
          get: s(function (m) {
            var h = u.filter(function (g) {
              return g[0] === m;
            })[0];
            return h && h[1];
          }, 'get'),
          has: s(function (m) {
            return !!p.get(m);
          }, 'has'),
          keys: s(function () {
            return u.map(function (m) {
              var h = n(m, 1),
                g = h[0];
              return g;
            });
          }, 'keys'),
          values: s(function () {
            return u.map(function (m) {
              var h = n(m, 2),
                g = h[1];
              return g;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(p, p.entries());
    },
  }),
  Yq = B({
    '../node_modules/aria-query/lib/domMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = r(gi());
      function r(f) {
        return f && f.__esModule ? f : { default: f };
      }
      s(r, '_interopRequireDefault');
      function n(f, m) {
        return d(f) || c(f, m) || i(f, m) || o();
      }
      s(n, '_slicedToArray');
      function o() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(o, '_nonIterableRest');
      function i(f, m) {
        if (f) {
          if (typeof f == 'string') return a(f, m);
          var h = {}.toString.call(f).slice(8, -1);
          return (
            h === 'Object' && f.constructor && (h = f.constructor.name),
            h === 'Map' || h === 'Set'
              ? Array.from(f)
              : h === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)
                ? a(f, m)
                : void 0
          );
        }
      }
      s(i, '_unsupportedIterableToArray');
      function a(f, m) {
        (m == null || m > f.length) && (m = f.length);
        for (var h = 0, g = Array(m); h < m; h++) g[h] = f[h];
        return g;
      }
      s(a, '_arrayLikeToArray');
      function c(f, m) {
        var h = f == null ? null : (typeof Symbol < 'u' && f[Symbol.iterator]) || f['@@iterator'];
        if (h != null) {
          var g,
            v,
            E,
            b,
            S = [],
            R = !0,
            I = !1;
          try {
            if (((E = (h = h.call(f)).next), m === 0)) {
              if (Object(h) !== h) return;
              R = !1;
            } else for (; !(R = (g = E.call(h)).done) && (S.push(g.value), S.length !== m); R = !0);
          } catch (q) {
            ((I = !0), (v = q));
          } finally {
            try {
              if (!R && h.return != null && ((b = h.return()), Object(b) !== b)) return;
            } finally {
              if (I) throw v;
            }
          }
          return S;
        }
      }
      s(c, '_iterableToArrayLimit');
      function d(f) {
        if (Array.isArray(f)) return f;
      }
      s(d, '_arrayWithHoles');
      var u = [
          ['a', { reserved: !1 }],
          ['abbr', { reserved: !1 }],
          ['acronym', { reserved: !1 }],
          ['address', { reserved: !1 }],
          ['applet', { reserved: !1 }],
          ['area', { reserved: !1 }],
          ['article', { reserved: !1 }],
          ['aside', { reserved: !1 }],
          ['audio', { reserved: !1 }],
          ['b', { reserved: !1 }],
          ['base', { reserved: !0 }],
          ['bdi', { reserved: !1 }],
          ['bdo', { reserved: !1 }],
          ['big', { reserved: !1 }],
          ['blink', { reserved: !1 }],
          ['blockquote', { reserved: !1 }],
          ['body', { reserved: !1 }],
          ['br', { reserved: !1 }],
          ['button', { reserved: !1 }],
          ['canvas', { reserved: !1 }],
          ['caption', { reserved: !1 }],
          ['center', { reserved: !1 }],
          ['cite', { reserved: !1 }],
          ['code', { reserved: !1 }],
          ['col', { reserved: !0 }],
          ['colgroup', { reserved: !0 }],
          ['content', { reserved: !1 }],
          ['data', { reserved: !1 }],
          ['datalist', { reserved: !1 }],
          ['dd', { reserved: !1 }],
          ['del', { reserved: !1 }],
          ['details', { reserved: !1 }],
          ['dfn', { reserved: !1 }],
          ['dialog', { reserved: !1 }],
          ['dir', { reserved: !1 }],
          ['div', { reserved: !1 }],
          ['dl', { reserved: !1 }],
          ['dt', { reserved: !1 }],
          ['em', { reserved: !1 }],
          ['embed', { reserved: !1 }],
          ['fieldset', { reserved: !1 }],
          ['figcaption', { reserved: !1 }],
          ['figure', { reserved: !1 }],
          ['font', { reserved: !1 }],
          ['footer', { reserved: !1 }],
          ['form', { reserved: !1 }],
          ['frame', { reserved: !1 }],
          ['frameset', { reserved: !1 }],
          ['h1', { reserved: !1 }],
          ['h2', { reserved: !1 }],
          ['h3', { reserved: !1 }],
          ['h4', { reserved: !1 }],
          ['h5', { reserved: !1 }],
          ['h6', { reserved: !1 }],
          ['head', { reserved: !0 }],
          ['header', { reserved: !1 }],
          ['hgroup', { reserved: !1 }],
          ['hr', { reserved: !1 }],
          ['html', { reserved: !0 }],
          ['i', { reserved: !1 }],
          ['iframe', { reserved: !1 }],
          ['img', { reserved: !1 }],
          ['input', { reserved: !1 }],
          ['ins', { reserved: !1 }],
          ['kbd', { reserved: !1 }],
          ['keygen', { reserved: !1 }],
          ['label', { reserved: !1 }],
          ['legend', { reserved: !1 }],
          ['li', { reserved: !1 }],
          ['link', { reserved: !0 }],
          ['main', { reserved: !1 }],
          ['map', { reserved: !1 }],
          ['mark', { reserved: !1 }],
          ['marquee', { reserved: !1 }],
          ['menu', { reserved: !1 }],
          ['menuitem', { reserved: !1 }],
          ['meta', { reserved: !0 }],
          ['meter', { reserved: !1 }],
          ['nav', { reserved: !1 }],
          ['noembed', { reserved: !0 }],
          ['noscript', { reserved: !0 }],
          ['object', { reserved: !1 }],
          ['ol', { reserved: !1 }],
          ['optgroup', { reserved: !1 }],
          ['option', { reserved: !1 }],
          ['output', { reserved: !1 }],
          ['p', { reserved: !1 }],
          ['param', { reserved: !0 }],
          ['picture', { reserved: !0 }],
          ['pre', { reserved: !1 }],
          ['progress', { reserved: !1 }],
          ['q', { reserved: !1 }],
          ['rp', { reserved: !1 }],
          ['rt', { reserved: !1 }],
          ['rtc', { reserved: !1 }],
          ['ruby', { reserved: !1 }],
          ['s', { reserved: !1 }],
          ['samp', { reserved: !1 }],
          ['script', { reserved: !0 }],
          ['section', { reserved: !1 }],
          ['select', { reserved: !1 }],
          ['small', { reserved: !1 }],
          ['source', { reserved: !0 }],
          ['spacer', { reserved: !1 }],
          ['span', { reserved: !1 }],
          ['strike', { reserved: !1 }],
          ['strong', { reserved: !1 }],
          ['style', { reserved: !0 }],
          ['sub', { reserved: !1 }],
          ['summary', { reserved: !1 }],
          ['sup', { reserved: !1 }],
          ['table', { reserved: !1 }],
          ['tbody', { reserved: !1 }],
          ['td', { reserved: !1 }],
          ['textarea', { reserved: !1 }],
          ['tfoot', { reserved: !1 }],
          ['th', { reserved: !1 }],
          ['thead', { reserved: !1 }],
          ['time', { reserved: !1 }],
          ['title', { reserved: !0 }],
          ['tr', { reserved: !1 }],
          ['track', { reserved: !0 }],
          ['tt', { reserved: !1 }],
          ['u', { reserved: !1 }],
          ['ul', { reserved: !1 }],
          ['var', { reserved: !1 }],
          ['video', { reserved: !1 }],
          ['wbr', { reserved: !1 }],
          ['xmp', { reserved: !1 }],
        ],
        p = {
          entries: s(function () {
            return u;
          }, 'entries'),
          forEach: s(function (m) {
            for (
              var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                g = 0,
                v = u;
              g < v.length;
              g++
            ) {
              var E = n(v[g], 2),
                b = E[0],
                S = E[1];
              m.call(h, S, b, u);
            }
          }, 'forEach'),
          get: s(function (m) {
            var h = u.filter(function (g) {
              return g[0] === m;
            })[0];
            return h && h[1];
          }, 'get'),
          has: s(function (m) {
            return !!p.get(m);
          }, 'has'),
          keys: s(function () {
            return u.map(function (m) {
              var h = n(m, 1),
                g = h[0];
              return g;
            });
          }, 'keys'),
          values: s(function () {
            return u.map(function (m) {
              var h = n(m, 2),
                g = h[1];
              return g;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(p, p.entries());
    },
  }),
  Xq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  Qq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-activedescendant': null, 'aria-disabled': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  Zq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-disabled': null },
        relatedConcepts: [{ concept: { name: 'input' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  eM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  tM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuemax': null, 'aria-valuemin': null, 'aria-valuenow': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  rM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {
          'aria-atomic': null,
          'aria-busy': null,
          'aria-controls': null,
          'aria-current': null,
          'aria-describedby': null,
          'aria-details': null,
          'aria-dropeffect': null,
          'aria-flowto': null,
          'aria-grabbed': null,
          'aria-hidden': null,
          'aria-keyshortcuts': null,
          'aria-label': null,
          'aria-labelledby': null,
          'aria-live': null,
          'aria-owns': null,
          'aria-relevant': null,
          'aria-roledescription': null,
        },
        relatedConcepts: [
          { concept: { name: 'role' }, module: 'XHTML' },
          { concept: { name: 'type' }, module: 'Dublin Core' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [],
      };
      e.default = t;
    },
  }),
  nM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'frontmatter' }, module: 'DTB' },
          { concept: { name: 'level' }, module: 'DTB' },
          { concept: { name: 'level' }, module: 'SMIL' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  oM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  sM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'structure', 'section', 'group'],
        ],
      };
      e.default = t;
    },
  }),
  iM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  aM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  lM = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-modal': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  cM = B({
    '../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = h(Xq()),
        r = h(Qq()),
        n = h(Zq()),
        o = h(eM()),
        i = h(tM()),
        a = h(rM()),
        c = h(nM()),
        d = h(oM()),
        u = h(sM()),
        p = h(iM()),
        f = h(aM()),
        m = h(lM());
      function h(v) {
        return v && v.__esModule ? v : { default: v };
      }
      s(h, '_interopRequireDefault');
      var g = [
        ['command', t.default],
        ['composite', r.default],
        ['input', n.default],
        ['landmark', o.default],
        ['range', i.default],
        ['roletype', a.default],
        ['section', c.default],
        ['sectionhead', d.default],
        ['select', u.default],
        ['structure', p.default],
        ['widget', f.default],
        ['window', m.default],
      ];
      e.default = g;
    },
  }),
  uM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/alertRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-atomic': 'true', 'aria-live': 'assertive' },
        relatedConcepts: [{ concept: { name: 'alert' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  dM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'alert' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'alert'],
          ['roletype', 'window', 'dialog'],
        ],
      };
      e.default = t;
    },
  }),
  pM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'Device Independence Delivery Unit' } }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  fM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/articleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [{ concept: { name: 'article' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'document']],
      };
      e.default = t;
    },
  }),
  mM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { constraints: ['scoped to the body element'], name: 'header' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  yM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'blockquote' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  hM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-pressed': null,
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'button' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'image' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'reset' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'submit' }], name: 'input' },
            module: 'HTML',
          },
          { concept: { name: 'button' }, module: 'HTML' },
          { concept: { name: 'trigger' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  gM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/captionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'caption' }, module: 'HTML' }],
        requireContextRole: ['figure', 'grid', 'table'],
        requiredContextRole: ['figure', 'grid', 'table'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  bM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/cellRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-colindex': null,
          'aria-colspan': null,
          'aria-rowindex': null,
          'aria-rowspan': null,
        },
        relatedConcepts: [
          {
            concept: { constraints: ['ancestor table element has table role'], name: 'td' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  vM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'checkbox' }], name: 'input' },
            module: 'HTML',
          },
          { concept: { name: 'option' }, module: 'ARIA' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  TM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/codeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'code' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  EM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-sort': null },
        relatedConcepts: [
          { concept: { name: 'th' }, module: 'HTML' },
          {
            concept: { attributes: [{ name: 'scope', value: 'col' }], name: 'th' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'scope', value: 'colgroup' }], name: 'th' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'structure', 'section', 'cell', 'gridcell'],
          ['roletype', 'widget', 'gridcell'],
          ['roletype', 'structure', 'sectionhead'],
        ],
      };
      e.default = t;
    },
  }),
  wM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-autocomplete': null,
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-expanded': 'false',
          'aria-haspopup': 'listbox',
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'email' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'search' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'tel' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'text' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'multiple' },
                { constraints: ['undefined'], name: 'size' },
              ],
              constraints: [
                'the multiple attribute is not set and the size attribute does not have a value greater than 1',
              ],
              name: 'select',
            },
            module: 'HTML',
          },
          { concept: { name: 'select' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-controls': null, 'aria-expanded': 'false' },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  SM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              constraints: ['scoped to the body element', 'scoped to the main element'],
              name: 'aside',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-label' }],
              constraints: [
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'aside',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              constraints: [
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'aside',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  _M = B({
    '../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { constraints: ['scoped to the body element'], name: 'footer' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  AM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'dd' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  RM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'del' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  xM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'dialog' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'window']],
      };
      e.default = t;
    },
  }),
  PM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ module: 'DAISY Guide' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'list']],
      };
      e.default = t;
    },
  }),
  OM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/documentRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'Device Independence Delivery Unit' } },
          { concept: { name: 'html' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  CM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'em' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  IM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/feedRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['article']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'list']],
      };
      e.default = t;
    },
  }),
  NM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/figureRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'figure' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  qM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/formRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'aria-label' }], name: 'form' },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              name: 'form',
            },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['set'], name: 'name' }], name: 'form' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  MM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/genericRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [
          { concept: { name: 'a' }, module: 'HTML' },
          { concept: { name: 'area' }, module: 'HTML' },
          { concept: { name: 'aside' }, module: 'HTML' },
          { concept: { name: 'b' }, module: 'HTML' },
          { concept: { name: 'bdo' }, module: 'HTML' },
          { concept: { name: 'body' }, module: 'HTML' },
          { concept: { name: 'data' }, module: 'HTML' },
          { concept: { name: 'div' }, module: 'HTML' },
          {
            concept: {
              constraints: [
                'scoped to the main element',
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'footer',
            },
            module: 'HTML',
          },
          {
            concept: {
              constraints: [
                'scoped to the main element',
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'header',
            },
            module: 'HTML',
          },
          { concept: { name: 'hgroup' }, module: 'HTML' },
          { concept: { name: 'i' }, module: 'HTML' },
          { concept: { name: 'pre' }, module: 'HTML' },
          { concept: { name: 'q' }, module: 'HTML' },
          { concept: { name: 'samp' }, module: 'HTML' },
          { concept: { name: 'section' }, module: 'HTML' },
          { concept: { name: 'small' }, module: 'HTML' },
          { concept: { name: 'span' }, module: 'HTML' },
          { concept: { name: 'u' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  jM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/gridRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-multiselectable': null, 'aria-readonly': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'structure', 'section', 'table'],
        ],
      };
      e.default = t;
    },
  }),
  $M = B({
    '../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-selected': null,
        },
        relatedConcepts: [
          {
            concept: {
              constraints: [
                'ancestor table element has grid role',
                'ancestor table element has treegrid role',
              ],
              name: 'td',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  kM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/groupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-activedescendant': null, 'aria-disabled': null },
        relatedConcepts: [
          { concept: { name: 'details' }, module: 'HTML' },
          { concept: { name: 'fieldset' }, module: 'HTML' },
          { concept: { name: 'optgroup' }, module: 'HTML' },
          { concept: { name: 'address' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  DM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/headingRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-level': '2' },
        relatedConcepts: [
          { concept: { name: 'h1' }, module: 'HTML' },
          { concept: { name: 'h2' }, module: 'HTML' },
          { concept: { name: 'h3' }, module: 'HTML' },
          { concept: { name: 'h4' }, module: 'HTML' },
          { concept: { name: 'h5' }, module: 'HTML' },
          { concept: { name: 'h6' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-level': '2' },
        superClass: [['roletype', 'structure', 'sectionhead']],
      };
      e.default = t;
    },
  }),
  LM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/imgRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'alt' }], name: 'img' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['undefined'], name: 'alt' }], name: 'img' },
            module: 'HTML',
          },
          { concept: { name: 'imggroup' }, module: 'DTB' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  FM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'ins' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  BM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/linkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-disabled': null, 'aria-expanded': null, 'aria-haspopup': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'href' }], name: 'a' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['set'], name: 'href' }], name: 'area' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  JM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/listRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'menu' }, module: 'HTML' },
          { concept: { name: 'ol' }, module: 'HTML' },
          { concept: { name: 'ul' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['listitem']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  UM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-invalid': null,
          'aria-multiselectable': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-orientation': 'vertical',
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [{ constraints: ['>1'], name: 'size' }],
              constraints: ['the size attribute value is greater than 1'],
              name: 'select',
            },
            module: 'HTML',
          },
          { concept: { attributes: [{ name: 'multiple' }], name: 'select' }, module: 'HTML' },
          { concept: { name: 'datalist' }, module: 'HTML' },
          { concept: { name: 'list' }, module: 'ARIA' },
          { concept: { name: 'select' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['option', 'group'], ['option']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  VM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-level': null, 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [
          {
            concept: {
              constraints: [
                'direct descendant of ol',
                'direct descendant of ul',
                'direct descendant of menu',
              ],
              name: 'li',
            },
            module: 'HTML',
          },
          { concept: { name: 'item' }, module: 'XForms' },
        ],
        requireContextRole: ['directory', 'list'],
        requiredContextRole: ['directory', 'list'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  HM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/logRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-live': 'polite' },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  zM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/mainRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'main' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  GM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/markRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
        },
        relatedConcepts: [{ concept: { name: 'mark' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  WM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  KM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/mathRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'math' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  YM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menuRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'vertical' },
        relatedConcepts: [
          { concept: { name: 'MENU' }, module: 'JAPI' },
          { concept: { name: 'list' }, module: 'ARIA' },
          { concept: { name: 'select' }, module: 'XForms' },
          { concept: { name: 'sidebar' }, module: 'DTB' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
          ['menuitem', 'group'],
          ['menuitemradio', 'group'],
          ['menuitemcheckbox', 'group'],
          ['menuitem'],
          ['menuitemcheckbox'],
          ['menuitemradio'],
        ],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  XM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'horizontal' },
        relatedConcepts: [{ concept: { name: 'toolbar' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
          ['menuitem', 'group'],
          ['menuitemradio', 'group'],
          ['menuitemcheckbox', 'group'],
          ['menuitem'],
          ['menuitemcheckbox'],
          ['menuitemradio'],
        ],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select', 'menu'],
          ['roletype', 'structure', 'section', 'group', 'select', 'menu'],
        ],
      };
      e.default = t;
    },
  }),
  QM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-posinset': null,
          'aria-setsize': null,
        },
        relatedConcepts: [
          { concept: { name: 'MENU_ITEM' }, module: 'JAPI' },
          { concept: { name: 'listitem' }, module: 'ARIA' },
          { concept: { name: 'option' }, module: 'ARIA' },
        ],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  ZM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'menuitem' }, module: 'ARIA' }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [
          ['roletype', 'widget', 'input', 'checkbox'],
          ['roletype', 'widget', 'command', 'menuitem'],
        ],
      };
      e.default = t;
    },
  }),
  ej = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'menuitem' }, module: 'ARIA' }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [
          ['roletype', 'widget', 'input', 'checkbox', 'menuitemcheckbox'],
          ['roletype', 'widget', 'command', 'menuitem', 'menuitemcheckbox'],
          ['roletype', 'widget', 'input', 'radio'],
        ],
      };
      e.default = t;
    },
  }),
  tj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/meterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuetext': null, 'aria-valuemax': '100', 'aria-valuemin': '0' },
        relatedConcepts: [{ concept: { name: 'meter' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-valuenow': null },
        superClass: [['roletype', 'structure', 'range']],
      };
      e.default = t;
    },
  }),
  rj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'nav' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  nj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/noneRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [],
      };
      e.default = t;
    },
  }),
  oj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/noteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  sj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/optionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-posinset': null,
          'aria-setsize': null,
          'aria-selected': 'false',
        },
        relatedConcepts: [
          { concept: { name: 'item' }, module: 'XForms' },
          { concept: { name: 'listitem' }, module: 'ARIA' },
          { concept: { name: 'option' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-selected': 'false' },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  ij = B({
    '../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'p' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  aj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [
          { concept: { attributes: [{ name: 'alt', value: '' }], name: 'img' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  lj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuetext': null },
        relatedConcepts: [
          { concept: { name: 'progress' }, module: 'HTML' },
          { concept: { name: 'status' }, module: 'ARIA' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'range'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  cj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/radioRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-checked': null, 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'radio' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  uj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [{ concept: { name: 'list' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['radio']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  dj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/regionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-label' }],
              name: 'section',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              name: 'section',
            },
            module: 'HTML',
          },
          { concept: { name: 'Device Independence Glossart perceivable unit' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  pj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/rowRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-colindex': null,
          'aria-expanded': null,
          'aria-level': null,
          'aria-posinset': null,
          'aria-rowindex': null,
          'aria-selected': null,
          'aria-setsize': null,
        },
        relatedConcepts: [{ concept: { name: 'tr' }, module: 'HTML' }],
        requireContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
        requiredContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
        requiredOwnedElements: [['cell'], ['columnheader'], ['gridcell'], ['rowheader']],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'group'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  fj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'tbody' }, module: 'HTML' },
          { concept: { name: 'tfoot' }, module: 'HTML' },
          { concept: { name: 'thead' }, module: 'HTML' },
        ],
        requireContextRole: ['grid', 'table', 'treegrid'],
        requiredContextRole: ['grid', 'table', 'treegrid'],
        requiredOwnedElements: [['row']],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  mj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-sort': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'scope', value: 'row' }], name: 'th' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'scope', value: 'rowgroup' }], name: 'th' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row', 'rowgroup'],
        requiredContextRole: ['row', 'rowgroup'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'structure', 'section', 'cell', 'gridcell'],
          ['roletype', 'widget', 'gridcell'],
          ['roletype', 'structure', 'sectionhead'],
        ],
      };
      e.default = t;
    },
  }),
  yj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-valuetext': null,
          'aria-orientation': 'vertical',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-controls': null, 'aria-valuenow': null },
        superClass: [
          ['roletype', 'structure', 'range'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  hj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/searchRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  gj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'search' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'input', 'textbox']],
      };
      e.default = t;
    },
  }),
  bj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-orientation': 'horizontal',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
          'aria-valuenow': null,
          'aria-valuetext': null,
        },
        relatedConcepts: [{ concept: { name: 'hr' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  vj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-valuetext': null,
          'aria-orientation': 'horizontal',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'range' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-valuenow': null },
        superClass: [
          ['roletype', 'widget', 'input'],
          ['roletype', 'structure', 'range'],
        ],
      };
      e.default = t;
    },
  }),
  Tj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-valuetext': null,
          'aria-valuenow': '0',
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'number' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'widget', 'input'],
          ['roletype', 'structure', 'range'],
        ],
      };
      e.default = t;
    },
  }),
  Ej = B({
    '../node_modules/aria-query/lib/etc/roles/literal/statusRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-atomic': 'true', 'aria-live': 'polite' },
        relatedConcepts: [{ concept: { name: 'output' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  wj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/strongRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'strong' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Sj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'sub' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  _j = B({
    '../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'sup' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Aj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/switchRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'button' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input', 'checkbox']],
      };
      e.default = t;
    },
  }),
  Rj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tabRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-posinset': null,
          'aria-setsize': null,
          'aria-selected': 'false',
        },
        relatedConcepts: [],
        requireContextRole: ['tablist'],
        requiredContextRole: ['tablist'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'sectionhead'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  xj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tableRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-colcount': null, 'aria-rowcount': null },
        relatedConcepts: [{ concept: { name: 'table' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Pj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-level': null,
          'aria-multiselectable': null,
          'aria-orientation': 'horizontal',
        },
        relatedConcepts: [{ module: 'DAISY', concept: { name: 'guide' } }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['tab']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite']],
      };
      e.default = t;
    },
  }),
  Oj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Cj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/termRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'dfn' }, module: 'HTML' },
          { concept: { name: 'dt' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Ij = B({
    '../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-autocomplete': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-multiline': null,
          'aria-placeholder': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'type' },
                { constraints: ['undefined'], name: 'list' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'email' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'tel' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'text' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          { concept: { name: 'input' }, module: 'XForms' },
          { concept: { name: 'textarea' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  Nj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/timeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'time' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  qj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/timerRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'status']],
      };
      e.default = t;
    },
  }),
  Mj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'horizontal' },
        relatedConcepts: [{ concept: { name: 'menubar' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group']],
      };
      e.default = t;
    },
  }),
  jj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  $j = B({
    '../node_modules/aria-query/lib/etc/roles/literal/treeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-multiselectable': null,
          'aria-required': null,
          'aria-orientation': 'vertical',
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['treeitem', 'group'], ['treeitem']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  kj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'grid'],
          ['roletype', 'structure', 'section', 'table', 'grid'],
          ['roletype', 'widget', 'composite', 'select', 'tree'],
          ['roletype', 'structure', 'section', 'group', 'select', 'tree'],
        ],
      };
      e.default = t;
    },
  }),
  Dj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-expanded': null, 'aria-haspopup': null },
        relatedConcepts: [],
        requireContextRole: ['group', 'tree'],
        requiredContextRole: ['group', 'tree'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-selected': null },
        superClass: [
          ['roletype', 'structure', 'section', 'listitem'],
          ['roletype', 'widget', 'input', 'option'],
        ],
      };
      e.default = t;
    },
  }),
  Lj = B({
    '../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = Y(uM()),
        r = Y(dM()),
        n = Y(pM()),
        o = Y(fM()),
        i = Y(mM()),
        a = Y(yM()),
        c = Y(hM()),
        d = Y(gM()),
        u = Y(bM()),
        p = Y(vM()),
        f = Y(TM()),
        m = Y(EM()),
        h = Y(wM()),
        g = Y(SM()),
        v = Y(_M()),
        E = Y(AM()),
        b = Y(RM()),
        S = Y(xM()),
        R = Y(PM()),
        I = Y(OM()),
        q = Y(CM()),
        P = Y(IM()),
        A = Y(NM()),
        w = Y(qM()),
        _ = Y(MM()),
        $ = Y(jM()),
        N = Y($M()),
        V = Y(kM()),
        H = Y(DM()),
        x = Y(LM()),
        D = Y(FM()),
        F = Y(BM()),
        k = Y(JM()),
        K = Y(UM()),
        X = Y(VM()),
        se = Y(HM()),
        ie = Y(zM()),
        W = Y(GM()),
        ae = Y(WM()),
        be = Y(KM()),
        ue = Y(YM()),
        ee = Y(XM()),
        xe = Y(QM()),
        Pe = Y(ZM()),
        He = Y(ej()),
        Ke = Y(tj()),
        J = Y(rj()),
        Q = Y(nj()),
        re = Y(oj()),
        oe = Y(sj()),
        ne = Y(ij()),
        de = Y(aj()),
        ye = Y(lj()),
        pe = Y(cj()),
        Fe = Y(uj()),
        ot = Y(dj()),
        ft = Y(pj()),
        _t = Y(fj()),
        st = Y(mj()),
        mt = Y(yj()),
        yt = Y(hj()),
        ht = Y(gj()),
        sn = Y(bj()),
        Go = Y(vj()),
        an = Y(Tj()),
        Wo = Y(Ej()),
        Ko = Y(wj()),
        Yo = Y(Sj()),
        ln = Y(_j()),
        Xo = Y(Aj()),
        Qo = Y(Rj()),
        Zo = Y(xj()),
        es = Y(Pj()),
        ts = Y(Oj()),
        rs = Y(Cj()),
        ns = Y(Ij()),
        os = Y(Nj()),
        ss = Y(qj()),
        is = Y(Mj()),
        as = Y(jj()),
        ls = Y($j()),
        pr = Y(kj()),
        cn = Y(Dj());
      function Y(Mt) {
        return Mt && Mt.__esModule ? Mt : { default: Mt };
      }
      s(Y, '_interopRequireDefault');
      var le = [
        ['alert', t.default],
        ['alertdialog', r.default],
        ['application', n.default],
        ['article', o.default],
        ['banner', i.default],
        ['blockquote', a.default],
        ['button', c.default],
        ['caption', d.default],
        ['cell', u.default],
        ['checkbox', p.default],
        ['code', f.default],
        ['columnheader', m.default],
        ['combobox', h.default],
        ['complementary', g.default],
        ['contentinfo', v.default],
        ['definition', E.default],
        ['deletion', b.default],
        ['dialog', S.default],
        ['directory', R.default],
        ['document', I.default],
        ['emphasis', q.default],
        ['feed', P.default],
        ['figure', A.default],
        ['form', w.default],
        ['generic', _.default],
        ['grid', $.default],
        ['gridcell', N.default],
        ['group', V.default],
        ['heading', H.default],
        ['img', x.default],
        ['insertion', D.default],
        ['link', F.default],
        ['list', k.default],
        ['listbox', K.default],
        ['listitem', X.default],
        ['log', se.default],
        ['main', ie.default],
        ['mark', W.default],
        ['marquee', ae.default],
        ['math', be.default],
        ['menu', ue.default],
        ['menubar', ee.default],
        ['menuitem', xe.default],
        ['menuitemcheckbox', Pe.default],
        ['menuitemradio', He.default],
        ['meter', Ke.default],
        ['navigation', J.default],
        ['none', Q.default],
        ['note', re.default],
        ['option', oe.default],
        ['paragraph', ne.default],
        ['presentation', de.default],
        ['progressbar', ye.default],
        ['radio', pe.default],
        ['radiogroup', Fe.default],
        ['region', ot.default],
        ['row', ft.default],
        ['rowgroup', _t.default],
        ['rowheader', st.default],
        ['scrollbar', mt.default],
        ['search', yt.default],
        ['searchbox', ht.default],
        ['separator', sn.default],
        ['slider', Go.default],
        ['spinbutton', an.default],
        ['status', Wo.default],
        ['strong', Ko.default],
        ['subscript', Yo.default],
        ['superscript', ln.default],
        ['switch', Xo.default],
        ['tab', Qo.default],
        ['table', Zo.default],
        ['tablist', es.default],
        ['tabpanel', ts.default],
        ['term', rs.default],
        ['textbox', ns.default],
        ['time', os.default],
        ['timer', ss.default],
        ['toolbar', is.default],
        ['tooltip', as.default],
        ['tree', ls.default],
        ['treegrid', pr.default],
        ['treeitem', cn.default],
      ];
      e.default = le;
    },
  }),
  Fj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'abstract [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Bj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'acknowledgments [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Jj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'afterword [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Uj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'appendix [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Vj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'referrer [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  Hj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'EPUB biblioentry [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: ['doc-bibliography'],
        requiredContextRole: ['doc-bibliography'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'listitem']],
      };
      e.default = t;
    },
  }),
  zj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'bibliography [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['doc-biblioentry']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Gj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'biblioref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  Wj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'chapter [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Kj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'colophon [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Yj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'conclusion [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Xj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'cover [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'img']],
      };
      e.default = t;
    },
  }),
  Qj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'credit [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Zj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'credits [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  e$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'dedication [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  t$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'rearnote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: ['doc-endnotes'],
        requiredContextRole: ['doc-endnotes'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'listitem']],
      };
      e.default = t;
    },
  }),
  r$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'rearnotes [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['doc-endnote']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  n$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'epigraph [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  o$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'epilogue [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  s$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'errata [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  i$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  a$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'footnote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  l$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'foreword [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  c$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'glossary [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['definition'], ['term']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  u$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'glossref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  d$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'index [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  p$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'introduction [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  f$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'noteref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  m$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'notice [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'note']],
      };
      e.default = t;
    },
  }),
  y$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'pagebreak [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'separator']],
      };
      e.default = t;
    },
  }),
  h$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  g$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  b$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'page-list [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  v$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'part [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  T$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'preface [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  E$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'prologue [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  w$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'pullquote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['none']],
      };
      e.default = t;
    },
  }),
  S$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'qna [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  _$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'subtitle [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'sectionhead']],
      };
      e.default = t;
    },
  }),
  A$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'help [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'note']],
      };
      e.default = t;
    },
  }),
  R$ = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'toc [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  x$ = B({
    '../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = ee(Fj()),
        r = ee(Bj()),
        n = ee(Jj()),
        o = ee(Uj()),
        i = ee(Vj()),
        a = ee(Hj()),
        c = ee(zj()),
        d = ee(Gj()),
        u = ee(Wj()),
        p = ee(Kj()),
        f = ee(Yj()),
        m = ee(Xj()),
        h = ee(Qj()),
        g = ee(Zj()),
        v = ee(e$()),
        E = ee(t$()),
        b = ee(r$()),
        S = ee(n$()),
        R = ee(o$()),
        I = ee(s$()),
        q = ee(i$()),
        P = ee(a$()),
        A = ee(l$()),
        w = ee(c$()),
        _ = ee(u$()),
        $ = ee(d$()),
        N = ee(p$()),
        V = ee(f$()),
        H = ee(m$()),
        x = ee(y$()),
        D = ee(h$()),
        F = ee(g$()),
        k = ee(b$()),
        K = ee(v$()),
        X = ee(T$()),
        se = ee(E$()),
        ie = ee(w$()),
        W = ee(S$()),
        ae = ee(_$()),
        be = ee(A$()),
        ue = ee(R$());
      function ee(Pe) {
        return Pe && Pe.__esModule ? Pe : { default: Pe };
      }
      s(ee, '_interopRequireDefault');
      var xe = [
        ['doc-abstract', t.default],
        ['doc-acknowledgments', r.default],
        ['doc-afterword', n.default],
        ['doc-appendix', o.default],
        ['doc-backlink', i.default],
        ['doc-biblioentry', a.default],
        ['doc-bibliography', c.default],
        ['doc-biblioref', d.default],
        ['doc-chapter', u.default],
        ['doc-colophon', p.default],
        ['doc-conclusion', f.default],
        ['doc-cover', m.default],
        ['doc-credit', h.default],
        ['doc-credits', g.default],
        ['doc-dedication', v.default],
        ['doc-endnote', E.default],
        ['doc-endnotes', b.default],
        ['doc-epigraph', S.default],
        ['doc-epilogue', R.default],
        ['doc-errata', I.default],
        ['doc-example', q.default],
        ['doc-footnote', P.default],
        ['doc-foreword', A.default],
        ['doc-glossary', w.default],
        ['doc-glossref', _.default],
        ['doc-index', $.default],
        ['doc-introduction', N.default],
        ['doc-noteref', V.default],
        ['doc-notice', H.default],
        ['doc-pagebreak', x.default],
        ['doc-pagefooter', D.default],
        ['doc-pageheader', F.default],
        ['doc-pagelist', k.default],
        ['doc-part', K.default],
        ['doc-preface', X.default],
        ['doc-prologue', se.default],
        ['doc-pullquote', ie.default],
        ['doc-qna', W.default],
        ['doc-subtitle', ae.default],
        ['doc-tip', be.default],
        ['doc-toc', ue.default],
      ];
      e.default = xe;
    },
  }),
  P$ = B({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [
          { module: 'GRAPHICS', concept: { name: 'graphics-object' } },
          { module: 'ARIA', concept: { name: 'img' } },
          { module: 'ARIA', concept: { name: 'article' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'document']],
      };
      e.default = t;
    },
  }),
  O$ = B({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [
          { module: 'GRAPHICS', concept: { name: 'graphics-document' } },
          { module: 'ARIA', concept: { name: 'group' } },
          { module: 'ARIA', concept: { name: 'img' } },
          { module: 'GRAPHICS', concept: { name: 'graphics-symbol' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group']],
      };
      e.default = t;
    },
  }),
  C$ = B({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'img']],
      };
      e.default = t;
    },
  }),
  I$ = B({
    '../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = o(P$()),
        r = o(O$()),
        n = o(C$());
      function o(a) {
        return a && a.__esModule ? a : { default: a };
      }
      s(o, '_interopRequireDefault');
      var i = [
        ['graphics-document', t.default],
        ['graphics-object', r.default],
        ['graphics-symbol', n.default],
      ];
      e.default = i;
    },
  }),
  Op = B({
    '../node_modules/aria-query/lib/rolesMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = a(cM()),
        r = a(Lj()),
        n = a(x$()),
        o = a(I$()),
        i = a(gi());
      function a(E) {
        return E && E.__esModule ? E : { default: E };
      }
      s(a, '_interopRequireDefault');
      function c(E, b) {
        var S = (typeof Symbol < 'u' && E[Symbol.iterator]) || E['@@iterator'];
        if (!S) {
          if (Array.isArray(E) || (S = p(E)) || (b && E && typeof E.length == 'number')) {
            S && (E = S);
            var R = 0,
              I = s(function () {}, 'F');
            return {
              s: I,
              n: s(function () {
                return R >= E.length ? { done: !0 } : { done: !1, value: E[R++] };
              }, 'n'),
              e: s(function (_) {
                throw _;
              }, 'e'),
              f: I,
            };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var q,
          P = !0,
          A = !1;
        return {
          s: s(function () {
            S = S.call(E);
          }, 's'),
          n: s(function () {
            var _ = S.next();
            return ((P = _.done), _);
          }, 'n'),
          e: s(function (_) {
            ((A = !0), (q = _));
          }, 'e'),
          f: s(function () {
            try {
              P || S.return == null || S.return();
            } finally {
              if (A) throw q;
            }
          }, 'f'),
        };
      }
      s(c, '_createForOfIteratorHelper');
      function d(E, b) {
        return h(E) || m(E, b) || p(E, b) || u();
      }
      s(d, '_slicedToArray');
      function u() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(u, '_nonIterableRest');
      function p(E, b) {
        if (E) {
          if (typeof E == 'string') return f(E, b);
          var S = {}.toString.call(E).slice(8, -1);
          return (
            S === 'Object' && E.constructor && (S = E.constructor.name),
            S === 'Map' || S === 'Set'
              ? Array.from(E)
              : S === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(S)
                ? f(E, b)
                : void 0
          );
        }
      }
      s(p, '_unsupportedIterableToArray');
      function f(E, b) {
        (b == null || b > E.length) && (b = E.length);
        for (var S = 0, R = Array(b); S < b; S++) R[S] = E[S];
        return R;
      }
      s(f, '_arrayLikeToArray');
      function m(E, b) {
        var S = E == null ? null : (typeof Symbol < 'u' && E[Symbol.iterator]) || E['@@iterator'];
        if (S != null) {
          var R,
            I,
            q,
            P,
            A = [],
            w = !0,
            _ = !1;
          try {
            if (((q = (S = S.call(E)).next), b === 0)) {
              if (Object(S) !== S) return;
              w = !1;
            } else for (; !(w = (R = q.call(S)).done) && (A.push(R.value), A.length !== b); w = !0);
          } catch ($) {
            ((_ = !0), (I = $));
          } finally {
            try {
              if (!w && S.return != null && ((P = S.return()), Object(P) !== P)) return;
            } finally {
              if (_) throw I;
            }
          }
          return A;
        }
      }
      s(m, '_iterableToArrayLimit');
      function h(E) {
        if (Array.isArray(E)) return E;
      }
      s(h, '_arrayWithHoles');
      var g = [].concat(t.default, r.default, n.default, o.default);
      g.forEach(function (E) {
        var b = d(E, 2),
          S = b[1],
          R = c(S.superClass),
          I;
        try {
          for (R.s(); !(I = R.n()).done; ) {
            var q = I.value,
              P = c(q),
              A;
            try {
              var w = s(function () {
                var $ = A.value,
                  N = g.filter(function (F) {
                    var k = d(F, 1),
                      K = k[0];
                    return K === $;
                  })[0];
                if (N)
                  for (var V = N[1], H = 0, x = Object.keys(V.props); H < x.length; H++) {
                    var D = x[H];
                    Object.prototype.hasOwnProperty.call(S.props, D) || (S.props[D] = V.props[D]);
                  }
              }, '_loop');
              for (P.s(); !(A = P.n()).done; ) w();
            } catch (_) {
              P.e(_);
            } finally {
              P.f();
            }
          }
        } catch (_) {
          R.e(_);
        } finally {
          R.f();
        }
      });
      var v = {
        entries: s(function () {
          return g;
        }, 'entries'),
        forEach: s(function (b) {
          var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
            R = c(g),
            I;
          try {
            for (R.s(); !(I = R.n()).done; ) {
              var q = d(I.value, 2),
                P = q[0],
                A = q[1];
              b.call(S, A, P, g);
            }
          } catch (w) {
            R.e(w);
          } finally {
            R.f();
          }
        }, 'forEach'),
        get: s(function (b) {
          var S = g.filter(function (R) {
            return R[0] === b;
          })[0];
          return S && S[1];
        }, 'get'),
        has: s(function (b) {
          return !!v.get(b);
        }, 'has'),
        keys: s(function () {
          return g.map(function (b) {
            var S = d(b, 1),
              R = S[0];
            return R;
          });
        }, 'keys'),
        values: s(function () {
          return g.map(function (b) {
            var S = d(b, 2),
              R = S[1];
            return R;
          });
        }, 'values'),
      };
      e.default = (0, i.default)(v, v.entries());
    },
  }),
  N$ = B({
    '../node_modules/aria-query/lib/elementRoleMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = n(gi()),
        r = n(Op());
      function n(P) {
        return P && P.__esModule ? P : { default: P };
      }
      s(n, '_interopRequireDefault');
      function o(P, A) {
        return u(P) || d(P, A) || a(P, A) || i();
      }
      s(o, '_slicedToArray');
      function i() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(i, '_nonIterableRest');
      function a(P, A) {
        if (P) {
          if (typeof P == 'string') return c(P, A);
          var w = {}.toString.call(P).slice(8, -1);
          return (
            w === 'Object' && P.constructor && (w = P.constructor.name),
            w === 'Map' || w === 'Set'
              ? Array.from(P)
              : w === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w)
                ? c(P, A)
                : void 0
          );
        }
      }
      s(a, '_unsupportedIterableToArray');
      function c(P, A) {
        (A == null || A > P.length) && (A = P.length);
        for (var w = 0, _ = Array(A); w < A; w++) _[w] = P[w];
        return _;
      }
      s(c, '_arrayLikeToArray');
      function d(P, A) {
        var w = P == null ? null : (typeof Symbol < 'u' && P[Symbol.iterator]) || P['@@iterator'];
        if (w != null) {
          var _,
            $,
            N,
            V,
            H = [],
            x = !0,
            D = !1;
          try {
            if (((N = (w = w.call(P)).next), A === 0)) {
              if (Object(w) !== w) return;
              x = !1;
            } else for (; !(x = (_ = N.call(w)).done) && (H.push(_.value), H.length !== A); x = !0);
          } catch (F) {
            ((D = !0), ($ = F));
          } finally {
            try {
              if (!x && w.return != null && ((V = w.return()), Object(V) !== V)) return;
            } finally {
              if (D) throw $;
            }
          }
          return H;
        }
      }
      s(d, '_iterableToArrayLimit');
      function u(P) {
        if (Array.isArray(P)) return P;
      }
      s(u, '_arrayWithHoles');
      var p = [],
        f = r.default.keys();
      for (b = 0; b < f.length; b++)
        if (((m = f[b]), (h = r.default.get(m)), h))
          for (
            g = [].concat(h.baseConcepts, h.relatedConcepts),
              v = s(function () {
                var A = g[E];
                if (A.module === 'HTML') {
                  var w = A.concept;
                  if (w) {
                    var _ = p.filter(function (H) {
                        return R(H[0], w);
                      })[0],
                      $;
                    _ ? ($ = _[1]) : ($ = []);
                    for (var N = !0, V = 0; V < $.length; V++)
                      if ($[V] === m) {
                        N = !1;
                        break;
                      }
                    (N && $.push(m), _ || p.push([w, $]));
                  }
                }
              }, '_loop'),
              E = 0;
            E < g.length;
            E++
          )
            v();
      var m,
        h,
        g,
        v,
        E,
        b,
        S = {
          entries: s(function () {
            return p;
          }, 'entries'),
          forEach: s(function (A) {
            for (
              var w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                _ = 0,
                $ = p;
              _ < $.length;
              _++
            ) {
              var N = o($[_], 2),
                V = N[0],
                H = N[1];
              A.call(w, H, V, p);
            }
          }, 'forEach'),
          get: s(function (A) {
            var w = p.filter(function (_) {
              return A.name === _[0].name && q(A.attributes, _[0].attributes);
            })[0];
            return w && w[1];
          }, 'get'),
          has: s(function (A) {
            return !!S.get(A);
          }, 'has'),
          keys: s(function () {
            return p.map(function (A) {
              var w = o(A, 1),
                _ = w[0];
              return _;
            });
          }, 'keys'),
          values: s(function () {
            return p.map(function (A) {
              var w = o(A, 2),
                _ = w[1];
              return _;
            });
          }, 'values'),
        };
      function R(P, A) {
        return (
          P.name === A.name && I(P.constraints, A.constraints) && q(P.attributes, A.attributes)
        );
      }
      s(R, 'ariaRoleRelationConceptEquals');
      function I(P, A) {
        if ((P === void 0 && A !== void 0) || (P !== void 0 && A === void 0)) return !1;
        if (P !== void 0 && A !== void 0) {
          if (P.length !== A.length) return !1;
          for (var w = 0; w < P.length; w++) if (P[w] !== A[w]) return !1;
        }
        return !0;
      }
      s(I, 'ariaRoleRelationConstraintsEquals');
      function q(P, A) {
        if ((P === void 0 && A !== void 0) || (P !== void 0 && A === void 0)) return !1;
        if (P !== void 0 && A !== void 0) {
          if (P.length !== A.length) return !1;
          for (var w = 0; w < P.length; w++) {
            if (
              P[w].name !== A[w].name ||
              P[w].value !== A[w].value ||
              (P[w].constraints === void 0 && A[w].constraints !== void 0) ||
              (P[w].constraints !== void 0 && A[w].constraints === void 0)
            )
              return !1;
            if (P[w].constraints !== void 0 && A[w].constraints !== void 0) {
              if (P[w].constraints.length !== A[w].constraints.length) return !1;
              for (var _ = 0; _ < P[w].constraints.length; _++)
                if (P[w].constraints[_] !== A[w].constraints[_]) return !1;
            }
          }
        }
        return !0;
      }
      (s(q, 'ariaRoleRelationConceptAttributeEquals'),
        (e.default = (0, t.default)(S, S.entries())));
    },
  }),
  q$ = B({
    '../node_modules/aria-query/lib/roleElementMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = n(gi()),
        r = n(Op());
      function n(q) {
        return q && q.__esModule ? q : { default: q };
      }
      s(n, '_interopRequireDefault');
      function o(q, P) {
        return u(q) || d(q, P) || a(q, P) || i();
      }
      s(o, '_slicedToArray');
      function i() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(i, '_nonIterableRest');
      function a(q, P) {
        if (q) {
          if (typeof q == 'string') return c(q, P);
          var A = {}.toString.call(q).slice(8, -1);
          return (
            A === 'Object' && q.constructor && (A = q.constructor.name),
            A === 'Map' || A === 'Set'
              ? Array.from(q)
              : A === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(A)
                ? c(q, P)
                : void 0
          );
        }
      }
      s(a, '_unsupportedIterableToArray');
      function c(q, P) {
        (P == null || P > q.length) && (P = q.length);
        for (var A = 0, w = Array(P); A < P; A++) w[A] = q[A];
        return w;
      }
      s(c, '_arrayLikeToArray');
      function d(q, P) {
        var A = q == null ? null : (typeof Symbol < 'u' && q[Symbol.iterator]) || q['@@iterator'];
        if (A != null) {
          var w,
            _,
            $,
            N,
            V = [],
            H = !0,
            x = !1;
          try {
            if ((($ = (A = A.call(q)).next), P === 0)) {
              if (Object(A) !== A) return;
              H = !1;
            } else for (; !(H = (w = $.call(A)).done) && (V.push(w.value), V.length !== P); H = !0);
          } catch (D) {
            ((x = !0), (_ = D));
          } finally {
            try {
              if (!H && A.return != null && ((N = A.return()), Object(N) !== N)) return;
            } finally {
              if (x) throw _;
            }
          }
          return V;
        }
      }
      s(d, '_iterableToArrayLimit');
      function u(q) {
        if (Array.isArray(q)) return q;
      }
      s(u, '_arrayWithHoles');
      var p = [],
        f = r.default.keys();
      for (R = 0; R < f.length; R++)
        if (((m = f[R]), (h = r.default.get(m)), (g = []), h)) {
          for (v = [].concat(h.baseConcepts, h.relatedConcepts), S = 0; S < v.length; S++)
            ((E = v[S]), E.module === 'HTML' && ((b = E.concept), b != null && g.push(b)));
          g.length > 0 && p.push([m, g]);
        }
      var m,
        h,
        g,
        v,
        E,
        b,
        S,
        R,
        I = {
          entries: s(function () {
            return p;
          }, 'entries'),
          forEach: s(function (P) {
            for (
              var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                w = 0,
                _ = p;
              w < _.length;
              w++
            ) {
              var $ = o(_[w], 2),
                N = $[0],
                V = $[1];
              P.call(A, V, N, p);
            }
          }, 'forEach'),
          get: s(function (P) {
            var A = p.filter(function (w) {
              return w[0] === P;
            })[0];
            return A && A[1];
          }, 'get'),
          has: s(function (P) {
            return !!I.get(P);
          }, 'has'),
          keys: s(function () {
            return p.map(function (P) {
              var A = o(P, 1),
                w = A[0];
              return w;
            });
          }, 'keys'),
          values: s(function () {
            return p.map(function (P) {
              var A = o(P, 2),
                w = A[1];
              return w;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(I, I.entries());
    },
  }),
  Cp = B({
    '../node_modules/aria-query/lib/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.roles = e.roleElements = e.elementRoles = e.dom = e.aria = void 0));
      var t = a(Kq()),
        r = a(Yq()),
        n = a(Op()),
        o = a(N$()),
        i = a(q$());
      function a(c) {
        return c && c.__esModule ? c : { default: c };
      }
      (s(a, '_interopRequireDefault'),
        (e.aria = t.default),
        (e.dom = r.default),
        (e.roles = n.default),
        (e.elementRoles = o.default),
        (e.roleElements = i.default));
    },
  }),
  Sv = B({
    '../node_modules/picocolors/picocolors.browser.js'(e, t) {
      var r = String,
        n = s(function () {
          return {
            isColorSupported: !1,
            reset: r,
            bold: r,
            dim: r,
            italic: r,
            underline: r,
            inverse: r,
            hidden: r,
            strikethrough: r,
            black: r,
            red: r,
            green: r,
            yellow: r,
            blue: r,
            magenta: r,
            cyan: r,
            white: r,
            gray: r,
            bgBlack: r,
            bgRed: r,
            bgGreen: r,
            bgYellow: r,
            bgBlue: r,
            bgMagenta: r,
            bgCyan: r,
            bgWhite: r,
            blackBright: r,
            redBright: r,
            greenBright: r,
            yellowBright: r,
            blueBright: r,
            magentaBright: r,
            cyanBright: r,
            whiteBright: r,
            bgBlackBright: r,
            bgRedBright: r,
            bgGreenBright: r,
            bgYellowBright: r,
            bgBlueBright: r,
            bgMagentaBright: r,
            bgCyanBright: r,
            bgWhiteBright: r,
          };
        }, 'create');
      ((t.exports = n()), (t.exports.createColors = n));
    },
  }),
  _v = B({
    '../node_modules/css.escape/css.escape.js'(e, t) {
      (function (r, n) {
        typeof e == 'object'
          ? (t.exports = n(r))
          : typeof define == 'function' && define.amd
            ? define([], n.bind(r, r))
            : n(r);
      })(typeof global < 'u' ? global : e, function (r) {
        if (r.CSS && r.CSS.escape) return r.CSS.escape;
        var n = s(function (o) {
          if (arguments.length == 0) throw new TypeError('`CSS.escape` requires an argument.');
          for (var i = String(o), a = i.length, c = -1, d, u = '', p = i.charCodeAt(0); ++c < a; ) {
            if (((d = i.charCodeAt(c)), d == 0)) {
              u += '';
              continue;
            }
            if (
              (d >= 1 && d <= 31) ||
              d == 127 ||
              (c == 0 && d >= 48 && d <= 57) ||
              (c == 1 && d >= 48 && d <= 57 && p == 45)
            ) {
              u += '\\' + d.toString(16) + ' ';
              continue;
            }
            if (c == 0 && a == 1 && d == 45) {
              u += '\\' + i.charAt(c);
              continue;
            }
            if (
              d >= 128 ||
              d == 45 ||
              d == 95 ||
              (d >= 48 && d <= 57) ||
              (d >= 65 && d <= 90) ||
              (d >= 97 && d <= 122)
            ) {
              u += i.charAt(c);
              continue;
            }
            u += '\\' + i.charAt(c);
          }
          return u;
        }, 'cssEscape');
        return (r.CSS || (r.CSS = {}), (r.CSS.escape = n), n);
      });
    },
  }),
  Av = B({
    '../node_modules/pretty-format/node_modules/ansi-styles/index.js'(e, t) {
      var r = 10,
        n = s(
          (a = 0) =>
            (c) =>
              `\x1B[${38 + a};5;${c}m`,
          'wrapAnsi256',
        ),
        o = s(
          (a = 0) =>
            (c, d, u) =>
              `\x1B[${38 + a};2;${c};${d};${u}m`,
          'wrapAnsi16m',
        );
      function i() {
        const a = new Map(),
          c = {
            modifier: {
              reset: [0, 0],
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              overline: [53, 55],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29],
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              blackBright: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39],
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49],
            },
          };
        ((c.color.gray = c.color.blackBright),
          (c.bgColor.bgGray = c.bgColor.bgBlackBright),
          (c.color.grey = c.color.blackBright),
          (c.bgColor.bgGrey = c.bgColor.bgBlackBright));
        for (const [d, u] of Object.entries(c)) {
          for (const [p, f] of Object.entries(u))
            ((c[p] = { open: `\x1B[${f[0]}m`, close: `\x1B[${f[1]}m` }),
              (u[p] = c[p]),
              a.set(f[0], f[1]));
          Object.defineProperty(c, d, { value: u, enumerable: !1 });
        }
        return (
          Object.defineProperty(c, 'codes', { value: a, enumerable: !1 }),
          (c.color.close = '\x1B[39m'),
          (c.bgColor.close = '\x1B[49m'),
          (c.color.ansi256 = n()),
          (c.color.ansi16m = o()),
          (c.bgColor.ansi256 = n(r)),
          (c.bgColor.ansi16m = o(r)),
          Object.defineProperties(c, {
            rgbToAnsi256: {
              value: s(
                (d, u, p) =>
                  d === u && u === p
                    ? d < 8
                      ? 16
                      : d > 248
                        ? 231
                        : Math.round(((d - 8) / 247) * 24) + 232
                    : 16 +
                      36 * Math.round((d / 255) * 5) +
                      6 * Math.round((u / 255) * 5) +
                      Math.round((p / 255) * 5),
                'value',
              ),
              enumerable: !1,
            },
            hexToRgb: {
              value: s((d) => {
                const u = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(d.toString(16));
                if (!u) return [0, 0, 0];
                let { colorString: p } = u.groups;
                p.length === 3 &&
                  (p = p
                    .split('')
                    .map((m) => m + m)
                    .join(''));
                const f = Number.parseInt(p, 16);
                return [(f >> 16) & 255, (f >> 8) & 255, f & 255];
              }, 'value'),
              enumerable: !1,
            },
            hexToAnsi256: {
              value: s((d) => c.rgbToAnsi256(...c.hexToRgb(d)), 'value'),
              enumerable: !1,
            },
          }),
          c
        );
      }
      (s(i, 'assembleStyles'), Object.defineProperty(t, 'exports', { enumerable: !0, get: i }));
    },
  }),
  hl = B({
    '../node_modules/pretty-format/build/collections.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.printIteratorEntries = r),
        (e.printIteratorValues = n),
        (e.printListItems = o),
        (e.printObjectProperties = i));
      var t = s((a, c) => {
        const d = Object.keys(a).sort(c);
        return (
          Object.getOwnPropertySymbols &&
            Object.getOwnPropertySymbols(a).forEach((u) => {
              Object.getOwnPropertyDescriptor(a, u).enumerable && d.push(u);
            }),
          d
        );
      }, 'getKeysOfEnumerableProperties');
      function r(a, c, d, u, p, f, m = ': ') {
        let h = '',
          g = a.next();
        if (!g.done) {
          h += c.spacingOuter;
          const v = d + c.indent;
          for (; !g.done; ) {
            const E = f(g.value[0], c, v, u, p),
              b = f(g.value[1], c, v, u, p);
            ((h += v + E + m + b),
              (g = a.next()),
              g.done ? c.min || (h += ',') : (h += ',' + c.spacingInner));
          }
          h += c.spacingOuter + d;
        }
        return h;
      }
      s(r, 'printIteratorEntries');
      function n(a, c, d, u, p, f) {
        let m = '',
          h = a.next();
        if (!h.done) {
          m += c.spacingOuter;
          const g = d + c.indent;
          for (; !h.done; )
            ((m += g + f(h.value, c, g, u, p)),
              (h = a.next()),
              h.done ? c.min || (m += ',') : (m += ',' + c.spacingInner));
          m += c.spacingOuter + d;
        }
        return m;
      }
      s(n, 'printIteratorValues');
      function o(a, c, d, u, p, f) {
        let m = '';
        if (a.length) {
          m += c.spacingOuter;
          const h = d + c.indent;
          for (let g = 0; g < a.length; g++)
            ((m += h),
              g in a && (m += f(a[g], c, h, u, p)),
              g < a.length - 1 ? (m += ',' + c.spacingInner) : c.min || (m += ','));
          m += c.spacingOuter + d;
        }
        return m;
      }
      s(o, 'printListItems');
      function i(a, c, d, u, p, f) {
        let m = '';
        const h = t(a, c.compareKeys);
        if (h.length) {
          m += c.spacingOuter;
          const g = d + c.indent;
          for (let v = 0; v < h.length; v++) {
            const E = h[v],
              b = f(E, c, g, u, p),
              S = f(a[E], c, g, u, p);
            ((m += g + b + ': ' + S),
              v < h.length - 1 ? (m += ',' + c.spacingInner) : c.min || (m += ','));
          }
          m += c.spacingOuter + d;
        }
        return m;
      }
      s(i, 'printObjectProperties');
    },
  }),
  M$ = B({
    '../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = hl(),
        r = (function () {
          return typeof globalThis < 'u'
            ? globalThis
            : typeof r < 'u'
              ? r
              : typeof self < 'u'
                ? self
                : typeof window < 'u'
                  ? window
                  : Function('return this')();
        })(),
        n = r['jest-symbol-do-not-touch'] || r.Symbol,
        o = typeof n == 'function' && n.for ? n.for('jest.asymmetricMatcher') : 1267621,
        i = ' ',
        a = s((p, f, m, h, g, v) => {
          const E = p.toString();
          return E === 'ArrayContaining' || E === 'ArrayNotContaining'
            ? ++h > f.maxDepth
              ? '[' + E + ']'
              : E + i + '[' + (0, t.printListItems)(p.sample, f, m, h, g, v) + ']'
            : E === 'ObjectContaining' || E === 'ObjectNotContaining'
              ? ++h > f.maxDepth
                ? '[' + E + ']'
                : E + i + '{' + (0, t.printObjectProperties)(p.sample, f, m, h, g, v) + '}'
              : E === 'StringMatching' ||
                  E === 'StringNotMatching' ||
                  E === 'StringContaining' ||
                  E === 'StringNotContaining'
                ? E + i + v(p.sample, f, m, h, g)
                : p.toAsymmetricMatcher();
        }, 'serialize');
      e.serialize = a;
      var c = s((p) => p && p.$$typeof === o, 'test');
      e.test = c;
      var d = { serialize: a, test: c },
        u = d;
      e.default = u;
    },
  }),
  j$ = B({
    '../node_modules/pretty-format/node_modules/ansi-regex/index.js'(e, t) {
      t.exports = ({ onlyFirst: r = !1 } = {}) => {
        const n = [
          '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
          '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
        ].join('|');
        return new RegExp(n, r ? void 0 : 'g');
      };
    },
  }),
  $$ = B({
    '../node_modules/pretty-format/build/plugins/ConvertAnsi.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = n(j$()),
        r = n(Av());
      function n(u) {
        return u && u.__esModule ? u : { default: u };
      }
      s(n, '_interopRequireDefault');
      var o = s(
          (u) =>
            u.replace((0, t.default)(), (p) => {
              switch (p) {
                case r.default.red.close:
                case r.default.green.close:
                case r.default.cyan.close:
                case r.default.gray.close:
                case r.default.white.close:
                case r.default.yellow.close:
                case r.default.bgRed.close:
                case r.default.bgGreen.close:
                case r.default.bgYellow.close:
                case r.default.inverse.close:
                case r.default.dim.close:
                case r.default.bold.close:
                case r.default.reset.open:
                case r.default.reset.close:
                  return '</>';
                case r.default.red.open:
                  return '<red>';
                case r.default.green.open:
                  return '<green>';
                case r.default.cyan.open:
                  return '<cyan>';
                case r.default.gray.open:
                  return '<gray>';
                case r.default.white.open:
                  return '<white>';
                case r.default.yellow.open:
                  return '<yellow>';
                case r.default.bgRed.open:
                  return '<bgRed>';
                case r.default.bgGreen.open:
                  return '<bgGreen>';
                case r.default.bgYellow.open:
                  return '<bgYellow>';
                case r.default.inverse.open:
                  return '<inverse>';
                case r.default.dim.open:
                  return '<dim>';
                case r.default.bold.open:
                  return '<bold>';
                default:
                  return '';
              }
            }),
          'toHumanReadableAnsi',
        ),
        i = s((u) => typeof u == 'string' && !!u.match((0, t.default)()), 'test');
      e.test = i;
      var a = s((u, p, f, m, h, g) => g(o(u), p, f, m, h), 'serialize');
      e.serialize = a;
      var c = { serialize: a, test: i },
        d = c;
      e.default = d;
    },
  }),
  k$ = B({
    '../node_modules/pretty-format/build/plugins/DOMCollection.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = hl(),
        r = ' ',
        n = ['DOMStringMap', 'NamedNodeMap'],
        o = /^(HTML\w*Collection|NodeList)$/,
        i = s((f) => n.indexOf(f) !== -1 || o.test(f), 'testName'),
        a = s((f) => f && f.constructor && !!f.constructor.name && i(f.constructor.name), 'test');
      e.test = a;
      var c = s((f) => f.constructor.name === 'NamedNodeMap', 'isNamedNodeMap'),
        d = s((f, m, h, g, v, E) => {
          const b = f.constructor.name;
          return ++g > m.maxDepth
            ? '[' + b + ']'
            : (m.min ? '' : b + r) +
                (n.indexOf(b) !== -1
                  ? '{' +
                    (0, t.printObjectProperties)(
                      c(f)
                        ? Array.from(f).reduce((S, R) => ((S[R.name] = R.value), S), {})
                        : { ...f },
                      m,
                      h,
                      g,
                      v,
                      E,
                    ) +
                    '}'
                  : '[' + (0, t.printListItems)(Array.from(f), m, h, g, v, E) + ']');
        }, 'serialize');
      e.serialize = d;
      var u = { serialize: d, test: a },
        p = u;
      e.default = p;
    },
  }),
  D$ = B({
    '../node_modules/pretty-format/build/plugins/lib/escapeHTML.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = t));
      function t(r) {
        return r.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      s(t, 'escapeHTML');
    },
  }),
  Ip = B({
    '../node_modules/pretty-format/build/plugins/lib/markup.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.printText =
          e.printProps =
          e.printElementAsLeaf =
          e.printElement =
          e.printComment =
          e.printChildren =
            void 0));
      var t = r(D$());
      function r(u) {
        return u && u.__esModule ? u : { default: u };
      }
      s(r, '_interopRequireDefault');
      var n = s((u, p, f, m, h, g, v) => {
        const E = m + f.indent,
          b = f.colors;
        return u
          .map((S) => {
            const R = p[S];
            let I = v(R, f, E, h, g);
            return (
              typeof R != 'string' &&
                (I.indexOf(`
`) !== -1 && (I = f.spacingOuter + E + I + f.spacingOuter + m),
                (I = '{' + I + '}')),
              f.spacingInner +
                m +
                b.prop.open +
                S +
                b.prop.close +
                '=' +
                b.value.open +
                I +
                b.value.close
            );
          })
          .join('');
      }, 'printProps');
      e.printProps = n;
      var o = s(
        (u, p, f, m, h, g) =>
          u
            .map((v) => p.spacingOuter + f + (typeof v == 'string' ? i(v, p) : g(v, p, f, m, h)))
            .join(''),
        'printChildren',
      );
      e.printChildren = o;
      var i = s((u, p) => {
        const f = p.colors.content;
        return f.open + (0, t.default)(u) + f.close;
      }, 'printText');
      e.printText = i;
      var a = s((u, p) => {
        const f = p.colors.comment;
        return f.open + '<!--' + (0, t.default)(u) + '-->' + f.close;
      }, 'printComment');
      e.printComment = a;
      var c = s((u, p, f, m, h) => {
        const g = m.colors.tag;
        return (
          g.open +
          '<' +
          u +
          (p && g.close + p + m.spacingOuter + h + g.open) +
          (f
            ? '>' + g.close + f + m.spacingOuter + h + g.open + '</' + u
            : (p && !m.min ? '' : ' ') + '/') +
          '>' +
          g.close
        );
      }, 'printElement');
      e.printElement = c;
      var d = s((u, p) => {
        const f = p.colors.tag;
        return f.open + '<' + u + f.close + ' ' + f.open + ' />' + f.close;
      }, 'printElementAsLeaf');
      e.printElementAsLeaf = d;
    },
  }),
  L$ = B({
    '../node_modules/pretty-format/build/plugins/DOMElement.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Ip(),
        r = 1,
        n = 3,
        o = 8,
        i = 11,
        a = /^((HTML|SVG)\w*)?Element$/,
        c = s((E) => {
          try {
            return typeof E.hasAttribute == 'function' && E.hasAttribute('is');
          } catch {
            return !1;
          }
        }, 'testHasAttribute'),
        d = s((E) => {
          const b = E.constructor.name,
            { nodeType: S, tagName: R } = E,
            I = (typeof R == 'string' && R.includes('-')) || c(E);
          return (
            (S === r && (a.test(b) || I)) ||
            (S === n && b === 'Text') ||
            (S === o && b === 'Comment') ||
            (S === i && b === 'DocumentFragment')
          );
        }, 'testNode'),
        u = s((E) => {
          var b;
          return (
            (E == null || (b = E.constructor) === null || b === void 0 ? void 0 : b.name) && d(E)
          );
        }, 'test');
      e.test = u;
      function p(E) {
        return E.nodeType === n;
      }
      s(p, 'nodeIsText');
      function f(E) {
        return E.nodeType === o;
      }
      s(f, 'nodeIsComment');
      function m(E) {
        return E.nodeType === i;
      }
      s(m, 'nodeIsFragment');
      var h = s((E, b, S, R, I, q) => {
        if (p(E)) return (0, t.printText)(E.data, b);
        if (f(E)) return (0, t.printComment)(E.data, b);
        const P = m(E) ? 'DocumentFragment' : E.tagName.toLowerCase();
        return ++R > b.maxDepth
          ? (0, t.printElementAsLeaf)(P, b)
          : (0, t.printElement)(
              P,
              (0, t.printProps)(
                m(E)
                  ? []
                  : Array.from(E.attributes)
                      .map((A) => A.name)
                      .sort(),
                m(E)
                  ? {}
                  : Array.from(E.attributes).reduce((A, w) => ((A[w.name] = w.value), A), {}),
                b,
                S + b.indent,
                R,
                I,
                q,
              ),
              (0, t.printChildren)(
                Array.prototype.slice.call(E.childNodes || E.children),
                b,
                S + b.indent,
                R,
                I,
                q,
              ),
              b,
              S,
            );
      }, 'serialize');
      e.serialize = h;
      var g = { serialize: h, test: u },
        v = g;
      e.default = v;
    },
  }),
  F$ = B({
    '../node_modules/pretty-format/build/plugins/Immutable.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = hl(),
        r = '@@__IMMUTABLE_ITERABLE__@@',
        n = '@@__IMMUTABLE_LIST__@@',
        o = '@@__IMMUTABLE_KEYED__@@',
        i = '@@__IMMUTABLE_MAP__@@',
        a = '@@__IMMUTABLE_ORDERED__@@',
        c = '@@__IMMUTABLE_RECORD__@@',
        d = '@@__IMMUTABLE_SEQ__@@',
        u = '@@__IMMUTABLE_SET__@@',
        p = '@@__IMMUTABLE_STACK__@@',
        f = s((w) => 'Immutable.' + w, 'getImmutableName'),
        m = s((w) => '[' + w + ']', 'printAsLeaf'),
        h = ' ',
        g = '',
        v = s(
          (w, _, $, N, V, H, x) =>
            ++N > _.maxDepth
              ? m(f(x))
              : f(x) + h + '{' + (0, t.printIteratorEntries)(w.entries(), _, $, N, V, H) + '}',
          'printImmutableEntries',
        );
      function E(w) {
        let _ = 0;
        return {
          next() {
            if (_ < w._keys.length) {
              const $ = w._keys[_++];
              return { done: !1, value: [$, w.get($)] };
            }
            return { done: !0, value: void 0 };
          },
        };
      }
      s(E, 'getRecordEntries');
      var b = s((w, _, $, N, V, H) => {
          const x = f(w._name || 'Record');
          return ++N > _.maxDepth
            ? m(x)
            : x + h + '{' + (0, t.printIteratorEntries)(E(w), _, $, N, V, H) + '}';
        }, 'printImmutableRecord'),
        S = s((w, _, $, N, V, H) => {
          const x = f('Seq');
          return ++N > _.maxDepth
            ? m(x)
            : w[o]
              ? x +
                h +
                '{' +
                (w._iter || w._object
                  ? (0, t.printIteratorEntries)(w.entries(), _, $, N, V, H)
                  : g) +
                '}'
              : x +
                h +
                '[' +
                (w._iter || w._array || w._collection || w._iterable
                  ? (0, t.printIteratorValues)(w.values(), _, $, N, V, H)
                  : g) +
                ']';
        }, 'printImmutableSeq'),
        R = s(
          (w, _, $, N, V, H, x) =>
            ++N > _.maxDepth
              ? m(f(x))
              : f(x) + h + '[' + (0, t.printIteratorValues)(w.values(), _, $, N, V, H) + ']',
          'printImmutableValues',
        ),
        I = s(
          (w, _, $, N, V, H) =>
            w[i]
              ? v(w, _, $, N, V, H, w[a] ? 'OrderedMap' : 'Map')
              : w[n]
                ? R(w, _, $, N, V, H, 'List')
                : w[u]
                  ? R(w, _, $, N, V, H, w[a] ? 'OrderedSet' : 'Set')
                  : w[p]
                    ? R(w, _, $, N, V, H, 'Stack')
                    : w[d]
                      ? S(w, _, $, N, V, H)
                      : b(w, _, $, N, V, H),
          'serialize',
        );
      e.serialize = I;
      var q = s((w) => w && (w[r] === !0 || w[c] === !0), 'test');
      e.test = q;
      var P = { serialize: I, test: q },
        A = P;
      e.default = A;
    },
  }),
  B$ = B({
    '../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js'(e) {
      var t = 60103,
        r = 60106,
        n = 60107,
        o = 60108,
        i = 60114,
        a = 60109,
        c = 60110,
        d = 60112,
        u = 60113,
        p = 60120,
        f = 60115,
        m = 60116,
        h = 60121,
        g = 60122,
        v = 60117,
        E = 60129,
        b = 60131;
      typeof Symbol == 'function' &&
        Symbol.for &&
        ((S = Symbol.for),
        (t = S('react.element')),
        (r = S('react.portal')),
        (n = S('react.fragment')),
        (o = S('react.strict_mode')),
        (i = S('react.profiler')),
        (a = S('react.provider')),
        (c = S('react.context')),
        (d = S('react.forward_ref')),
        (u = S('react.suspense')),
        (p = S('react.suspense_list')),
        (f = S('react.memo')),
        (m = S('react.lazy')),
        (h = S('react.block')),
        (g = S('react.server.block')),
        (v = S('react.fundamental')),
        (E = S('react.debug_trace_mode')),
        (b = S('react.legacy_hidden')));
      var S;
      function R(x) {
        if (typeof x == 'object' && x !== null) {
          var D = x.$$typeof;
          switch (D) {
            case t:
              switch (((x = x.type), x)) {
                case n:
                case i:
                case o:
                case u:
                case p:
                  return x;
                default:
                  switch (((x = x && x.$$typeof), x)) {
                    case c:
                    case d:
                    case m:
                    case f:
                    case a:
                      return x;
                    default:
                      return D;
                  }
              }
            case r:
              return D;
          }
        }
      }
      s(R, 'y');
      var I = a,
        q = t,
        P = d,
        A = n,
        w = m,
        _ = f,
        $ = r,
        N = i,
        V = o,
        H = u;
      ((e.ContextConsumer = c),
        (e.ContextProvider = I),
        (e.Element = q),
        (e.ForwardRef = P),
        (e.Fragment = A),
        (e.Lazy = w),
        (e.Memo = _),
        (e.Portal = $),
        (e.Profiler = N),
        (e.StrictMode = V),
        (e.Suspense = H),
        (e.isAsyncMode = function () {
          return !1;
        }),
        (e.isConcurrentMode = function () {
          return !1;
        }),
        (e.isContextConsumer = function (x) {
          return R(x) === c;
        }),
        (e.isContextProvider = function (x) {
          return R(x) === a;
        }),
        (e.isElement = function (x) {
          return typeof x == 'object' && x !== null && x.$$typeof === t;
        }),
        (e.isForwardRef = function (x) {
          return R(x) === d;
        }),
        (e.isFragment = function (x) {
          return R(x) === n;
        }),
        (e.isLazy = function (x) {
          return R(x) === m;
        }),
        (e.isMemo = function (x) {
          return R(x) === f;
        }),
        (e.isPortal = function (x) {
          return R(x) === r;
        }),
        (e.isProfiler = function (x) {
          return R(x) === i;
        }),
        (e.isStrictMode = function (x) {
          return R(x) === o;
        }),
        (e.isSuspense = function (x) {
          return R(x) === u;
        }),
        (e.isValidElementType = function (x) {
          return (
            typeof x == 'string' ||
            typeof x == 'function' ||
            x === n ||
            x === i ||
            x === E ||
            x === o ||
            x === u ||
            x === p ||
            x === b ||
            (typeof x == 'object' &&
              x !== null &&
              (x.$$typeof === m ||
                x.$$typeof === f ||
                x.$$typeof === a ||
                x.$$typeof === c ||
                x.$$typeof === d ||
                x.$$typeof === v ||
                x.$$typeof === h ||
                x[0] === g))
          );
        }),
        (e.typeOf = R));
    },
  }),
  J$ = B({
    '../node_modules/pretty-format/node_modules/react-is/index.js'(e, t) {
      t.exports = B$();
    },
  }),
  U$ = B({
    '../node_modules/pretty-format/build/plugins/ReactElement.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = o(J$()),
        r = Ip();
      function n(m) {
        if (typeof WeakMap != 'function') return null;
        var h = new WeakMap(),
          g = new WeakMap();
        return (n = s(function (v) {
          return v ? g : h;
        }, '_getRequireWildcardCache'))(m);
      }
      s(n, '_getRequireWildcardCache');
      function o(m, h) {
        if (!h && m && m.__esModule) return m;
        if (m === null || (typeof m != 'object' && typeof m != 'function')) return { default: m };
        var g = n(h);
        if (g && g.has(m)) return g.get(m);
        var v = {},
          E = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var b in m)
          if (b !== 'default' && Object.prototype.hasOwnProperty.call(m, b)) {
            var S = E ? Object.getOwnPropertyDescriptor(m, b) : null;
            S && (S.get || S.set) ? Object.defineProperty(v, b, S) : (v[b] = m[b]);
          }
        return ((v.default = m), g && g.set(m, v), v);
      }
      s(o, '_interopRequireWildcard');
      var i = s(
          (m, h = []) => (
            Array.isArray(m)
              ? m.forEach((g) => {
                  i(g, h);
                })
              : m != null && m !== !1 && h.push(m),
            h
          ),
          'getChildren',
        ),
        a = s((m) => {
          const h = m.type;
          if (typeof h == 'string') return h;
          if (typeof h == 'function') return h.displayName || h.name || 'Unknown';
          if (t.isFragment(m)) return 'React.Fragment';
          if (t.isSuspense(m)) return 'React.Suspense';
          if (typeof h == 'object' && h !== null) {
            if (t.isContextProvider(m)) return 'Context.Provider';
            if (t.isContextConsumer(m)) return 'Context.Consumer';
            if (t.isForwardRef(m)) {
              if (h.displayName) return h.displayName;
              const g = h.render.displayName || h.render.name || '';
              return g !== '' ? 'ForwardRef(' + g + ')' : 'ForwardRef';
            }
            if (t.isMemo(m)) {
              const g = h.displayName || h.type.displayName || h.type.name || '';
              return g !== '' ? 'Memo(' + g + ')' : 'Memo';
            }
          }
          return 'UNDEFINED';
        }, 'getType'),
        c = s((m) => {
          const { props: h } = m;
          return Object.keys(h)
            .filter((g) => g !== 'children' && h[g] !== void 0)
            .sort();
        }, 'getPropKeys'),
        d = s(
          (m, h, g, v, E, b) =>
            ++v > h.maxDepth
              ? (0, r.printElementAsLeaf)(a(m), h)
              : (0, r.printElement)(
                  a(m),
                  (0, r.printProps)(c(m), m.props, h, g + h.indent, v, E, b),
                  (0, r.printChildren)(i(m.props.children), h, g + h.indent, v, E, b),
                  h,
                  g,
                ),
          'serialize',
        );
      e.serialize = d;
      var u = s((m) => m != null && t.isElement(m), 'test');
      e.test = u;
      var p = { serialize: d, test: u },
        f = p;
      e.default = f;
    },
  }),
  V$ = B({
    '../node_modules/pretty-format/build/plugins/ReactTestComponent.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Ip(),
        r = (function () {
          return typeof globalThis < 'u'
            ? globalThis
            : typeof r < 'u'
              ? r
              : typeof self < 'u'
                ? self
                : typeof window < 'u'
                  ? window
                  : Function('return this')();
        })(),
        n = r['jest-symbol-do-not-touch'] || r.Symbol,
        o = typeof n == 'function' && n.for ? n.for('react.test.json') : 245830487,
        i = s((p) => {
          const { props: f } = p;
          return f
            ? Object.keys(f)
                .filter((m) => f[m] !== void 0)
                .sort()
            : [];
        }, 'getPropKeys'),
        a = s(
          (p, f, m, h, g, v) =>
            ++h > f.maxDepth
              ? (0, t.printElementAsLeaf)(p.type, f)
              : (0, t.printElement)(
                  p.type,
                  p.props ? (0, t.printProps)(i(p), p.props, f, m + f.indent, h, g, v) : '',
                  p.children ? (0, t.printChildren)(p.children, f, m + f.indent, h, g, v) : '',
                  f,
                  m,
                ),
          'serialize',
        );
      e.serialize = a;
      var c = s((p) => p && p.$$typeof === o, 'test');
      e.test = c;
      var d = { serialize: a, test: c },
        u = d;
      e.default = u;
    },
  }),
  H$ = B({
    '../node_modules/pretty-format/build/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = e.DEFAULT_OPTIONS = void 0),
        (e.format = Pe),
        (e.plugins = void 0));
      var t = p(Av()),
        r = hl(),
        n = p(M$()),
        o = p($$()),
        i = p(k$()),
        a = p(L$()),
        c = p(F$()),
        d = p(U$()),
        u = p(V$());
      function p(J) {
        return J && J.__esModule ? J : { default: J };
      }
      s(p, '_interopRequireDefault');
      var f = Object.prototype.toString,
        m = Date.prototype.toISOString,
        h = Error.prototype.toString,
        g = RegExp.prototype.toString,
        v = s(
          (J) => (typeof J.constructor == 'function' && J.constructor.name) || 'Object',
          'getConstructorName',
        ),
        E = s((J) => typeof window < 'u' && J === window, 'isWindow'),
        b = /^Symbol\((.*)\)(.*)$/,
        S = /\n/gi,
        R = class extends Error {
          constructor(Q, re) {
            (super(Q), (this.stack = re), (this.name = this.constructor.name));
          }
        };
      s(R, 'PrettyFormatPluginError');
      var I = R;
      function q(J) {
        return (
          J === '[object Array]' ||
          J === '[object ArrayBuffer]' ||
          J === '[object DataView]' ||
          J === '[object Float32Array]' ||
          J === '[object Float64Array]' ||
          J === '[object Int8Array]' ||
          J === '[object Int16Array]' ||
          J === '[object Int32Array]' ||
          J === '[object Uint8Array]' ||
          J === '[object Uint8ClampedArray]' ||
          J === '[object Uint16Array]' ||
          J === '[object Uint32Array]'
        );
      }
      s(q, 'isToStringedArrayType');
      function P(J) {
        return Object.is(J, -0) ? '-0' : String(J);
      }
      s(P, 'printNumber');
      function A(J) {
        return `${J}n`;
      }
      s(A, 'printBigInt');
      function w(J, Q) {
        return Q ? '[Function ' + (J.name || 'anonymous') + ']' : '[Function]';
      }
      s(w, 'printFunction');
      function _(J) {
        return String(J).replace(b, 'Symbol($1)');
      }
      s(_, 'printSymbol');
      function $(J) {
        return '[' + h.call(J) + ']';
      }
      s($, 'printError');
      function N(J, Q, re, oe) {
        if (J === !0 || J === !1) return '' + J;
        if (J === void 0) return 'undefined';
        if (J === null) return 'null';
        const ne = typeof J;
        if (ne === 'number') return P(J);
        if (ne === 'bigint') return A(J);
        if (ne === 'string') return oe ? '"' + J.replace(/"|\\/g, '\\$&') + '"' : '"' + J + '"';
        if (ne === 'function') return w(J, Q);
        if (ne === 'symbol') return _(J);
        const de = f.call(J);
        return de === '[object WeakMap]'
          ? 'WeakMap {}'
          : de === '[object WeakSet]'
            ? 'WeakSet {}'
            : de === '[object Function]' || de === '[object GeneratorFunction]'
              ? w(J, Q)
              : de === '[object Symbol]'
                ? _(J)
                : de === '[object Date]'
                  ? isNaN(+J)
                    ? 'Date { NaN }'
                    : m.call(J)
                  : de === '[object Error]'
                    ? $(J)
                    : de === '[object RegExp]'
                      ? re
                        ? g.call(J).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&')
                        : g.call(J)
                      : J instanceof Error
                        ? $(J)
                        : null;
      }
      s(N, 'printBasicValue');
      function V(J, Q, re, oe, ne, de) {
        if (ne.indexOf(J) !== -1) return '[Circular]';
        ((ne = ne.slice()), ne.push(J));
        const ye = ++oe > Q.maxDepth,
          pe = Q.min;
        if (Q.callToJSON && !ye && J.toJSON && typeof J.toJSON == 'function' && !de)
          return F(J.toJSON(), Q, re, oe, ne, !0);
        const Fe = f.call(J);
        return Fe === '[object Arguments]'
          ? ye
            ? '[Arguments]'
            : (pe ? '' : 'Arguments ') + '[' + (0, r.printListItems)(J, Q, re, oe, ne, F) + ']'
          : q(Fe)
            ? ye
              ? '[' + J.constructor.name + ']'
              : (pe || (!Q.printBasicPrototype && J.constructor.name === 'Array')
                  ? ''
                  : J.constructor.name + ' ') +
                '[' +
                (0, r.printListItems)(J, Q, re, oe, ne, F) +
                ']'
            : Fe === '[object Map]'
              ? ye
                ? '[Map]'
                : 'Map {' + (0, r.printIteratorEntries)(J.entries(), Q, re, oe, ne, F, ' => ') + '}'
              : Fe === '[object Set]'
                ? ye
                  ? '[Set]'
                  : 'Set {' + (0, r.printIteratorValues)(J.values(), Q, re, oe, ne, F) + '}'
                : ye || E(J)
                  ? '[' + v(J) + ']'
                  : (pe || (!Q.printBasicPrototype && v(J) === 'Object') ? '' : v(J) + ' ') +
                    '{' +
                    (0, r.printObjectProperties)(J, Q, re, oe, ne, F) +
                    '}';
      }
      s(V, 'printComplexValue');
      function H(J) {
        return J.serialize != null;
      }
      s(H, 'isNewPlugin');
      function x(J, Q, re, oe, ne, de) {
        let ye;
        try {
          ye = H(J)
            ? J.serialize(Q, re, oe, ne, de, F)
            : J.print(
                Q,
                (pe) => F(pe, re, oe, ne, de),
                (pe) => {
                  const Fe = oe + re.indent;
                  return (
                    Fe +
                    pe.replace(
                      S,
                      `
` + Fe,
                    )
                  );
                },
                { edgeSpacing: re.spacingOuter, min: re.min, spacing: re.spacingInner },
                re.colors,
              );
        } catch (pe) {
          throw new I(pe.message, pe.stack);
        }
        if (typeof ye != 'string')
          throw new Error(
            `pretty-format: Plugin must return type "string" but instead returned "${typeof ye}".`,
          );
        return ye;
      }
      s(x, 'printPlugin');
      function D(J, Q) {
        for (let re = 0; re < J.length; re++)
          try {
            if (J[re].test(Q)) return J[re];
          } catch (oe) {
            throw new I(oe.message, oe.stack);
          }
        return null;
      }
      s(D, 'findPlugin');
      function F(J, Q, re, oe, ne, de) {
        const ye = D(Q.plugins, J);
        if (ye !== null) return x(ye, J, Q, re, oe, ne);
        const pe = N(J, Q.printFunctionName, Q.escapeRegex, Q.escapeString);
        return pe !== null ? pe : V(J, Q, re, oe, ne, de);
      }
      s(F, 'printer');
      var k = { comment: 'gray', content: 'reset', prop: 'yellow', tag: 'cyan', value: 'green' },
        K = Object.keys(k),
        X = {
          callToJSON: !0,
          compareKeys: void 0,
          escapeRegex: !1,
          escapeString: !0,
          highlight: !1,
          indent: 2,
          maxDepth: 1 / 0,
          min: !1,
          plugins: [],
          printBasicPrototype: !0,
          printFunctionName: !0,
          theme: k,
        };
      e.DEFAULT_OPTIONS = X;
      function se(J) {
        if (
          (Object.keys(J).forEach((Q) => {
            if (!X.hasOwnProperty(Q)) throw new Error(`pretty-format: Unknown option "${Q}".`);
          }),
          J.min && J.indent !== void 0 && J.indent !== 0)
        )
          throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
        if (J.theme !== void 0) {
          if (J.theme === null) throw new Error('pretty-format: Option "theme" must not be null.');
          if (typeof J.theme != 'object')
            throw new Error(
              `pretty-format: Option "theme" must be of type "object" but instead received "${typeof J.theme}".`,
            );
        }
      }
      s(se, 'validateOptions');
      var ie = s(
          (J) =>
            K.reduce((Q, re) => {
              const oe = J.theme && J.theme[re] !== void 0 ? J.theme[re] : k[re],
                ne = oe && t.default[oe];
              if (ne && typeof ne.close == 'string' && typeof ne.open == 'string') Q[re] = ne;
              else
                throw new Error(
                  `pretty-format: Option "theme" has a key "${re}" whose value "${oe}" is undefined in ansi-styles.`,
                );
              return Q;
            }, Object.create(null)),
          'getColorsHighlight',
        ),
        W = s(
          () => K.reduce((J, Q) => ((J[Q] = { close: '', open: '' }), J), Object.create(null)),
          'getColorsEmpty',
        ),
        ae = s(
          (J) => (J && J.printFunctionName !== void 0 ? J.printFunctionName : X.printFunctionName),
          'getPrintFunctionName',
        ),
        be = s(
          (J) => (J && J.escapeRegex !== void 0 ? J.escapeRegex : X.escapeRegex),
          'getEscapeRegex',
        ),
        ue = s(
          (J) => (J && J.escapeString !== void 0 ? J.escapeString : X.escapeString),
          'getEscapeString',
        ),
        ee = s((J) => {
          var Q;
          return {
            callToJSON: J && J.callToJSON !== void 0 ? J.callToJSON : X.callToJSON,
            colors: J && J.highlight ? ie(J) : W(),
            compareKeys: J && typeof J.compareKeys == 'function' ? J.compareKeys : X.compareKeys,
            escapeRegex: be(J),
            escapeString: ue(J),
            indent: J && J.min ? '' : xe(J && J.indent !== void 0 ? J.indent : X.indent),
            maxDepth: J && J.maxDepth !== void 0 ? J.maxDepth : X.maxDepth,
            min: J && J.min !== void 0 ? J.min : X.min,
            plugins: J && J.plugins !== void 0 ? J.plugins : X.plugins,
            printBasicPrototype: (Q = J?.printBasicPrototype) !== null && Q !== void 0 ? Q : !0,
            printFunctionName: ae(J),
            spacingInner:
              J && J.min
                ? ' '
                : `
`,
            spacingOuter:
              J && J.min
                ? ''
                : `
`,
          };
        }, 'getConfig');
      function xe(J) {
        return new Array(J + 1).join(' ');
      }
      s(xe, 'createIndent');
      function Pe(J, Q) {
        if (Q && (se(Q), Q.plugins)) {
          const oe = D(Q.plugins, J);
          if (oe !== null) return x(oe, J, ee(Q), '', 0, []);
        }
        const re = N(J, ae(Q), be(Q), ue(Q));
        return re !== null ? re : V(J, ee(Q), '', 0, []);
      }
      s(Pe, 'format');
      var He = {
        AsymmetricMatcher: n.default,
        ConvertAnsi: o.default,
        DOMCollection: i.default,
        DOMElement: a.default,
        Immutable: c.default,
        ReactElement: d.default,
        ReactTestComponent: u.default,
      };
      e.plugins = He;
      var Ke = Pe;
      e.default = Ke;
    },
  }),
  z$ = B({
    '../node_modules/lz-string/libs/lz-string.js'(e, t) {
      var r = (function () {
        var n = String.fromCharCode,
          o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$',
          a = {};
        function c(u, p) {
          if (!a[u]) {
            a[u] = {};
            for (var f = 0; f < u.length; f++) a[u][u.charAt(f)] = f;
          }
          return a[u][p];
        }
        s(c, 'getBaseValue');
        var d = {
          compressToBase64: s(function (u) {
            if (u == null) return '';
            var p = d._compress(u, 6, function (f) {
              return o.charAt(f);
            });
            switch (p.length % 4) {
              default:
              case 0:
                return p;
              case 1:
                return p + '===';
              case 2:
                return p + '==';
              case 3:
                return p + '=';
            }
          }, 'compressToBase64'),
          decompressFromBase64: s(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 32, function (p) {
                    return c(o, u.charAt(p));
                  });
          }, 'decompressFromBase64'),
          compressToUTF16: s(function (u) {
            return u == null
              ? ''
              : d._compress(u, 15, function (p) {
                  return n(p + 32);
                }) + ' ';
          }, 'compressToUTF16'),
          decompressFromUTF16: s(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 16384, function (p) {
                    return u.charCodeAt(p) - 32;
                  });
          }, 'decompressFromUTF16'),
          compressToUint8Array: s(function (u) {
            for (
              var p = d.compress(u), f = new Uint8Array(p.length * 2), m = 0, h = p.length;
              m < h;
              m++
            ) {
              var g = p.charCodeAt(m);
              ((f[m * 2] = g >>> 8), (f[m * 2 + 1] = g % 256));
            }
            return f;
          }, 'compressToUint8Array'),
          decompressFromUint8Array: s(function (u) {
            if (u == null) return d.decompress(u);
            for (var p = new Array(u.length / 2), f = 0, m = p.length; f < m; f++)
              p[f] = u[f * 2] * 256 + u[f * 2 + 1];
            var h = [];
            return (
              p.forEach(function (g) {
                h.push(n(g));
              }),
              d.decompress(h.join(''))
            );
          }, 'decompressFromUint8Array'),
          compressToEncodedURIComponent: s(function (u) {
            return u == null
              ? ''
              : d._compress(u, 6, function (p) {
                  return i.charAt(p);
                });
          }, 'compressToEncodedURIComponent'),
          decompressFromEncodedURIComponent: s(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : ((u = u.replace(/ /g, '+')),
                  d._decompress(u.length, 32, function (p) {
                    return c(i, u.charAt(p));
                  }));
          }, 'decompressFromEncodedURIComponent'),
          compress: s(function (u) {
            return d._compress(u, 16, function (p) {
              return n(p);
            });
          }, 'compress'),
          _compress: s(function (u, p, f) {
            if (u == null) return '';
            var m,
              h,
              g = {},
              v = {},
              E = '',
              b = '',
              S = '',
              R = 2,
              I = 3,
              q = 2,
              P = [],
              A = 0,
              w = 0,
              _;
            for (_ = 0; _ < u.length; _ += 1)
              if (
                ((E = u.charAt(_)),
                Object.prototype.hasOwnProperty.call(g, E) || ((g[E] = I++), (v[E] = !0)),
                (b = S + E),
                Object.prototype.hasOwnProperty.call(g, b))
              )
                S = b;
              else {
                if (Object.prototype.hasOwnProperty.call(v, S)) {
                  if (S.charCodeAt(0) < 256) {
                    for (m = 0; m < q; m++)
                      ((A = A << 1), w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++);
                    for (h = S.charCodeAt(0), m = 0; m < 8; m++)
                      ((A = (A << 1) | (h & 1)),
                        w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                        (h = h >> 1));
                  } else {
                    for (h = 1, m = 0; m < q; m++)
                      ((A = (A << 1) | h),
                        w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                        (h = 0));
                    for (h = S.charCodeAt(0), m = 0; m < 16; m++)
                      ((A = (A << 1) | (h & 1)),
                        w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                        (h = h >> 1));
                  }
                  (R--, R == 0 && ((R = Math.pow(2, q)), q++), delete v[S]);
                } else
                  for (h = g[S], m = 0; m < q; m++)
                    ((A = (A << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                      (h = h >> 1));
                (R--, R == 0 && ((R = Math.pow(2, q)), q++), (g[b] = I++), (S = String(E)));
              }
            if (S !== '') {
              if (Object.prototype.hasOwnProperty.call(v, S)) {
                if (S.charCodeAt(0) < 256) {
                  for (m = 0; m < q; m++)
                    ((A = A << 1), w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++);
                  for (h = S.charCodeAt(0), m = 0; m < 8; m++)
                    ((A = (A << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                      (h = h >> 1));
                } else {
                  for (h = 1, m = 0; m < q; m++)
                    ((A = (A << 1) | h),
                      w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                      (h = 0));
                  for (h = S.charCodeAt(0), m = 0; m < 16; m++)
                    ((A = (A << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                      (h = h >> 1));
                }
                (R--, R == 0 && ((R = Math.pow(2, q)), q++), delete v[S]);
              } else
                for (h = g[S], m = 0; m < q; m++)
                  ((A = (A << 1) | (h & 1)),
                    w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                    (h = h >> 1));
              (R--, R == 0 && ((R = Math.pow(2, q)), q++));
            }
            for (h = 2, m = 0; m < q; m++)
              ((A = (A << 1) | (h & 1)),
                w == p - 1 ? ((w = 0), P.push(f(A)), (A = 0)) : w++,
                (h = h >> 1));
            for (;;)
              if (((A = A << 1), w == p - 1)) {
                P.push(f(A));
                break;
              } else w++;
            return P.join('');
          }, '_compress'),
          decompress: s(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 32768, function (p) {
                    return u.charCodeAt(p);
                  });
          }, 'decompress'),
          _decompress: s(function (u, p, f) {
            var m = [],
              h = 4,
              g = 4,
              v = 3,
              E = '',
              b = [],
              S,
              R,
              I,
              q,
              P,
              A,
              w,
              _ = { val: f(0), position: p, index: 1 };
            for (S = 0; S < 3; S += 1) m[S] = S;
            for (I = 0, P = Math.pow(2, 2), A = 1; A != P; )
              ((q = _.val & _.position),
                (_.position >>= 1),
                _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                (I |= (q > 0 ? 1 : 0) * A),
                (A <<= 1));
            switch (I) {
              case 0:
                for (I = 0, P = Math.pow(2, 8), A = 1; A != P; )
                  ((q = _.val & _.position),
                    (_.position >>= 1),
                    _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                    (I |= (q > 0 ? 1 : 0) * A),
                    (A <<= 1));
                w = n(I);
                break;
              case 1:
                for (I = 0, P = Math.pow(2, 16), A = 1; A != P; )
                  ((q = _.val & _.position),
                    (_.position >>= 1),
                    _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                    (I |= (q > 0 ? 1 : 0) * A),
                    (A <<= 1));
                w = n(I);
                break;
              case 2:
                return '';
            }
            for (m[3] = w, R = w, b.push(w); ; ) {
              if (_.index > u) return '';
              for (I = 0, P = Math.pow(2, v), A = 1; A != P; )
                ((q = _.val & _.position),
                  (_.position >>= 1),
                  _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                  (I |= (q > 0 ? 1 : 0) * A),
                  (A <<= 1));
              switch ((w = I)) {
                case 0:
                  for (I = 0, P = Math.pow(2, 8), A = 1; A != P; )
                    ((q = _.val & _.position),
                      (_.position >>= 1),
                      _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                      (I |= (q > 0 ? 1 : 0) * A),
                      (A <<= 1));
                  ((m[g++] = n(I)), (w = g - 1), h--);
                  break;
                case 1:
                  for (I = 0, P = Math.pow(2, 16), A = 1; A != P; )
                    ((q = _.val & _.position),
                      (_.position >>= 1),
                      _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                      (I |= (q > 0 ? 1 : 0) * A),
                      (A <<= 1));
                  ((m[g++] = n(I)), (w = g - 1), h--);
                  break;
                case 2:
                  return b.join('');
              }
              if ((h == 0 && ((h = Math.pow(2, v)), v++), m[w])) E = m[w];
              else if (w === g) E = R + R.charAt(0);
              else return null;
              (b.push(E),
                (m[g++] = R + E.charAt(0)),
                h--,
                (R = E),
                h == 0 && ((h = Math.pow(2, v)), v++));
            }
          }, '_decompress'),
        };
        return d;
      })();
      typeof define == 'function' && define.amd
        ? define(function () {
            return r;
          })
        : typeof t < 'u' && t != null
          ? (t.exports = r)
          : typeof angular < 'u' &&
            angular != null &&
            angular.module('LZString', []).factory('LZString', function () {
              return r;
            });
    },
  }),
  Rv = B({
    '../node_modules/memoizerific/memoizerific.js'(e, t) {
      (function (r) {
        if (typeof e == 'object' && typeof t < 'u') t.exports = r();
        else if (typeof define == 'function' && define.amd) define([], r);
        else {
          var n;
          (typeof window < 'u'
            ? (n = window)
            : typeof global < 'u'
              ? (n = global)
              : typeof self < 'u'
                ? (n = self)
                : (n = this),
            (n.memoizerific = r()));
        }
      })(function () {
        return s(function r(n, o, i) {
          function a(u, p) {
            if (!o[u]) {
              if (!n[u]) {
                var f = typeof Li == 'function' && Li;
                if (!p && f) return f(u, !0);
                if (c) return c(u, !0);
                var m = new Error("Cannot find module '" + u + "'");
                throw ((m.code = 'MODULE_NOT_FOUND'), m);
              }
              var h = (o[u] = { exports: {} });
              n[u][0].call(
                h.exports,
                function (g) {
                  var v = n[u][1][g];
                  return a(v || g);
                },
                h,
                h.exports,
                r,
                n,
                o,
                i,
              );
            }
            return o[u].exports;
          }
          s(a, 's');
          for (var c = typeof Li == 'function' && Li, d = 0; d < i.length; d++) a(i[d]);
          return a;
        }, 'e')(
          {
            1: [
              function (r, n, o) {
                n.exports = function (i) {
                  if (typeof Map != 'function' || i) {
                    var a = r('./similar');
                    return new a();
                  } else return new Map();
                };
              },
              { './similar': 2 },
            ],
            2: [
              function (r, n, o) {
                function i() {
                  return ((this.list = []), (this.lastItem = void 0), (this.size = 0), this);
                }
                (s(i, 'Similar'),
                  (i.prototype.get = function (a) {
                    var c;
                    if (this.lastItem && this.isEqual(this.lastItem.key, a))
                      return this.lastItem.val;
                    if (((c = this.indexOf(a)), c >= 0))
                      return ((this.lastItem = this.list[c]), this.list[c].val);
                  }),
                  (i.prototype.set = function (a, c) {
                    var d;
                    return this.lastItem && this.isEqual(this.lastItem.key, a)
                      ? ((this.lastItem.val = c), this)
                      : ((d = this.indexOf(a)),
                        d >= 0
                          ? ((this.lastItem = this.list[d]), (this.list[d].val = c), this)
                          : ((this.lastItem = { key: a, val: c }),
                            this.list.push(this.lastItem),
                            this.size++,
                            this));
                  }),
                  (i.prototype.delete = function (a) {
                    var c;
                    if (
                      (this.lastItem &&
                        this.isEqual(this.lastItem.key, a) &&
                        (this.lastItem = void 0),
                      (c = this.indexOf(a)),
                      c >= 0)
                    )
                      return (this.size--, this.list.splice(c, 1)[0]);
                  }),
                  (i.prototype.has = function (a) {
                    var c;
                    return this.lastItem && this.isEqual(this.lastItem.key, a)
                      ? !0
                      : ((c = this.indexOf(a)), c >= 0 ? ((this.lastItem = this.list[c]), !0) : !1);
                  }),
                  (i.prototype.forEach = function (a, c) {
                    var d;
                    for (d = 0; d < this.size; d++)
                      a.call(c || this, this.list[d].val, this.list[d].key, this);
                  }),
                  (i.prototype.indexOf = function (a) {
                    var c;
                    for (c = 0; c < this.size; c++) if (this.isEqual(this.list[c].key, a)) return c;
                    return -1;
                  }),
                  (i.prototype.isEqual = function (a, c) {
                    return a === c || (a !== a && c !== c);
                  }),
                  (n.exports = i));
              },
              {},
            ],
            3: [
              function (r, n, o) {
                var i = r('map-or-similar');
                n.exports = function (u) {
                  var p = new i(!1),
                    f = [];
                  return function (m) {
                    var h = s(function () {
                      var g = p,
                        v,
                        E,
                        b = arguments.length - 1,
                        S = Array(b + 1),
                        R = !0,
                        I;
                      if ((h.numArgs || h.numArgs === 0) && h.numArgs !== b + 1)
                        throw new Error(
                          'Memoizerific functions should always be called with the same number of arguments',
                        );
                      for (I = 0; I < b; I++) {
                        if (((S[I] = { cacheItem: g, arg: arguments[I] }), g.has(arguments[I]))) {
                          g = g.get(arguments[I]);
                          continue;
                        }
                        ((R = !1), (v = new i(!1)), g.set(arguments[I], v), (g = v));
                      }
                      return (
                        R && (g.has(arguments[b]) ? (E = g.get(arguments[b])) : (R = !1)),
                        R || ((E = m.apply(null, arguments)), g.set(arguments[b], E)),
                        u > 0 &&
                          ((S[b] = { cacheItem: g, arg: arguments[b] }),
                          R ? a(f, S) : f.push(S),
                          f.length > u && c(f.shift())),
                        (h.wasMemoized = R),
                        (h.numArgs = b + 1),
                        E
                      );
                    }, 'memoizerific');
                    return ((h.limit = u), (h.wasMemoized = !1), (h.cache = p), (h.lru = f), h);
                  };
                };
                function a(u, p) {
                  var f = u.length,
                    m = p.length,
                    h,
                    g,
                    v;
                  for (g = 0; g < f; g++) {
                    for (h = !0, v = 0; v < m; v++)
                      if (!d(u[g][v].arg, p[v].arg)) {
                        h = !1;
                        break;
                      }
                    if (h) break;
                  }
                  u.push(u.splice(g, 1)[0]);
                }
                s(a, 'moveToMostRecentLru');
                function c(u) {
                  var p = u.length,
                    f = u[p - 1],
                    m,
                    h;
                  for (
                    f.cacheItem.delete(f.arg), h = p - 2;
                    h >= 0 && ((f = u[h]), (m = f.cacheItem.get(f.arg)), !m || !m.size);
                    h--
                  )
                    f.cacheItem.delete(f.arg);
                }
                s(c, 'removeCachedResult');
                function d(u, p) {
                  return u === p || (u !== u && p !== p);
                }
                s(d, 'isEqual');
              },
              { 'map-or-similar': 1 },
            ],
          },
          {},
          [3],
        )(3);
      });
    },
  }),
  xv = B({
    '../node_modules/picoquery/lib/string-util.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.encodeString = n));
      var t = Array.from(
          { length: 256 },
          (o, i) => '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase(),
        ),
        r = new Int8Array([
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
          0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 0, 0, 0, 1, 0,
        ]);
      function n(o) {
        const i = o.length;
        if (i === 0) return '';
        let a = '',
          c = 0,
          d = 0;
        e: for (; d < i; d++) {
          let u = o.charCodeAt(d);
          for (; u < 128; ) {
            if (
              (r[u] !== 1 && (c < d && (a += o.slice(c, d)), (c = d + 1), (a += t[u])), ++d === i)
            )
              break e;
            u = o.charCodeAt(d);
          }
          if ((c < d && (a += o.slice(c, d)), u < 2048)) {
            ((c = d + 1), (a += t[192 | (u >> 6)] + t[128 | (u & 63)]));
            continue;
          }
          if (u < 55296 || u >= 57344) {
            ((c = d + 1), (a += t[224 | (u >> 12)] + t[128 | ((u >> 6) & 63)] + t[128 | (u & 63)]));
            continue;
          }
          if ((++d, d >= i)) throw new Error('URI malformed');
          const p = o.charCodeAt(d) & 1023;
          ((c = d + 1),
            (u = 65536 + (((u & 1023) << 10) | p)),
            (a +=
              t[240 | (u >> 18)] +
              t[128 | ((u >> 12) & 63)] +
              t[128 | ((u >> 6) & 63)] +
              t[128 | (u & 63)]));
        }
        return c === 0 ? o : c < i ? a + o.slice(c) : a;
      }
      s(n, 'encodeString');
    },
  }),
  Np = B({
    '../node_modules/picoquery/lib/shared.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.defaultOptions = e.defaultShouldSerializeObject = e.defaultValueSerializer = void 0));
      var t = xv(),
        r = s((i) => {
          switch (typeof i) {
            case 'string':
              return (0, t.encodeString)(i);
            case 'bigint':
            case 'boolean':
              return '' + i;
            case 'number':
              if (Number.isFinite(i)) return i < 1e21 ? '' + i : (0, t.encodeString)('' + i);
              break;
          }
          return i instanceof Date ? (0, t.encodeString)(i.toISOString()) : '';
        }, 'defaultValueSerializer');
      e.defaultValueSerializer = r;
      var n = s((i) => i instanceof Date, 'defaultShouldSerializeObject');
      e.defaultShouldSerializeObject = n;
      var o = s((i) => i, 'identityFunc');
      e.defaultOptions = {
        nesting: !0,
        nestingSyntax: 'dot',
        arrayRepeat: !1,
        arrayRepeatSyntax: 'repeat',
        delimiter: 38,
        valueDeserializer: o,
        valueSerializer: e.defaultValueSerializer,
        keyDeserializer: o,
        shouldSerializeObject: e.defaultShouldSerializeObject,
      };
    },
  }),
  Pv = B({
    '../node_modules/picoquery/lib/object-util.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.getDeepObject = o),
        (e.stringifyObject = p));
      var t = Np(),
        r = xv();
      function n(f) {
        return f === '__proto__' || f === 'constructor' || f === 'prototype';
      }
      s(n, 'isPrototypeKey');
      function o(f, m, h, g, v) {
        if (n(m)) return f;
        const E = f[m];
        return typeof E == 'object' && E !== null
          ? E
          : !g &&
              (v ||
                typeof h == 'number' ||
                (typeof h == 'string' && h * 0 === 0 && h.indexOf('.') === -1))
            ? (f[m] = [])
            : (f[m] = {});
      }
      s(o, 'getDeepObject');
      var i = 20,
        a = '[]',
        c = '[',
        d = ']',
        u = '.';
      function p(f, m, h = 0, g, v) {
        const {
            nestingSyntax: E = t.defaultOptions.nestingSyntax,
            arrayRepeat: b = t.defaultOptions.arrayRepeat,
            arrayRepeatSyntax: S = t.defaultOptions.arrayRepeatSyntax,
            nesting: R = t.defaultOptions.nesting,
            delimiter: I = t.defaultOptions.delimiter,
            valueSerializer: q = t.defaultOptions.valueSerializer,
            shouldSerializeObject: P = t.defaultOptions.shouldSerializeObject,
          } = m,
          A = typeof I == 'number' ? String.fromCharCode(I) : I,
          w = v === !0 && b,
          _ = E === 'dot' || (E === 'js' && !v);
        if (h > i) return '';
        let $ = '',
          N = !0,
          V = !1;
        for (const H in f) {
          const x = f[H];
          if (x === void 0) continue;
          let D;
          (g
            ? ((D = g),
              w
                ? S === 'bracket' && (D += a)
                : _
                  ? ((D += u), (D += H))
                  : ((D += c), (D += H), (D += d)))
            : (D = H),
            N || ($ += A),
            typeof x == 'object' && x !== null && !P(x)
              ? ((V = x.pop !== void 0), (R || (b && V)) && ($ += p(x, m, h + 1, D, V)))
              : (($ += (0, r.encodeString)(D)), ($ += '='), ($ += q(x, H))),
            N && (N = !1));
        }
        return $;
      }
      s(p, 'stringifyObject');
    },
  }),
  G$ = B({
    '../node_modules/picoquery/lib/decode-uri-component.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.decodeURIComponent = o));
      var t = 12,
        r = 0,
        n = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,
          10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,
          0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7,
        ];
      function o(c) {
        let d = c.indexOf('%');
        if (d === -1) return c;
        const u = c.length;
        let p = '',
          f = 0,
          m = 0,
          h = d,
          g = t;
        for (; d > -1 && d < u; ) {
          const v = a(c[d + 1], 4),
            E = a(c[d + 2], 0),
            b = v | E,
            S = n[b];
          if (((g = n[256 + g + S]), (m = (m << 6) | (b & n[364 + S])), g === t))
            ((p += c.slice(f, h)),
              (p +=
                m <= 65535
                  ? String.fromCharCode(m)
                  : String.fromCharCode(55232 + (m >> 10), 56320 + (m & 1023))),
              (m = 0),
              (f = d + 3),
              (d = h = c.indexOf('%', f)));
          else {
            if (g === r) return null;
            if (((d += 3), d < u && c.charCodeAt(d) === 37)) continue;
            return null;
          }
        }
        return p + c.slice(f);
      }
      s(o, 'decodeURIComponent');
      var i = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15,
      };
      function a(c, d) {
        const u = i[c];
        return u === void 0 ? 255 : u << d;
      }
      s(a, 'hexCodeToInt');
    },
  }),
  W$ = B({
    '../node_modules/picoquery/lib/parse.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.numberValueDeserializer = e.numberKeyDeserializer = void 0),
        (e.parse = u));
      var t = Pv(),
        r = Np(),
        n = G$(),
        o = s((p) => {
          const f = Number(p);
          return Number.isNaN(f) ? p : f;
        }, 'numberKeyDeserializer');
      e.numberKeyDeserializer = o;
      var i = s((p) => {
        const f = Number(p);
        return Number.isNaN(f) ? p : f;
      }, 'numberValueDeserializer');
      e.numberValueDeserializer = i;
      var a = /\+/g,
        c = s(function () {}, 'Empty');
      c.prototype = Object.create(null);
      function d(p, f, m, h, g) {
        let v = p.substring(f, m);
        return (h && (v = v.replace(a, ' ')), g && (v = (0, n.decodeURIComponent)(v) || v), v);
      }
      s(d, 'computeKeySlice');
      function u(p, f) {
        const {
            valueDeserializer: m = r.defaultOptions.valueDeserializer,
            keyDeserializer: h = r.defaultOptions.keyDeserializer,
            arrayRepeatSyntax: g = r.defaultOptions.arrayRepeatSyntax,
            nesting: v = r.defaultOptions.nesting,
            arrayRepeat: E = r.defaultOptions.arrayRepeat,
            nestingSyntax: b = r.defaultOptions.nestingSyntax,
            delimiter: S = r.defaultOptions.delimiter,
          } = f ?? {},
          R = typeof S == 'string' ? S.charCodeAt(0) : S,
          I = b === 'js',
          q = new c();
        if (typeof p != 'string') return q;
        const P = p.length;
        let A = '',
          w = -1,
          _ = -1,
          $ = -1,
          N = q,
          V,
          H = '',
          x = '',
          D = !1,
          F = !1,
          k = !1,
          K = !1,
          X = !1,
          se = !1,
          ie = 0,
          W = -1,
          ae = -1,
          be = -1;
        for (let ue = 0; ue < P + 1; ue++) {
          if (((ie = ue !== P ? p.charCodeAt(ue) : R), ie === R)) {
            if (
              ((se = _ > w),
              se || (_ = ue),
              $ !== _ - 1 &&
                ((x = d(p, $ + 1, W > -1 ? W : _, k, D)),
                (H = h(x)),
                V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I && X, void 0))),
              se || H !== '')
            ) {
              se &&
                ((A = p.slice(_ + 1, ue)),
                K && (A = A.replace(a, ' ')),
                F && (A = (0, n.decodeURIComponent)(A) || A));
              const ee = m(A, H);
              if (E) {
                const xe = N[H];
                xe === void 0
                  ? W > -1
                    ? (N[H] = [ee])
                    : (N[H] = ee)
                  : xe.pop
                    ? xe.push(ee)
                    : (N[H] = [xe, ee]);
              } else N[H] = ee;
            }
            ((A = ''),
              (w = ue),
              (_ = ue),
              (D = !1),
              (F = !1),
              (k = !1),
              (K = !1),
              (X = !1),
              (W = -1),
              ($ = ue),
              (N = q),
              (V = void 0),
              (H = ''));
          } else
            ie === 93
              ? (E && g === 'bracket' && be === 91 && (W = ae),
                v &&
                  (b === 'index' || I) &&
                  _ <= w &&
                  ($ !== ae &&
                    ((x = d(p, $ + 1, ue, k, D)),
                    (H = h(x)),
                    V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, void 0, void 0)),
                    (V = H),
                    (k = !1),
                    (D = !1)),
                  ($ = ue),
                  (X = !1)))
              : ie === 46
                ? v &&
                  (b === 'dot' || I) &&
                  _ <= w &&
                  ($ !== ae &&
                    ((x = d(p, $ + 1, ue, k, D)),
                    (H = h(x)),
                    V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I)),
                    (V = H),
                    (k = !1),
                    (D = !1)),
                  (X = !0),
                  ($ = ue))
                : ie === 91
                  ? v &&
                    (b === 'index' || I) &&
                    _ <= w &&
                    ($ !== ae &&
                      ((x = d(p, $ + 1, ue, k, D)),
                      (H = h(x)),
                      I && V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I)),
                      (V = H),
                      (k = !1),
                      (D = !1),
                      (X = !1)),
                    ($ = ue))
                  : ie === 61
                    ? _ <= w
                      ? (_ = ue)
                      : (F = !0)
                    : ie === 43
                      ? _ > w
                        ? (K = !0)
                        : (k = !0)
                      : ie === 37 && (_ > w ? (F = !0) : (D = !0));
          ((ae = ue), (be = ie));
        }
        return q;
      }
      s(u, 'parse');
    },
  }),
  K$ = B({
    '../node_modules/picoquery/lib/stringify.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.stringify = r));
      var t = Pv();
      function r(n, o) {
        if (n === null || typeof n != 'object') return '';
        const i = o ?? {};
        return (0, t.stringifyObject)(n, i);
      }
      s(r, 'stringify');
    },
  }),
  qp = B({
    '../node_modules/picoquery/lib/main.js'(e) {
      var t =
          (e && e.__createBinding) ||
          (Object.create
            ? function (i, a, c, d) {
                d === void 0 && (d = c);
                var u = Object.getOwnPropertyDescriptor(a, c);
                ((!u || ('get' in u ? !a.__esModule : u.writable || u.configurable)) &&
                  (u = {
                    enumerable: !0,
                    get: s(function () {
                      return a[c];
                    }, 'get'),
                  }),
                  Object.defineProperty(i, d, u));
              }
            : function (i, a, c, d) {
                (d === void 0 && (d = c), (i[d] = a[c]));
              }),
        r =
          (e && e.__exportStar) ||
          function (i, a) {
            for (var c in i)
              c !== 'default' && !Object.prototype.hasOwnProperty.call(a, c) && t(a, i, c);
          };
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.stringify = e.parse = void 0));
      var n = W$();
      Object.defineProperty(e, 'parse', {
        enumerable: !0,
        get: s(function () {
          return n.parse;
        }, 'get'),
      });
      var o = K$();
      (Object.defineProperty(e, 'stringify', {
        enumerable: !0,
        get: s(function () {
          return o.stringify;
        }, 'get'),
      }),
        r(Np(), e));
    },
  }),
  Ov = B({
    '../node_modules/entities/lib/maps/entities.json'(e, t) {
      t.exports = {
        Aacute: '',
        aacute: '',
        Abreve: '',
        abreve: '',
        ac: '',
        acd: '',
        acE: '',
        Acirc: '',
        acirc: '',
        acute: '',
        Acy: '',
        acy: '',
        AElig: '',
        aelig: '',
        af: '',
        Afr: '',
        afr: '',
        Agrave: '',
        agrave: '',
        alefsym: '',
        aleph: '',
        Alpha: '',
        alpha: '',
        Amacr: '',
        amacr: '',
        amalg: '',
        amp: '&',
        AMP: '&',
        andand: '',
        And: '',
        and: '',
        andd: '',
        andslope: '',
        andv: '',
        ang: '',
        ange: '',
        angle: '',
        angmsdaa: '',
        angmsdab: '',
        angmsdac: '',
        angmsdad: '',
        angmsdae: '',
        angmsdaf: '',
        angmsdag: '',
        angmsdah: '',
        angmsd: '',
        angrt: '',
        angrtvb: '',
        angrtvbd: '',
        angsph: '',
        angst: '',
        angzarr: '',
        Aogon: '',
        aogon: '',
        Aopf: '',
        aopf: '',
        apacir: '',
        ap: '',
        apE: '',
        ape: '',
        apid: '',
        apos: "'",
        ApplyFunction: '',
        approx: '',
        approxeq: '',
        Aring: '',
        aring: '',
        Ascr: '',
        ascr: '',
        Assign: '',
        ast: '*',
        asymp: '',
        asympeq: '',
        Atilde: '',
        atilde: '',
        Auml: '',
        auml: '',
        awconint: '',
        awint: '',
        backcong: '',
        backepsilon: '',
        backprime: '',
        backsim: '',
        backsimeq: '',
        Backslash: '',
        Barv: '',
        barvee: '',
        barwed: '',
        Barwed: '',
        barwedge: '',
        bbrk: '',
        bbrktbrk: '',
        bcong: '',
        Bcy: '',
        bcy: '',
        bdquo: '',
        becaus: '',
        because: '',
        Because: '',
        bemptyv: '',
        bepsi: '',
        bernou: '',
        Bernoullis: '',
        Beta: '',
        beta: '',
        beth: '',
        between: '',
        Bfr: '',
        bfr: '',
        bigcap: '',
        bigcirc: '',
        bigcup: '',
        bigodot: '',
        bigoplus: '',
        bigotimes: '',
        bigsqcup: '',
        bigstar: '',
        bigtriangledown: '',
        bigtriangleup: '',
        biguplus: '',
        bigvee: '',
        bigwedge: '',
        bkarow: '',
        blacklozenge: '',
        blacksquare: '',
        blacktriangle: '',
        blacktriangledown: '',
        blacktriangleleft: '',
        blacktriangleright: '',
        blank: '',
        blk12: '',
        blk14: '',
        blk34: '',
        block: '',
        bne: '=',
        bnequiv: '',
        bNot: '',
        bnot: '',
        Bopf: '',
        bopf: '',
        bot: '',
        bottom: '',
        bowtie: '',
        boxbox: '',
        boxdl: '',
        boxdL: '',
        boxDl: '',
        boxDL: '',
        boxdr: '',
        boxdR: '',
        boxDr: '',
        boxDR: '',
        boxh: '',
        boxH: '',
        boxhd: '',
        boxHd: '',
        boxhD: '',
        boxHD: '',
        boxhu: '',
        boxHu: '',
        boxhU: '',
        boxHU: '',
        boxminus: '',
        boxplus: '',
        boxtimes: '',
        boxul: '',
        boxuL: '',
        boxUl: '',
        boxUL: '',
        boxur: '',
        boxuR: '',
        boxUr: '',
        boxUR: '',
        boxv: '',
        boxV: '',
        boxvh: '',
        boxvH: '',
        boxVh: '',
        boxVH: '',
        boxvl: '',
        boxvL: '',
        boxVl: '',
        boxVL: '',
        boxvr: '',
        boxvR: '',
        boxVr: '',
        boxVR: '',
        bprime: '',
        breve: '',
        Breve: '',
        brvbar: '',
        bscr: '',
        Bscr: '',
        bsemi: '',
        bsim: '',
        bsime: '',
        bsolb: '',
        bsol: '\\',
        bsolhsub: '',
        bull: '',
        bullet: '',
        bump: '',
        bumpE: '',
        bumpe: '',
        Bumpeq: '',
        bumpeq: '',
        Cacute: '',
        cacute: '',
        capand: '',
        capbrcup: '',
        capcap: '',
        cap: '',
        Cap: '',
        capcup: '',
        capdot: '',
        CapitalDifferentialD: '',
        caps: '',
        caret: '',
        caron: '',
        Cayleys: '',
        ccaps: '',
        Ccaron: '',
        ccaron: '',
        Ccedil: '',
        ccedil: '',
        Ccirc: '',
        ccirc: '',
        Cconint: '',
        ccups: '',
        ccupssm: '',
        Cdot: '',
        cdot: '',
        cedil: '',
        Cedilla: '',
        cemptyv: '',
        cent: '',
        centerdot: '',
        CenterDot: '',
        cfr: '',
        Cfr: '',
        CHcy: '',
        chcy: '',
        check: '',
        checkmark: '',
        Chi: '',
        chi: '',
        circ: '',
        circeq: '',
        circlearrowleft: '',
        circlearrowright: '',
        circledast: '',
        circledcirc: '',
        circleddash: '',
        CircleDot: '',
        circledR: '',
        circledS: '',
        CircleMinus: '',
        CirclePlus: '',
        CircleTimes: '',
        cir: '',
        cirE: '',
        cire: '',
        cirfnint: '',
        cirmid: '',
        cirscir: '',
        ClockwiseContourIntegral: '',
        CloseCurlyDoubleQuote: '',
        CloseCurlyQuote: '',
        clubs: '',
        clubsuit: '',
        colon: ':',
        Colon: '',
        Colone: '',
        colone: '',
        coloneq: '',
        comma: ',',
        commat: '@',
        comp: '',
        compfn: '',
        complement: '',
        complexes: '',
        cong: '',
        congdot: '',
        Congruent: '',
        conint: '',
        Conint: '',
        ContourIntegral: '',
        copf: '',
        Copf: '',
        coprod: '',
        Coproduct: '',
        copy: '',
        COPY: '',
        copysr: '',
        CounterClockwiseContourIntegral: '',
        crarr: '',
        cross: '',
        Cross: '',
        Cscr: '',
        cscr: '',
        csub: '',
        csube: '',
        csup: '',
        csupe: '',
        ctdot: '',
        cudarrl: '',
        cudarrr: '',
        cuepr: '',
        cuesc: '',
        cularr: '',
        cularrp: '',
        cupbrcap: '',
        cupcap: '',
        CupCap: '',
        cup: '',
        Cup: '',
        cupcup: '',
        cupdot: '',
        cupor: '',
        cups: '',
        curarr: '',
        curarrm: '',
        curlyeqprec: '',
        curlyeqsucc: '',
        curlyvee: '',
        curlywedge: '',
        curren: '',
        curvearrowleft: '',
        curvearrowright: '',
        cuvee: '',
        cuwed: '',
        cwconint: '',
        cwint: '',
        cylcty: '',
        dagger: '',
        Dagger: '',
        daleth: '',
        darr: '',
        Darr: '',
        dArr: '',
        dash: '',
        Dashv: '',
        dashv: '',
        dbkarow: '',
        dblac: '',
        Dcaron: '',
        dcaron: '',
        Dcy: '',
        dcy: '',
        ddagger: '',
        ddarr: '',
        DD: '',
        dd: '',
        DDotrahd: '',
        ddotseq: '',
        deg: '',
        Del: '',
        Delta: '',
        delta: '',
        demptyv: '',
        dfisht: '',
        Dfr: '',
        dfr: '',
        dHar: '',
        dharl: '',
        dharr: '',
        DiacriticalAcute: '',
        DiacriticalDot: '',
        DiacriticalDoubleAcute: '',
        DiacriticalGrave: '`',
        DiacriticalTilde: '',
        diam: '',
        diamond: '',
        Diamond: '',
        diamondsuit: '',
        diams: '',
        die: '',
        DifferentialD: '',
        digamma: '',
        disin: '',
        div: '',
        divide: '',
        divideontimes: '',
        divonx: '',
        DJcy: '',
        djcy: '',
        dlcorn: '',
        dlcrop: '',
        dollar: '$',
        Dopf: '',
        dopf: '',
        Dot: '',
        dot: '',
        DotDot: '',
        doteq: '',
        doteqdot: '',
        DotEqual: '',
        dotminus: '',
        dotplus: '',
        dotsquare: '',
        doublebarwedge: '',
        DoubleContourIntegral: '',
        DoubleDot: '',
        DoubleDownArrow: '',
        DoubleLeftArrow: '',
        DoubleLeftRightArrow: '',
        DoubleLeftTee: '',
        DoubleLongLeftArrow: '',
        DoubleLongLeftRightArrow: '',
        DoubleLongRightArrow: '',
        DoubleRightArrow: '',
        DoubleRightTee: '',
        DoubleUpArrow: '',
        DoubleUpDownArrow: '',
        DoubleVerticalBar: '',
        DownArrowBar: '',
        downarrow: '',
        DownArrow: '',
        Downarrow: '',
        DownArrowUpArrow: '',
        DownBreve: '',
        downdownarrows: '',
        downharpoonleft: '',
        downharpoonright: '',
        DownLeftRightVector: '',
        DownLeftTeeVector: '',
        DownLeftVectorBar: '',
        DownLeftVector: '',
        DownRightTeeVector: '',
        DownRightVectorBar: '',
        DownRightVector: '',
        DownTeeArrow: '',
        DownTee: '',
        drbkarow: '',
        drcorn: '',
        drcrop: '',
        Dscr: '',
        dscr: '',
        DScy: '',
        dscy: '',
        dsol: '',
        Dstrok: '',
        dstrok: '',
        dtdot: '',
        dtri: '',
        dtrif: '',
        duarr: '',
        duhar: '',
        dwangle: '',
        DZcy: '',
        dzcy: '',
        dzigrarr: '',
        Eacute: '',
        eacute: '',
        easter: '',
        Ecaron: '',
        ecaron: '',
        Ecirc: '',
        ecirc: '',
        ecir: '',
        ecolon: '',
        Ecy: '',
        ecy: '',
        eDDot: '',
        Edot: '',
        edot: '',
        eDot: '',
        ee: '',
        efDot: '',
        Efr: '',
        efr: '',
        eg: '',
        Egrave: '',
        egrave: '',
        egs: '',
        egsdot: '',
        el: '',
        Element: '',
        elinters: '',
        ell: '',
        els: '',
        elsdot: '',
        Emacr: '',
        emacr: '',
        empty: '',
        emptyset: '',
        EmptySmallSquare: '',
        emptyv: '',
        EmptyVerySmallSquare: '',
        emsp13: '',
        emsp14: '',
        emsp: '',
        ENG: '',
        eng: '',
        ensp: '',
        Eogon: '',
        eogon: '',
        Eopf: '',
        eopf: '',
        epar: '',
        eparsl: '',
        eplus: '',
        epsi: '',
        Epsilon: '',
        epsilon: '',
        epsiv: '',
        eqcirc: '',
        eqcolon: '',
        eqsim: '',
        eqslantgtr: '',
        eqslantless: '',
        Equal: '',
        equals: '=',
        EqualTilde: '',
        equest: '',
        Equilibrium: '',
        equiv: '',
        equivDD: '',
        eqvparsl: '',
        erarr: '',
        erDot: '',
        escr: '',
        Escr: '',
        esdot: '',
        Esim: '',
        esim: '',
        Eta: '',
        eta: '',
        ETH: '',
        eth: '',
        Euml: '',
        euml: '',
        euro: '',
        excl: '!',
        exist: '',
        Exists: '',
        expectation: '',
        exponentiale: '',
        ExponentialE: '',
        fallingdotseq: '',
        Fcy: '',
        fcy: '',
        female: '',
        ffilig: '',
        fflig: '',
        ffllig: '',
        Ffr: '',
        ffr: '',
        filig: '',
        FilledSmallSquare: '',
        FilledVerySmallSquare: '',
        fjlig: 'fj',
        flat: '',
        fllig: '',
        fltns: '',
        fnof: '',
        Fopf: '',
        fopf: '',
        forall: '',
        ForAll: '',
        fork: '',
        forkv: '',
        Fouriertrf: '',
        fpartint: '',
        frac12: '',
        frac13: '',
        frac14: '',
        frac15: '',
        frac16: '',
        frac18: '',
        frac23: '',
        frac25: '',
        frac34: '',
        frac35: '',
        frac38: '',
        frac45: '',
        frac56: '',
        frac58: '',
        frac78: '',
        frasl: '',
        frown: '',
        fscr: '',
        Fscr: '',
        gacute: '',
        Gamma: '',
        gamma: '',
        Gammad: '',
        gammad: '',
        gap: '',
        Gbreve: '',
        gbreve: '',
        Gcedil: '',
        Gcirc: '',
        gcirc: '',
        Gcy: '',
        gcy: '',
        Gdot: '',
        gdot: '',
        ge: '',
        gE: '',
        gEl: '',
        gel: '',
        geq: '',
        geqq: '',
        geqslant: '',
        gescc: '',
        ges: '',
        gesdot: '',
        gesdoto: '',
        gesdotol: '',
        gesl: '',
        gesles: '',
        Gfr: '',
        gfr: '',
        gg: '',
        Gg: '',
        ggg: '',
        gimel: '',
        GJcy: '',
        gjcy: '',
        gla: '',
        gl: '',
        glE: '',
        glj: '',
        gnap: '',
        gnapprox: '',
        gne: '',
        gnE: '',
        gneq: '',
        gneqq: '',
        gnsim: '',
        Gopf: '',
        gopf: '',
        grave: '`',
        GreaterEqual: '',
        GreaterEqualLess: '',
        GreaterFullEqual: '',
        GreaterGreater: '',
        GreaterLess: '',
        GreaterSlantEqual: '',
        GreaterTilde: '',
        Gscr: '',
        gscr: '',
        gsim: '',
        gsime: '',
        gsiml: '',
        gtcc: '',
        gtcir: '',
        gt: '>',
        GT: '>',
        Gt: '',
        gtdot: '',
        gtlPar: '',
        gtquest: '',
        gtrapprox: '',
        gtrarr: '',
        gtrdot: '',
        gtreqless: '',
        gtreqqless: '',
        gtrless: '',
        gtrsim: '',
        gvertneqq: '',
        gvnE: '',
        Hacek: '',
        hairsp: '',
        half: '',
        hamilt: '',
        HARDcy: '',
        hardcy: '',
        harrcir: '',
        harr: '',
        hArr: '',
        harrw: '',
        Hat: '^',
        hbar: '',
        Hcirc: '',
        hcirc: '',
        hearts: '',
        heartsuit: '',
        hellip: '',
        hercon: '',
        hfr: '',
        Hfr: '',
        HilbertSpace: '',
        hksearow: '',
        hkswarow: '',
        hoarr: '',
        homtht: '',
        hookleftarrow: '',
        hookrightarrow: '',
        hopf: '',
        Hopf: '',
        horbar: '',
        HorizontalLine: '',
        hscr: '',
        Hscr: '',
        hslash: '',
        Hstrok: '',
        hstrok: '',
        HumpDownHump: '',
        HumpEqual: '',
        hybull: '',
        hyphen: '',
        Iacute: '',
        iacute: '',
        ic: '',
        Icirc: '',
        icirc: '',
        Icy: '',
        icy: '',
        Idot: '',
        IEcy: '',
        iecy: '',
        iexcl: '',
        iff: '',
        ifr: '',
        Ifr: '',
        Igrave: '',
        igrave: '',
        ii: '',
        iiiint: '',
        iiint: '',
        iinfin: '',
        iiota: '',
        IJlig: '',
        ijlig: '',
        Imacr: '',
        imacr: '',
        image: '',
        ImaginaryI: '',
        imagline: '',
        imagpart: '',
        imath: '',
        Im: '',
        imof: '',
        imped: '',
        Implies: '',
        incare: '',
        in: '',
        infin: '',
        infintie: '',
        inodot: '',
        intcal: '',
        int: '',
        Int: '',
        integers: '',
        Integral: '',
        intercal: '',
        Intersection: '',
        intlarhk: '',
        intprod: '',
        InvisibleComma: '',
        InvisibleTimes: '',
        IOcy: '',
        iocy: '',
        Iogon: '',
        iogon: '',
        Iopf: '',
        iopf: '',
        Iota: '',
        iota: '',
        iprod: '',
        iquest: '',
        iscr: '',
        Iscr: '',
        isin: '',
        isindot: '',
        isinE: '',
        isins: '',
        isinsv: '',
        isinv: '',
        it: '',
        Itilde: '',
        itilde: '',
        Iukcy: '',
        iukcy: '',
        Iuml: '',
        iuml: '',
        Jcirc: '',
        jcirc: '',
        Jcy: '',
        jcy: '',
        Jfr: '',
        jfr: '',
        jmath: '',
        Jopf: '',
        jopf: '',
        Jscr: '',
        jscr: '',
        Jsercy: '',
        jsercy: '',
        Jukcy: '',
        jukcy: '',
        Kappa: '',
        kappa: '',
        kappav: '',
        Kcedil: '',
        kcedil: '',
        Kcy: '',
        kcy: '',
        Kfr: '',
        kfr: '',
        kgreen: '',
        KHcy: '',
        khcy: '',
        KJcy: '',
        kjcy: '',
        Kopf: '',
        kopf: '',
        Kscr: '',
        kscr: '',
        lAarr: '',
        Lacute: '',
        lacute: '',
        laemptyv: '',
        lagran: '',
        Lambda: '',
        lambda: '',
        lang: '',
        Lang: '',
        langd: '',
        langle: '',
        lap: '',
        Laplacetrf: '',
        laquo: '',
        larrb: '',
        larrbfs: '',
        larr: '',
        Larr: '',
        lArr: '',
        larrfs: '',
        larrhk: '',
        larrlp: '',
        larrpl: '',
        larrsim: '',
        larrtl: '',
        latail: '',
        lAtail: '',
        lat: '',
        late: '',
        lates: '',
        lbarr: '',
        lBarr: '',
        lbbrk: '',
        lbrace: '{',
        lbrack: '[',
        lbrke: '',
        lbrksld: '',
        lbrkslu: '',
        Lcaron: '',
        lcaron: '',
        Lcedil: '',
        lcedil: '',
        lceil: '',
        lcub: '{',
        Lcy: '',
        lcy: '',
        ldca: '',
        ldquo: '',
        ldquor: '',
        ldrdhar: '',
        ldrushar: '',
        ldsh: '',
        le: '',
        lE: '',
        LeftAngleBracket: '',
        LeftArrowBar: '',
        leftarrow: '',
        LeftArrow: '',
        Leftarrow: '',
        LeftArrowRightArrow: '',
        leftarrowtail: '',
        LeftCeiling: '',
        LeftDoubleBracket: '',
        LeftDownTeeVector: '',
        LeftDownVectorBar: '',
        LeftDownVector: '',
        LeftFloor: '',
        leftharpoondown: '',
        leftharpoonup: '',
        leftleftarrows: '',
        leftrightarrow: '',
        LeftRightArrow: '',
        Leftrightarrow: '',
        leftrightarrows: '',
        leftrightharpoons: '',
        leftrightsquigarrow: '',
        LeftRightVector: '',
        LeftTeeArrow: '',
        LeftTee: '',
        LeftTeeVector: '',
        leftthreetimes: '',
        LeftTriangleBar: '',
        LeftTriangle: '',
        LeftTriangleEqual: '',
        LeftUpDownVector: '',
        LeftUpTeeVector: '',
        LeftUpVectorBar: '',
        LeftUpVector: '',
        LeftVectorBar: '',
        LeftVector: '',
        lEg: '',
        leg: '',
        leq: '',
        leqq: '',
        leqslant: '',
        lescc: '',
        les: '',
        lesdot: '',
        lesdoto: '',
        lesdotor: '',
        lesg: '',
        lesges: '',
        lessapprox: '',
        lessdot: '',
        lesseqgtr: '',
        lesseqqgtr: '',
        LessEqualGreater: '',
        LessFullEqual: '',
        LessGreater: '',
        lessgtr: '',
        LessLess: '',
        lesssim: '',
        LessSlantEqual: '',
        LessTilde: '',
        lfisht: '',
        lfloor: '',
        Lfr: '',
        lfr: '',
        lg: '',
        lgE: '',
        lHar: '',
        lhard: '',
        lharu: '',
        lharul: '',
        lhblk: '',
        LJcy: '',
        ljcy: '',
        llarr: '',
        ll: '',
        Ll: '',
        llcorner: '',
        Lleftarrow: '',
        llhard: '',
        lltri: '',
        Lmidot: '',
        lmidot: '',
        lmoustache: '',
        lmoust: '',
        lnap: '',
        lnapprox: '',
        lne: '',
        lnE: '',
        lneq: '',
        lneqq: '',
        lnsim: '',
        loang: '',
        loarr: '',
        lobrk: '',
        longleftarrow: '',
        LongLeftArrow: '',
        Longleftarrow: '',
        longleftrightarrow: '',
        LongLeftRightArrow: '',
        Longleftrightarrow: '',
        longmapsto: '',
        longrightarrow: '',
        LongRightArrow: '',
        Longrightarrow: '',
        looparrowleft: '',
        looparrowright: '',
        lopar: '',
        Lopf: '',
        lopf: '',
        loplus: '',
        lotimes: '',
        lowast: '',
        lowbar: '_',
        LowerLeftArrow: '',
        LowerRightArrow: '',
        loz: '',
        lozenge: '',
        lozf: '',
        lpar: '(',
        lparlt: '',
        lrarr: '',
        lrcorner: '',
        lrhar: '',
        lrhard: '',
        lrm: '',
        lrtri: '',
        lsaquo: '',
        lscr: '',
        Lscr: '',
        lsh: '',
        Lsh: '',
        lsim: '',
        lsime: '',
        lsimg: '',
        lsqb: '[',
        lsquo: '',
        lsquor: '',
        Lstrok: '',
        lstrok: '',
        ltcc: '',
        ltcir: '',
        lt: '<',
        LT: '<',
        Lt: '',
        ltdot: '',
        lthree: '',
        ltimes: '',
        ltlarr: '',
        ltquest: '',
        ltri: '',
        ltrie: '',
        ltrif: '',
        ltrPar: '',
        lurdshar: '',
        luruhar: '',
        lvertneqq: '',
        lvnE: '',
        macr: '',
        male: '',
        malt: '',
        maltese: '',
        Map: '',
        map: '',
        mapsto: '',
        mapstodown: '',
        mapstoleft: '',
        mapstoup: '',
        marker: '',
        mcomma: '',
        Mcy: '',
        mcy: '',
        mdash: '',
        mDDot: '',
        measuredangle: '',
        MediumSpace: '',
        Mellintrf: '',
        Mfr: '',
        mfr: '',
        mho: '',
        micro: '',
        midast: '*',
        midcir: '',
        mid: '',
        middot: '',
        minusb: '',
        minus: '',
        minusd: '',
        minusdu: '',
        MinusPlus: '',
        mlcp: '',
        mldr: '',
        mnplus: '',
        models: '',
        Mopf: '',
        mopf: '',
        mp: '',
        mscr: '',
        Mscr: '',
        mstpos: '',
        Mu: '',
        mu: '',
        multimap: '',
        mumap: '',
        nabla: '',
        Nacute: '',
        nacute: '',
        nang: '',
        nap: '',
        napE: '',
        napid: '',
        napos: '',
        napprox: '',
        natural: '',
        naturals: '',
        natur: '',
        nbsp: '',
        nbump: '',
        nbumpe: '',
        ncap: '',
        Ncaron: '',
        ncaron: '',
        Ncedil: '',
        ncedil: '',
        ncong: '',
        ncongdot: '',
        ncup: '',
        Ncy: '',
        ncy: '',
        ndash: '',
        nearhk: '',
        nearr: '',
        neArr: '',
        nearrow: '',
        ne: '',
        nedot: '',
        NegativeMediumSpace: '',
        NegativeThickSpace: '',
        NegativeThinSpace: '',
        NegativeVeryThinSpace: '',
        nequiv: '',
        nesear: '',
        nesim: '',
        NestedGreaterGreater: '',
        NestedLessLess: '',
        NewLine: `
`,
        nexist: '',
        nexists: '',
        Nfr: '',
        nfr: '',
        ngE: '',
        nge: '',
        ngeq: '',
        ngeqq: '',
        ngeqslant: '',
        nges: '',
        nGg: '',
        ngsim: '',
        nGt: '',
        ngt: '',
        ngtr: '',
        nGtv: '',
        nharr: '',
        nhArr: '',
        nhpar: '',
        ni: '',
        nis: '',
        nisd: '',
        niv: '',
        NJcy: '',
        njcy: '',
        nlarr: '',
        nlArr: '',
        nldr: '',
        nlE: '',
        nle: '',
        nleftarrow: '',
        nLeftarrow: '',
        nleftrightarrow: '',
        nLeftrightarrow: '',
        nleq: '',
        nleqq: '',
        nleqslant: '',
        nles: '',
        nless: '',
        nLl: '',
        nlsim: '',
        nLt: '',
        nlt: '',
        nltri: '',
        nltrie: '',
        nLtv: '',
        nmid: '',
        NoBreak: '',
        NonBreakingSpace: '',
        nopf: '',
        Nopf: '',
        Not: '',
        not: '',
        NotCongruent: '',
        NotCupCap: '',
        NotDoubleVerticalBar: '',
        NotElement: '',
        NotEqual: '',
        NotEqualTilde: '',
        NotExists: '',
        NotGreater: '',
        NotGreaterEqual: '',
        NotGreaterFullEqual: '',
        NotGreaterGreater: '',
        NotGreaterLess: '',
        NotGreaterSlantEqual: '',
        NotGreaterTilde: '',
        NotHumpDownHump: '',
        NotHumpEqual: '',
        notin: '',
        notindot: '',
        notinE: '',
        notinva: '',
        notinvb: '',
        notinvc: '',
        NotLeftTriangleBar: '',
        NotLeftTriangle: '',
        NotLeftTriangleEqual: '',
        NotLess: '',
        NotLessEqual: '',
        NotLessGreater: '',
        NotLessLess: '',
        NotLessSlantEqual: '',
        NotLessTilde: '',
        NotNestedGreaterGreater: '',
        NotNestedLessLess: '',
        notni: '',
        notniva: '',
        notnivb: '',
        notnivc: '',
        NotPrecedes: '',
        NotPrecedesEqual: '',
        NotPrecedesSlantEqual: '',
        NotReverseElement: '',
        NotRightTriangleBar: '',
        NotRightTriangle: '',
        NotRightTriangleEqual: '',
        NotSquareSubset: '',
        NotSquareSubsetEqual: '',
        NotSquareSuperset: '',
        NotSquareSupersetEqual: '',
        NotSubset: '',
        NotSubsetEqual: '',
        NotSucceeds: '',
        NotSucceedsEqual: '',
        NotSucceedsSlantEqual: '',
        NotSucceedsTilde: '',
        NotSuperset: '',
        NotSupersetEqual: '',
        NotTilde: '',
        NotTildeEqual: '',
        NotTildeFullEqual: '',
        NotTildeTilde: '',
        NotVerticalBar: '',
        nparallel: '',
        npar: '',
        nparsl: '',
        npart: '',
        npolint: '',
        npr: '',
        nprcue: '',
        nprec: '',
        npreceq: '',
        npre: '',
        nrarrc: '',
        nrarr: '',
        nrArr: '',
        nrarrw: '',
        nrightarrow: '',
        nRightarrow: '',
        nrtri: '',
        nrtrie: '',
        nsc: '',
        nsccue: '',
        nsce: '',
        Nscr: '',
        nscr: '',
        nshortmid: '',
        nshortparallel: '',
        nsim: '',
        nsime: '',
        nsimeq: '',
        nsmid: '',
        nspar: '',
        nsqsube: '',
        nsqsupe: '',
        nsub: '',
        nsubE: '',
        nsube: '',
        nsubset: '',
        nsubseteq: '',
        nsubseteqq: '',
        nsucc: '',
        nsucceq: '',
        nsup: '',
        nsupE: '',
        nsupe: '',
        nsupset: '',
        nsupseteq: '',
        nsupseteqq: '',
        ntgl: '',
        Ntilde: '',
        ntilde: '',
        ntlg: '',
        ntriangleleft: '',
        ntrianglelefteq: '',
        ntriangleright: '',
        ntrianglerighteq: '',
        Nu: '',
        nu: '',
        num: '#',
        numero: '',
        numsp: '',
        nvap: '',
        nvdash: '',
        nvDash: '',
        nVdash: '',
        nVDash: '',
        nvge: '',
        nvgt: '>',
        nvHarr: '',
        nvinfin: '',
        nvlArr: '',
        nvle: '',
        nvlt: '<',
        nvltrie: '',
        nvrArr: '',
        nvrtrie: '',
        nvsim: '',
        nwarhk: '',
        nwarr: '',
        nwArr: '',
        nwarrow: '',
        nwnear: '',
        Oacute: '',
        oacute: '',
        oast: '',
        Ocirc: '',
        ocirc: '',
        ocir: '',
        Ocy: '',
        ocy: '',
        odash: '',
        Odblac: '',
        odblac: '',
        odiv: '',
        odot: '',
        odsold: '',
        OElig: '',
        oelig: '',
        ofcir: '',
        Ofr: '',
        ofr: '',
        ogon: '',
        Ograve: '',
        ograve: '',
        ogt: '',
        ohbar: '',
        ohm: '',
        oint: '',
        olarr: '',
        olcir: '',
        olcross: '',
        oline: '',
        olt: '',
        Omacr: '',
        omacr: '',
        Omega: '',
        omega: '',
        Omicron: '',
        omicron: '',
        omid: '',
        ominus: '',
        Oopf: '',
        oopf: '',
        opar: '',
        OpenCurlyDoubleQuote: '',
        OpenCurlyQuote: '',
        operp: '',
        oplus: '',
        orarr: '',
        Or: '',
        or: '',
        ord: '',
        order: '',
        orderof: '',
        ordf: '',
        ordm: '',
        origof: '',
        oror: '',
        orslope: '',
        orv: '',
        oS: '',
        Oscr: '',
        oscr: '',
        Oslash: '',
        oslash: '',
        osol: '',
        Otilde: '',
        otilde: '',
        otimesas: '',
        Otimes: '',
        otimes: '',
        Ouml: '',
        ouml: '',
        ovbar: '',
        OverBar: '',
        OverBrace: '',
        OverBracket: '',
        OverParenthesis: '',
        para: '',
        parallel: '',
        par: '',
        parsim: '',
        parsl: '',
        part: '',
        PartialD: '',
        Pcy: '',
        pcy: '',
        percnt: '%',
        period: '.',
        permil: '',
        perp: '',
        pertenk: '',
        Pfr: '',
        pfr: '',
        Phi: '',
        phi: '',
        phiv: '',
        phmmat: '',
        phone: '',
        Pi: '',
        pi: '',
        pitchfork: '',
        piv: '',
        planck: '',
        planckh: '',
        plankv: '',
        plusacir: '',
        plusb: '',
        pluscir: '',
        plus: '+',
        plusdo: '',
        plusdu: '',
        pluse: '',
        PlusMinus: '',
        plusmn: '',
        plussim: '',
        plustwo: '',
        pm: '',
        Poincareplane: '',
        pointint: '',
        popf: '',
        Popf: '',
        pound: '',
        prap: '',
        Pr: '',
        pr: '',
        prcue: '',
        precapprox: '',
        prec: '',
        preccurlyeq: '',
        Precedes: '',
        PrecedesEqual: '',
        PrecedesSlantEqual: '',
        PrecedesTilde: '',
        preceq: '',
        precnapprox: '',
        precneqq: '',
        precnsim: '',
        pre: '',
        prE: '',
        precsim: '',
        prime: '',
        Prime: '',
        primes: '',
        prnap: '',
        prnE: '',
        prnsim: '',
        prod: '',
        Product: '',
        profalar: '',
        profline: '',
        profsurf: '',
        prop: '',
        Proportional: '',
        Proportion: '',
        propto: '',
        prsim: '',
        prurel: '',
        Pscr: '',
        pscr: '',
        Psi: '',
        psi: '',
        puncsp: '',
        Qfr: '',
        qfr: '',
        qint: '',
        qopf: '',
        Qopf: '',
        qprime: '',
        Qscr: '',
        qscr: '',
        quaternions: '',
        quatint: '',
        quest: '?',
        questeq: '',
        quot: '"',
        QUOT: '"',
        rAarr: '',
        race: '',
        Racute: '',
        racute: '',
        radic: '',
        raemptyv: '',
        rang: '',
        Rang: '',
        rangd: '',
        range: '',
        rangle: '',
        raquo: '',
        rarrap: '',
        rarrb: '',
        rarrbfs: '',
        rarrc: '',
        rarr: '',
        Rarr: '',
        rArr: '',
        rarrfs: '',
        rarrhk: '',
        rarrlp: '',
        rarrpl: '',
        rarrsim: '',
        Rarrtl: '',
        rarrtl: '',
        rarrw: '',
        ratail: '',
        rAtail: '',
        ratio: '',
        rationals: '',
        rbarr: '',
        rBarr: '',
        RBarr: '',
        rbbrk: '',
        rbrace: '}',
        rbrack: ']',
        rbrke: '',
        rbrksld: '',
        rbrkslu: '',
        Rcaron: '',
        rcaron: '',
        Rcedil: '',
        rcedil: '',
        rceil: '',
        rcub: '}',
        Rcy: '',
        rcy: '',
        rdca: '',
        rdldhar: '',
        rdquo: '',
        rdquor: '',
        rdsh: '',
        real: '',
        realine: '',
        realpart: '',
        reals: '',
        Re: '',
        rect: '',
        reg: '',
        REG: '',
        ReverseElement: '',
        ReverseEquilibrium: '',
        ReverseUpEquilibrium: '',
        rfisht: '',
        rfloor: '',
        rfr: '',
        Rfr: '',
        rHar: '',
        rhard: '',
        rharu: '',
        rharul: '',
        Rho: '',
        rho: '',
        rhov: '',
        RightAngleBracket: '',
        RightArrowBar: '',
        rightarrow: '',
        RightArrow: '',
        Rightarrow: '',
        RightArrowLeftArrow: '',
        rightarrowtail: '',
        RightCeiling: '',
        RightDoubleBracket: '',
        RightDownTeeVector: '',
        RightDownVectorBar: '',
        RightDownVector: '',
        RightFloor: '',
        rightharpoondown: '',
        rightharpoonup: '',
        rightleftarrows: '',
        rightleftharpoons: '',
        rightrightarrows: '',
        rightsquigarrow: '',
        RightTeeArrow: '',
        RightTee: '',
        RightTeeVector: '',
        rightthreetimes: '',
        RightTriangleBar: '',
        RightTriangle: '',
        RightTriangleEqual: '',
        RightUpDownVector: '',
        RightUpTeeVector: '',
        RightUpVectorBar: '',
        RightUpVector: '',
        RightVectorBar: '',
        RightVector: '',
        ring: '',
        risingdotseq: '',
        rlarr: '',
        rlhar: '',
        rlm: '',
        rmoustache: '',
        rmoust: '',
        rnmid: '',
        roang: '',
        roarr: '',
        robrk: '',
        ropar: '',
        ropf: '',
        Ropf: '',
        roplus: '',
        rotimes: '',
        RoundImplies: '',
        rpar: ')',
        rpargt: '',
        rppolint: '',
        rrarr: '',
        Rrightarrow: '',
        rsaquo: '',
        rscr: '',
        Rscr: '',
        rsh: '',
        Rsh: '',
        rsqb: ']',
        rsquo: '',
        rsquor: '',
        rthree: '',
        rtimes: '',
        rtri: '',
        rtrie: '',
        rtrif: '',
        rtriltri: '',
        RuleDelayed: '',
        ruluhar: '',
        rx: '',
        Sacute: '',
        sacute: '',
        sbquo: '',
        scap: '',
        Scaron: '',
        scaron: '',
        Sc: '',
        sc: '',
        sccue: '',
        sce: '',
        scE: '',
        Scedil: '',
        scedil: '',
        Scirc: '',
        scirc: '',
        scnap: '',
        scnE: '',
        scnsim: '',
        scpolint: '',
        scsim: '',
        Scy: '',
        scy: '',
        sdotb: '',
        sdot: '',
        sdote: '',
        searhk: '',
        searr: '',
        seArr: '',
        searrow: '',
        sect: '',
        semi: ';',
        seswar: '',
        setminus: '',
        setmn: '',
        sext: '',
        Sfr: '',
        sfr: '',
        sfrown: '',
        sharp: '',
        SHCHcy: '',
        shchcy: '',
        SHcy: '',
        shcy: '',
        ShortDownArrow: '',
        ShortLeftArrow: '',
        shortmid: '',
        shortparallel: '',
        ShortRightArrow: '',
        ShortUpArrow: '',
        shy: '',
        Sigma: '',
        sigma: '',
        sigmaf: '',
        sigmav: '',
        sim: '',
        simdot: '',
        sime: '',
        simeq: '',
        simg: '',
        simgE: '',
        siml: '',
        simlE: '',
        simne: '',
        simplus: '',
        simrarr: '',
        slarr: '',
        SmallCircle: '',
        smallsetminus: '',
        smashp: '',
        smeparsl: '',
        smid: '',
        smile: '',
        smt: '',
        smte: '',
        smtes: '',
        SOFTcy: '',
        softcy: '',
        solbar: '',
        solb: '',
        sol: '/',
        Sopf: '',
        sopf: '',
        spades: '',
        spadesuit: '',
        spar: '',
        sqcap: '',
        sqcaps: '',
        sqcup: '',
        sqcups: '',
        Sqrt: '',
        sqsub: '',
        sqsube: '',
        sqsubset: '',
        sqsubseteq: '',
        sqsup: '',
        sqsupe: '',
        sqsupset: '',
        sqsupseteq: '',
        square: '',
        Square: '',
        SquareIntersection: '',
        SquareSubset: '',
        SquareSubsetEqual: '',
        SquareSuperset: '',
        SquareSupersetEqual: '',
        SquareUnion: '',
        squarf: '',
        squ: '',
        squf: '',
        srarr: '',
        Sscr: '',
        sscr: '',
        ssetmn: '',
        ssmile: '',
        sstarf: '',
        Star: '',
        star: '',
        starf: '',
        straightepsilon: '',
        straightphi: '',
        strns: '',
        sub: '',
        Sub: '',
        subdot: '',
        subE: '',
        sube: '',
        subedot: '',
        submult: '',
        subnE: '',
        subne: '',
        subplus: '',
        subrarr: '',
        subset: '',
        Subset: '',
        subseteq: '',
        subseteqq: '',
        SubsetEqual: '',
        subsetneq: '',
        subsetneqq: '',
        subsim: '',
        subsub: '',
        subsup: '',
        succapprox: '',
        succ: '',
        succcurlyeq: '',
        Succeeds: '',
        SucceedsEqual: '',
        SucceedsSlantEqual: '',
        SucceedsTilde: '',
        succeq: '',
        succnapprox: '',
        succneqq: '',
        succnsim: '',
        succsim: '',
        SuchThat: '',
        sum: '',
        Sum: '',
        sung: '',
        sup1: '',
        sup2: '',
        sup3: '',
        sup: '',
        Sup: '',
        supdot: '',
        supdsub: '',
        supE: '',
        supe: '',
        supedot: '',
        Superset: '',
        SupersetEqual: '',
        suphsol: '',
        suphsub: '',
        suplarr: '',
        supmult: '',
        supnE: '',
        supne: '',
        supplus: '',
        supset: '',
        Supset: '',
        supseteq: '',
        supseteqq: '',
        supsetneq: '',
        supsetneqq: '',
        supsim: '',
        supsub: '',
        supsup: '',
        swarhk: '',
        swarr: '',
        swArr: '',
        swarrow: '',
        swnwar: '',
        szlig: '',
        Tab: '	',
        target: '',
        Tau: '',
        tau: '',
        tbrk: '',
        Tcaron: '',
        tcaron: '',
        Tcedil: '',
        tcedil: '',
        Tcy: '',
        tcy: '',
        tdot: '',
        telrec: '',
        Tfr: '',
        tfr: '',
        there4: '',
        therefore: '',
        Therefore: '',
        Theta: '',
        theta: '',
        thetasym: '',
        thetav: '',
        thickapprox: '',
        thicksim: '',
        ThickSpace: '',
        ThinSpace: '',
        thinsp: '',
        thkap: '',
        thksim: '',
        THORN: '',
        thorn: '',
        tilde: '',
        Tilde: '',
        TildeEqual: '',
        TildeFullEqual: '',
        TildeTilde: '',
        timesbar: '',
        timesb: '',
        times: '',
        timesd: '',
        tint: '',
        toea: '',
        topbot: '',
        topcir: '',
        top: '',
        Topf: '',
        topf: '',
        topfork: '',
        tosa: '',
        tprime: '',
        trade: '',
        TRADE: '',
        triangle: '',
        triangledown: '',
        triangleleft: '',
        trianglelefteq: '',
        triangleq: '',
        triangleright: '',
        trianglerighteq: '',
        tridot: '',
        trie: '',
        triminus: '',
        TripleDot: '',
        triplus: '',
        trisb: '',
        tritime: '',
        trpezium: '',
        Tscr: '',
        tscr: '',
        TScy: '',
        tscy: '',
        TSHcy: '',
        tshcy: '',
        Tstrok: '',
        tstrok: '',
        twixt: '',
        twoheadleftarrow: '',
        twoheadrightarrow: '',
        Uacute: '',
        uacute: '',
        uarr: '',
        Uarr: '',
        uArr: '',
        Uarrocir: '',
        Ubrcy: '',
        ubrcy: '',
        Ubreve: '',
        ubreve: '',
        Ucirc: '',
        ucirc: '',
        Ucy: '',
        ucy: '',
        udarr: '',
        Udblac: '',
        udblac: '',
        udhar: '',
        ufisht: '',
        Ufr: '',
        ufr: '',
        Ugrave: '',
        ugrave: '',
        uHar: '',
        uharl: '',
        uharr: '',
        uhblk: '',
        ulcorn: '',
        ulcorner: '',
        ulcrop: '',
        ultri: '',
        Umacr: '',
        umacr: '',
        uml: '',
        UnderBar: '_',
        UnderBrace: '',
        UnderBracket: '',
        UnderParenthesis: '',
        Union: '',
        UnionPlus: '',
        Uogon: '',
        uogon: '',
        Uopf: '',
        uopf: '',
        UpArrowBar: '',
        uparrow: '',
        UpArrow: '',
        Uparrow: '',
        UpArrowDownArrow: '',
        updownarrow: '',
        UpDownArrow: '',
        Updownarrow: '',
        UpEquilibrium: '',
        upharpoonleft: '',
        upharpoonright: '',
        uplus: '',
        UpperLeftArrow: '',
        UpperRightArrow: '',
        upsi: '',
        Upsi: '',
        upsih: '',
        Upsilon: '',
        upsilon: '',
        UpTeeArrow: '',
        UpTee: '',
        upuparrows: '',
        urcorn: '',
        urcorner: '',
        urcrop: '',
        Uring: '',
        uring: '',
        urtri: '',
        Uscr: '',
        uscr: '',
        utdot: '',
        Utilde: '',
        utilde: '',
        utri: '',
        utrif: '',
        uuarr: '',
        Uuml: '',
        uuml: '',
        uwangle: '',
        vangrt: '',
        varepsilon: '',
        varkappa: '',
        varnothing: '',
        varphi: '',
        varpi: '',
        varpropto: '',
        varr: '',
        vArr: '',
        varrho: '',
        varsigma: '',
        varsubsetneq: '',
        varsubsetneqq: '',
        varsupsetneq: '',
        varsupsetneqq: '',
        vartheta: '',
        vartriangleleft: '',
        vartriangleright: '',
        vBar: '',
        Vbar: '',
        vBarv: '',
        Vcy: '',
        vcy: '',
        vdash: '',
        vDash: '',
        Vdash: '',
        VDash: '',
        Vdashl: '',
        veebar: '',
        vee: '',
        Vee: '',
        veeeq: '',
        vellip: '',
        verbar: '|',
        Verbar: '',
        vert: '|',
        Vert: '',
        VerticalBar: '',
        VerticalLine: '|',
        VerticalSeparator: '',
        VerticalTilde: '',
        VeryThinSpace: '',
        Vfr: '',
        vfr: '',
        vltri: '',
        vnsub: '',
        vnsup: '',
        Vopf: '',
        vopf: '',
        vprop: '',
        vrtri: '',
        Vscr: '',
        vscr: '',
        vsubnE: '',
        vsubne: '',
        vsupnE: '',
        vsupne: '',
        Vvdash: '',
        vzigzag: '',
        Wcirc: '',
        wcirc: '',
        wedbar: '',
        wedge: '',
        Wedge: '',
        wedgeq: '',
        weierp: '',
        Wfr: '',
        wfr: '',
        Wopf: '',
        wopf: '',
        wp: '',
        wr: '',
        wreath: '',
        Wscr: '',
        wscr: '',
        xcap: '',
        xcirc: '',
        xcup: '',
        xdtri: '',
        Xfr: '',
        xfr: '',
        xharr: '',
        xhArr: '',
        Xi: '',
        xi: '',
        xlarr: '',
        xlArr: '',
        xmap: '',
        xnis: '',
        xodot: '',
        Xopf: '',
        xopf: '',
        xoplus: '',
        xotime: '',
        xrarr: '',
        xrArr: '',
        Xscr: '',
        xscr: '',
        xsqcup: '',
        xuplus: '',
        xutri: '',
        xvee: '',
        xwedge: '',
        Yacute: '',
        yacute: '',
        YAcy: '',
        yacy: '',
        Ycirc: '',
        ycirc: '',
        Ycy: '',
        ycy: '',
        yen: '',
        Yfr: '',
        yfr: '',
        YIcy: '',
        yicy: '',
        Yopf: '',
        yopf: '',
        Yscr: '',
        yscr: '',
        YUcy: '',
        yucy: '',
        yuml: '',
        Yuml: '',
        Zacute: '',
        zacute: '',
        Zcaron: '',
        zcaron: '',
        Zcy: '',
        zcy: '',
        Zdot: '',
        zdot: '',
        zeetrf: '',
        ZeroWidthSpace: '',
        Zeta: '',
        zeta: '',
        zfr: '',
        Zfr: '',
        ZHcy: '',
        zhcy: '',
        zigrarr: '',
        zopf: '',
        Zopf: '',
        Zscr: '',
        zscr: '',
        zwj: '',
        zwnj: '',
      };
    },
  }),
  Y$ = B({
    '../node_modules/entities/lib/maps/legacy.json'(e, t) {
      t.exports = {
        Aacute: '',
        aacute: '',
        Acirc: '',
        acirc: '',
        acute: '',
        AElig: '',
        aelig: '',
        Agrave: '',
        agrave: '',
        amp: '&',
        AMP: '&',
        Aring: '',
        aring: '',
        Atilde: '',
        atilde: '',
        Auml: '',
        auml: '',
        brvbar: '',
        Ccedil: '',
        ccedil: '',
        cedil: '',
        cent: '',
        copy: '',
        COPY: '',
        curren: '',
        deg: '',
        divide: '',
        Eacute: '',
        eacute: '',
        Ecirc: '',
        ecirc: '',
        Egrave: '',
        egrave: '',
        ETH: '',
        eth: '',
        Euml: '',
        euml: '',
        frac12: '',
        frac14: '',
        frac34: '',
        gt: '>',
        GT: '>',
        Iacute: '',
        iacute: '',
        Icirc: '',
        icirc: '',
        iexcl: '',
        Igrave: '',
        igrave: '',
        iquest: '',
        Iuml: '',
        iuml: '',
        laquo: '',
        lt: '<',
        LT: '<',
        macr: '',
        micro: '',
        middot: '',
        nbsp: '',
        not: '',
        Ntilde: '',
        ntilde: '',
        Oacute: '',
        oacute: '',
        Ocirc: '',
        ocirc: '',
        Ograve: '',
        ograve: '',
        ordf: '',
        ordm: '',
        Oslash: '',
        oslash: '',
        Otilde: '',
        otilde: '',
        Ouml: '',
        ouml: '',
        para: '',
        plusmn: '',
        pound: '',
        quot: '"',
        QUOT: '"',
        raquo: '',
        reg: '',
        REG: '',
        sect: '',
        shy: '',
        sup1: '',
        sup2: '',
        sup3: '',
        szlig: '',
        THORN: '',
        thorn: '',
        times: '',
        Uacute: '',
        uacute: '',
        Ucirc: '',
        ucirc: '',
        Ugrave: '',
        ugrave: '',
        uml: '',
        Uuml: '',
        uuml: '',
        Yacute: '',
        yacute: '',
        yen: '',
        yuml: '',
      };
    },
  }),
  Cv = B({
    '../node_modules/entities/lib/maps/xml.json'(e, t) {
      t.exports = { amp: '&', apos: "'", gt: '>', lt: '<', quot: '"' };
    },
  }),
  X$ = B({
    '../node_modules/entities/lib/maps/decode.json'(e, t) {
      t.exports = {
        0: 65533,
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376,
      };
    },
  }),
  Q$ = B({
    '../node_modules/entities/lib/decode_codepoint.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (i) {
          return i && i.__esModule ? i : { default: i };
        };
      Object.defineProperty(e, '__esModule', { value: !0 });
      var r = t(X$()),
        n =
          String.fromCodePoint ||
          function (i) {
            var a = '';
            return (
              i > 65535 &&
                ((i -= 65536),
                (a += String.fromCharCode(((i >>> 10) & 1023) | 55296)),
                (i = 56320 | (i & 1023))),
              (a += String.fromCharCode(i)),
              a
            );
          };
      function o(i) {
        return (i >= 55296 && i <= 57343) || i > 1114111
          ? ''
          : (i in r.default && (i = r.default[i]), n(i));
      }
      (s(o, 'decodeCodePoint'), (e.default = o));
    },
  }),
  ug = B({
    '../node_modules/entities/lib/decode.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (p) {
          return p && p.__esModule ? p : { default: p };
        };
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0));
      var r = t(Ov()),
        n = t(Y$()),
        o = t(Cv()),
        i = t(Q$()),
        a = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
      ((e.decodeXML = c(o.default)), (e.decodeHTMLStrict = c(r.default)));
      function c(p) {
        var f = u(p);
        return function (m) {
          return String(m).replace(a, f);
        };
      }
      s(c, 'getStrictDecoder');
      var d = s(function (p, f) {
        return p < f ? 1 : -1;
      }, 'sorter');
      e.decodeHTML = (function () {
        for (
          var p = Object.keys(n.default).sort(d), f = Object.keys(r.default).sort(d), m = 0, h = 0;
          m < f.length;
          m++
        )
          p[h] === f[m] ? ((f[m] += ';?'), h++) : (f[m] += ';');
        var g = new RegExp('&(?:' + f.join('|') + '|#[xX][\\da-fA-F]+;?|#\\d+;?)', 'g'),
          v = u(r.default);
        function E(b) {
          return (b.substr(-1) !== ';' && (b += ';'), v(b));
        }
        return (
          s(E, 'replacer'),
          function (b) {
            return String(b).replace(g, E);
          }
        );
      })();
      function u(p) {
        return s(function (m) {
          if (m.charAt(1) === '#') {
            var h = m.charAt(2);
            return h === 'X' || h === 'x'
              ? i.default(parseInt(m.substr(3), 16))
              : i.default(parseInt(m.substr(2), 10));
          }
          return p[m.slice(1, -1)] || m;
        }, 'replace');
      }
      s(u, 'getReplacer');
    },
  }),
  dg = B({
    '../node_modules/entities/lib/encode.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (S) {
          return S && S.__esModule ? S : { default: S };
        };
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = void 0));
      var r = t(Cv()),
        n = d(r.default),
        o = u(n);
      e.encodeXML = b(n);
      var i = t(Ov()),
        a = d(i.default),
        c = u(a);
      ((e.encodeHTML = h(a, c)), (e.encodeNonAsciiHTML = b(a)));
      function d(S) {
        return Object.keys(S)
          .sort()
          .reduce(function (R, I) {
            return ((R[S[I]] = '&' + I + ';'), R);
          }, {});
      }
      s(d, 'getInverseObj');
      function u(S) {
        for (var R = [], I = [], q = 0, P = Object.keys(S); q < P.length; q++) {
          var A = P[q];
          A.length === 1 ? R.push('\\' + A) : I.push(A);
        }
        R.sort();
        for (var w = 0; w < R.length - 1; w++) {
          for (var _ = w; _ < R.length - 1 && R[_].charCodeAt(1) + 1 === R[_ + 1].charCodeAt(1); )
            _ += 1;
          var $ = 1 + _ - w;
          $ < 3 || R.splice(w, $, R[w] + '-' + R[_]);
        }
        return (I.unshift('[' + R.join('') + ']'), new RegExp(I.join('|'), 'g'));
      }
      s(u, 'getInverseReplacer');
      var p =
          /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
        f =
          String.prototype.codePointAt != null
            ? function (S) {
                return S.codePointAt(0);
              }
            : function (S) {
                return (S.charCodeAt(0) - 55296) * 1024 + S.charCodeAt(1) - 56320 + 65536;
              };
      function m(S) {
        return '&#x' + (S.length > 1 ? f(S) : S.charCodeAt(0)).toString(16).toUpperCase() + ';';
      }
      s(m, 'singleCharReplacer');
      function h(S, R) {
        return function (I) {
          return I.replace(R, function (q) {
            return S[q];
          }).replace(p, m);
        };
      }
      s(h, 'getInverse');
      var g = new RegExp(o.source + '|' + p.source, 'g');
      function v(S) {
        return S.replace(g, m);
      }
      (s(v, 'escape'), (e.escape = v));
      function E(S) {
        return S.replace(o, m);
      }
      (s(E, 'escapeUTF8'), (e.escapeUTF8 = E));
      function b(S) {
        return function (R) {
          return R.replace(g, function (I) {
            return S[I] || m(I);
          });
        };
      }
      s(b, 'getASCIIEncoder');
    },
  }),
  Z$ = B({
    '../node_modules/entities/lib/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeXMLStrict =
          e.decodeHTML5Strict =
          e.decodeHTML4Strict =
          e.decodeHTML5 =
          e.decodeHTML4 =
          e.decodeHTMLStrict =
          e.decodeHTML =
          e.decodeXML =
          e.encodeHTML5 =
          e.encodeHTML4 =
          e.escapeUTF8 =
          e.escape =
          e.encodeNonAsciiHTML =
          e.encodeHTML =
          e.encodeXML =
          e.encode =
          e.decodeStrict =
          e.decode =
            void 0));
      var t = ug(),
        r = dg();
      function n(d, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTML)(d);
      }
      (s(n, 'decode'), (e.decode = n));
      function o(d, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTMLStrict)(d);
      }
      (s(o, 'decodeStrict'), (e.decodeStrict = o));
      function i(d, u) {
        return (!u || u <= 0 ? r.encodeXML : r.encodeHTML)(d);
      }
      (s(i, 'encode'), (e.encode = i));
      var a = dg();
      (Object.defineProperty(e, 'encodeXML', {
        enumerable: !0,
        get: s(function () {
          return a.encodeXML;
        }, 'get'),
      }),
        Object.defineProperty(e, 'encodeHTML', {
          enumerable: !0,
          get: s(function () {
            return a.encodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeNonAsciiHTML', {
          enumerable: !0,
          get: s(function () {
            return a.encodeNonAsciiHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'escape', {
          enumerable: !0,
          get: s(function () {
            return a.escape;
          }, 'get'),
        }),
        Object.defineProperty(e, 'escapeUTF8', {
          enumerable: !0,
          get: s(function () {
            return a.escapeUTF8;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML4', {
          enumerable: !0,
          get: s(function () {
            return a.encodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML5', {
          enumerable: !0,
          get: s(function () {
            return a.encodeHTML;
          }, 'get'),
        }));
      var c = ug();
      (Object.defineProperty(e, 'decodeXML', {
        enumerable: !0,
        get: s(function () {
          return c.decodeXML;
        }, 'get'),
      }),
        Object.defineProperty(e, 'decodeHTML', {
          enumerable: !0,
          get: s(function () {
            return c.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTMLStrict', {
          enumerable: !0,
          get: s(function () {
            return c.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4', {
          enumerable: !0,
          get: s(function () {
            return c.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5', {
          enumerable: !0,
          get: s(function () {
            return c.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4Strict', {
          enumerable: !0,
          get: s(function () {
            return c.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5Strict', {
          enumerable: !0,
          get: s(function () {
            return c.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeXMLStrict', {
          enumerable: !0,
          get: s(function () {
            return c.decodeXML;
          }, 'get'),
        }));
    },
  }),
  ek = B({
    '../node_modules/ansi-to-html/lib/ansi_to_html.js'(e, t) {
      function r(x, D) {
        if (!(x instanceof D)) throw new TypeError('Cannot call a class as a function');
      }
      s(r, '_classCallCheck');
      function n(x, D) {
        for (var F = 0; F < D.length; F++) {
          var k = D[F];
          ((k.enumerable = k.enumerable || !1),
            (k.configurable = !0),
            'value' in k && (k.writable = !0),
            Object.defineProperty(x, k.key, k));
        }
      }
      s(n, '_defineProperties');
      function o(x, D, F) {
        return (D && n(x.prototype, D), F && n(x, F), x);
      }
      s(o, '_createClass');
      function i(x, D) {
        var F = (typeof Symbol < 'u' && x[Symbol.iterator]) || x['@@iterator'];
        if (!F) {
          if (Array.isArray(x) || (F = a(x)) || (D && x && typeof x.length == 'number')) {
            F && (x = F);
            var k = 0,
              K = s(function () {}, 'F');
            return {
              s: K,
              n: s(function () {
                return k >= x.length ? { done: !0 } : { done: !1, value: x[k++] };
              }, 'n'),
              e: s(function (ae) {
                throw ae;
              }, 'e'),
              f: K,
            };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var X = !0,
          se = !1,
          ie;
        return {
          s: s(function () {
            F = F.call(x);
          }, 's'),
          n: s(function () {
            var ae = F.next();
            return ((X = ae.done), ae);
          }, 'n'),
          e: s(function (ae) {
            ((se = !0), (ie = ae));
          }, 'e'),
          f: s(function () {
            try {
              !X && F.return != null && F.return();
            } finally {
              if (se) throw ie;
            }
          }, 'f'),
        };
      }
      s(i, '_createForOfIteratorHelper');
      function a(x, D) {
        if (x) {
          if (typeof x == 'string') return c(x, D);
          var F = Object.prototype.toString.call(x).slice(8, -1);
          if (
            (F === 'Object' && x.constructor && (F = x.constructor.name),
            F === 'Map' || F === 'Set')
          )
            return Array.from(x);
          if (F === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(F))
            return c(x, D);
        }
      }
      s(a, '_unsupportedIterableToArray');
      function c(x, D) {
        (D == null || D > x.length) && (D = x.length);
        for (var F = 0, k = new Array(D); F < D; F++) k[F] = x[F];
        return k;
      }
      s(c, '_arrayLikeToArray');
      var d = Z$(),
        u = { fg: '#FFF', bg: '#000', newline: !1, escapeXML: !1, stream: !1, colors: p() };
      function p() {
        var x = {
          0: '#000',
          1: '#A00',
          2: '#0A0',
          3: '#A50',
          4: '#00A',
          5: '#A0A',
          6: '#0AA',
          7: '#AAA',
          8: '#555',
          9: '#F55',
          10: '#5F5',
          11: '#FF5',
          12: '#55F',
          13: '#F5F',
          14: '#5FF',
          15: '#FFF',
        };
        return (
          S(0, 5).forEach(function (D) {
            S(0, 5).forEach(function (F) {
              S(0, 5).forEach(function (k) {
                return f(D, F, k, x);
              });
            });
          }),
          S(0, 23).forEach(function (D) {
            var F = D + 232,
              k = m(D * 10 + 8);
            x[F] = '#' + k + k + k;
          }),
          x
        );
      }
      s(p, 'getDefaultColors');
      function f(x, D, F, k) {
        var K = 16 + x * 36 + D * 6 + F,
          X = x > 0 ? x * 40 + 55 : 0,
          se = D > 0 ? D * 40 + 55 : 0,
          ie = F > 0 ? F * 40 + 55 : 0;
        k[K] = h([X, se, ie]);
      }
      s(f, 'setStyleColor');
      function m(x) {
        for (var D = x.toString(16); D.length < 2; ) D = '0' + D;
        return D;
      }
      s(m, 'toHexString');
      function h(x) {
        var D = [],
          F = i(x),
          k;
        try {
          for (F.s(); !(k = F.n()).done; ) {
            var K = k.value;
            D.push(m(K));
          }
        } catch (X) {
          F.e(X);
        } finally {
          F.f();
        }
        return '#' + D.join('');
      }
      s(h, 'toColorHexString');
      function g(x, D, F, k) {
        var K;
        return (
          D === 'text'
            ? (K = q(F, k))
            : D === 'display'
              ? (K = E(x, F, k))
              : D === 'xterm256Foreground'
                ? (K = w(x, k.colors[F]))
                : D === 'xterm256Background'
                  ? (K = _(x, k.colors[F]))
                  : D === 'rgb' && (K = v(x, F)),
          K
        );
      }
      s(g, 'generateOutput');
      function v(x, D) {
        D = D.substring(2).slice(0, -1);
        var F = +D.substr(0, 2),
          k = D.substring(5).split(';'),
          K = k
            .map(function (X) {
              return ('0' + Number(X).toString(16)).substr(-2);
            })
            .join('');
        return A(x, (F === 38 ? 'color:#' : 'background-color:#') + K);
      }
      s(v, 'handleRgb');
      function E(x, D, F) {
        D = parseInt(D, 10);
        var k = {
            '-1': s(function () {
              return '<br/>';
            }, '_'),
            0: s(function () {
              return x.length && b(x);
            }, '_'),
            1: s(function () {
              return P(x, 'b');
            }, '_'),
            3: s(function () {
              return P(x, 'i');
            }, '_'),
            4: s(function () {
              return P(x, 'u');
            }, '_'),
            8: s(function () {
              return A(x, 'display:none');
            }, '_'),
            9: s(function () {
              return P(x, 'strike');
            }, '_'),
            22: s(function () {
              return A(x, 'font-weight:normal;text-decoration:none;font-style:normal');
            }, '_'),
            23: s(function () {
              return $(x, 'i');
            }, '_'),
            24: s(function () {
              return $(x, 'u');
            }, '_'),
            39: s(function () {
              return w(x, F.fg);
            }, '_'),
            49: s(function () {
              return _(x, F.bg);
            }, '_'),
            53: s(function () {
              return A(x, 'text-decoration:overline');
            }, '_'),
          },
          K;
        return (
          k[D]
            ? (K = k[D]())
            : 4 < D && D < 7
              ? (K = P(x, 'blink'))
              : 29 < D && D < 38
                ? (K = w(x, F.colors[D - 30]))
                : 39 < D && D < 48
                  ? (K = _(x, F.colors[D - 40]))
                  : 89 < D && D < 98
                    ? (K = w(x, F.colors[8 + (D - 90)]))
                    : 99 < D && D < 108 && (K = _(x, F.colors[8 + (D - 100)])),
          K
        );
      }
      s(E, 'handleDisplay');
      function b(x) {
        var D = x.slice(0);
        return (
          (x.length = 0),
          D.reverse()
            .map(function (F) {
              return '</' + F + '>';
            })
            .join('')
        );
      }
      s(b, 'resetStyles');
      function S(x, D) {
        for (var F = [], k = x; k <= D; k++) F.push(k);
        return F;
      }
      s(S, 'range');
      function R(x) {
        return function (D) {
          return (x === null || D.category !== x) && x !== 'all';
        };
      }
      s(R, 'notCategory');
      function I(x) {
        x = parseInt(x, 10);
        var D = null;
        return (
          x === 0
            ? (D = 'all')
            : x === 1
              ? (D = 'bold')
              : 2 < x && x < 5
                ? (D = 'underline')
                : 4 < x && x < 7
                  ? (D = 'blink')
                  : x === 8
                    ? (D = 'hide')
                    : x === 9
                      ? (D = 'strike')
                      : (29 < x && x < 38) || x === 39 || (89 < x && x < 98)
                        ? (D = 'foreground-color')
                        : ((39 < x && x < 48) || x === 49 || (99 < x && x < 108)) &&
                          (D = 'background-color'),
          D
        );
      }
      s(I, 'categoryForCode');
      function q(x, D) {
        return D.escapeXML ? d.encodeXML(x) : x;
      }
      s(q, 'pushText');
      function P(x, D, F) {
        return (
          F || (F = ''),
          x.push(D),
          '<'.concat(D).concat(F ? ' style="'.concat(F, '"') : '', '>')
        );
      }
      s(P, 'pushTag');
      function A(x, D) {
        return P(x, 'span', D);
      }
      s(A, 'pushStyle');
      function w(x, D) {
        return P(x, 'span', 'color:' + D);
      }
      s(w, 'pushForegroundColor');
      function _(x, D) {
        return P(x, 'span', 'background-color:' + D);
      }
      s(_, 'pushBackgroundColor');
      function $(x, D) {
        var F;
        if ((x.slice(-1)[0] === D && (F = x.pop()), F)) return '</' + D + '>';
      }
      s($, 'closeTag');
      function N(x, D, F) {
        var k = !1,
          K = 3;
        function X() {
          return '';
        }
        s(X, 'remove');
        function se(ne, de) {
          return (F('xterm256Foreground', de), '');
        }
        s(se, 'removeXterm256Foreground');
        function ie(ne, de) {
          return (F('xterm256Background', de), '');
        }
        s(ie, 'removeXterm256Background');
        function W(ne) {
          return (D.newline ? F('display', -1) : F('text', ne), '');
        }
        s(W, 'newline');
        function ae(ne, de) {
          ((k = !0), de.trim().length === 0 && (de = '0'), (de = de.trimRight(';').split(';')));
          var ye = i(de),
            pe;
          try {
            for (ye.s(); !(pe = ye.n()).done; ) {
              var Fe = pe.value;
              F('display', Fe);
            }
          } catch (ot) {
            ye.e(ot);
          } finally {
            ye.f();
          }
          return '';
        }
        s(ae, 'ansiMess');
        function be(ne) {
          return (F('text', ne), '');
        }
        s(be, 'realText');
        function ue(ne) {
          return (F('rgb', ne), '');
        }
        s(ue, 'rgb');
        var ee = [
          { pattern: /^\x08+/, sub: X },
          { pattern: /^\x1b\[[012]?K/, sub: X },
          { pattern: /^\x1b\[\(B/, sub: X },
          { pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/, sub: ue },
          { pattern: /^\x1b\[38;5;(\d+)m/, sub: se },
          { pattern: /^\x1b\[48;5;(\d+)m/, sub: ie },
          { pattern: /^\n/, sub: W },
          { pattern: /^\r+\n/, sub: W },
          { pattern: /^\r/, sub: W },
          { pattern: /^\x1b\[((?:\d{1,3};?)+|)m/, sub: ae },
          { pattern: /^\x1b\[\d?J/, sub: X },
          { pattern: /^\x1b\[\d{0,3};\d{0,3}f/, sub: X },
          { pattern: /^\x1b\[?[\d;]{0,3}/, sub: X },
          { pattern: /^(([^\x1b\x08\r\n])+)/, sub: be },
        ];
        function xe(ne, de) {
          (de > K && k) || ((k = !1), (x = x.replace(ne.pattern, ne.sub)));
        }
        s(xe, 'process');
        var Pe = [],
          He = x,
          Ke = He.length;
        e: for (; Ke > 0; ) {
          for (var J = 0, Q = 0, re = ee.length; Q < re; J = ++Q) {
            var oe = ee[J];
            if ((xe(oe, J), x.length !== Ke)) {
              Ke = x.length;
              continue e;
            }
          }
          if (x.length === Ke) break;
          (Pe.push(0), (Ke = x.length));
        }
        return Pe;
      }
      s(N, 'tokenize');
      function V(x, D, F) {
        return (
          D !== 'text' && ((x = x.filter(R(I(F)))), x.push({ token: D, data: F, category: I(F) })),
          x
        );
      }
      s(V, 'updateStickyStack');
      var H = (function () {
        function x(D) {
          (r(this, x),
            (D = D || {}),
            D.colors && (D.colors = Object.assign({}, u.colors, D.colors)),
            (this.options = Object.assign({}, u, D)),
            (this.stack = []),
            (this.stickyStack = []));
        }
        return (
          s(x, 'Filter'),
          o(x, [
            {
              key: 'toHtml',
              value: s(function (F) {
                var k = this;
                F = typeof F == 'string' ? [F] : F;
                var K = this.stack,
                  X = this.options,
                  se = [];
                return (
                  this.stickyStack.forEach(function (ie) {
                    var W = g(K, ie.token, ie.data, X);
                    W && se.push(W);
                  }),
                  N(F.join(''), X, function (ie, W) {
                    var ae = g(K, ie, W, X);
                    (ae && se.push(ae), X.stream && (k.stickyStack = V(k.stickyStack, ie, W)));
                  }),
                  K.length && se.push(b(K)),
                  se.join('')
                );
              }, 'toHtml'),
            },
          ]),
          x
        );
      })();
      t.exports = H;
    },
  }),
  tk = B({
    '../node_modules/jsdoc-type-pratt-parser/dist/index.js'(e, t) {
      (function (r, n) {
        typeof e == 'object' && typeof t < 'u'
          ? n(e)
          : typeof define == 'function' && define.amd
            ? define(['exports'], n)
            : ((r = typeof globalThis < 'u' ? globalThis : r || self), n((r.jtpp = {})));
      })(e, function (r) {
        function n(l) {
          return l.text !== void 0 && l.text !== ''
            ? `'${l.type}' with value '${l.text}'`
            : `'${l.type}'`;
        }
        s(n, 'tokenToString');
        const o = class Iv extends Error {
          constructor(y) {
            (super(`No parslet found for token: ${n(y)}`),
              (this.token = y),
              Object.setPrototypeOf(this, Iv.prototype));
          }
          getToken() {
            return this.token;
          }
        };
        s(o, 'NoParsletFoundError');
        let i = o;
        const a = class Nv extends Error {
          constructor(y) {
            (super(`The parsing ended early. The next token was: ${n(y)}`),
              (this.token = y),
              Object.setPrototypeOf(this, Nv.prototype));
          }
          getToken() {
            return this.token;
          }
        };
        s(a, 'EarlyEndOfParseError');
        let c = a;
        const d = class qv extends Error {
          constructor(y, T) {
            let C = `Unexpected type: '${y.type}'.`;
            (T !== void 0 && (C += ` Message: ${T}`),
              super(C),
              Object.setPrototypeOf(this, qv.prototype));
          }
        };
        s(d, 'UnexpectedTypeError');
        let u = d;
        function p(l) {
          return (y) => (y.startsWith(l) ? { type: l, text: l } : null);
        }
        s(p, 'makePunctuationRule');
        function f(l) {
          let y = 0,
            T;
          const C = l[0];
          let L = !1;
          if (C !== "'" && C !== '"') return null;
          for (; y < l.length; ) {
            if ((y++, (T = l[y]), !L && T === C)) {
              y++;
              break;
            }
            L = !L && T === '\\';
          }
          if (T !== C) throw new Error('Unterminated String');
          return l.slice(0, y);
        }
        s(f, 'getQuoted');
        const m = new RegExp(
            '[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
            'u',
          ),
          h = new RegExp(
            '[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
            'u',
          );
        function g(l) {
          let y = l[0];
          if (!m.test(y)) return null;
          let T = 1;
          do {
            if (((y = l[T]), !h.test(y))) break;
            T++;
          } while (T < l.length);
          return l.slice(0, T);
        }
        s(g, 'getIdentifier');
        const v = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
        function E(l) {
          var y, T;
          return (T = (y = v.exec(l)) === null || y === void 0 ? void 0 : y[0]) !== null &&
            T !== void 0
            ? T
            : null;
        }
        s(E, 'getNumber');
        const b = s((l) => {
          const y = g(l);
          return y == null ? null : { type: 'Identifier', text: y };
        }, 'identifierRule');
        function S(l) {
          return (y) => {
            if (!y.startsWith(l)) return null;
            const T = y[l.length];
            return T !== void 0 && h.test(T) ? null : { type: l, text: l };
          };
        }
        s(S, 'makeKeyWordRule');
        const R = s((l) => {
            const y = f(l);
            return y == null ? null : { type: 'StringValue', text: y };
          }, 'stringValueRule'),
          I = s((l) => (l.length > 0 ? null : { type: 'EOF', text: '' }), 'eofRule'),
          q = s((l) => {
            const y = E(l);
            return y === null ? null : { type: 'Number', text: y };
          }, 'numberRule'),
          P = [
            I,
            p('=>'),
            p('('),
            p(')'),
            p('{'),
            p('}'),
            p('['),
            p(']'),
            p('|'),
            p('&'),
            p('<'),
            p('>'),
            p(','),
            p(';'),
            p('*'),
            p('?'),
            p('!'),
            p('='),
            p(':'),
            p('...'),
            p('.'),
            p('#'),
            p('~'),
            p('/'),
            p('@'),
            S('undefined'),
            S('null'),
            S('function'),
            S('this'),
            S('new'),
            S('module'),
            S('event'),
            S('extends'),
            S('external'),
            S('infer'),
            S('typeof'),
            S('keyof'),
            S('readonly'),
            S('import'),
            S('is'),
            S('in'),
            S('asserts'),
            q,
            b,
            R,
          ],
          A = /^\s*\n\s*/,
          w = class Wi {
            static create(y) {
              const T = this.read(y);
              y = T.text;
              const C = this.read(y);
              return ((y = C.text), new Wi(y, void 0, T.token, C.token));
            }
            constructor(y, T, C, L) {
              ((this.text = ''),
                (this.text = y),
                (this.previous = T),
                (this.current = C),
                (this.next = L));
            }
            static read(y, T = !1) {
              ((T = T || A.test(y)), (y = y.trim()));
              for (const C of P) {
                const L = C(y);
                if (L !== null) {
                  const G = Object.assign(Object.assign({}, L), { startOfLine: T });
                  return ((y = y.slice(G.text.length)), { text: y, token: G });
                }
              }
              throw new Error('Unexpected Token ' + y);
            }
            advance() {
              const y = Wi.read(this.text);
              return new Wi(y.text, this.current, this.next, y.token);
            }
          };
        s(w, 'Lexer');
        let _ = w;
        function $(l) {
          if (l === void 0) throw new Error('Unexpected undefined');
          if (
            l.type === 'JsdocTypeKeyValue' ||
            l.type === 'JsdocTypeParameterList' ||
            l.type === 'JsdocTypeProperty' ||
            l.type === 'JsdocTypeReadonlyProperty' ||
            l.type === 'JsdocTypeObjectField' ||
            l.type === 'JsdocTypeJsdocObjectField' ||
            l.type === 'JsdocTypeIndexSignature' ||
            l.type === 'JsdocTypeMappedType' ||
            l.type === 'JsdocTypeTypeParameter'
          )
            throw new u(l);
          return l;
        }
        s($, 'assertRootResult');
        function N(l) {
          return l.type === 'JsdocTypeKeyValue' ? H(l) : $(l);
        }
        s(N, 'assertPlainKeyValueOrRootResult');
        function V(l) {
          return l.type === 'JsdocTypeName' ? l : H(l);
        }
        s(V, 'assertPlainKeyValueOrNameResult');
        function H(l) {
          if (l.type !== 'JsdocTypeKeyValue') throw new u(l);
          return l;
        }
        s(H, 'assertPlainKeyValueResult');
        function x(l) {
          var y;
          if (l.type === 'JsdocTypeVariadic') {
            if (((y = l.element) === null || y === void 0 ? void 0 : y.type) === 'JsdocTypeName')
              return l;
            throw new u(l);
          }
          if (l.type !== 'JsdocTypeNumber' && l.type !== 'JsdocTypeName') throw new u(l);
          return l;
        }
        s(x, 'assertNumberOrVariadicNameResult');
        function D(l) {
          if (
            l.type === 'JsdocTypeTuple' ||
            (l.type === 'JsdocTypeGeneric' && l.meta.brackets === 'square')
          )
            return l;
          throw new u(l);
        }
        s(D, 'assertArrayOrTupleResult');
        function F(l) {
          return l.type === 'JsdocTypeIndexSignature' || l.type === 'JsdocTypeMappedType';
        }
        s(F, 'isSquaredProperty');
        var k;
        (function (l) {
          ((l[(l.ALL = 0)] = 'ALL'),
            (l[(l.PARAMETER_LIST = 1)] = 'PARAMETER_LIST'),
            (l[(l.OBJECT = 2)] = 'OBJECT'),
            (l[(l.KEY_VALUE = 3)] = 'KEY_VALUE'),
            (l[(l.INDEX_BRACKETS = 4)] = 'INDEX_BRACKETS'),
            (l[(l.UNION = 5)] = 'UNION'),
            (l[(l.INTERSECTION = 6)] = 'INTERSECTION'),
            (l[(l.PREFIX = 7)] = 'PREFIX'),
            (l[(l.INFIX = 8)] = 'INFIX'),
            (l[(l.TUPLE = 9)] = 'TUPLE'),
            (l[(l.SYMBOL = 10)] = 'SYMBOL'),
            (l[(l.OPTIONAL = 11)] = 'OPTIONAL'),
            (l[(l.NULLABLE = 12)] = 'NULLABLE'),
            (l[(l.KEY_OF_TYPE_OF = 13)] = 'KEY_OF_TYPE_OF'),
            (l[(l.FUNCTION = 14)] = 'FUNCTION'),
            (l[(l.ARROW = 15)] = 'ARROW'),
            (l[(l.ARRAY_BRACKETS = 16)] = 'ARRAY_BRACKETS'),
            (l[(l.GENERIC = 17)] = 'GENERIC'),
            (l[(l.NAME_PATH = 18)] = 'NAME_PATH'),
            (l[(l.PARENTHESIS = 19)] = 'PARENTHESIS'),
            (l[(l.SPECIAL_TYPES = 20)] = 'SPECIAL_TYPES'));
        })(k || (k = {}));
        const K = class {
          constructor(y, T, C) {
            ((this.grammar = y),
              typeof T == 'string' ? (this._lexer = _.create(T)) : (this._lexer = T),
              (this.baseParser = C));
          }
          get lexer() {
            return this._lexer;
          }
          parse() {
            const y = this.parseType(k.ALL);
            if (this.lexer.current.type !== 'EOF') throw new c(this.lexer.current);
            return y;
          }
          parseType(y) {
            return $(this.parseIntermediateType(y));
          }
          parseIntermediateType(y) {
            const T = this.tryParslets(null, y);
            if (T === null) throw new i(this.lexer.current);
            return this.parseInfixIntermediateType(T, y);
          }
          parseInfixIntermediateType(y, T) {
            let C = this.tryParslets(y, T);
            for (; C !== null; ) ((y = C), (C = this.tryParslets(y, T)));
            return y;
          }
          tryParslets(y, T) {
            for (const C of this.grammar) {
              const L = C(this, T, y);
              if (L !== null) return L;
            }
            return null;
          }
          consume(y) {
            return (
              Array.isArray(y) || (y = [y]),
              y.includes(this.lexer.current.type) ? ((this._lexer = this.lexer.advance()), !0) : !1
            );
          }
          acceptLexerState(y) {
            this._lexer = y.lexer;
          }
        };
        s(K, 'Parser');
        let X = K;
        function se(l) {
          return l === '}' || l === 'EOF' || l === '|' || l === ',' || l === ')' || l === '>';
        }
        s(se, 'isQuestionMarkUnknownType');
        const ie = s((l, y, T) => {
          const C = l.lexer.current.type,
            L = l.lexer.next.type;
          return (T == null && C === '?' && !se(L)) || (T != null && C === '?')
            ? (l.consume('?'),
              T == null
                ? {
                    type: 'JsdocTypeNullable',
                    element: l.parseType(k.NULLABLE),
                    meta: { position: 'prefix' },
                  }
                : { type: 'JsdocTypeNullable', element: $(T), meta: { position: 'suffix' } })
            : null;
        }, 'nullableParslet');
        function W(l) {
          const y = s((T, C, L) => {
            const G = T.lexer.current.type,
              Z = T.lexer.next.type;
            if (L === null) {
              if ('parsePrefix' in l && l.accept(G, Z)) return l.parsePrefix(T);
            } else if ('parseInfix' in l && l.precedence > C && l.accept(G, Z))
              return l.parseInfix(T, L);
            return null;
          }, 'parslet');
          return (Object.defineProperty(y, 'name', { value: l.name }), y);
        }
        s(W, 'composeParslet');
        const ae = W({
            name: 'optionalParslet',
            accept: s((l) => l === '=', 'accept'),
            precedence: k.OPTIONAL,
            parsePrefix: s(
              (l) => (
                l.consume('='),
                {
                  type: 'JsdocTypeOptional',
                  element: l.parseType(k.OPTIONAL),
                  meta: { position: 'prefix' },
                }
              ),
              'parsePrefix',
            ),
            parseInfix: s(
              (l, y) => (
                l.consume('='),
                { type: 'JsdocTypeOptional', element: $(y), meta: { position: 'suffix' } }
              ),
              'parseInfix',
            ),
          }),
          be = W({
            name: 'numberParslet',
            accept: s((l) => l === 'Number', 'accept'),
            parsePrefix: s((l) => {
              const y = parseFloat(l.lexer.current.text);
              return (l.consume('Number'), { type: 'JsdocTypeNumber', value: y });
            }, 'parsePrefix'),
          }),
          ue = W({
            name: 'parenthesisParslet',
            accept: s((l) => l === '(', 'accept'),
            parsePrefix: s((l) => {
              if ((l.consume('('), l.consume(')')))
                return { type: 'JsdocTypeParameterList', elements: [] };
              const y = l.parseIntermediateType(k.ALL);
              if (!l.consume(')')) throw new Error('Unterminated parenthesis');
              return y.type === 'JsdocTypeParameterList'
                ? y
                : y.type === 'JsdocTypeKeyValue'
                  ? { type: 'JsdocTypeParameterList', elements: [y] }
                  : { type: 'JsdocTypeParenthesis', element: $(y) };
            }, 'parsePrefix'),
          }),
          ee = W({
            name: 'specialTypesParslet',
            accept: s(
              (l, y) => (l === '?' && se(y)) || l === 'null' || l === 'undefined' || l === '*',
              'accept',
            ),
            parsePrefix: s((l) => {
              if (l.consume('null')) return { type: 'JsdocTypeNull' };
              if (l.consume('undefined')) return { type: 'JsdocTypeUndefined' };
              if (l.consume('*')) return { type: 'JsdocTypeAny' };
              if (l.consume('?')) return { type: 'JsdocTypeUnknown' };
              throw new Error('Unacceptable token: ' + l.lexer.current.text);
            }, 'parsePrefix'),
          }),
          xe = W({
            name: 'notNullableParslet',
            accept: s((l) => l === '!', 'accept'),
            precedence: k.NULLABLE,
            parsePrefix: s(
              (l) => (
                l.consume('!'),
                {
                  type: 'JsdocTypeNotNullable',
                  element: l.parseType(k.NULLABLE),
                  meta: { position: 'prefix' },
                }
              ),
              'parsePrefix',
            ),
            parseInfix: s(
              (l, y) => (
                l.consume('!'),
                { type: 'JsdocTypeNotNullable', element: $(y), meta: { position: 'suffix' } }
              ),
              'parseInfix',
            ),
          });
        function Pe({ allowTrailingComma: l }) {
          return W({
            name: 'parameterListParslet',
            accept: s((y) => y === ',', 'accept'),
            precedence: k.PARAMETER_LIST,
            parseInfix: s((y, T) => {
              const C = [N(T)];
              y.consume(',');
              do
                try {
                  const L = y.parseIntermediateType(k.PARAMETER_LIST);
                  C.push(N(L));
                } catch (L) {
                  if (L instanceof i) break;
                  throw L;
                }
              while (y.consume(','));
              if (C.length > 0 && C.slice(0, -1).some((L) => L.type === 'JsdocTypeVariadic'))
                throw new Error('Only the last parameter may be a rest parameter');
              return { type: 'JsdocTypeParameterList', elements: C };
            }, 'parseInfix'),
          });
        }
        s(Pe, 'createParameterListParslet');
        const He = W({
            name: 'genericParslet',
            accept: s((l, y) => l === '<' || (l === '.' && y === '<'), 'accept'),
            precedence: k.GENERIC,
            parseInfix: s((l, y) => {
              const T = l.consume('.');
              l.consume('<');
              const C = [];
              let L = !1;
              if (l.consume('infer')) {
                L = !0;
                const G = l.parseIntermediateType(k.SYMBOL);
                if (G.type !== 'JsdocTypeName')
                  throw new u(
                    G,
                    'A typescript asserts always has to have a name on the left side.',
                  );
                C.push(G);
              } else
                do C.push(l.parseType(k.PARAMETER_LIST));
                while (l.consume(','));
              if (!l.consume('>')) throw new Error('Unterminated generic parameter list');
              return Object.assign(
                Object.assign(
                  { type: 'JsdocTypeGeneric', left: $(y), elements: C },
                  L ? { infer: !0 } : {},
                ),
                { meta: { brackets: 'angle', dot: T } },
              );
            }, 'parseInfix'),
          }),
          Ke = W({
            name: 'unionParslet',
            accept: s((l) => l === '|', 'accept'),
            precedence: k.UNION,
            parseInfix: s((l, y) => {
              l.consume('|');
              const T = [];
              do T.push(l.parseType(k.UNION));
              while (l.consume('|'));
              return { type: 'JsdocTypeUnion', elements: [$(y), ...T] };
            }, 'parseInfix'),
          }),
          J = [ie, ae, be, ue, ee, xe, Pe({ allowTrailingComma: !0 }), He, Ke, ae];
        function Q({ allowSquareBracketsOnAnyType: l, allowJsdocNamePaths: y, pathGrammar: T }) {
          return s(function (L, G, Z) {
            if (Z == null || G >= k.NAME_PATH) return null;
            const ce = L.lexer.current.type,
              _e = L.lexer.next.type;
            if (
              !(
                (ce === '.' && _e !== '<') ||
                (ce === '[' && (l || Z.type === 'JsdocTypeName')) ||
                (y && (ce === '~' || ce === '#'))
              )
            )
              return null;
            let qe,
              yr = !1;
            L.consume('.')
              ? (qe = 'property')
              : L.consume('[')
                ? ((qe = 'property-brackets'), (yr = !0))
                : L.consume('~')
                  ? (qe = 'inner')
                  : (L.consume('#'), (qe = 'instance'));
            const hs = T !== null ? new X(T, L.lexer, L) : L,
              Qe = hs.parseIntermediateType(k.NAME_PATH);
            L.acceptLexerState(hs);
            let Vt;
            switch (Qe.type) {
              case 'JsdocTypeName':
                Vt = { type: 'JsdocTypeProperty', value: Qe.value, meta: { quote: void 0 } };
                break;
              case 'JsdocTypeNumber':
                Vt = {
                  type: 'JsdocTypeProperty',
                  value: Qe.value.toString(10),
                  meta: { quote: void 0 },
                };
                break;
              case 'JsdocTypeStringValue':
                Vt = { type: 'JsdocTypeProperty', value: Qe.value, meta: { quote: Qe.meta.quote } };
                break;
              case 'JsdocTypeSpecialNamePath':
                if (Qe.specialType === 'event') Vt = Qe;
                else
                  throw new u(
                    Qe,
                    "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'",
                  );
                break;
              default:
                throw new u(
                  Qe,
                  "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'",
                );
            }
            if (yr && !L.consume(']')) {
              const gs = L.lexer.current;
              throw new Error(
                `Unterminated square brackets. Next token is '${gs.type}' with text '${gs.text}'`,
              );
            }
            return { type: 'JsdocTypeNamePath', left: $(Z), right: Vt, pathType: qe };
          }, 'namePathParslet');
        }
        s(Q, 'createNamePathParslet');
        function re({ allowedAdditionalTokens: l }) {
          return W({
            name: 'nameParslet',
            accept: s(
              (y) => y === 'Identifier' || y === 'this' || y === 'new' || l.includes(y),
              'accept',
            ),
            parsePrefix: s((y) => {
              const { type: T, text: C } = y.lexer.current;
              return (y.consume(T), { type: 'JsdocTypeName', value: C });
            }, 'parsePrefix'),
          });
        }
        s(re, 'createNameParslet');
        const oe = W({
          name: 'stringValueParslet',
          accept: s((l) => l === 'StringValue', 'accept'),
          parsePrefix: s((l) => {
            const y = l.lexer.current.text;
            return (
              l.consume('StringValue'),
              {
                type: 'JsdocTypeStringValue',
                value: y.slice(1, -1),
                meta: { quote: y[0] === "'" ? 'single' : 'double' },
              }
            );
          }, 'parsePrefix'),
        });
        function ne({ pathGrammar: l, allowedTypes: y }) {
          return W({
            name: 'specialNamePathParslet',
            accept: s((T) => y.includes(T), 'accept'),
            parsePrefix: s((T) => {
              const C = T.lexer.current.type;
              if ((T.consume(C), !T.consume(':'))) return { type: 'JsdocTypeName', value: C };
              let L,
                G = T.lexer.current;
              if (T.consume('StringValue'))
                L = {
                  type: 'JsdocTypeSpecialNamePath',
                  value: G.text.slice(1, -1),
                  specialType: C,
                  meta: { quote: G.text[0] === "'" ? 'single' : 'double' },
                };
              else {
                let _e = '';
                const Te = ['Identifier', '@', '/'];
                for (; Te.some((qe) => T.consume(qe)); ) ((_e += G.text), (G = T.lexer.current));
                L = {
                  type: 'JsdocTypeSpecialNamePath',
                  value: _e,
                  specialType: C,
                  meta: { quote: void 0 },
                };
              }
              const Z = new X(l, T.lexer, T),
                ce = Z.parseInfixIntermediateType(L, k.ALL);
              return (T.acceptLexerState(Z), $(ce));
            }, 'parsePrefix'),
          });
        }
        s(ne, 'createSpecialNamePathParslet');
        const de = [
            re({ allowedAdditionalTokens: ['external', 'module'] }),
            oe,
            be,
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: null }),
          ],
          ye = [...de, ne({ allowedTypes: ['event'], pathGrammar: de })];
        function pe(l) {
          let y;
          if (l.type === 'JsdocTypeParameterList') y = l.elements;
          else if (l.type === 'JsdocTypeParenthesis') y = [l.element];
          else throw new u(l);
          return y.map((T) => N(T));
        }
        s(pe, 'getParameters');
        function Fe(l) {
          const y = pe(l);
          if (y.some((T) => T.type === 'JsdocTypeKeyValue'))
            throw new Error('No parameter should be named');
          return y;
        }
        s(Fe, 'getUnnamedParameters');
        function ot({
          allowNamedParameters: l,
          allowNoReturnType: y,
          allowWithoutParenthesis: T,
          allowNewAsFunctionKeyword: C,
        }) {
          return W({
            name: 'functionParslet',
            accept: s((L, G) => L === 'function' || (C && L === 'new' && G === '('), 'accept'),
            parsePrefix: s((L) => {
              const G = L.consume('new');
              L.consume('function');
              const Z = L.lexer.current.type === '(';
              if (!Z) {
                if (!T) throw new Error('function is missing parameter list');
                return { type: 'JsdocTypeName', value: 'function' };
              }
              let ce = {
                type: 'JsdocTypeFunction',
                parameters: [],
                arrow: !1,
                constructor: G,
                parenthesis: Z,
              };
              const _e = L.parseIntermediateType(k.FUNCTION);
              if (l === void 0) ce.parameters = Fe(_e);
              else {
                if (G && _e.type === 'JsdocTypeFunction' && _e.arrow)
                  return ((ce = _e), (ce.constructor = !0), ce);
                ce.parameters = pe(_e);
                for (const Te of ce.parameters)
                  if (Te.type === 'JsdocTypeKeyValue' && !l.includes(Te.key))
                    throw new Error(
                      `only allowed named parameters are ${l.join(', ')} but got ${Te.type}`,
                    );
              }
              if (L.consume(':')) ce.returnType = L.parseType(k.PREFIX);
              else if (!y) throw new Error('function is missing return type');
              return ce;
            }, 'parsePrefix'),
          });
        }
        s(ot, 'createFunctionParslet');
        function ft({ allowPostfix: l, allowEnclosingBrackets: y }) {
          return W({
            name: 'variadicParslet',
            accept: s((T) => T === '...', 'accept'),
            precedence: k.PREFIX,
            parsePrefix: s((T) => {
              T.consume('...');
              const C = y && T.consume('[');
              try {
                const L = T.parseType(k.PREFIX);
                if (C && !T.consume(']'))
                  throw new Error("Unterminated variadic type. Missing ']'");
                return {
                  type: 'JsdocTypeVariadic',
                  element: $(L),
                  meta: { position: 'prefix', squareBrackets: C },
                };
              } catch (L) {
                if (L instanceof i) {
                  if (C) throw new Error('Empty square brackets for variadic are not allowed.');
                  return {
                    type: 'JsdocTypeVariadic',
                    meta: { position: void 0, squareBrackets: !1 },
                  };
                } else throw L;
              }
            }, 'parsePrefix'),
            parseInfix: l
              ? (T, C) => (
                  T.consume('...'),
                  {
                    type: 'JsdocTypeVariadic',
                    element: $(C),
                    meta: { position: 'suffix', squareBrackets: !1 },
                  }
                )
              : void 0,
          });
        }
        s(ft, 'createVariadicParslet');
        const _t = W({
            name: 'symbolParslet',
            accept: s((l) => l === '(', 'accept'),
            precedence: k.SYMBOL,
            parseInfix: s((l, y) => {
              if (y.type !== 'JsdocTypeName')
                throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
              l.consume('(');
              const T = { type: 'JsdocTypeSymbol', value: y.value };
              if (!l.consume(')')) {
                const C = l.parseIntermediateType(k.SYMBOL);
                if (((T.element = x(C)), !l.consume(')')))
                  throw new Error('Symbol does not end after value');
              }
              return T;
            }, 'parseInfix'),
          }),
          st = W({
            name: 'arrayBracketsParslet',
            precedence: k.ARRAY_BRACKETS,
            accept: s((l, y) => l === '[' && y === ']', 'accept'),
            parseInfix: s(
              (l, y) => (
                l.consume('['),
                l.consume(']'),
                {
                  type: 'JsdocTypeGeneric',
                  left: { type: 'JsdocTypeName', value: 'Array' },
                  elements: [$(y)],
                  meta: { brackets: 'square', dot: !1 },
                }
              ),
              'parseInfix',
            ),
          });
        function mt({ objectFieldGrammar: l, allowKeyTypes: y }) {
          return W({
            name: 'objectParslet',
            accept: s((T) => T === '{', 'accept'),
            parsePrefix: s((T) => {
              T.consume('{');
              const C = { type: 'JsdocTypeObject', meta: { separator: 'comma' }, elements: [] };
              if (!T.consume('}')) {
                let L;
                const G = new X(l, T.lexer, T);
                for (;;) {
                  G.acceptLexerState(T);
                  let Z = G.parseIntermediateType(k.OBJECT);
                  (T.acceptLexerState(G),
                    Z === void 0 && y && (Z = T.parseIntermediateType(k.OBJECT)));
                  let ce = !1;
                  if (
                    (Z.type === 'JsdocTypeNullable' && ((ce = !0), (Z = Z.element)),
                    Z.type === 'JsdocTypeNumber' ||
                      Z.type === 'JsdocTypeName' ||
                      Z.type === 'JsdocTypeStringValue')
                  ) {
                    let Te;
                    (Z.type === 'JsdocTypeStringValue' && (Te = Z.meta.quote),
                      C.elements.push({
                        type: 'JsdocTypeObjectField',
                        key: Z.value.toString(),
                        right: void 0,
                        optional: ce,
                        readonly: !1,
                        meta: { quote: Te },
                      }));
                  } else if (
                    Z.type === 'JsdocTypeObjectField' ||
                    Z.type === 'JsdocTypeJsdocObjectField'
                  )
                    C.elements.push(Z);
                  else throw new u(Z);
                  if (T.lexer.current.startOfLine)
                    ((L = 'linebreak'), T.consume(',') || T.consume(';'));
                  else if (T.consume(',')) L = 'comma';
                  else if (T.consume(';')) L = 'semicolon';
                  else break;
                  if (T.lexer.current.type === '}') break;
                }
                if (
                  ((C.meta.separator = L ?? 'comma'),
                  L === 'linebreak' && (C.meta.propertyIndent = '  '),
                  !T.consume('}'))
                )
                  throw new Error("Unterminated record type. Missing '}'");
              }
              return C;
            }, 'parsePrefix'),
          });
        }
        s(mt, 'createObjectParslet');
        function yt({
          allowSquaredProperties: l,
          allowKeyTypes: y,
          allowReadonly: T,
          allowOptional: C,
        }) {
          return W({
            name: 'objectFieldParslet',
            precedence: k.KEY_VALUE,
            accept: s((L) => L === ':', 'accept'),
            parseInfix: s((L, G) => {
              var Z;
              let ce = !1,
                _e = !1;
              (C && G.type === 'JsdocTypeNullable' && ((ce = !0), (G = G.element)),
                T && G.type === 'JsdocTypeReadonlyProperty' && ((_e = !0), (G = G.element)));
              const Te = (Z = L.baseParser) !== null && Z !== void 0 ? Z : L;
              if (
                (Te.acceptLexerState(L),
                G.type === 'JsdocTypeNumber' ||
                  G.type === 'JsdocTypeName' ||
                  G.type === 'JsdocTypeStringValue' ||
                  F(G))
              ) {
                if (F(G) && !l) throw new u(G);
                Te.consume(':');
                let qe;
                G.type === 'JsdocTypeStringValue' && (qe = G.meta.quote);
                const yr = Te.parseType(k.KEY_VALUE);
                return (
                  L.acceptLexerState(Te),
                  {
                    type: 'JsdocTypeObjectField',
                    key: F(G) ? G : G.value.toString(),
                    right: yr,
                    optional: ce,
                    readonly: _e,
                    meta: { quote: qe },
                  }
                );
              } else {
                if (!y) throw new u(G);
                Te.consume(':');
                const qe = Te.parseType(k.KEY_VALUE);
                return (
                  L.acceptLexerState(Te),
                  { type: 'JsdocTypeJsdocObjectField', left: $(G), right: qe }
                );
              }
            }, 'parseInfix'),
          });
        }
        s(yt, 'createObjectFieldParslet');
        function ht({ allowOptional: l, allowVariadic: y }) {
          return W({
            name: 'keyValueParslet',
            precedence: k.KEY_VALUE,
            accept: s((T) => T === ':', 'accept'),
            parseInfix: s((T, C) => {
              let L = !1,
                G = !1;
              if (
                (l && C.type === 'JsdocTypeNullable' && ((L = !0), (C = C.element)),
                y &&
                  C.type === 'JsdocTypeVariadic' &&
                  C.element !== void 0 &&
                  ((G = !0), (C = C.element)),
                C.type !== 'JsdocTypeName')
              )
                throw new u(C);
              T.consume(':');
              const Z = T.parseType(k.KEY_VALUE);
              return {
                type: 'JsdocTypeKeyValue',
                key: C.value,
                right: Z,
                optional: L,
                variadic: G,
              };
            }, 'parseInfix'),
          });
        }
        s(ht, 'createKeyValueParslet');
        const sn = [
            ...J,
            ot({
              allowWithoutParenthesis: !0,
              allowNamedParameters: ['this', 'new'],
              allowNoReturnType: !0,
              allowNewAsFunctionKeyword: !1,
            }),
            oe,
            ne({ allowedTypes: ['module', 'external', 'event'], pathGrammar: ye }),
            ft({ allowEnclosingBrackets: !0, allowPostfix: !0 }),
            re({ allowedAdditionalTokens: ['keyof'] }),
            _t,
            st,
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
          ],
          Go = [
            ...sn,
            mt({
              objectFieldGrammar: [
                re({ allowedAdditionalTokens: ['typeof', 'module', 'in'] }),
                yt({
                  allowSquaredProperties: !1,
                  allowKeyTypes: !0,
                  allowOptional: !1,
                  allowReadonly: !1,
                }),
                ...sn,
              ],
              allowKeyTypes: !0,
            }),
            ht({ allowOptional: !0, allowVariadic: !0 }),
          ],
          an = W({
            name: 'typeOfParslet',
            accept: s((l) => l === 'typeof', 'accept'),
            parsePrefix: s(
              (l) => (
                l.consume('typeof'),
                { type: 'JsdocTypeTypeof', element: l.parseType(k.KEY_OF_TYPE_OF) }
              ),
              'parsePrefix',
            ),
          }),
          Wo = [
            re({
              allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'],
            }),
            ie,
            ae,
            oe,
            be,
            yt({
              allowSquaredProperties: !1,
              allowKeyTypes: !1,
              allowOptional: !1,
              allowReadonly: !1,
            }),
          ],
          Ko = [
            ...J,
            mt({ allowKeyTypes: !1, objectFieldGrammar: Wo }),
            re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
            an,
            ot({
              allowWithoutParenthesis: !1,
              allowNamedParameters: ['this', 'new'],
              allowNoReturnType: !0,
              allowNewAsFunctionKeyword: !1,
            }),
            ft({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
            re({ allowedAdditionalTokens: ['keyof'] }),
            ne({ allowedTypes: ['module'], pathGrammar: ye }),
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
            ht({ allowOptional: !1, allowVariadic: !1 }),
            _t,
          ],
          Yo = W({
            name: 'assertsParslet',
            accept: s((l) => l === 'asserts', 'accept'),
            parsePrefix: s((l) => {
              l.consume('asserts');
              const y = l.parseIntermediateType(k.SYMBOL);
              if (y.type !== 'JsdocTypeName')
                throw new u(y, 'A typescript asserts always has to have a name on the left side.');
              return l.consume('is')
                ? { type: 'JsdocTypeAsserts', left: y, right: $(l.parseIntermediateType(k.INFIX)) }
                : { type: 'JsdocTypeAssertsPlain', element: y };
            }, 'parsePrefix'),
          });
        function ln({ allowQuestionMark: l }) {
          return W({
            name: 'tupleParslet',
            accept: s((y) => y === '[', 'accept'),
            parsePrefix: s((y) => {
              y.consume('[');
              const T = { type: 'JsdocTypeTuple', elements: [] };
              if (y.consume(']')) return T;
              const C = y.parseIntermediateType(k.ALL);
              if (
                (C.type === 'JsdocTypeParameterList'
                  ? C.elements[0].type === 'JsdocTypeKeyValue'
                    ? (T.elements = C.elements.map(H))
                    : (T.elements = C.elements.map($))
                  : C.type === 'JsdocTypeKeyValue'
                    ? (T.elements = [H(C)])
                    : (T.elements = [$(C)]),
                !y.consume(']'))
              )
                throw new Error("Unterminated '['");
              if (T.elements.some((L) => L.type === 'JsdocTypeUnknown'))
                throw new Error('Question mark in tuple not allowed');
              return T;
            }, 'parsePrefix'),
          });
        }
        s(ln, 'createTupleParslet');
        const Xo = W({
            name: 'keyOfParslet',
            accept: s((l) => l === 'keyof', 'accept'),
            parsePrefix: s(
              (l) => (
                l.consume('keyof'),
                { type: 'JsdocTypeKeyof', element: $(l.parseType(k.KEY_OF_TYPE_OF)) }
              ),
              'parsePrefix',
            ),
          }),
          Qo = W({
            name: 'importParslet',
            accept: s((l) => l === 'import', 'accept'),
            parsePrefix: s((l) => {
              if ((l.consume('import'), !l.consume('(')))
                throw new Error('Missing parenthesis after import keyword');
              const y = l.parseType(k.PREFIX);
              if (y.type !== 'JsdocTypeStringValue')
                throw new Error('Only string values are allowed as paths for imports');
              if (!l.consume(')'))
                throw new Error('Missing closing parenthesis after import keyword');
              return { type: 'JsdocTypeImport', element: y };
            }, 'parsePrefix'),
          }),
          Zo = W({
            name: 'readonlyPropertyParslet',
            accept: s((l) => l === 'readonly', 'accept'),
            parsePrefix: s(
              (l) => (
                l.consume('readonly'),
                { type: 'JsdocTypeReadonlyProperty', element: l.parseIntermediateType(k.KEY_VALUE) }
              ),
              'parsePrefix',
            ),
          }),
          es = W({
            name: 'arrowFunctionParslet',
            precedence: k.ARROW,
            accept: s((l) => l === '=>', 'accept'),
            parseInfix: s(
              (l, y) => (
                l.consume('=>'),
                {
                  type: 'JsdocTypeFunction',
                  parameters: pe(y).map(V),
                  arrow: !0,
                  constructor: !1,
                  parenthesis: !0,
                  returnType: l.parseType(k.OBJECT),
                }
              ),
              'parseInfix',
            ),
          }),
          ts = W({
            name: 'genericArrowFunctionParslet',
            accept: s((l) => l === '<', 'accept'),
            parsePrefix: s((l) => {
              const y = [];
              l.consume('<');
              do {
                let C,
                  L = l.parseIntermediateType(k.SYMBOL);
                if (
                  (L.type === 'JsdocTypeOptional' && ((L = L.element), (C = l.parseType(k.SYMBOL))),
                  L.type !== 'JsdocTypeName')
                )
                  throw new u(L);
                let G;
                l.consume('extends') &&
                  ((G = l.parseType(k.SYMBOL)),
                  G.type === 'JsdocTypeOptional' && ((G = G.element), (C = l.parseType(k.SYMBOL))));
                const Z = { type: 'JsdocTypeTypeParameter', name: L };
                if (
                  (G !== void 0 && (Z.constraint = G),
                  C !== void 0 && (Z.defaultValue = C),
                  y.push(Z),
                  l.consume('>'))
                )
                  break;
              } while (l.consume(','));
              const T = l.parseIntermediateType(k.SYMBOL);
              return ((T.typeParameters = y), T);
            }, 'parsePrefix'),
          }),
          rs = W({
            name: 'intersectionParslet',
            accept: s((l) => l === '&', 'accept'),
            precedence: k.INTERSECTION,
            parseInfix: s((l, y) => {
              l.consume('&');
              const T = [];
              do T.push(l.parseType(k.INTERSECTION));
              while (l.consume('&'));
              return { type: 'JsdocTypeIntersection', elements: [$(y), ...T] };
            }, 'parseInfix'),
          }),
          ns = W({
            name: 'predicateParslet',
            precedence: k.INFIX,
            accept: s((l) => l === 'is', 'accept'),
            parseInfix: s((l, y) => {
              if (y.type !== 'JsdocTypeName')
                throw new u(
                  y,
                  'A typescript predicate always has to have a name on the left side.',
                );
              return (
                l.consume('is'),
                { type: 'JsdocTypePredicate', left: y, right: $(l.parseIntermediateType(k.INFIX)) }
              );
            }, 'parseInfix'),
          }),
          os = W({
            name: 'objectSquareBracketPropertyParslet',
            accept: s((l) => l === '[', 'accept'),
            parsePrefix: s((l) => {
              if (l.baseParser === void 0) throw new Error('Only allowed inside object grammar');
              l.consume('[');
              const y = l.lexer.current.text;
              l.consume('Identifier');
              let T;
              if (l.consume(':')) {
                const C = l.baseParser;
                (C.acceptLexerState(l),
                  (T = {
                    type: 'JsdocTypeIndexSignature',
                    key: y,
                    right: C.parseType(k.INDEX_BRACKETS),
                  }),
                  l.acceptLexerState(C));
              } else if (l.consume('in')) {
                const C = l.baseParser;
                (C.acceptLexerState(l),
                  (T = {
                    type: 'JsdocTypeMappedType',
                    key: y,
                    right: C.parseType(k.ARRAY_BRACKETS),
                  }),
                  l.acceptLexerState(C));
              } else throw new Error("Missing ':' or 'in' inside square bracketed property.");
              if (!l.consume(']')) throw new Error('Unterminated square brackets');
              return T;
            }, 'parsePrefix'),
          }),
          ss = W({
            name: 'readonlyArrayParslet',
            accept: s((l) => l === 'readonly', 'accept'),
            parsePrefix: s(
              (l) => (
                l.consume('readonly'),
                { type: 'JsdocTypeReadonlyArray', element: D(l.parseIntermediateType(k.ALL)) }
              ),
              'parsePrefix',
            ),
          }),
          is = W({
            name: 'conditionalParslet',
            precedence: k.INFIX,
            accept: s((l) => l === 'extends', 'accept'),
            parseInfix: s((l, y) => {
              l.consume('extends');
              const T = l.parseType(k.KEY_OF_TYPE_OF).element,
                C = l.parseType(k.INFIX);
              return (
                l.consume(':'),
                {
                  type: 'JsdocTypeConditional',
                  checksType: $(y),
                  extendsType: T,
                  trueType: C,
                  falseType: l.parseType(k.INFIX),
                }
              );
            }, 'parseInfix'),
          }),
          as = [
            Zo,
            re({
              allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'],
            }),
            ie,
            ae,
            oe,
            be,
            yt({
              allowSquaredProperties: !0,
              allowKeyTypes: !1,
              allowOptional: !0,
              allowReadonly: !0,
            }),
            os,
          ],
          ls = [
            ...J,
            mt({ allowKeyTypes: !1, objectFieldGrammar: as }),
            ss,
            an,
            Xo,
            Qo,
            oe,
            ot({
              allowWithoutParenthesis: !0,
              allowNoReturnType: !1,
              allowNamedParameters: ['this', 'new', 'args'],
              allowNewAsFunctionKeyword: !0,
            }),
            ln({ allowQuestionMark: !1 }),
            ft({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
            Yo,
            is,
            re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
            ne({ allowedTypes: ['module'], pathGrammar: ye }),
            st,
            es,
            ts,
            Q({ allowSquareBracketsOnAnyType: !0, allowJsdocNamePaths: !1, pathGrammar: ye }),
            rs,
            ns,
            ht({ allowVariadic: !0, allowOptional: !0 }),
          ];
        function pr(l, y) {
          switch (y) {
            case 'closure':
              return new X(Ko, l).parse();
            case 'jsdoc':
              return new X(Go, l).parse();
            case 'typescript':
              return new X(ls, l).parse();
          }
        }
        s(pr, 'parse');
        function cn(l, y = ['typescript', 'closure', 'jsdoc']) {
          let T;
          for (const C of y)
            try {
              return pr(l, C);
            } catch (L) {
              T = L;
            }
          throw T;
        }
        s(cn, 'tryParse');
        function Y(l, y) {
          const T = l[y.type];
          if (T === void 0)
            throw new Error(`In this set of transform rules exists no rule for type ${y.type}.`);
          return T(y, (C) => Y(l, C));
        }
        s(Y, 'transform');
        function le(l) {
          throw new Error(
            'This transform is not available. Are you trying the correct parsing mode?',
          );
        }
        s(le, 'notAvailableTransform');
        function Mt(l) {
          const y = { params: [] };
          for (const T of l.parameters)
            T.type === 'JsdocTypeKeyValue'
              ? T.key === 'this'
                ? (y.this = T.right)
                : T.key === 'new'
                  ? (y.new = T.right)
                  : y.params.push(T)
              : y.params.push(T);
          return y;
        }
        s(Mt, 'extractSpecialParams');
        function Ut(l, y, T) {
          return l === 'prefix' ? T + y : y + T;
        }
        s(Ut, 'applyPosition');
        function Ye(l, y) {
          switch (y) {
            case 'double':
              return `"${l}"`;
            case 'single':
              return `'${l}'`;
            case void 0:
              return l;
          }
        }
        s(Ye, 'quote');
        function un() {
          return {
            JsdocTypeParenthesis: s(
              (l, y) => `(${l.element !== void 0 ? y(l.element) : ''})`,
              'JsdocTypeParenthesis',
            ),
            JsdocTypeKeyof: s((l, y) => `keyof ${y(l.element)}`, 'JsdocTypeKeyof'),
            JsdocTypeFunction: s((l, y) => {
              var T;
              if (l.arrow) {
                if (l.returnType === void 0) throw new Error('Arrow function needs a return type.');
                let C = `${l.typeParameters !== void 0 ? `<${(T = l.typeParameters.map(y).join(', ')) !== null && T !== void 0 ? T : ''}>` : ''}(${l.parameters.map(y).join(', ')}) => ${y(l.returnType)}`;
                return (l.constructor && (C = 'new ' + C), C);
              } else {
                let C = l.constructor ? 'new' : 'function';
                return (
                  l.parenthesis &&
                    ((C += `(${l.parameters.map(y).join(', ')})`),
                    l.returnType !== void 0 && (C += `: ${y(l.returnType)}`)),
                  C
                );
              }
            }, 'JsdocTypeFunction'),
            JsdocTypeName: s((l) => l.value, 'JsdocTypeName'),
            JsdocTypeTuple: s((l, y) => `[${l.elements.map(y).join(', ')}]`, 'JsdocTypeTuple'),
            JsdocTypeVariadic: s(
              (l, y) =>
                l.meta.position === void 0 ? '...' : Ut(l.meta.position, y(l.element), '...'),
              'JsdocTypeVariadic',
            ),
            JsdocTypeNamePath: s((l, y) => {
              const T = y(l.left),
                C = y(l.right);
              switch (l.pathType) {
                case 'inner':
                  return `${T}~${C}`;
                case 'instance':
                  return `${T}#${C}`;
                case 'property':
                  return `${T}.${C}`;
                case 'property-brackets':
                  return `${T}[${C}]`;
              }
            }, 'JsdocTypeNamePath'),
            JsdocTypeStringValue: s((l) => Ye(l.value, l.meta.quote), 'JsdocTypeStringValue'),
            JsdocTypeAny: s(() => '*', 'JsdocTypeAny'),
            JsdocTypeGeneric: s((l, y) => {
              if (l.meta.brackets === 'square') {
                const T = l.elements[0],
                  C = y(T);
                return T.type === 'JsdocTypeUnion' || T.type === 'JsdocTypeIntersection'
                  ? `(${C})[]`
                  : `${C}[]`;
              } else
                return `${y(l.left)}${l.meta.dot ? '.' : ''}<${l.infer === !0 ? 'infer ' : ''}${l.elements.map(y).join(', ')}>`;
            }, 'JsdocTypeGeneric'),
            JsdocTypeImport: s((l, y) => `import(${y(l.element)})`, 'JsdocTypeImport'),
            JsdocTypeObjectField: s((l, y) => {
              let T = '';
              return (
                l.readonly && (T += 'readonly '),
                typeof l.key == 'string' ? (T += Ye(l.key, l.meta.quote)) : (T += y(l.key)),
                l.optional && (T += '?'),
                l.right === void 0 ? T : T + `: ${y(l.right)}`
              );
            }, 'JsdocTypeObjectField'),
            JsdocTypeJsdocObjectField: s(
              (l, y) => `${y(l.left)}: ${y(l.right)}`,
              'JsdocTypeJsdocObjectField',
            ),
            JsdocTypeKeyValue: s((l, y) => {
              let T = l.key;
              return (
                l.optional && (T += '?'),
                l.variadic && (T = '...' + T),
                l.right === void 0 ? T : T + `: ${y(l.right)}`
              );
            }, 'JsdocTypeKeyValue'),
            JsdocTypeSpecialNamePath: s(
              (l) => `${l.specialType}:${Ye(l.value, l.meta.quote)}`,
              'JsdocTypeSpecialNamePath',
            ),
            JsdocTypeNotNullable: s(
              (l, y) => Ut(l.meta.position, y(l.element), '!'),
              'JsdocTypeNotNullable',
            ),
            JsdocTypeNull: s(() => 'null', 'JsdocTypeNull'),
            JsdocTypeNullable: s(
              (l, y) => Ut(l.meta.position, y(l.element), '?'),
              'JsdocTypeNullable',
            ),
            JsdocTypeNumber: s((l) => l.value.toString(), 'JsdocTypeNumber'),
            JsdocTypeObject: s((l, y) => {
              var T, C;
              return `{${
                (l.meta.separator === 'linebreak' && l.elements.length > 1
                  ? `
` + ((T = l.meta.propertyIndent) !== null && T !== void 0 ? T : '')
                  : '') +
                l.elements.map(y).join(
                  l.meta.separator === 'comma'
                    ? ', '
                    : l.meta.separator === 'linebreak'
                      ? `
` + ((C = l.meta.propertyIndent) !== null && C !== void 0 ? C : '')
                      : '; ',
                ) +
                (l.meta.separator === 'linebreak' && l.elements.length > 1
                  ? `
`
                  : '')
              }}`;
            }, 'JsdocTypeObject'),
            JsdocTypeOptional: s(
              (l, y) => Ut(l.meta.position, y(l.element), '='),
              'JsdocTypeOptional',
            ),
            JsdocTypeSymbol: s(
              (l, y) => `${l.value}(${l.element !== void 0 ? y(l.element) : ''})`,
              'JsdocTypeSymbol',
            ),
            JsdocTypeTypeof: s((l, y) => `typeof ${y(l.element)}`, 'JsdocTypeTypeof'),
            JsdocTypeUndefined: s(() => 'undefined', 'JsdocTypeUndefined'),
            JsdocTypeUnion: s((l, y) => l.elements.map(y).join(' | '), 'JsdocTypeUnion'),
            JsdocTypeUnknown: s(() => '?', 'JsdocTypeUnknown'),
            JsdocTypeIntersection: s(
              (l, y) => l.elements.map(y).join(' & '),
              'JsdocTypeIntersection',
            ),
            JsdocTypeProperty: s((l) => Ye(l.value, l.meta.quote), 'JsdocTypeProperty'),
            JsdocTypePredicate: s((l, y) => `${y(l.left)} is ${y(l.right)}`, 'JsdocTypePredicate'),
            JsdocTypeIndexSignature: s(
              (l, y) => `[${l.key}: ${y(l.right)}]`,
              'JsdocTypeIndexSignature',
            ),
            JsdocTypeMappedType: s((l, y) => `[${l.key} in ${y(l.right)}]`, 'JsdocTypeMappedType'),
            JsdocTypeAsserts: s(
              (l, y) => `asserts ${y(l.left)} is ${y(l.right)}`,
              'JsdocTypeAsserts',
            ),
            JsdocTypeReadonlyArray: s(
              (l, y) => `readonly ${y(l.element)}`,
              'JsdocTypeReadonlyArray',
            ),
            JsdocTypeAssertsPlain: s((l, y) => `asserts ${y(l.element)}`, 'JsdocTypeAssertsPlain'),
            JsdocTypeConditional: s(
              (l, y) =>
                `${y(l.checksType)} extends ${y(l.extendsType)} ? ${y(l.trueType)} : ${y(l.falseType)}`,
              'JsdocTypeConditional',
            ),
            JsdocTypeTypeParameter: s(
              (l, y) =>
                `${y(l.name)}${l.constraint !== void 0 ? ` extends ${y(l.constraint)}` : ''}${l.defaultValue !== void 0 ? ` = ${y(l.defaultValue)}` : ''}`,
              'JsdocTypeTypeParameter',
            ),
          };
        }
        s(un, 'stringifyRules');
        const Jc = un();
        function cs(l) {
          return Y(Jc, l);
        }
        s(cs, 'stringify');
        const Uc = [
          'null',
          'true',
          'false',
          'break',
          'case',
          'catch',
          'class',
          'const',
          'continue',
          'debugger',
          'default',
          'delete',
          'do',
          'else',
          'export',
          'extends',
          'finally',
          'for',
          'function',
          'if',
          'import',
          'in',
          'instanceof',
          'new',
          'return',
          'super',
          'switch',
          'this',
          'throw',
          'try',
          'typeof',
          'var',
          'void',
          'while',
          'with',
          'yield',
        ];
        function Xe(l) {
          const y = { type: 'NameExpression', name: l };
          return (Uc.includes(l) && (y.reservedWord = !0), y);
        }
        s(Xe, 'makeName');
        const Vc = {
          JsdocTypeOptional: s((l, y) => {
            const T = y(l.element);
            return ((T.optional = !0), T);
          }, 'JsdocTypeOptional'),
          JsdocTypeNullable: s((l, y) => {
            const T = y(l.element);
            return ((T.nullable = !0), T);
          }, 'JsdocTypeNullable'),
          JsdocTypeNotNullable: s((l, y) => {
            const T = y(l.element);
            return ((T.nullable = !1), T);
          }, 'JsdocTypeNotNullable'),
          JsdocTypeVariadic: s((l, y) => {
            if (l.element === void 0)
              throw new Error('dots without value are not allowed in catharsis mode');
            const T = y(l.element);
            return ((T.repeatable = !0), T);
          }, 'JsdocTypeVariadic'),
          JsdocTypeAny: s(() => ({ type: 'AllLiteral' }), 'JsdocTypeAny'),
          JsdocTypeNull: s(() => ({ type: 'NullLiteral' }), 'JsdocTypeNull'),
          JsdocTypeStringValue: s((l) => Xe(Ye(l.value, l.meta.quote)), 'JsdocTypeStringValue'),
          JsdocTypeUndefined: s(() => ({ type: 'UndefinedLiteral' }), 'JsdocTypeUndefined'),
          JsdocTypeUnknown: s(() => ({ type: 'UnknownLiteral' }), 'JsdocTypeUnknown'),
          JsdocTypeFunction: s((l, y) => {
            const T = Mt(l),
              C = { type: 'FunctionType', params: T.params.map(y) };
            return (
              T.this !== void 0 && (C.this = y(T.this)),
              T.new !== void 0 && (C.new = y(T.new)),
              l.returnType !== void 0 && (C.result = y(l.returnType)),
              C
            );
          }, 'JsdocTypeFunction'),
          JsdocTypeGeneric: s(
            (l, y) => ({
              type: 'TypeApplication',
              applications: l.elements.map((T) => y(T)),
              expression: y(l.left),
            }),
            'JsdocTypeGeneric',
          ),
          JsdocTypeSpecialNamePath: s(
            (l) => Xe(l.specialType + ':' + Ye(l.value, l.meta.quote)),
            'JsdocTypeSpecialNamePath',
          ),
          JsdocTypeName: s(
            (l) => (l.value !== 'function' ? Xe(l.value) : { type: 'FunctionType', params: [] }),
            'JsdocTypeName',
          ),
          JsdocTypeNumber: s((l) => Xe(l.value.toString()), 'JsdocTypeNumber'),
          JsdocTypeObject: s((l, y) => {
            const T = { type: 'RecordType', fields: [] };
            for (const C of l.elements)
              C.type !== 'JsdocTypeObjectField' && C.type !== 'JsdocTypeJsdocObjectField'
                ? T.fields.push({ type: 'FieldType', key: y(C), value: void 0 })
                : T.fields.push(y(C));
            return T;
          }, 'JsdocTypeObject'),
          JsdocTypeObjectField: s((l, y) => {
            if (typeof l.key != 'string')
              throw new Error('Index signatures and mapped types are not supported');
            return {
              type: 'FieldType',
              key: Xe(Ye(l.key, l.meta.quote)),
              value: l.right === void 0 ? void 0 : y(l.right),
            };
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: s(
            (l, y) => ({ type: 'FieldType', key: y(l.left), value: y(l.right) }),
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeUnion: s(
            (l, y) => ({ type: 'TypeUnion', elements: l.elements.map((T) => y(T)) }),
            'JsdocTypeUnion',
          ),
          JsdocTypeKeyValue: s(
            (l, y) => ({
              type: 'FieldType',
              key: Xe(l.key),
              value: l.right === void 0 ? void 0 : y(l.right),
            }),
            'JsdocTypeKeyValue',
          ),
          JsdocTypeNamePath: s((l, y) => {
            const T = y(l.left);
            let C;
            l.right.type === 'JsdocTypeSpecialNamePath'
              ? (C = y(l.right).name)
              : (C = Ye(l.right.value, l.right.meta.quote));
            const L = l.pathType === 'inner' ? '~' : l.pathType === 'instance' ? '#' : '.';
            return Xe(`${T.name}${L}${C}`);
          }, 'JsdocTypeNamePath'),
          JsdocTypeSymbol: s((l) => {
            let y = '',
              T = l.element,
              C = !1;
            return (
              T?.type === 'JsdocTypeVariadic' &&
                (T.meta.position === 'prefix' ? (y = '...') : (C = !0), (T = T.element)),
              T?.type === 'JsdocTypeName'
                ? (y += T.value)
                : T?.type === 'JsdocTypeNumber' && (y += T.value.toString()),
              C && (y += '...'),
              Xe(`${l.value}(${y})`)
            );
          }, 'JsdocTypeSymbol'),
          JsdocTypeParenthesis: s((l, y) => y($(l.element)), 'JsdocTypeParenthesis'),
          JsdocTypeMappedType: le,
          JsdocTypeIndexSignature: le,
          JsdocTypeImport: le,
          JsdocTypeKeyof: le,
          JsdocTypeTuple: le,
          JsdocTypeTypeof: le,
          JsdocTypeIntersection: le,
          JsdocTypeProperty: le,
          JsdocTypePredicate: le,
          JsdocTypeAsserts: le,
          JsdocTypeReadonlyArray: le,
          JsdocTypeAssertsPlain: le,
          JsdocTypeConditional: le,
          JsdocTypeTypeParameter: le,
        };
        function us(l) {
          return Y(Vc, l);
        }
        s(us, 'catharsisTransform');
        function it(l) {
          switch (l) {
            case void 0:
              return 'none';
            case 'single':
              return 'single';
            case 'double':
              return 'double';
          }
        }
        s(it, 'getQuoteStyle');
        function ds(l) {
          switch (l) {
            case 'inner':
              return 'INNER_MEMBER';
            case 'instance':
              return 'INSTANCE_MEMBER';
            case 'property':
              return 'MEMBER';
            case 'property-brackets':
              return 'MEMBER';
          }
        }
        s(ds, 'getMemberType');
        function fr(l, y) {
          return y.length === 2
            ? { type: l, left: y[0], right: y[1] }
            : { type: l, left: y[0], right: fr(l, y.slice(1)) };
        }
        s(fr, 'nestResults');
        const Hc = {
          JsdocTypeOptional: s(
            (l, y) => ({
              type: 'OPTIONAL',
              value: y(l.element),
              meta: {
                syntax: l.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN',
              },
            }),
            'JsdocTypeOptional',
          ),
          JsdocTypeNullable: s(
            (l, y) => ({
              type: 'NULLABLE',
              value: y(l.element),
              meta: {
                syntax:
                  l.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK',
              },
            }),
            'JsdocTypeNullable',
          ),
          JsdocTypeNotNullable: s(
            (l, y) => ({
              type: 'NOT_NULLABLE',
              value: y(l.element),
              meta: { syntax: l.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG' },
            }),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeVariadic: s((l, y) => {
            const T = {
              type: 'VARIADIC',
              meta: {
                syntax:
                  l.meta.position === 'prefix'
                    ? 'PREFIX_DOTS'
                    : l.meta.position === 'suffix'
                      ? 'SUFFIX_DOTS'
                      : 'ONLY_DOTS',
              },
            };
            return (l.element !== void 0 && (T.value = y(l.element)), T);
          }, 'JsdocTypeVariadic'),
          JsdocTypeName: s((l) => ({ type: 'NAME', name: l.value }), 'JsdocTypeName'),
          JsdocTypeTypeof: s(
            (l, y) => ({ type: 'TYPE_QUERY', name: y(l.element) }),
            'JsdocTypeTypeof',
          ),
          JsdocTypeTuple: s(
            (l, y) => ({ type: 'TUPLE', entries: l.elements.map(y) }),
            'JsdocTypeTuple',
          ),
          JsdocTypeKeyof: s(
            (l, y) => ({ type: 'KEY_QUERY', value: y(l.element) }),
            'JsdocTypeKeyof',
          ),
          JsdocTypeImport: s(
            (l) => ({
              type: 'IMPORT',
              path: {
                type: 'STRING_VALUE',
                quoteStyle: it(l.element.meta.quote),
                string: l.element.value,
              },
            }),
            'JsdocTypeImport',
          ),
          JsdocTypeUndefined: s(() => ({ type: 'NAME', name: 'undefined' }), 'JsdocTypeUndefined'),
          JsdocTypeAny: s(() => ({ type: 'ANY' }), 'JsdocTypeAny'),
          JsdocTypeFunction: s((l, y) => {
            const T = Mt(l),
              C = {
                type: l.arrow ? 'ARROW' : 'FUNCTION',
                params: T.params.map((L) => {
                  if (L.type === 'JsdocTypeKeyValue') {
                    if (L.right === void 0)
                      throw new Error(
                        "Function parameter without ':' is not expected to be 'KEY_VALUE'",
                      );
                    return { type: 'NAMED_PARAMETER', name: L.key, typeName: y(L.right) };
                  } else return y(L);
                }),
                new: null,
                returns: null,
              };
            return (
              T.this !== void 0 ? (C.this = y(T.this)) : l.arrow || (C.this = null),
              T.new !== void 0 && (C.new = y(T.new)),
              l.returnType !== void 0 && (C.returns = y(l.returnType)),
              C
            );
          }, 'JsdocTypeFunction'),
          JsdocTypeGeneric: s((l, y) => {
            const T = {
              type: 'GENERIC',
              subject: y(l.left),
              objects: l.elements.map(y),
              meta: {
                syntax:
                  l.meta.brackets === 'square'
                    ? 'SQUARE_BRACKET'
                    : l.meta.dot
                      ? 'ANGLE_BRACKET_WITH_DOT'
                      : 'ANGLE_BRACKET',
              },
            };
            return (
              l.meta.brackets === 'square' &&
                l.elements[0].type === 'JsdocTypeFunction' &&
                !l.elements[0].parenthesis &&
                (T.objects[0] = { type: 'NAME', name: 'function' }),
              T
            );
          }, 'JsdocTypeGeneric'),
          JsdocTypeObjectField: s((l, y) => {
            if (typeof l.key != 'string')
              throw new Error('Index signatures and mapped types are not supported');
            if (l.right === void 0)
              return {
                type: 'RECORD_ENTRY',
                key: l.key,
                quoteStyle: it(l.meta.quote),
                value: null,
                readonly: !1,
              };
            let T = y(l.right);
            return (
              l.optional &&
                (T = { type: 'OPTIONAL', value: T, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
              {
                type: 'RECORD_ENTRY',
                key: l.key.toString(),
                quoteStyle: it(l.meta.quote),
                value: T,
                readonly: !1,
              }
            );
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: s(() => {
            throw new Error('Keys may not be typed in jsdoctypeparser.');
          }, 'JsdocTypeJsdocObjectField'),
          JsdocTypeKeyValue: s((l, y) => {
            if (l.right === void 0)
              return {
                type: 'RECORD_ENTRY',
                key: l.key,
                quoteStyle: 'none',
                value: null,
                readonly: !1,
              };
            let T = y(l.right);
            return (
              l.optional &&
                (T = { type: 'OPTIONAL', value: T, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
              { type: 'RECORD_ENTRY', key: l.key, quoteStyle: 'none', value: T, readonly: !1 }
            );
          }, 'JsdocTypeKeyValue'),
          JsdocTypeObject: s((l, y) => {
            const T = [];
            for (const C of l.elements)
              (C.type === 'JsdocTypeObjectField' || C.type === 'JsdocTypeJsdocObjectField') &&
                T.push(y(C));
            return { type: 'RECORD', entries: T };
          }, 'JsdocTypeObject'),
          JsdocTypeSpecialNamePath: s((l) => {
            if (l.specialType !== 'module')
              throw new Error(
                `jsdoctypeparser does not support type ${l.specialType} at this point.`,
              );
            return {
              type: 'MODULE',
              value: { type: 'FILE_PATH', quoteStyle: it(l.meta.quote), path: l.value },
            };
          }, 'JsdocTypeSpecialNamePath'),
          JsdocTypeNamePath: s((l, y) => {
            let T = !1,
              C,
              L;
            l.right.type === 'JsdocTypeSpecialNamePath' && l.right.specialType === 'event'
              ? ((T = !0), (C = l.right.value), (L = it(l.right.meta.quote)))
              : ((C = l.right.value), (L = it(l.right.meta.quote)));
            const G = {
              type: ds(l.pathType),
              owner: y(l.left),
              name: C,
              quoteStyle: L,
              hasEventPrefix: T,
            };
            if (G.owner.type === 'MODULE') {
              const Z = G.owner;
              return ((G.owner = G.owner.value), (Z.value = G), Z);
            } else return G;
          }, 'JsdocTypeNamePath'),
          JsdocTypeUnion: s((l, y) => fr('UNION', l.elements.map(y)), 'JsdocTypeUnion'),
          JsdocTypeParenthesis: s(
            (l, y) => ({ type: 'PARENTHESIS', value: y($(l.element)) }),
            'JsdocTypeParenthesis',
          ),
          JsdocTypeNull: s(() => ({ type: 'NAME', name: 'null' }), 'JsdocTypeNull'),
          JsdocTypeUnknown: s(() => ({ type: 'UNKNOWN' }), 'JsdocTypeUnknown'),
          JsdocTypeStringValue: s(
            (l) => ({ type: 'STRING_VALUE', quoteStyle: it(l.meta.quote), string: l.value }),
            'JsdocTypeStringValue',
          ),
          JsdocTypeIntersection: s(
            (l, y) => fr('INTERSECTION', l.elements.map(y)),
            'JsdocTypeIntersection',
          ),
          JsdocTypeNumber: s(
            (l) => ({ type: 'NUMBER_VALUE', number: l.value.toString() }),
            'JsdocTypeNumber',
          ),
          JsdocTypeSymbol: le,
          JsdocTypeProperty: le,
          JsdocTypePredicate: le,
          JsdocTypeMappedType: le,
          JsdocTypeIndexSignature: le,
          JsdocTypeAsserts: le,
          JsdocTypeReadonlyArray: le,
          JsdocTypeAssertsPlain: le,
          JsdocTypeConditional: le,
          JsdocTypeTypeParameter: le,
        };
        function ps(l) {
          return Y(Hc, l);
        }
        s(ps, 'jtpTransform');
        function fs() {
          return {
            JsdocTypeIntersection: s(
              (l, y) => ({ type: 'JsdocTypeIntersection', elements: l.elements.map(y) }),
              'JsdocTypeIntersection',
            ),
            JsdocTypeGeneric: s(
              (l, y) => ({
                type: 'JsdocTypeGeneric',
                left: y(l.left),
                elements: l.elements.map(y),
                meta: { dot: l.meta.dot, brackets: l.meta.brackets },
              }),
              'JsdocTypeGeneric',
            ),
            JsdocTypeNullable: s((l) => l, 'JsdocTypeNullable'),
            JsdocTypeUnion: s(
              (l, y) => ({ type: 'JsdocTypeUnion', elements: l.elements.map(y) }),
              'JsdocTypeUnion',
            ),
            JsdocTypeUnknown: s((l) => l, 'JsdocTypeUnknown'),
            JsdocTypeUndefined: s((l) => l, 'JsdocTypeUndefined'),
            JsdocTypeTypeof: s(
              (l, y) => ({ type: 'JsdocTypeTypeof', element: y(l.element) }),
              'JsdocTypeTypeof',
            ),
            JsdocTypeSymbol: s((l, y) => {
              const T = { type: 'JsdocTypeSymbol', value: l.value };
              return (l.element !== void 0 && (T.element = y(l.element)), T);
            }, 'JsdocTypeSymbol'),
            JsdocTypeOptional: s(
              (l, y) => ({
                type: 'JsdocTypeOptional',
                element: y(l.element),
                meta: { position: l.meta.position },
              }),
              'JsdocTypeOptional',
            ),
            JsdocTypeObject: s(
              (l, y) => ({
                type: 'JsdocTypeObject',
                meta: { separator: 'comma' },
                elements: l.elements.map(y),
              }),
              'JsdocTypeObject',
            ),
            JsdocTypeNumber: s((l) => l, 'JsdocTypeNumber'),
            JsdocTypeNull: s((l) => l, 'JsdocTypeNull'),
            JsdocTypeNotNullable: s(
              (l, y) => ({
                type: 'JsdocTypeNotNullable',
                element: y(l.element),
                meta: { position: l.meta.position },
              }),
              'JsdocTypeNotNullable',
            ),
            JsdocTypeSpecialNamePath: s((l) => l, 'JsdocTypeSpecialNamePath'),
            JsdocTypeObjectField: s(
              (l, y) => ({
                type: 'JsdocTypeObjectField',
                key: l.key,
                right: l.right === void 0 ? void 0 : y(l.right),
                optional: l.optional,
                readonly: l.readonly,
                meta: l.meta,
              }),
              'JsdocTypeObjectField',
            ),
            JsdocTypeJsdocObjectField: s(
              (l, y) => ({ type: 'JsdocTypeJsdocObjectField', left: y(l.left), right: y(l.right) }),
              'JsdocTypeJsdocObjectField',
            ),
            JsdocTypeKeyValue: s(
              (l, y) => ({
                type: 'JsdocTypeKeyValue',
                key: l.key,
                right: l.right === void 0 ? void 0 : y(l.right),
                optional: l.optional,
                variadic: l.variadic,
              }),
              'JsdocTypeKeyValue',
            ),
            JsdocTypeImport: s(
              (l, y) => ({ type: 'JsdocTypeImport', element: y(l.element) }),
              'JsdocTypeImport',
            ),
            JsdocTypeAny: s((l) => l, 'JsdocTypeAny'),
            JsdocTypeStringValue: s((l) => l, 'JsdocTypeStringValue'),
            JsdocTypeNamePath: s((l) => l, 'JsdocTypeNamePath'),
            JsdocTypeVariadic: s((l, y) => {
              const T = {
                type: 'JsdocTypeVariadic',
                meta: { position: l.meta.position, squareBrackets: l.meta.squareBrackets },
              };
              return (l.element !== void 0 && (T.element = y(l.element)), T);
            }, 'JsdocTypeVariadic'),
            JsdocTypeTuple: s(
              (l, y) => ({ type: 'JsdocTypeTuple', elements: l.elements.map(y) }),
              'JsdocTypeTuple',
            ),
            JsdocTypeName: s((l) => l, 'JsdocTypeName'),
            JsdocTypeFunction: s((l, y) => {
              const T = {
                type: 'JsdocTypeFunction',
                arrow: l.arrow,
                parameters: l.parameters.map(y),
                constructor: l.constructor,
                parenthesis: l.parenthesis,
              };
              return (l.returnType !== void 0 && (T.returnType = y(l.returnType)), T);
            }, 'JsdocTypeFunction'),
            JsdocTypeKeyof: s(
              (l, y) => ({ type: 'JsdocTypeKeyof', element: y(l.element) }),
              'JsdocTypeKeyof',
            ),
            JsdocTypeParenthesis: s(
              (l, y) => ({ type: 'JsdocTypeParenthesis', element: y(l.element) }),
              'JsdocTypeParenthesis',
            ),
            JsdocTypeProperty: s((l) => l, 'JsdocTypeProperty'),
            JsdocTypePredicate: s(
              (l, y) => ({ type: 'JsdocTypePredicate', left: y(l.left), right: y(l.right) }),
              'JsdocTypePredicate',
            ),
            JsdocTypeIndexSignature: s(
              (l, y) => ({ type: 'JsdocTypeIndexSignature', key: l.key, right: y(l.right) }),
              'JsdocTypeIndexSignature',
            ),
            JsdocTypeMappedType: s(
              (l, y) => ({ type: 'JsdocTypeMappedType', key: l.key, right: y(l.right) }),
              'JsdocTypeMappedType',
            ),
            JsdocTypeAsserts: s(
              (l, y) => ({ type: 'JsdocTypeAsserts', left: y(l.left), right: y(l.right) }),
              'JsdocTypeAsserts',
            ),
            JsdocTypeReadonlyArray: s(
              (l, y) => ({ type: 'JsdocTypeReadonlyArray', element: y(l.element) }),
              'JsdocTypeReadonlyArray',
            ),
            JsdocTypeAssertsPlain: s(
              (l, y) => ({ type: 'JsdocTypeAssertsPlain', element: y(l.element) }),
              'JsdocTypeAssertsPlain',
            ),
            JsdocTypeConditional: s(
              (l, y) => ({
                type: 'JsdocTypeConditional',
                checksType: y(l.checksType),
                extendsType: y(l.extendsType),
                trueType: y(l.trueType),
                falseType: y(l.falseType),
              }),
              'JsdocTypeConditional',
            ),
            JsdocTypeTypeParameter: s(
              (l, y) => ({
                type: 'JsdocTypeTypeParameter',
                name: y(l.name),
                constraint: l.constraint !== void 0 ? y(l.constraint) : void 0,
                defaultValue: l.defaultValue !== void 0 ? y(l.defaultValue) : void 0,
              }),
              'JsdocTypeTypeParameter',
            ),
          };
        }
        s(fs, 'identityTransformRules');
        const ms = {
          JsdocTypeAny: [],
          JsdocTypeFunction: ['parameters', 'returnType'],
          JsdocTypeGeneric: ['left', 'elements'],
          JsdocTypeImport: [],
          JsdocTypeIndexSignature: ['right'],
          JsdocTypeIntersection: ['elements'],
          JsdocTypeKeyof: ['element'],
          JsdocTypeKeyValue: ['right'],
          JsdocTypeMappedType: ['right'],
          JsdocTypeName: [],
          JsdocTypeNamePath: ['left', 'right'],
          JsdocTypeNotNullable: ['element'],
          JsdocTypeNull: [],
          JsdocTypeNullable: ['element'],
          JsdocTypeNumber: [],
          JsdocTypeObject: ['elements'],
          JsdocTypeObjectField: ['right'],
          JsdocTypeJsdocObjectField: ['left', 'right'],
          JsdocTypeOptional: ['element'],
          JsdocTypeParenthesis: ['element'],
          JsdocTypeSpecialNamePath: [],
          JsdocTypeStringValue: [],
          JsdocTypeSymbol: ['element'],
          JsdocTypeTuple: ['elements'],
          JsdocTypeTypeof: ['element'],
          JsdocTypeUndefined: [],
          JsdocTypeUnion: ['elements'],
          JsdocTypeUnknown: [],
          JsdocTypeVariadic: ['element'],
          JsdocTypeProperty: [],
          JsdocTypePredicate: ['left', 'right'],
          JsdocTypeAsserts: ['left', 'right'],
          JsdocTypeReadonlyArray: ['element'],
          JsdocTypeAssertsPlain: ['element'],
          JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],
          JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue'],
        };
        function mr(l, y, T, C, L) {
          C?.(l, y, T);
          const G = ms[l.type];
          for (const Z of G) {
            const ce = l[Z];
            if (ce !== void 0)
              if (Array.isArray(ce)) for (const _e of ce) mr(_e, l, Z, C, L);
              else mr(ce, l, Z, C, L);
          }
          L?.(l, y, T);
        }
        s(mr, '_traverse');
        function ys(l, y, T) {
          mr(l, void 0, void 0, y, T);
        }
        (s(ys, 'traverse'),
          (r.catharsisTransform = us),
          (r.identityTransformRules = fs),
          (r.jtpTransform = ps),
          (r.parse = pr),
          (r.stringify = cs),
          (r.stringifyRules = un),
          (r.transform = Y),
          (r.traverse = ys),
          (r.tryParse = cn),
          (r.visitorKeys = ms));
      });
    },
  }),
  rk = B({
    '../node_modules/browser-dtector/browser-dtector.umd.min.js'(e, t) {
      (function (r, n) {
        typeof e == 'object' && typeof t < 'u'
          ? (t.exports = n())
          : typeof define == 'function' && define.amd
            ? define(n)
            : ((r = typeof globalThis < 'u' ? globalThis : r || self).BrowserDetector = n());
      })(e, function () {
        function r(d, u) {
          for (var p = 0; p < u.length; p++) {
            var f = u[p];
            ((f.enumerable = f.enumerable || !1),
              (f.configurable = !0),
              'value' in f && (f.writable = !0),
              Object.defineProperty(
                d,
                ((m = f.key),
                (h = void 0),
                typeof (h = (function (g, v) {
                  if (typeof g != 'object' || g === null) return g;
                  var E = g[Symbol.toPrimitive];
                  if (E !== void 0) {
                    var b = E.call(g, v);
                    if (typeof b != 'object') return b;
                    throw new TypeError('@@toPrimitive must return a primitive value.');
                  }
                  return (v === 'string' ? String : Number)(g);
                })(m, 'string')) == 'symbol'
                  ? h
                  : String(h)),
                f,
              ));
          }
          var m, h;
        }
        s(r, 'e');
        var n = {
            chrome: 'Google Chrome',
            brave: 'Brave',
            crios: 'Google Chrome',
            edge: 'Microsoft Edge',
            edg: 'Microsoft Edge',
            edgios: 'Microsoft Edge',
            fennec: 'Mozilla Firefox',
            jsdom: 'JsDOM',
            mozilla: 'Mozilla Firefox',
            fxios: 'Mozilla Firefox',
            msie: 'Microsoft Internet Explorer',
            opera: 'Opera',
            opios: 'Opera',
            opr: 'Opera',
            opt: 'Opera',
            rv: 'Microsoft Internet Explorer',
            safari: 'Safari',
            samsungbrowser: 'Samsung Browser',
            electron: 'Electron',
          },
          o = {
            android: 'Android',
            androidTablet: 'Android Tablet',
            cros: 'Chrome OS',
            fennec: 'Android Tablet',
            ipad: 'IPad',
            iphone: 'IPhone',
            jsdom: 'JsDOM',
            linux: 'Linux',
            mac: 'Macintosh',
            tablet: 'Android Tablet',
            win: 'Windows',
            'windows phone': 'Windows Phone',
            xbox: 'Microsoft Xbox',
          },
          i = s(function (d) {
            var u = new RegExp(
                '^-?\\d+(?:.\\d{0,'.concat(
                  arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1,
                  '})?',
                ),
              ),
              p = Number(d).toString().match(u);
            return p ? p[0] : null;
          }, 'n'),
          a = s(function () {
            return typeof window < 'u' ? window.navigator : null;
          }, 'i'),
          c = (function () {
            function d(m) {
              var h;
              ((function (g, v) {
                if (!(g instanceof v)) throw new TypeError('Cannot call a class as a function');
              })(this, d),
                (this.userAgent =
                  m || ((h = a()) === null || h === void 0 ? void 0 : h.userAgent) || null));
            }
            s(d, 't');
            var u, p, f;
            return (
              (u = d),
              (p = [
                {
                  key: 'parseUserAgent',
                  value: s(function (m) {
                    var h,
                      g,
                      v,
                      E = {},
                      b = m || this.userAgent || '',
                      S = b.toLowerCase().replace(/\s\s+/g, ' '),
                      R =
                        /(edge)\/([\w.]+)/.exec(S) ||
                        /(edg)[/]([\w.]+)/.exec(S) ||
                        /(opr)[/]([\w.]+)/.exec(S) ||
                        /(opt)[/]([\w.]+)/.exec(S) ||
                        /(fxios)[/]([\w.]+)/.exec(S) ||
                        /(edgios)[/]([\w.]+)/.exec(S) ||
                        /(jsdom)[/]([\w.]+)/.exec(S) ||
                        /(samsungbrowser)[/]([\w.]+)/.exec(S) ||
                        /(electron)[/]([\w.]+)/.exec(S) ||
                        /(chrome)[/]([\w.]+)/.exec(S) ||
                        /(crios)[/]([\w.]+)/.exec(S) ||
                        /(opios)[/]([\w.]+)/.exec(S) ||
                        /(version)(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(webkit)[/]([\w.]+).*(version)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(webkit)[/]([\w.]+)/.exec(S) ||
                        /(opera)(?:.*version|)[/]([\w.]+)/.exec(S) ||
                        /(msie) ([\w.]+)/.exec(S) ||
                        /(fennec)[/]([\w.]+)/.exec(S) ||
                        (S.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(S)) ||
                        (S.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(S)) ||
                        [],
                      I =
                        /(ipad)/.exec(S) ||
                        /(ipod)/.exec(S) ||
                        /(iphone)/.exec(S) ||
                        /(jsdom)/.exec(S) ||
                        /(windows phone)/.exec(S) ||
                        /(xbox)/.exec(S) ||
                        /(win)/.exec(S) ||
                        /(tablet)/.exec(S) ||
                        (/(android)/.test(S) && /(mobile)/.test(S) === !1 && ['androidTablet']) ||
                        /(android)/.exec(S) ||
                        /(mac)/.exec(S) ||
                        /(linux)/.exec(S) ||
                        /(cros)/.exec(S) ||
                        [],
                      q = R[5] || R[3] || R[1] || null,
                      P = I[0] || null,
                      A = R[4] || R[2] || null,
                      w = a();
                    (q === 'chrome' &&
                      typeof (w == null || (h = w.brave) === null || h === void 0
                        ? void 0
                        : h.isBrave) == 'function' &&
                      (q = 'brave'),
                      q && (E[q] = !0),
                      P && (E[P] = !0));
                    var _ = !!(E.tablet || E.android || E.androidTablet),
                      $ = !!(E.ipad || E.tablet || E.androidTablet),
                      N = !!(
                        E.android ||
                        E.androidTablet ||
                        E.tablet ||
                        E.ipad ||
                        E.ipod ||
                        E.iphone ||
                        E['windows phone']
                      ),
                      V = !!(E.cros || E.mac || E.linux || E.win),
                      H = !!(
                        E.brave ||
                        E.chrome ||
                        E.crios ||
                        E.opr ||
                        E.safari ||
                        E.edg ||
                        E.electron
                      ),
                      x = !!(E.msie || E.rv);
                    return {
                      name: (g = n[q]) !== null && g !== void 0 ? g : null,
                      platform: (v = o[P]) !== null && v !== void 0 ? v : null,
                      userAgent: b,
                      version: A,
                      shortVersion: A ? i(parseFloat(A), 2) : null,
                      isAndroid: _,
                      isTablet: $,
                      isMobile: N,
                      isDesktop: V,
                      isWebkit: H,
                      isIE: x,
                    };
                  }, 'value'),
                },
                {
                  key: 'getBrowserInfo',
                  value: s(function () {
                    var m = this.parseUserAgent();
                    return {
                      name: m.name,
                      platform: m.platform,
                      userAgent: m.userAgent,
                      version: m.version,
                      shortVersion: m.shortVersion,
                    };
                  }, 'value'),
                },
              ]),
              (f = [
                {
                  key: 'VERSION',
                  get: s(function () {
                    return '3.4.0';
                  }, 'get'),
                },
              ]),
              p && r(u.prototype, p),
              f && r(u, f),
              Object.defineProperty(u, 'prototype', { writable: !1 }),
              d
            );
          })();
        return c;
      });
    },
  }),
  Mp = {};
St(Mp, {
  ARGTYPES_INFO_REQUEST: () => eT,
  ARGTYPES_INFO_RESPONSE: () => _u,
  CHANNEL_CREATED: () => ok,
  CHANNEL_WS_DISCONNECT: () => Mv,
  CONFIG_ERROR: () => jv,
  CREATE_NEW_STORYFILE_REQUEST: () => sk,
  CREATE_NEW_STORYFILE_RESPONSE: () => ik,
  CURRENT_STORY_WAS_SET: () => Eu,
  DOCS_PREPARED: () => $v,
  DOCS_RENDERED: () => $p,
  FILE_COMPONENT_SEARCH_REQUEST: () => ak,
  FILE_COMPONENT_SEARCH_RESPONSE: () => lk,
  FORCE_REMOUNT: () => fa,
  FORCE_RE_RENDER: () => kp,
  GLOBALS_UPDATED: () => Hs,
  NAVIGATE_URL: () => ck,
  OPEN_IN_EDITOR_REQUEST: () => xk,
  OPEN_IN_EDITOR_RESPONSE: () => Pk,
  PLAY_FUNCTION_THREW_EXCEPTION: () => kv,
  PRELOAD_ENTRIES: () => Lv,
  PREVIEW_BUILDER_PROGRESS: () => uk,
  PREVIEW_INITIALIZED: () => Fv,
  PREVIEW_KEYDOWN: () => Bv,
  REGISTER_SUBSCRIPTION: () => dk,
  REQUEST_WHATS_NEW_DATA: () => Ek,
  RESET_STORY_ARGS: () => Dp,
  RESULT_WHATS_NEW_DATA: () => wk,
  SAVE_STORY_REQUEST: () => Ak,
  SAVE_STORY_RESPONSE: () => Rk,
  SELECT_STORY: () => pk,
  SET_CONFIG: () => fk,
  SET_CURRENT_STORY: () => Lp,
  SET_FILTER: () => mk,
  SET_GLOBALS: () => Jv,
  SET_INDEX: () => yk,
  SET_STORIES: () => hk,
  SET_WHATS_NEW_CACHE: () => Sk,
  SHARED_STATE_CHANGED: () => gk,
  SHARED_STATE_SET: () => bk,
  STORIES_COLLAPSE_ALL: () => vk,
  STORIES_EXPAND_ALL: () => Tk,
  STORY_ARGS_UPDATED: () => Uv,
  STORY_CHANGED: () => Vv,
  STORY_ERRORED: () => Hv,
  STORY_FINISHED: () => Su,
  STORY_HOT_UPDATED: () => Xv,
  STORY_INDEX_INVALIDATED: () => zv,
  STORY_MISSING: () => wu,
  STORY_PREPARED: () => Gv,
  STORY_RENDERED: () => ma,
  STORY_RENDER_PHASE_CHANGED: () => xn,
  STORY_SPECIFIED: () => Wv,
  STORY_THREW_EXCEPTION: () => Kv,
  STORY_UNCHANGED: () => Yv,
  TELEMETRY_ERROR: () => Zv,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => _k,
  UNHANDLED_ERRORS_WHILE_PLAYING: () => Dv,
  UPDATE_GLOBALS: () => Fp,
  UPDATE_QUERY_PARAMS: () => Qv,
  UPDATE_STORY_ARGS: () => Bp,
  default: () => nk,
});
var jp = ((e) => (
    (e.CHANNEL_WS_DISCONNECT = 'channelWSDisconnect'),
    (e.CHANNEL_CREATED = 'channelCreated'),
    (e.CONFIG_ERROR = 'configError'),
    (e.STORY_INDEX_INVALIDATED = 'storyIndexInvalidated'),
    (e.STORY_SPECIFIED = 'storySpecified'),
    (e.SET_CONFIG = 'setConfig'),
    (e.SET_STORIES = 'setStories'),
    (e.SET_INDEX = 'setIndex'),
    (e.SET_CURRENT_STORY = 'setCurrentStory'),
    (e.CURRENT_STORY_WAS_SET = 'currentStoryWasSet'),
    (e.FORCE_RE_RENDER = 'forceReRender'),
    (e.FORCE_REMOUNT = 'forceRemount'),
    (e.PRELOAD_ENTRIES = 'preloadStories'),
    (e.STORY_PREPARED = 'storyPrepared'),
    (e.DOCS_PREPARED = 'docsPrepared'),
    (e.STORY_CHANGED = 'storyChanged'),
    (e.STORY_UNCHANGED = 'storyUnchanged'),
    (e.STORY_RENDERED = 'storyRendered'),
    (e.STORY_FINISHED = 'storyFinished'),
    (e.STORY_MISSING = 'storyMissing'),
    (e.STORY_ERRORED = 'storyErrored'),
    (e.STORY_THREW_EXCEPTION = 'storyThrewException'),
    (e.STORY_RENDER_PHASE_CHANGED = 'storyRenderPhaseChanged'),
    (e.STORY_HOT_UPDATED = 'storyHotUpdated'),
    (e.PLAY_FUNCTION_THREW_EXCEPTION = 'playFunctionThrewException'),
    (e.UNHANDLED_ERRORS_WHILE_PLAYING = 'unhandledErrorsWhilePlaying'),
    (e.UPDATE_STORY_ARGS = 'updateStoryArgs'),
    (e.STORY_ARGS_UPDATED = 'storyArgsUpdated'),
    (e.RESET_STORY_ARGS = 'resetStoryArgs'),
    (e.SET_FILTER = 'setFilter'),
    (e.SET_GLOBALS = 'setGlobals'),
    (e.UPDATE_GLOBALS = 'updateGlobals'),
    (e.GLOBALS_UPDATED = 'globalsUpdated'),
    (e.REGISTER_SUBSCRIPTION = 'registerSubscription'),
    (e.PREVIEW_INITIALIZED = 'previewInitialized'),
    (e.PREVIEW_KEYDOWN = 'previewKeydown'),
    (e.PREVIEW_BUILDER_PROGRESS = 'preview_builder_progress'),
    (e.SELECT_STORY = 'selectStory'),
    (e.STORIES_COLLAPSE_ALL = 'storiesCollapseAll'),
    (e.STORIES_EXPAND_ALL = 'storiesExpandAll'),
    (e.DOCS_RENDERED = 'docsRendered'),
    (e.SHARED_STATE_CHANGED = 'sharedStateChanged'),
    (e.SHARED_STATE_SET = 'sharedStateSet'),
    (e.NAVIGATE_URL = 'navigateUrl'),
    (e.UPDATE_QUERY_PARAMS = 'updateQueryParams'),
    (e.REQUEST_WHATS_NEW_DATA = 'requestWhatsNewData'),
    (e.RESULT_WHATS_NEW_DATA = 'resultWhatsNewData'),
    (e.SET_WHATS_NEW_CACHE = 'setWhatsNewCache'),
    (e.TOGGLE_WHATS_NEW_NOTIFICATIONS = 'toggleWhatsNewNotifications'),
    (e.TELEMETRY_ERROR = 'telemetryError'),
    (e.FILE_COMPONENT_SEARCH_REQUEST = 'fileComponentSearchRequest'),
    (e.FILE_COMPONENT_SEARCH_RESPONSE = 'fileComponentSearchResponse'),
    (e.SAVE_STORY_REQUEST = 'saveStoryRequest'),
    (e.SAVE_STORY_RESPONSE = 'saveStoryResponse'),
    (e.ARGTYPES_INFO_REQUEST = 'argtypesInfoRequest'),
    (e.ARGTYPES_INFO_RESPONSE = 'argtypesInfoResponse'),
    (e.CREATE_NEW_STORYFILE_REQUEST = 'createNewStoryfileRequest'),
    (e.CREATE_NEW_STORYFILE_RESPONSE = 'createNewStoryfileResponse'),
    (e.OPEN_IN_EDITOR_REQUEST = 'openInEditorRequest'),
    (e.OPEN_IN_EDITOR_RESPONSE = 'openInEditorResponse'),
    e
  ))(jp || {}),
  nk = jp,
  {
    CHANNEL_WS_DISCONNECT: Mv,
    CHANNEL_CREATED: ok,
    CONFIG_ERROR: jv,
    CREATE_NEW_STORYFILE_REQUEST: sk,
    CREATE_NEW_STORYFILE_RESPONSE: ik,
    CURRENT_STORY_WAS_SET: Eu,
    DOCS_PREPARED: $v,
    DOCS_RENDERED: $p,
    FILE_COMPONENT_SEARCH_REQUEST: ak,
    FILE_COMPONENT_SEARCH_RESPONSE: lk,
    FORCE_RE_RENDER: kp,
    FORCE_REMOUNT: fa,
    GLOBALS_UPDATED: Hs,
    NAVIGATE_URL: ck,
    PLAY_FUNCTION_THREW_EXCEPTION: kv,
    UNHANDLED_ERRORS_WHILE_PLAYING: Dv,
    PRELOAD_ENTRIES: Lv,
    PREVIEW_INITIALIZED: Fv,
    PREVIEW_BUILDER_PROGRESS: uk,
    PREVIEW_KEYDOWN: Bv,
    REGISTER_SUBSCRIPTION: dk,
    RESET_STORY_ARGS: Dp,
    SELECT_STORY: pk,
    SET_CONFIG: fk,
    SET_CURRENT_STORY: Lp,
    SET_FILTER: mk,
    SET_GLOBALS: Jv,
    SET_INDEX: yk,
    SET_STORIES: hk,
    SHARED_STATE_CHANGED: gk,
    SHARED_STATE_SET: bk,
    STORIES_COLLAPSE_ALL: vk,
    STORIES_EXPAND_ALL: Tk,
    STORY_ARGS_UPDATED: Uv,
    STORY_CHANGED: Vv,
    STORY_ERRORED: Hv,
    STORY_INDEX_INVALIDATED: zv,
    STORY_MISSING: wu,
    STORY_PREPARED: Gv,
    STORY_RENDER_PHASE_CHANGED: xn,
    STORY_RENDERED: ma,
    STORY_FINISHED: Su,
    STORY_SPECIFIED: Wv,
    STORY_THREW_EXCEPTION: Kv,
    STORY_UNCHANGED: Yv,
    STORY_HOT_UPDATED: Xv,
    UPDATE_GLOBALS: Fp,
    UPDATE_QUERY_PARAMS: Qv,
    UPDATE_STORY_ARGS: Bp,
    REQUEST_WHATS_NEW_DATA: Ek,
    RESULT_WHATS_NEW_DATA: wk,
    SET_WHATS_NEW_CACHE: Sk,
    TOGGLE_WHATS_NEW_NOTIFICATIONS: _k,
    TELEMETRY_ERROR: Zv,
    SAVE_STORY_REQUEST: Ak,
    SAVE_STORY_RESPONSE: Rk,
    ARGTYPES_INFO_REQUEST: eT,
    ARGTYPES_INFO_RESPONSE: _u,
    OPEN_IN_EDITOR_REQUEST: xk,
    OPEN_IN_EDITOR_RESPONSE: Pk,
  } = jp,
  tT = {};
St(tT, { global: () => te });
var te = (() => {
    let e;
    return (
      typeof window < 'u'
        ? (e = window)
        : typeof globalThis < 'u'
          ? (e = globalThis)
          : typeof global < 'u'
            ? (e = global)
            : typeof self < 'u'
              ? (e = self)
              : (e = {}),
      e
    );
  })(),
  rT = {
    '@storybook/global': '__STORYBOOK_MODULE_GLOBAL__',
    'storybook/test': '__STORYBOOK_MODULE_TEST__',
    'storybook/actions': '__STORYBOOK_MODULE_ACTIONS__',
    'storybook/preview-api': '__STORYBOOK_MODULE_PREVIEW_API__',
    'storybook/internal/channels': '__STORYBOOK_MODULE_CHANNELS__',
    'storybook/internal/client-logger': '__STORYBOOK_MODULE_CLIENT_LOGGER__',
    'storybook/internal/core-events': '__STORYBOOK_MODULE_CORE_EVENTS__',
    'storybook/internal/preview-errors': '__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__',
    'storybook/internal/types': '__STORYBOOK_MODULE_TYPES__',
    'storybook/internal/preview-api': '__STORYBOOK_MODULE_PREVIEW_API__',
  },
  Ok = Object.keys(rT),
  nT = {};
St(nT, {
  Channel: () => gl,
  HEARTBEAT_INTERVAL: () => mE,
  HEARTBEAT_MAX_LATENCY: () => yE,
  PostMessageTransport: () => fE,
  WebsocketTransport: () => gE,
  createBrowserChannel: () => bE,
  default: () => eL,
});
function ve(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = Array.from(typeof e == 'string' ? [e] : e);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '');
  var o = n.reduce(function (c, d) {
    var u = d.match(/\n([\t ]+|(?!\s).)/g);
    return u
      ? c.concat(
          u.map(function (p) {
            var f, m;
            return (m = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !==
              null && m !== void 0
              ? m
              : 0;
          }),
        )
      : c;
  }, []);
  if (o.length) {
    var i = new RegExp(
      `
[	 ]{` +
        Math.min.apply(Math, o) +
        '}',
      'g',
    );
    n = n.map(function (c) {
      return c.replace(
        i,
        `
`,
      );
    });
  }
  n[0] = n[0].replace(/^\r?\n/, '');
  var a = n[0];
  return (
    t.forEach(function (c, d) {
      var u = a.match(/(?:^|\n)( *)$/),
        p = u ? u[1] : '',
        f = c;
      (typeof c == 'string' &&
        c.includes(`
`) &&
        (f = String(c)
          .split(
            `
`,
          )
          .map(function (m, h) {
            return h === 0 ? m : '' + p + m;
          }).join(`
`)),
        (a += f + n[d + 1]));
    }),
    a
  );
}
s(ve, 'dedent');
var pg = new Map(),
  Ck = 'UNIVERSAL_STORE:',
  jt = { PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED' },
  en = class fe {
    constructor(t, r) {
      if (
        ((this.debugging = !1),
        (this.listeners = new Map([['*', new Set()]])),
        (this.getState = s(
          () => (this.debug('getState', { state: this.state }), this.state),
          'getState',
        )),
        (this.subscribe = s((n, o) => {
          const i = typeof n == 'function',
            a = i ? '*' : n,
            c = i ? n : o;
          if ((this.debug('subscribe', { eventType: a, listener: c }), !c))
            throw new TypeError(
              `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`,
            );
          return (
            this.listeners.has(a) || this.listeners.set(a, new Set()),
            this.listeners.get(a).add(c),
            () => {
              (this.debug('unsubscribe', { eventType: a, listener: c }),
                this.listeners.has(a) &&
                  (this.listeners.get(a).delete(c),
                  this.listeners.get(a)?.size === 0 && this.listeners.delete(a)));
            }
          );
        }, 'subscribe')),
        (this.send = s((n) => {
          if ((this.debug('send', { event: n }), this.status !== fe.Status.READY))
            throw new TypeError(ve`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify({ event: n, id: this.id, actor: this.actor, environment: this.environment }, null, 2)}`);
          (this.emitToListeners(n, { actor: this.actor }),
            this.emitToChannel(n, { actor: this.actor }));
        }, 'send')),
        (this.debugging = t.debug ?? !1),
        !fe.isInternalConstructing)
      )
        throw new TypeError(
          'UniversalStore is not constructable - use UniversalStore.create() instead',
        );
      if (
        ((fe.isInternalConstructing = !1),
        (this.id = t.id),
        (this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2)),
        (this.actorType = t.leader ? fe.ActorType.LEADER : fe.ActorType.FOLLOWER),
        (this.state = t.initialState),
        (this.channelEventName = `${Ck}${this.id}`),
        this.debug('constructor', {
          options: t,
          environmentOverrides: r,
          channelEventName: this.channelEventName,
        }),
        this.actor.type === fe.ActorType.LEADER)
      )
        this.syncing = { state: jt.RESOLVED, promise: Promise.resolve() };
      else {
        let n, o;
        const i = new Promise((a, c) => {
          ((n = s(() => {
            this.syncing.state === jt.PENDING && ((this.syncing.state = jt.RESOLVED), a());
          }, 'syncingResolve')),
            (o = s((d) => {
              this.syncing.state === jt.PENDING && ((this.syncing.state = jt.REJECTED), c(d));
            }, 'syncingReject')));
        });
        this.syncing = { state: jt.PENDING, promise: i, resolve: n, reject: o };
      }
      ((this.getState = this.getState.bind(this)),
        (this.setState = this.setState.bind(this)),
        (this.subscribe = this.subscribe.bind(this)),
        (this.onStateChange = this.onStateChange.bind(this)),
        (this.send = this.send.bind(this)),
        (this.emitToChannel = this.emitToChannel.bind(this)),
        (this.prepareThis = this.prepareThis.bind(this)),
        (this.emitToListeners = this.emitToListeners.bind(this)),
        (this.handleChannelEvents = this.handleChannelEvents.bind(this)),
        (this.debug = this.debug.bind(this)),
        (this.channel = r?.channel ?? fe.preparation.channel),
        (this.environment = r?.environment ?? fe.preparation.environment),
        this.channel && this.environment
          ? (fe.preparation.resolve({ channel: this.channel, environment: this.environment }),
            this.prepareThis({ channel: this.channel, environment: this.environment }))
          : fe.preparation.promise.then(this.prepareThis));
    }
    static setupPreparationPromise() {
      let t, r;
      const n = new Promise((o, i) => {
        ((t = s((a) => {
          o(a);
        }, 'resolveRef')),
          (r = s((...a) => {
            i(a);
          }, 'rejectRef')));
      });
      fe.preparation = { resolve: t, reject: r, promise: n };
    }
    get actor() {
      return Object.freeze({
        id: this.actorId,
        type: this.actorType,
        environment: this.environment ?? fe.Environment.UNKNOWN,
      });
    }
    get status() {
      if (!this.channel || !this.environment) return fe.Status.UNPREPARED;
      switch (this.syncing?.state) {
        case jt.PENDING:
        case void 0:
          return fe.Status.SYNCING;
        case jt.REJECTED:
          return fe.Status.ERROR;
        case jt.RESOLVED:
        default:
          return fe.Status.READY;
      }
    }
    untilReady() {
      return Promise.all([fe.preparation.promise, this.syncing?.promise]);
    }
    static create(t) {
      if (!t || typeof t?.id != 'string')
        throw new TypeError('id is required and must be a string, when creating a UniversalStore');
      t.debug &&
        console.debug(
          ve`[UniversalStore]
        create`,
          { options: t },
        );
      const r = pg.get(t.id);
      if (r)
        return (
          console.warn(ve`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`),
          r
        );
      fe.isInternalConstructing = !0;
      const n = new fe(t);
      return (pg.set(t.id, n), n);
    }
    static __prepare(t, r) {
      ((fe.preparation.channel = t),
        (fe.preparation.environment = r),
        fe.preparation.resolve({ channel: t, environment: r }));
    }
    setState(t) {
      const r = this.state,
        n = typeof t == 'function' ? t(r) : t;
      if (
        (this.debug('setState', { newState: n, previousState: r, updater: t }),
        this.status !== fe.Status.READY)
      )
        throw new TypeError(ve`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify({ newState: n, id: this.id, actor: this.actor, environment: this.environment }, null, 2)}`);
      this.state = n;
      const o = { type: fe.InternalEventType.SET_STATE, payload: { state: n, previousState: r } };
      (this.emitToChannel(o, { actor: this.actor }),
        this.emitToListeners(o, { actor: this.actor }));
    }
    onStateChange(t) {
      return (
        this.debug('onStateChange', { listener: t }),
        this.subscribe(fe.InternalEventType.SET_STATE, ({ payload: r }, n) => {
          t(r.state, r.previousState, n);
        })
      );
    }
    emitToChannel(t, r) {
      (this.debug('emitToChannel', { event: t, eventInfo: r, channel: !!this.channel }),
        this.channel?.emit(this.channelEventName, { event: t, eventInfo: r }));
    }
    prepareThis({ channel: t, environment: r }) {
      ((this.channel = t),
        (this.environment = r),
        this.debug('prepared', { channel: !!t, environment: r }),
        this.channel.on(this.channelEventName, this.handleChannelEvents),
        this.actor.type === fe.ActorType.LEADER
          ? this.emitToChannel({ type: fe.InternalEventType.LEADER_CREATED }, { actor: this.actor })
          : (this.emitToChannel(
              { type: fe.InternalEventType.FOLLOWER_CREATED },
              { actor: this.actor },
            ),
            this.emitToChannel(
              { type: fe.InternalEventType.EXISTING_STATE_REQUEST },
              { actor: this.actor },
            ),
            setTimeout(() => {
              this.syncing.reject(
                new TypeError(
                  `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`,
                ),
              );
            }, 1e3)));
    }
    emitToListeners(t, r) {
      const n = this.listeners.get(t.type),
        o = this.listeners.get('*');
      (this.debug('emitToListeners', {
        event: t,
        eventInfo: r,
        eventTypeListeners: n,
        everythingListeners: o,
      }),
        [...(n ?? []), ...(o ?? [])].forEach((i) => i(t, r)));
    }
    handleChannelEvents(t) {
      const { event: r, eventInfo: n } = t;
      if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
        this.debug('handleChannelEvents: Ignoring event from self', { channelEvent: t });
        return;
      } else if (
        this.syncing?.state === jt.PENDING &&
        r.type !== fe.InternalEventType.EXISTING_STATE_RESPONSE
      ) {
        this.debug('handleChannelEvents: Ignoring event while syncing', { channelEvent: t });
        return;
      }
      if (
        (this.debug('handleChannelEvents', { channelEvent: t }),
        this.actor.type === fe.ActorType.LEADER)
      ) {
        let o = !0;
        switch (r.type) {
          case fe.InternalEventType.EXISTING_STATE_REQUEST:
            o = !1;
            const i = { type: fe.InternalEventType.EXISTING_STATE_RESPONSE, payload: this.state };
            (this.debug('handleChannelEvents: responding to existing state request', {
              responseEvent: i,
            }),
              this.emitToChannel(i, { actor: this.actor }),
              this.emitToListeners(i, { actor: this.actor }));
            break;
          case fe.InternalEventType.LEADER_CREATED:
            ((o = !1),
              (this.syncing.state = jt.REJECTED),
              this.debug('handleChannelEvents: erroring due to second leader being created', {
                event: r,
              }),
              console.error(ve`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`));
            break;
        }
        o &&
          (this.debug('handleChannelEvents: forwarding event', { channelEvent: t }),
          this.emitToChannel(r, { actor: n.actor, forwardingActor: this.actor }));
      }
      if (this.actor.type === fe.ActorType.FOLLOWER)
        switch (r.type) {
          case fe.InternalEventType.EXISTING_STATE_RESPONSE:
            if (
              (this.debug(
                "handleChannelEvents: Setting state from leader's existing state response",
                { event: r },
              ),
              this.syncing?.state !== jt.PENDING)
            )
              break;
            this.syncing.resolve?.();
            const o = {
              type: fe.InternalEventType.SET_STATE,
              payload: { state: r.payload, previousState: this.state },
            };
            ((this.state = r.payload), this.emitToListeners(o, n));
            break;
        }
      switch (r.type) {
        case fe.InternalEventType.SET_STATE:
          (this.debug('handleChannelEvents: Setting state', { event: r }),
            (this.state = r.payload.state));
          break;
      }
      this.emitToListeners(r, { actor: n.actor });
    }
    debug(t, r) {
      this.debugging &&
        console.debug(
          ve`[UniversalStore::${this.id}::${this.environment ?? fe.Environment.UNKNOWN}]
        ${t}`,
          JSON.stringify(
            { data: r, actor: this.actor, state: this.state, status: this.status },
            null,
            2,
          ),
        );
    }
    static __reset() {
      (fe.preparation.reject(new Error('reset')),
        fe.setupPreparationPromise(),
        (fe.isInternalConstructing = !1));
    }
  };
s(en, 'UniversalStore');
en.ActorType = { LEADER: 'LEADER', FOLLOWER: 'FOLLOWER' };
en.Environment = {
  SERVER: 'SERVER',
  MANAGER: 'MANAGER',
  PREVIEW: 'PREVIEW',
  UNKNOWN: 'UNKNOWN',
  MOCK: 'MOCK',
};
en.InternalEventType = {
  EXISTING_STATE_REQUEST: '__EXISTING_STATE_REQUEST',
  EXISTING_STATE_RESPONSE: '__EXISTING_STATE_RESPONSE',
  SET_STATE: '__SET_STATE',
  LEADER_CREATED: '__LEADER_CREATED',
  FOLLOWER_CREATED: '__FOLLOWER_CREATED',
};
en.Status = { UNPREPARED: 'UNPREPARED', SYNCING: 'SYNCING', READY: 'READY', ERROR: 'ERROR' };
en.isInternalConstructing = !1;
en.setupPreparationPromise();
var zc = en,
  Ik = s((e) => e.transports !== void 0, 'isMulti'),
  Nk = s(() => Math.random().toString(16).slice(2), 'generateRandomId'),
  oT = class {
    constructor(t = {}) {
      ((this.sender = Nk()),
        (this.events = {}),
        (this.data = {}),
        (this.transports = []),
        (this.isAsync = t.async || !1),
        Ik(t)
          ? ((this.transports = t.transports || []),
            this.transports.forEach((r) => {
              r.setHandler((n) => this.handleEvent(n));
            }))
          : (this.transports = t.transport ? [t.transport] : []),
        this.transports.forEach((r) => {
          r.setHandler((n) => this.handleEvent(n));
        }));
    }
    get hasTransport() {
      return this.transports.length > 0;
    }
    addListener(t, r) {
      ((this.events[t] = this.events[t] || []), this.events[t].push(r));
    }
    emit(t, ...r) {
      const n = { type: t, args: r, from: this.sender };
      let o = {};
      r.length >= 1 && r[0] && r[0].options && (o = r[0].options);
      const i = s(() => {
        (this.transports.forEach((a) => {
          a.send(n, o);
        }),
          this.handleEvent(n));
      }, 'handler');
      this.isAsync ? setImmediate(i) : i();
    }
    last(t) {
      return this.data[t];
    }
    eventNames() {
      return Object.keys(this.events);
    }
    listenerCount(t) {
      const r = this.listeners(t);
      return r ? r.length : 0;
    }
    listeners(t) {
      return this.events[t] || void 0;
    }
    once(t, r) {
      const n = this.onceListener(t, r);
      this.addListener(t, n);
    }
    removeAllListeners(t) {
      t ? this.events[t] && delete this.events[t] : (this.events = {});
    }
    removeListener(t, r) {
      const n = this.listeners(t);
      n && (this.events[t] = n.filter((o) => o !== r));
    }
    on(t, r) {
      this.addListener(t, r);
    }
    off(t, r) {
      this.removeListener(t, r);
    }
    handleEvent(t) {
      const r = this.listeners(t.type);
      (r &&
        r.length &&
        r.forEach((n) => {
          n.apply(t, t.args);
        }),
        (this.data[t.type] = t.args));
    }
    onceListener(t, r) {
      const n = s((...o) => (this.removeListener(t, n), r(...o)), 'onceListener');
      return n;
    }
  };
s(oT, 'Channel');
var gl = oT,
  sT = {};
St(sT, { deprecate: () => Jp, logger: () => ke, once: () => Ve, pretty: () => It });
var { LOGLEVEL: qk } = te,
  Dr = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 },
  Mk = qk,
  zn = Dr[Mk] || Dr.info,
  ke = {
    trace: s((e, ...t) => {
      zn <= Dr.trace && console.trace(e, ...t);
    }, 'trace'),
    debug: s((e, ...t) => {
      zn <= Dr.debug && console.debug(e, ...t);
    }, 'debug'),
    info: s((e, ...t) => {
      zn <= Dr.info && console.info(e, ...t);
    }, 'info'),
    warn: s((e, ...t) => {
      zn <= Dr.warn && console.warn(e, ...t);
    }, 'warn'),
    error: s((e, ...t) => {
      zn <= Dr.error && console.error(e, ...t);
    }, 'error'),
    log: s((e, ...t) => {
      zn < Dr.silent && console.log(e, ...t);
    }, 'log'),
  },
  Au = new Set(),
  Ve = s(
    (e) =>
      (t, ...r) => {
        if (!Au.has(t)) return (Au.add(t), ke[e](t, ...r));
      },
    'once',
  );
Ve.clear = () => Au.clear();
Ve.trace = Ve('trace');
Ve.debug = Ve('debug');
Ve.info = Ve('info');
Ve.warn = Ve('warn');
Ve.error = Ve('error');
Ve.log = Ve('log');
var Jp = Ve('warn'),
  It = s(
    (e) =>
      (...t) => {
        const r = [];
        if (t.length) {
          const n = /<span\s+style=(['"])([^'"]*)\1\s*>/gi,
            o = /<\/span>/gi;
          let i;
          for (r.push(t[0].replace(n, '%c').replace(o, '%c')); (i = n.exec(t[0])); )
            (r.push(i[2]), r.push(''));
          for (let a = 1; a < t.length; a++) r.push(t[a]);
        }
        ke[e].apply(ke, r);
      },
    'pretty',
  );
It.trace = It('trace');
It.debug = It('debug');
It.info = It('info');
It.warn = It('warn');
It.error = It('error');
var jk = Object.create,
  iT = Object.defineProperty,
  $k = Object.getOwnPropertyDescriptor,
  aT = Object.getOwnPropertyNames,
  kk = Object.getPrototypeOf,
  Dk = Object.prototype.hasOwnProperty,
  ge = s(
    (e, t) =>
      s(function () {
        return (t || (0, e[aT(e)[0]])((t = { exports: {} }).exports, t), t.exports);
      }, '__require'),
    '__commonJS',
  ),
  Lk = s((e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let o of aT(t))
        !Dk.call(e, o) &&
          o !== r &&
          iT(e, o, { get: s(() => t[o], 'get'), enumerable: !(n = $k(t, o)) || n.enumerable });
    return e;
  }, '__copyProps'),
  Up = s(
    (e, t, r) => (
      (r = e != null ? jk(kk(e)) : {}),
      Lk(t || !e || !e.__esModule ? iT(r, 'default', { value: e, enumerable: !0 }) : r, e)
    ),
    '__toESM',
  ),
  Fk = [
    'bubbles',
    'cancelBubble',
    'cancelable',
    'composed',
    'currentTarget',
    'defaultPrevented',
    'eventPhase',
    'isTrusted',
    'returnValue',
    'srcElement',
    'target',
    'timeStamp',
    'type',
  ],
  Bk = ['detail'];
function lT(e) {
  const t = Fk.filter((r) => e[r] !== void 0).reduce((r, n) => ((r[n] = e[n]), r), {});
  if (e instanceof CustomEvent) for (const r of Bk.filter((n) => e[n] !== void 0)) t[r] = e[r];
  return t;
}
s(lT, 'extractEventHiddenProperties');
var cT = ge({
    'node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js'(e, t) {
      t.exports = Object;
    },
  }),
  Jk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js'(e, t) {
      t.exports = Error;
    },
  }),
  Uk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js'(e, t) {
      t.exports = EvalError;
    },
  }),
  Vk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js'(e, t) {
      t.exports = RangeError;
    },
  }),
  Hk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js'(e, t) {
      t.exports = ReferenceError;
    },
  }),
  zk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js'(e, t) {
      t.exports = SyntaxError;
    },
  }),
  Vp = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js'(e, t) {
      t.exports = TypeError;
    },
  }),
  Gk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js'(e, t) {
      t.exports = URIError;
    },
  }),
  Wk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js'(e, t) {
      t.exports = Math.abs;
    },
  }),
  Kk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js'(e, t) {
      t.exports = Math.floor;
    },
  }),
  Yk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js'(e, t) {
      t.exports = Math.max;
    },
  }),
  Xk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js'(e, t) {
      t.exports = Math.min;
    },
  }),
  Qk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js'(e, t) {
      t.exports = Math.pow;
    },
  }),
  Zk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js'(e, t) {
      t.exports = Math.round;
    },
  }),
  e1 = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js'(e, t) {
      t.exports =
        Number.isNaN ||
        s(function (n) {
          return n !== n;
        }, 'isNaN2');
    },
  }),
  t1 = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js'(e, t) {
      var r = e1();
      t.exports = s(function (o) {
        return r(o) || o === 0 ? o : o < 0 ? -1 : 1;
      }, 'sign');
    },
  }),
  r1 = ge({
    'node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js'(e, t) {
      t.exports = Object.getOwnPropertyDescriptor;
    },
  }),
  Hp = ge({
    'node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js'(e, t) {
      var r = r1();
      if (r)
        try {
          r([], 'length');
        } catch {
          r = null;
        }
      t.exports = r;
    },
  }),
  n1 = ge({
    'node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js'(e, t) {
      var r = Object.defineProperty || !1;
      if (r)
        try {
          r({}, 'a', { value: 1 });
        } catch {
          r = !1;
        }
      t.exports = r;
    },
  }),
  uT = ge({
    'node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js'(e, t) {
      t.exports = s(function () {
        if (typeof Symbol != 'function' || typeof Object.getOwnPropertySymbols != 'function')
          return !1;
        if (typeof Symbol.iterator == 'symbol') return !0;
        var n = {},
          o = Symbol('test'),
          i = Object(o);
        if (
          typeof o == 'string' ||
          Object.prototype.toString.call(o) !== '[object Symbol]' ||
          Object.prototype.toString.call(i) !== '[object Symbol]'
        )
          return !1;
        var a = 42;
        n[o] = a;
        for (var c in n) return !1;
        if (
          (typeof Object.keys == 'function' && Object.keys(n).length !== 0) ||
          (typeof Object.getOwnPropertyNames == 'function' &&
            Object.getOwnPropertyNames(n).length !== 0)
        )
          return !1;
        var d = Object.getOwnPropertySymbols(n);
        if (d.length !== 1 || d[0] !== o || !Object.prototype.propertyIsEnumerable.call(n, o))
          return !1;
        if (typeof Object.getOwnPropertyDescriptor == 'function') {
          var u = Object.getOwnPropertyDescriptor(n, o);
          if (u.value !== a || u.enumerable !== !0) return !1;
        }
        return !0;
      }, 'hasSymbols');
    },
  }),
  dT = ge({
    'node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js'(e, t) {
      var r = typeof Symbol < 'u' && Symbol,
        n = uT();
      t.exports = s(function () {
        return typeof r != 'function' ||
          typeof Symbol != 'function' ||
          typeof r('foo') != 'symbol' ||
          typeof Symbol('bar') != 'symbol'
          ? !1
          : n();
      }, 'hasNativeSymbols');
    },
  }),
  pT = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js'(e, t) {
      t.exports = (typeof Reflect < 'u' && Reflect.getPrototypeOf) || null;
    },
  }),
  fT = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js'(e, t) {
      var r = cT();
      t.exports = r.getPrototypeOf || null;
    },
  }),
  o1 = ge({
    'node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js'(e, t) {
      var r = 'Function.prototype.bind called on incompatible ',
        n = Object.prototype.toString,
        o = Math.max,
        i = '[object Function]',
        a = s(function (p, f) {
          for (var m = [], h = 0; h < p.length; h += 1) m[h] = p[h];
          for (var g = 0; g < f.length; g += 1) m[g + p.length] = f[g];
          return m;
        }, 'concatty2'),
        c = s(function (p, f) {
          for (var m = [], h = f || 0, g = 0; h < p.length; h += 1, g += 1) m[g] = p[h];
          return m;
        }, 'slicy2'),
        d = s(function (u, p) {
          for (var f = '', m = 0; m < u.length; m += 1) ((f += u[m]), m + 1 < u.length && (f += p));
          return f;
        }, 'joiny');
      t.exports = s(function (p) {
        var f = this;
        if (typeof f != 'function' || n.apply(f) !== i) throw new TypeError(r + f);
        for (
          var m = c(arguments, 1),
            h,
            g = s(function () {
              if (this instanceof h) {
                var R = f.apply(this, a(m, arguments));
                return Object(R) === R ? R : this;
              }
              return f.apply(p, a(m, arguments));
            }, 'binder'),
            v = o(0, f.length - m.length),
            E = [],
            b = 0;
          b < v;
          b++
        )
          E[b] = '$' + b;
        if (
          ((h = Function(
            'binder',
            'return function (' + d(E, ',') + '){ return binder.apply(this,arguments); }',
          )(g)),
          f.prototype)
        ) {
          var S = s(function () {}, 'Empty2');
          ((S.prototype = f.prototype), (h.prototype = new S()), (S.prototype = null));
        }
        return h;
      }, 'bind');
    },
  }),
  bl = ge({
    'node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js'(e, t) {
      var r = o1();
      t.exports = Function.prototype.bind || r;
    },
  }),
  zp = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js'(
      e,
      t,
    ) {
      t.exports = Function.prototype.call;
    },
  }),
  mT = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js'(
      e,
      t,
    ) {
      t.exports = Function.prototype.apply;
    },
  }),
  s1 = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js'(
      e,
      t,
    ) {
      t.exports = typeof Reflect < 'u' && Reflect && Reflect.apply;
    },
  }),
  i1 = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js'(
      e,
      t,
    ) {
      var r = bl(),
        n = mT(),
        o = zp(),
        i = s1();
      t.exports = i || r.call(o, n);
    },
  }),
  yT = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js'(
      e,
      t,
    ) {
      var r = bl(),
        n = Vp(),
        o = zp(),
        i = i1();
      t.exports = s(function (c) {
        if (c.length < 1 || typeof c[0] != 'function') throw new n('a function is required');
        return i(r, o, c);
      }, 'callBindBasic');
    },
  }),
  a1 = ge({
    'node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js'(e, t) {
      var r = yT(),
        n = Hp(),
        o;
      try {
        o = [].__proto__ === Array.prototype;
      } catch (d) {
        if (!d || typeof d != 'object' || !('code' in d) || d.code !== 'ERR_PROTO_ACCESS') throw d;
      }
      var i = !!o && n && n(Object.prototype, '__proto__'),
        a = Object,
        c = a.getPrototypeOf;
      t.exports =
        i && typeof i.get == 'function'
          ? r([i.get])
          : typeof c == 'function'
            ? s(function (u) {
                return c(u == null ? u : a(u));
              }, 'getDunder')
            : !1;
    },
  }),
  l1 = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js'(e, t) {
      var r = pT(),
        n = fT(),
        o = a1();
      t.exports = r
        ? s(function (a) {
            return r(a);
          }, 'getProto')
        : n
          ? s(function (a) {
              if (!a || (typeof a != 'object' && typeof a != 'function'))
                throw new TypeError('getProto: not an object');
              return n(a);
            }, 'getProto')
          : o
            ? s(function (a) {
                return o(a);
              }, 'getProto')
            : null;
    },
  }),
  hT = ge({
    'node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js'(e, t) {
      var r = Function.prototype.call,
        n = Object.prototype.hasOwnProperty,
        o = bl();
      t.exports = o.call(r, n);
    },
  }),
  c1 = ge({
    'node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js'(e, t) {
      var r,
        n = cT(),
        o = Jk(),
        i = Uk(),
        a = Vk(),
        c = Hk(),
        d = zk(),
        u = Vp(),
        p = Gk(),
        f = Wk(),
        m = Kk(),
        h = Yk(),
        g = Xk(),
        v = Qk(),
        E = Zk(),
        b = t1(),
        S = Function,
        R = s(function (J) {
          try {
            return S('"use strict"; return (' + J + ').constructor;')();
          } catch {}
        }, 'getEvalledConstructor'),
        I = Hp(),
        q = n1(),
        P = s(function () {
          throw new u();
        }, 'throwTypeError'),
        A = I
          ? (function () {
              try {
                return (arguments.callee, P);
              } catch {
                try {
                  return I(arguments, 'callee').get;
                } catch {
                  return P;
                }
              }
            })()
          : P,
        w = dT()(),
        _ = l1(),
        $ = fT(),
        N = pT(),
        V = mT(),
        H = zp(),
        x = {},
        D = typeof Uint8Array > 'u' || !_ ? r : _(Uint8Array),
        F = {
          __proto__: null,
          '%AggregateError%': typeof AggregateError > 'u' ? r : AggregateError,
          '%Array%': Array,
          '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? r : ArrayBuffer,
          '%ArrayIteratorPrototype%': w && _ ? _([][Symbol.iterator]()) : r,
          '%AsyncFromSyncIteratorPrototype%': r,
          '%AsyncFunction%': x,
          '%AsyncGenerator%': x,
          '%AsyncGeneratorFunction%': x,
          '%AsyncIteratorPrototype%': x,
          '%Atomics%': typeof Atomics > 'u' ? r : Atomics,
          '%BigInt%': typeof BigInt > 'u' ? r : BigInt,
          '%BigInt64Array%': typeof BigInt64Array > 'u' ? r : BigInt64Array,
          '%BigUint64Array%': typeof BigUint64Array > 'u' ? r : BigUint64Array,
          '%Boolean%': Boolean,
          '%DataView%': typeof DataView > 'u' ? r : DataView,
          '%Date%': Date,
          '%decodeURI%': decodeURI,
          '%decodeURIComponent%': decodeURIComponent,
          '%encodeURI%': encodeURI,
          '%encodeURIComponent%': encodeURIComponent,
          '%Error%': o,
          '%eval%': eval,
          '%EvalError%': i,
          '%Float16Array%': typeof Float16Array > 'u' ? r : Float16Array,
          '%Float32Array%': typeof Float32Array > 'u' ? r : Float32Array,
          '%Float64Array%': typeof Float64Array > 'u' ? r : Float64Array,
          '%FinalizationRegistry%': typeof FinalizationRegistry > 'u' ? r : FinalizationRegistry,
          '%Function%': S,
          '%GeneratorFunction%': x,
          '%Int8Array%': typeof Int8Array > 'u' ? r : Int8Array,
          '%Int16Array%': typeof Int16Array > 'u' ? r : Int16Array,
          '%Int32Array%': typeof Int32Array > 'u' ? r : Int32Array,
          '%isFinite%': isFinite,
          '%isNaN%': isNaN,
          '%IteratorPrototype%': w && _ ? _(_([][Symbol.iterator]())) : r,
          '%JSON%': typeof JSON == 'object' ? JSON : r,
          '%Map%': typeof Map > 'u' ? r : Map,
          '%MapIteratorPrototype%':
            typeof Map > 'u' || !w || !_ ? r : _(new Map()[Symbol.iterator]()),
          '%Math%': Math,
          '%Number%': Number,
          '%Object%': n,
          '%Object.getOwnPropertyDescriptor%': I,
          '%parseFloat%': parseFloat,
          '%parseInt%': parseInt,
          '%Promise%': typeof Promise > 'u' ? r : Promise,
          '%Proxy%': typeof Proxy > 'u' ? r : Proxy,
          '%RangeError%': a,
          '%ReferenceError%': c,
          '%Reflect%': typeof Reflect > 'u' ? r : Reflect,
          '%RegExp%': RegExp,
          '%Set%': typeof Set > 'u' ? r : Set,
          '%SetIteratorPrototype%':
            typeof Set > 'u' || !w || !_ ? r : _(new Set()[Symbol.iterator]()),
          '%SharedArrayBuffer%': typeof SharedArrayBuffer > 'u' ? r : SharedArrayBuffer,
          '%String%': String,
          '%StringIteratorPrototype%': w && _ ? _(''[Symbol.iterator]()) : r,
          '%Symbol%': w ? Symbol : r,
          '%SyntaxError%': d,
          '%ThrowTypeError%': A,
          '%TypedArray%': D,
          '%TypeError%': u,
          '%Uint8Array%': typeof Uint8Array > 'u' ? r : Uint8Array,
          '%Uint8ClampedArray%': typeof Uint8ClampedArray > 'u' ? r : Uint8ClampedArray,
          '%Uint16Array%': typeof Uint16Array > 'u' ? r : Uint16Array,
          '%Uint32Array%': typeof Uint32Array > 'u' ? r : Uint32Array,
          '%URIError%': p,
          '%WeakMap%': typeof WeakMap > 'u' ? r : WeakMap,
          '%WeakRef%': typeof WeakRef > 'u' ? r : WeakRef,
          '%WeakSet%': typeof WeakSet > 'u' ? r : WeakSet,
          '%Function.prototype.call%': H,
          '%Function.prototype.apply%': V,
          '%Object.defineProperty%': q,
          '%Object.getPrototypeOf%': $,
          '%Math.abs%': f,
          '%Math.floor%': m,
          '%Math.max%': h,
          '%Math.min%': g,
          '%Math.pow%': v,
          '%Math.round%': E,
          '%Math.sign%': b,
          '%Reflect.getPrototypeOf%': N,
        };
      if (_)
        try {
          null.error;
        } catch (J) {
          ((k = _(_(J))), (F['%Error.prototype%'] = k));
        }
      var k,
        K = s(function J(Q) {
          var re;
          if (Q === '%AsyncFunction%') re = R('async function () {}');
          else if (Q === '%GeneratorFunction%') re = R('function* () {}');
          else if (Q === '%AsyncGeneratorFunction%') re = R('async function* () {}');
          else if (Q === '%AsyncGenerator%') {
            var oe = J('%AsyncGeneratorFunction%');
            oe && (re = oe.prototype);
          } else if (Q === '%AsyncIteratorPrototype%') {
            var ne = J('%AsyncGenerator%');
            ne && _ && (re = _(ne.prototype));
          }
          return ((F[Q] = re), re);
        }, 'doEval2'),
        X = {
          __proto__: null,
          '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
          '%ArrayPrototype%': ['Array', 'prototype'],
          '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
          '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
          '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
          '%ArrayProto_values%': ['Array', 'prototype', 'values'],
          '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
          '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
          '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
          '%BooleanPrototype%': ['Boolean', 'prototype'],
          '%DataViewPrototype%': ['DataView', 'prototype'],
          '%DatePrototype%': ['Date', 'prototype'],
          '%ErrorPrototype%': ['Error', 'prototype'],
          '%EvalErrorPrototype%': ['EvalError', 'prototype'],
          '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
          '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
          '%FunctionPrototype%': ['Function', 'prototype'],
          '%Generator%': ['GeneratorFunction', 'prototype'],
          '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
          '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
          '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
          '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
          '%JSONParse%': ['JSON', 'parse'],
          '%JSONStringify%': ['JSON', 'stringify'],
          '%MapPrototype%': ['Map', 'prototype'],
          '%NumberPrototype%': ['Number', 'prototype'],
          '%ObjectPrototype%': ['Object', 'prototype'],
          '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
          '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
          '%PromisePrototype%': ['Promise', 'prototype'],
          '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
          '%Promise_all%': ['Promise', 'all'],
          '%Promise_reject%': ['Promise', 'reject'],
          '%Promise_resolve%': ['Promise', 'resolve'],
          '%RangeErrorPrototype%': ['RangeError', 'prototype'],
          '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
          '%RegExpPrototype%': ['RegExp', 'prototype'],
          '%SetPrototype%': ['Set', 'prototype'],
          '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
          '%StringPrototype%': ['String', 'prototype'],
          '%SymbolPrototype%': ['Symbol', 'prototype'],
          '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
          '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
          '%TypeErrorPrototype%': ['TypeError', 'prototype'],
          '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
          '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
          '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
          '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
          '%URIErrorPrototype%': ['URIError', 'prototype'],
          '%WeakMapPrototype%': ['WeakMap', 'prototype'],
          '%WeakSetPrototype%': ['WeakSet', 'prototype'],
        },
        se = bl(),
        ie = hT(),
        W = se.call(H, Array.prototype.concat),
        ae = se.call(V, Array.prototype.splice),
        be = se.call(H, String.prototype.replace),
        ue = se.call(H, String.prototype.slice),
        ee = se.call(H, RegExp.prototype.exec),
        xe =
          /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        Pe = /\\(\\)?/g,
        He = s(function (Q) {
          var re = ue(Q, 0, 1),
            oe = ue(Q, -1);
          if (re === '%' && oe !== '%')
            throw new d('invalid intrinsic syntax, expected closing `%`');
          if (oe === '%' && re !== '%')
            throw new d('invalid intrinsic syntax, expected opening `%`');
          var ne = [];
          return (
            be(Q, xe, function (de, ye, pe, Fe) {
              ne[ne.length] = pe ? be(Fe, Pe, '$1') : ye || de;
            }),
            ne
          );
        }, 'stringToPath3'),
        Ke = s(function (Q, re) {
          var oe = Q,
            ne;
          if ((ie(X, oe) && ((ne = X[oe]), (oe = '%' + ne[0] + '%')), ie(F, oe))) {
            var de = F[oe];
            if ((de === x && (de = K(oe)), typeof de > 'u' && !re))
              throw new u(
                'intrinsic ' + Q + ' exists, but is not available. Please file an issue!',
              );
            return { alias: ne, name: oe, value: de };
          }
          throw new d('intrinsic ' + Q + ' does not exist!');
        }, 'getBaseIntrinsic2');
      t.exports = s(function (Q, re) {
        if (typeof Q != 'string' || Q.length === 0)
          throw new u('intrinsic name must be a non-empty string');
        if (arguments.length > 1 && typeof re != 'boolean')
          throw new u('"allowMissing" argument must be a boolean');
        if (ee(/^%?[^%]*%?$/, Q) === null)
          throw new d(
            '`%` may not be present anywhere but at the beginning and end of the intrinsic name',
          );
        var oe = He(Q),
          ne = oe.length > 0 ? oe[0] : '',
          de = Ke('%' + ne + '%', re),
          ye = de.name,
          pe = de.value,
          Fe = !1,
          ot = de.alias;
        ot && ((ne = ot[0]), ae(oe, W([0, 1], ot)));
        for (var ft = 1, _t = !0; ft < oe.length; ft += 1) {
          var st = oe[ft],
            mt = ue(st, 0, 1),
            yt = ue(st, -1);
          if (
            (mt === '"' || mt === "'" || mt === '`' || yt === '"' || yt === "'" || yt === '`') &&
            mt !== yt
          )
            throw new d('property names with quotes must have matching quotes');
          if (
            ((st === 'constructor' || !_t) && (Fe = !0),
            (ne += '.' + st),
            (ye = '%' + ne + '%'),
            ie(F, ye))
          )
            pe = F[ye];
          else if (pe != null) {
            if (!(st in pe)) {
              if (!re)
                throw new u(
                  'base intrinsic for ' + Q + ' exists, but the property is not available.',
                );
              return;
            }
            if (I && ft + 1 >= oe.length) {
              var ht = I(pe, st);
              ((_t = !!ht),
                _t && 'get' in ht && !('originalValue' in ht.get) ? (pe = ht.get) : (pe = pe[st]));
            } else ((_t = ie(pe, st)), (pe = pe[st]));
            _t && !Fe && (F[ye] = pe);
          }
        }
        return pe;
      }, 'GetIntrinsic');
    },
  }),
  Gp = ge({
    'node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js'(e, t) {
      var r = c1(),
        n = yT(),
        o = n([r('%String.prototype.indexOf%')]);
      t.exports = s(function (a, c) {
        var d = r(a, !!c);
        return typeof d == 'function' && o(a, '.prototype.') > -1 ? n([d]) : d;
      }, 'callBoundIntrinsic');
    },
  }),
  u1 = ge({
    'node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js'(e, t) {
      var r = uT();
      t.exports = s(function () {
        return r() && !!Symbol.toStringTag;
      }, 'hasToStringTagShams');
    },
  }),
  gT = ge({
    'node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js'(e, t) {
      var r = Gp(),
        n = u1()(),
        o = hT(),
        i = Hp(),
        a;
      n
        ? ((c = r('RegExp.prototype.exec')),
          (d = {}),
          (u = s(function () {
            throw d;
          }, 'throwRegexMarker')),
          (p = { toString: u, valueOf: u }),
          typeof Symbol.toPrimitive == 'symbol' && (p[Symbol.toPrimitive] = u),
          (a = s(function (g) {
            if (!g || typeof g != 'object') return !1;
            var v = i(g, 'lastIndex'),
              E = v && o(v, 'value');
            if (!E) return !1;
            try {
              c(g, p);
            } catch (b) {
              return b === d;
            }
          }, 'isRegex')))
        : ((f = r('Object.prototype.toString')),
          (m = '[object RegExp]'),
          (a = s(function (g) {
            return !g || (typeof g != 'object' && typeof g != 'function') ? !1 : f(g) === m;
          }, 'isRegex')));
      var c, d, u, p, f, m;
      t.exports = a;
    },
  }),
  d1 = ge({
    'node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js'(e, t) {
      t.exports = n;
      var r = Object.prototype.toString;
      function n(o) {
        if (!o) return !1;
        var i = r.call(o);
        return (
          i === '[object Function]' ||
          (typeof o == 'function' && i !== '[object RegExp]') ||
          (typeof window < 'u' &&
            (o === window.setTimeout ||
              o === window.alert ||
              o === window.confirm ||
              o === window.prompt))
        );
      }
      s(n, 'isFunction3');
    },
  }),
  p1 = ge({
    'node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js'(e, t) {
      var r = Gp(),
        n = gT(),
        o = r('RegExp.prototype.exec'),
        i = Vp();
      t.exports = s(function (c) {
        if (!n(c)) throw new i('`regex` must be a RegExp');
        return s(function (u) {
          return o(c, u) !== null;
        }, 'test');
      }, 'regexTester');
    },
  }),
  f1 = ge({
    'node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js'(e, t) {
      var r = Gp(),
        n = r('Object.prototype.toString'),
        o = dT()(),
        i = p1();
      o
        ? ((a = r('Symbol.prototype.toString')),
          (c = i(/^Symbol\(.*\)$/)),
          (d = s(function (p) {
            return typeof p.valueOf() != 'symbol' ? !1 : c(a(p));
          }, 'isRealSymbolObject')),
          (t.exports = s(function (p) {
            if (typeof p == 'symbol') return !0;
            if (!p || typeof p != 'object' || n(p) !== '[object Symbol]') return !1;
            try {
              return d(p);
            } catch {
              return !1;
            }
          }, 'isSymbol3')))
        : (t.exports = s(function (p) {
            return !1;
          }, 'isSymbol3'));
      var a, c, d;
    },
  }),
  m1 = Up(gT()),
  y1 = Up(d1()),
  h1 = Up(f1());
function bT(e) {
  return e != null && typeof e == 'object' && Array.isArray(e) === !1;
}
s(bT, 'isObject');
var g1 = typeof global == 'object' && global && global.Object === Object && global,
  b1 = g1,
  v1 = typeof self == 'object' && self && self.Object === Object && self,
  T1 = b1 || v1 || Function('return this')(),
  Wp = T1,
  E1 = Wp.Symbol,
  mo = E1,
  vT = Object.prototype,
  w1 = vT.hasOwnProperty,
  S1 = vT.toString,
  bs = mo ? mo.toStringTag : void 0;
function TT(e) {
  var t = w1.call(e, bs),
    r = e[bs];
  try {
    e[bs] = void 0;
    var n = !0;
  } catch {}
  var o = S1.call(e);
  return (n && (t ? (e[bs] = r) : delete e[bs]), o);
}
s(TT, 'getRawTag');
var _1 = TT,
  A1 = Object.prototype,
  R1 = A1.toString;
function ET(e) {
  return R1.call(e);
}
s(ET, 'objectToString');
var x1 = ET,
  P1 = '[object Null]',
  O1 = '[object Undefined]',
  fg = mo ? mo.toStringTag : void 0;
function wT(e) {
  return e == null ? (e === void 0 ? O1 : P1) : fg && fg in Object(e) ? _1(e) : x1(e);
}
s(wT, 'baseGetTag');
var ST = wT;
function _T(e) {
  return e != null && typeof e == 'object';
}
s(_T, 'isObjectLike');
var C1 = _T,
  I1 = '[object Symbol]';
function AT(e) {
  return typeof e == 'symbol' || (C1(e) && ST(e) == I1);
}
s(AT, 'isSymbol');
var Kp = AT;
function RT(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, o = Array(n); ++r < n; ) o[r] = t(e[r], r, e);
  return o;
}
s(RT, 'arrayMap');
var N1 = RT,
  q1 = Array.isArray,
  Yp = q1,
  mg = mo ? mo.prototype : void 0,
  yg = mg ? mg.toString : void 0;
function Xp(e) {
  if (typeof e == 'string') return e;
  if (Yp(e)) return N1(e, Xp) + '';
  if (Kp(e)) return yg ? yg.call(e) : '';
  var t = e + '';
  return t == '0' && 1 / e == -1 / 0 ? '-0' : t;
}
s(Xp, 'baseToString');
var M1 = Xp;
function xT(e) {
  var t = typeof e;
  return e != null && (t == 'object' || t == 'function');
}
s(xT, 'isObject2');
var PT = xT,
  j1 = '[object AsyncFunction]',
  $1 = '[object Function]',
  k1 = '[object GeneratorFunction]',
  D1 = '[object Proxy]';
function OT(e) {
  if (!PT(e)) return !1;
  var t = ST(e);
  return t == $1 || t == k1 || t == j1 || t == D1;
}
s(OT, 'isFunction');
var L1 = OT,
  F1 = Wp['__core-js_shared__'],
  Gc = F1,
  hg = (function () {
    var e = /[^.]+$/.exec((Gc && Gc.keys && Gc.keys.IE_PROTO) || '');
    return e ? 'Symbol(src)_1.' + e : '';
  })();
function CT(e) {
  return !!hg && hg in e;
}
s(CT, 'isMasked');
var B1 = CT,
  J1 = Function.prototype,
  U1 = J1.toString;
function IT(e) {
  if (e != null) {
    try {
      return U1.call(e);
    } catch {}
    try {
      return e + '';
    } catch {}
  }
  return '';
}
s(IT, 'toSource');
var V1 = IT,
  H1 = /[\\^$.*+?()[\]{}|]/g,
  z1 = /^\[object .+?Constructor\]$/,
  G1 = Function.prototype,
  W1 = Object.prototype,
  K1 = G1.toString,
  Y1 = W1.hasOwnProperty,
  X1 = RegExp(
    '^' +
      K1.call(Y1)
        .replace(H1, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
      '$',
  );
function NT(e) {
  if (!PT(e) || B1(e)) return !1;
  var t = L1(e) ? X1 : z1;
  return t.test(V1(e));
}
s(NT, 'baseIsNative');
var Q1 = NT;
function qT(e, t) {
  return e?.[t];
}
s(qT, 'getValue');
var Z1 = qT;
function MT(e, t) {
  var r = Z1(e, t);
  return Q1(r) ? r : void 0;
}
s(MT, 'getNative');
var jT = MT;
function $T(e, t) {
  return e === t || (e !== e && t !== t);
}
s($T, 'eq');
var eD = $T,
  tD = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  rD = /^\w*$/;
function kT(e, t) {
  if (Yp(e)) return !1;
  var r = typeof e;
  return r == 'number' || r == 'symbol' || r == 'boolean' || e == null || Kp(e)
    ? !0
    : rD.test(e) || !tD.test(e) || (t != null && e in Object(t));
}
s(kT, 'isKey');
var nD = kT,
  oD = jT(Object, 'create'),
  zs = oD;
function DT() {
  ((this.__data__ = zs ? zs(null) : {}), (this.size = 0));
}
s(DT, 'hashClear');
var sD = DT;
function LT(e) {
  var t = this.has(e) && delete this.__data__[e];
  return ((this.size -= t ? 1 : 0), t);
}
s(LT, 'hashDelete');
var iD = LT,
  aD = '__lodash_hash_undefined__',
  lD = Object.prototype,
  cD = lD.hasOwnProperty;
function FT(e) {
  var t = this.__data__;
  if (zs) {
    var r = t[e];
    return r === aD ? void 0 : r;
  }
  return cD.call(t, e) ? t[e] : void 0;
}
s(FT, 'hashGet');
var uD = FT,
  dD = Object.prototype,
  pD = dD.hasOwnProperty;
function BT(e) {
  var t = this.__data__;
  return zs ? t[e] !== void 0 : pD.call(t, e);
}
s(BT, 'hashHas');
var fD = BT,
  mD = '__lodash_hash_undefined__';
function JT(e, t) {
  var r = this.__data__;
  return ((this.size += this.has(e) ? 0 : 1), (r[e] = zs && t === void 0 ? mD : t), this);
}
s(JT, 'hashSet');
var yD = JT;
function Dn(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
s(Dn, 'Hash');
Dn.prototype.clear = sD;
Dn.prototype.delete = iD;
Dn.prototype.get = uD;
Dn.prototype.has = fD;
Dn.prototype.set = yD;
var gg = Dn;
function UT() {
  ((this.__data__ = []), (this.size = 0));
}
s(UT, 'listCacheClear');
var hD = UT;
function VT(e, t) {
  for (var r = e.length; r--; ) if (eD(e[r][0], t)) return r;
  return -1;
}
s(VT, 'assocIndexOf');
var vl = VT,
  gD = Array.prototype,
  bD = gD.splice;
function HT(e) {
  var t = this.__data__,
    r = vl(t, e);
  if (r < 0) return !1;
  var n = t.length - 1;
  return (r == n ? t.pop() : bD.call(t, r, 1), --this.size, !0);
}
s(HT, 'listCacheDelete');
var vD = HT;
function zT(e) {
  var t = this.__data__,
    r = vl(t, e);
  return r < 0 ? void 0 : t[r][1];
}
s(zT, 'listCacheGet');
var TD = zT;
function GT(e) {
  return vl(this.__data__, e) > -1;
}
s(GT, 'listCacheHas');
var ED = GT;
function WT(e, t) {
  var r = this.__data__,
    n = vl(r, e);
  return (n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this);
}
s(WT, 'listCacheSet');
var wD = WT;
function Ln(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
s(Ln, 'ListCache');
Ln.prototype.clear = hD;
Ln.prototype.delete = vD;
Ln.prototype.get = TD;
Ln.prototype.has = ED;
Ln.prototype.set = wD;
var SD = Ln,
  _D = jT(Wp, 'Map'),
  AD = _D;
function KT() {
  ((this.size = 0), (this.__data__ = { hash: new gg(), map: new (AD || SD)(), string: new gg() }));
}
s(KT, 'mapCacheClear');
var RD = KT;
function YT(e) {
  var t = typeof e;
  return t == 'string' || t == 'number' || t == 'symbol' || t == 'boolean'
    ? e !== '__proto__'
    : e === null;
}
s(YT, 'isKeyable');
var xD = YT;
function XT(e, t) {
  var r = e.__data__;
  return xD(t) ? r[typeof t == 'string' ? 'string' : 'hash'] : r.map;
}
s(XT, 'getMapData');
var Tl = XT;
function QT(e) {
  var t = Tl(this, e).delete(e);
  return ((this.size -= t ? 1 : 0), t);
}
s(QT, 'mapCacheDelete');
var PD = QT;
function ZT(e) {
  return Tl(this, e).get(e);
}
s(ZT, 'mapCacheGet');
var OD = ZT;
function eE(e) {
  return Tl(this, e).has(e);
}
s(eE, 'mapCacheHas');
var CD = eE;
function tE(e, t) {
  var r = Tl(this, e),
    n = r.size;
  return (r.set(e, t), (this.size += r.size == n ? 0 : 1), this);
}
s(tE, 'mapCacheSet');
var ID = tE;
function Fn(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
s(Fn, 'MapCache');
Fn.prototype.clear = RD;
Fn.prototype.delete = PD;
Fn.prototype.get = OD;
Fn.prototype.has = CD;
Fn.prototype.set = ID;
var rE = Fn,
  ND = 'Expected a function';
function El(e, t) {
  if (typeof e != 'function' || (t != null && typeof t != 'function')) throw new TypeError(ND);
  var r = s(function () {
    var n = arguments,
      o = t ? t.apply(this, n) : n[0],
      i = r.cache;
    if (i.has(o)) return i.get(o);
    var a = e.apply(this, n);
    return ((r.cache = i.set(o, a) || i), a);
  }, 'memoized');
  return ((r.cache = new (El.Cache || rE)()), r);
}
s(El, 'memoize');
El.Cache = rE;
var qD = El,
  MD = 500;
function nE(e) {
  var t = qD(e, function (n) {
      return (r.size === MD && r.clear(), n);
    }),
    r = t.cache;
  return t;
}
s(nE, 'memoizeCapped');
var jD = nE,
  $D =
    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
  kD = /\\(\\)?/g,
  DD = jD(function (e) {
    var t = [];
    return (
      e.charCodeAt(0) === 46 && t.push(''),
      e.replace($D, function (r, n, o, i) {
        t.push(o ? i.replace(kD, '$1') : n || r);
      }),
      t
    );
  }),
  LD = DD;
function oE(e) {
  return e == null ? '' : M1(e);
}
s(oE, 'toString');
var FD = oE;
function sE(e, t) {
  return Yp(e) ? e : nD(e, t) ? [e] : LD(FD(e));
}
s(sE, 'castPath');
var BD = sE;
function iE(e) {
  if (typeof e == 'string' || Kp(e)) return e;
  var t = e + '';
  return t == '0' && 1 / e == -1 / 0 ? '-0' : t;
}
s(iE, 'toKey');
var JD = iE;
function aE(e, t) {
  t = BD(t, e);
  for (var r = 0, n = t.length; e != null && r < n; ) e = e[JD(t[r++])];
  return r && r == n ? e : void 0;
}
s(aE, 'baseGet');
var UD = aE;
function lE(e, t, r) {
  var n = e == null ? void 0 : UD(e, t);
  return n === void 0 ? r : n;
}
s(lE, 'get');
var VD = lE,
  Qp = bT,
  HD = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/,
  Zp = s((e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/), 'isJSON');
function ef(e) {
  if (!Qp(e)) return e;
  let t = e,
    r = !1;
  return (
    typeof Event < 'u' && e instanceof Event && ((t = lT(t)), (r = !0)),
    (t = Object.keys(t).reduce((n, o) => {
      try {
        (t[o] && t[o].toJSON, (n[o] = t[o]));
      } catch {
        r = !0;
      }
      return n;
    }, {})),
    r ? t : e
  );
}
s(ef, 'convertUnconventionalData');
var zD = s(function (t) {
    let r, n, o, i;
    return s(function (c, d) {
      try {
        if (c === '') return ((i = []), (r = new Map([[d, '[]']])), (n = new Map()), (o = []), d);
        const u = n.get(this) || this;
        for (; o.length && u !== o[0]; ) (o.shift(), i.pop());
        if (typeof d == 'boolean') return d;
        if (d === void 0) return t.allowUndefined ? '_undefined_' : void 0;
        if (d === null) return null;
        if (typeof d == 'number')
          return d === Number.NEGATIVE_INFINITY
            ? '_-Infinity_'
            : d === Number.POSITIVE_INFINITY
              ? '_Infinity_'
              : Number.isNaN(d)
                ? '_NaN_'
                : d;
        if (typeof d == 'bigint') return `_bigint_${d.toString()}`;
        if (typeof d == 'string') return HD.test(d) ? (t.allowDate ? `_date_${d}` : void 0) : d;
        if ((0, m1.default)(d)) return t.allowRegExp ? `_regexp_${d.flags}|${d.source}` : void 0;
        if ((0, y1.default)(d)) return;
        if ((0, h1.default)(d)) {
          if (!t.allowSymbol) return;
          const f = Symbol.keyFor(d);
          return f !== void 0 ? `_gsymbol_${f}` : `_symbol_${d.toString().slice(7, -1)}`;
        }
        if (o.length >= t.maxDepth) return Array.isArray(d) ? `[Array(${d.length})]` : '[Object]';
        if (d === this) return `_duplicate_${JSON.stringify(i)}`;
        if (d instanceof Error && t.allowError)
          return {
            __isConvertedError__: !0,
            errorProperties: {
              ...(d.cause ? { cause: d.cause } : {}),
              ...d,
              name: d.name,
              message: d.message,
              stack: d.stack,
              '_constructor-name_': d.constructor.name,
            },
          };
        if (d?.constructor?.name && d.constructor.name !== 'Object' && !Array.isArray(d)) {
          const f = r.get(d);
          if (!f) {
            const m = {
              __isClassInstance__: !0,
              __className__: d.constructor.name,
              ...Object.getOwnPropertyNames(d).reduce((h, g) => {
                try {
                  h[g] = d[g];
                } catch {}
                return h;
              }, {}),
            };
            return (
              i.push(c),
              o.unshift(m),
              r.set(d, JSON.stringify(i)),
              d !== m && n.set(d, m),
              m
            );
          }
          return `_duplicate_${f}`;
        }
        const p = r.get(d);
        if (!p) {
          const f = Array.isArray(d) ? d : ef(d);
          return (i.push(c), o.unshift(f), r.set(d, JSON.stringify(i)), d !== f && n.set(d, f), f);
        }
        return `_duplicate_${p}`;
      } catch {
        return;
      }
    }, 'replace');
  }, 'replacer2'),
  GD = s(function (t) {
    const r = [];
    let n;
    return s(function (i, a) {
      if (
        (i === '' &&
          ((n = a),
          r.forEach(({ target: c, container: d, replacement: u }) => {
            const p = Zp(u) ? JSON.parse(u) : u.split('.');
            p.length === 0 ? (d[c] = n) : (d[c] = VD(n, p));
          })),
        i === '_constructor-name_')
      )
        return a;
      if (Qp(a) && a.__isConvertedError__) {
        const { message: c, ...d } = a.errorProperties,
          u = new Error(c);
        return (Object.assign(u, d), u);
      }
      if (typeof a == 'string' && a.startsWith('_regexp_') && t.allowRegExp) {
        const [, c, d] = a.match(/_regexp_([^|]*)\|(.*)/) || [];
        return new RegExp(d, c);
      }
      return typeof a == 'string' && a.startsWith('_date_') && t.allowDate
        ? new Date(a.replace('_date_', ''))
        : typeof a == 'string' && a.startsWith('_duplicate_')
          ? (r.push({ target: i, container: this, replacement: a.replace(/^_duplicate_/, '') }),
            null)
          : typeof a == 'string' && a.startsWith('_symbol_') && t.allowSymbol
            ? Symbol(a.replace('_symbol_', ''))
            : typeof a == 'string' && a.startsWith('_gsymbol_') && t.allowSymbol
              ? Symbol.for(a.replace('_gsymbol_', ''))
              : typeof a == 'string' && a === '_-Infinity_'
                ? Number.NEGATIVE_INFINITY
                : typeof a == 'string' && a === '_Infinity_'
                  ? Number.POSITIVE_INFINITY
                  : typeof a == 'string' && a === '_NaN_'
                    ? Number.NaN
                    : typeof a == 'string' &&
                        a.startsWith('_bigint_') &&
                        typeof BigInt == 'function'
                      ? BigInt(a.replace('_bigint_', ''))
                      : a;
    }, 'revive');
  }, 'reviver2'),
  cE = {
    maxDepth: 10,
    space: void 0,
    allowRegExp: !0,
    allowDate: !0,
    allowError: !0,
    allowUndefined: !0,
    allowSymbol: !0,
  },
  uE = s((e, t = {}) => {
    const r = { ...cE, ...t };
    return JSON.stringify(ef(e), zD(r), t.space);
  }, 'stringify'),
  WD = s(() => {
    const e = new Map();
    return s(function t(r) {
      (Qp(r) &&
        Object.entries(r).forEach(([n, o]) => {
          o === '_undefined_' ? (r[n] = void 0) : e.get(o) || (e.set(o, !0), t(o));
        }),
        Array.isArray(r) &&
          r.forEach((n, o) => {
            n === '_undefined_'
              ? (e.set(n, !0), (r[o] = void 0))
              : e.get(n) || (e.set(n, !0), t(n));
          }));
    }, 'mutateUndefined');
  }, 'mutator'),
  dE = s((e, t = {}) => {
    const r = { ...cE, ...t },
      n = JSON.parse(e, GD(r));
    return (WD()(n), n);
  }, 'parse'),
  KD = 'Invariant failed';
function sr(e, t) {
  if (!e) throw new Error(KD);
}
s(sr, 'invariant');
var YD = s((e) => {
    const t = Array.from(document.querySelectorAll('iframe[data-is-storybook]')),
      [r, ...n] = t.filter((i) => {
        try {
          return (
            i.contentWindow?.location.origin === e.source.location.origin &&
            i.contentWindow?.location.pathname === e.source.location.pathname
          );
        } catch {}
        try {
          return i.contentWindow === e.source;
        } catch {}
        const a = i.getAttribute('src');
        let c;
        try {
          if (!a) return !1;
          ({ origin: c } = new URL(a, document.location.toString()));
        } catch {
          return !1;
        }
        return c === e.origin;
      }),
      o = r?.getAttribute('src');
    if (o && n.length === 0) {
      const { protocol: i, host: a, pathname: c } = new URL(o, document.location.toString());
      return `${i}//${a}${c}`;
    }
    return (n.length > 0 && ke.error('found multiple candidates for event source'), null);
  }, 'getEventSourceUrl'),
  { document: Wc, location: Kc } = te,
  bg = 'storybook-channel',
  XD = { maxDepth: 25 },
  pE = class {
    constructor(t) {
      if (
        ((this.config = t),
        (this.connected = !1),
        (this.buffer = []),
        typeof te?.addEventListener == 'function' &&
          te.addEventListener('message', this.handleEvent.bind(this), !1),
        t.page !== 'manager' && t.page !== 'preview')
      )
        throw new Error(`postmsg-channel: "config.page" cannot be "${t.page}"`);
    }
    setHandler(t) {
      this.handler = (...r) => {
        (t.apply(this, r),
          !this.connected && this.getLocalFrame().length && (this.flush(), (this.connected = !0)));
      };
    }
    send(t, r) {
      const {
          target: n,
          allowRegExp: o,
          allowSymbol: i,
          allowDate: a,
          allowError: c,
          allowUndefined: d,
          maxDepth: u,
          space: p,
        } = r || {},
        f = Object.fromEntries(
          Object.entries({
            allowRegExp: o,
            allowSymbol: i,
            allowDate: a,
            allowError: c,
            allowUndefined: d,
            maxDepth: u,
            space: p,
          }).filter(([E, b]) => typeof b < 'u'),
        ),
        m = { ...XD, ...(te.CHANNEL_OPTIONS || {}), ...f },
        h = this.getFrames(n),
        g = new URLSearchParams(Kc?.search || ''),
        v = uE({ key: bg, event: t, refId: g.get('refId') }, m);
      return h.length
        ? (this.buffer.length && this.flush(),
          h.forEach((E) => {
            try {
              E.postMessage(v, '*');
            } catch {
              ke.error('sending over postmessage fail');
            }
          }),
          Promise.resolve(null))
        : new Promise((E, b) => {
            this.buffer.push({ event: t, resolve: E, reject: b });
          });
    }
    flush() {
      const { buffer: t } = this;
      ((this.buffer = []),
        t.forEach((r) => {
          this.send(r.event).then(r.resolve).catch(r.reject);
        }));
    }
    getFrames(t) {
      if (this.config.page === 'manager') {
        const n = Array.from(
          Wc.querySelectorAll('iframe[data-is-storybook][data-is-loaded]'),
        ).flatMap((o) => {
          try {
            return o.contentWindow && o.dataset.isStorybook !== void 0 && o.id === t
              ? [o.contentWindow]
              : [];
          } catch {
            return [];
          }
        });
        return n?.length ? n : this.getCurrentFrames();
      }
      return te && te.parent && te.parent !== te.self ? [te.parent] : [];
    }
    getCurrentFrames() {
      return this.config.page === 'manager'
        ? Array.from(Wc.querySelectorAll('[data-is-storybook="true"]')).flatMap((r) =>
            r.contentWindow ? [r.contentWindow] : [],
          )
        : te && te.parent
          ? [te.parent]
          : [];
    }
    getLocalFrame() {
      return this.config.page === 'manager'
        ? Array.from(Wc.querySelectorAll('#storybook-preview-iframe')).flatMap((r) =>
            r.contentWindow ? [r.contentWindow] : [],
          )
        : te && te.parent
          ? [te.parent]
          : [];
    }
    handleEvent(t) {
      try {
        const { data: r } = t,
          {
            key: n,
            event: o,
            refId: i,
          } = typeof r == 'string' && Zp(r) ? dE(r, te.CHANNEL_OPTIONS || {}) : r;
        if (n === bg) {
          const a =
              this.config.page === 'manager'
                ? '<span style="color: #37D5D3; background: black"> manager </span>'
                : '<span style="color: #1EA7FD; background: black"> preview </span>',
            c = Object.values(Mp).includes(o.type)
              ? `<span style="color: #FF4785">${o.type}</span>`
              : `<span style="color: #FFAE00">${o.type}</span>`;
          if (
            (i && (o.refId = i),
            (o.source = this.config.page === 'preview' ? t.origin : YD(t)),
            !o.source)
          ) {
            It.error(`${a} received ${c} but was unable to determine the source of the event`);
            return;
          }
          const d = `${a} received ${c} (${r.length})`;
          (It.debug(
            Kc.origin !== o.source
              ? d
              : `${d} <span style="color: gray">(on ${Kc.origin} from ${o.source})</span>`,
            ...o.args,
          ),
            sr(this.handler, 'ChannelHandler should be set'),
            this.handler(o));
        }
      } catch (r) {
        ke.error(r);
      }
    }
  };
s(pE, 'PostMessageTransport');
var fE = pE,
  { WebSocket: QD } = te,
  mE = 15e3,
  yE = 5e3,
  hE = class {
    constructor({ url: t, onError: r, page: n }) {
      ((this.buffer = []),
        (this.isReady = !1),
        (this.isClosed = !1),
        (this.pingTimeout = 0),
        (this.socket = new QD(t)),
        (this.socket.onopen = () => {
          ((this.isReady = !0), this.heartbeat(), this.flush());
        }),
        (this.socket.onmessage = ({ data: o }) => {
          const i = typeof o == 'string' && Zp(o) ? dE(o) : o;
          (sr(this.handler),
            this.handler(i),
            i.type === 'ping' && (this.heartbeat(), this.send({ type: 'pong' })));
        }),
        (this.socket.onerror = (o) => {
          r && r(o);
        }),
        (this.socket.onclose = (o) => {
          (sr(this.handler),
            this.handler({
              type: Mv,
              args: [{ reason: o.reason, code: o.code }],
              from: n || 'preview',
            }),
            (this.isClosed = !0),
            clearTimeout(this.pingTimeout));
        }));
    }
    heartbeat() {
      (clearTimeout(this.pingTimeout),
        (this.pingTimeout = setTimeout(() => {
          this.socket.close(3008, 'timeout');
        }, mE + yE)));
    }
    setHandler(t) {
      this.handler = t;
    }
    send(t) {
      this.isClosed || (this.isReady ? this.sendNow(t) : this.sendLater(t));
    }
    sendLater(t) {
      this.buffer.push(t);
    }
    sendNow(t) {
      const r = uE(t, { maxDepth: 15, ...te.CHANNEL_OPTIONS });
      this.socket.send(r);
    }
    flush() {
      const { buffer: t } = this;
      ((this.buffer = []), t.forEach((r) => this.send(r)));
    }
  };
s(hE, 'WebsocketTransport');
var gE = hE,
  { CONFIG_TYPE: ZD } = te,
  eL = gl;
function bE({ page: e, extraTransports: t = [] }) {
  const r = [new fE({ page: e }), ...t];
  if (ZD === 'DEVELOPMENT') {
    const o = window.location.protocol === 'http:' ? 'ws' : 'wss',
      { hostname: i, port: a } = window.location,
      c = `${o}://${i}:${a}/storybook-server-channel`;
    r.push(new gE({ url: c, onError: s(() => {}, 'onError'), page: e }));
  }
  const n = new gl({ transports: r });
  return (zc.__prepare(n, e === 'manager' ? zc.Environment.MANAGER : zc.Environment.PREVIEW), n);
}
s(bE, 'createBrowserChannel');
var vE = {};
St(vE, {
  CalledExtractOnStoreError: () => PE,
  CalledPreviewMethodBeforeInitializationError: () => Pt,
  Category: () => wE,
  ElementA11yParameterError: () => iL,
  EmptyIndexError: () => kE,
  ImplicitActionsDuringRendering: () => RE,
  MdxFileWithNoCsfReferencesError: () => jE,
  MissingRenderToCanvasError: () => CE,
  MissingStoryAfterHmrError: () => _E,
  MissingStoryFromCsfFileError: () => BE,
  MountMustBeDestructuredError: () => tf,
  NextJsSharpError: () => rL,
  NextjsRouterMocksNotAvailable: () => nL,
  NoRenderFunctionError: () => zE,
  NoStoryMatchError: () => LE,
  NoStoryMountedError: () => WE,
  StatusTypeIdMismatchError: () => tL,
  StoryIndexFetchError: () => qE,
  StoryStoreAccessedBeforeInitializationError: () => UE,
  UnknownArgTypesError: () => oL,
  UnsupportedViewportDimensionError: () => sL,
});
function Ru({ code: e, category: t }) {
  const r = String(e).padStart(4, '0');
  return `SB_${t}_${r}`;
}
s(Ru, 'parseErrorCode');
function xu(e) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e)) return e;
  try {
    const t = new URL(e);
    return (t.searchParams.set('ref', 'error'), t.toString());
  } catch {
    return e;
  }
}
s(xu, 'appendErrorRef');
var TE = class EE extends Error {
  constructor(t) {
    (super(EE.getFullMessage(t)),
      (this.data = {}),
      (this.fromStorybook = !0),
      (this.category = t.category),
      (this.documentation = t.documentation ?? !1),
      (this.code = t.code));
  }
  get fullErrorCode() {
    return Ru({ code: this.code, category: this.category });
  }
  get name() {
    const t = this.constructor.name;
    return `${this.fullErrorCode} (${t})`;
  }
  static getFullMessage({ documentation: t, code: r, category: n, message: o }) {
    let i;
    return (
      t === !0
        ? (i = `https://storybook.js.org/error/${Ru({ code: r, category: n })}?ref=error`)
        : typeof t == 'string'
          ? (i = xu(t))
          : Array.isArray(t) &&
            (i = `
${t.map((a) => `	- ${xu(a)}`).join(`
`)}`),
      `${o}${
        i != null
          ? `

More info: ${i}
`
          : ''
      }`
    );
  }
};
s(TE, 'StorybookError');
var We = TE,
  wE = ((e) => (
    (e.BLOCKS = 'BLOCKS'),
    (e.DOCS_TOOLS = 'DOCS-TOOLS'),
    (e.PREVIEW_CLIENT_LOGGER = 'PREVIEW_CLIENT-LOGGER'),
    (e.PREVIEW_CHANNELS = 'PREVIEW_CHANNELS'),
    (e.PREVIEW_CORE_EVENTS = 'PREVIEW_CORE-EVENTS'),
    (e.PREVIEW_INSTRUMENTER = 'PREVIEW_INSTRUMENTER'),
    (e.PREVIEW_API = 'PREVIEW_API'),
    (e.PREVIEW_REACT_DOM_SHIM = 'PREVIEW_REACT-DOM-SHIM'),
    (e.PREVIEW_ROUTER = 'PREVIEW_ROUTER'),
    (e.PREVIEW_THEMING = 'PREVIEW_THEMING'),
    (e.RENDERER_HTML = 'RENDERER_HTML'),
    (e.RENDERER_PREACT = 'RENDERER_PREACT'),
    (e.RENDERER_REACT = 'RENDERER_REACT'),
    (e.RENDERER_SERVER = 'RENDERER_SERVER'),
    (e.RENDERER_SVELTE = 'RENDERER_SVELTE'),
    (e.RENDERER_VUE = 'RENDERER_VUE'),
    (e.RENDERER_VUE3 = 'RENDERER_VUE3'),
    (e.RENDERER_WEB_COMPONENTS = 'RENDERER_WEB-COMPONENTS'),
    (e.FRAMEWORK_NEXTJS = 'FRAMEWORK_NEXTJS'),
    (e.ADDON_VITEST = 'ADDON_VITEST'),
    (e.ADDON_A11Y = 'ADDON_A11Y'),
    e
  ))(wE || {}),
  SE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 1,
        message: ve`
        Couldn't find story matching id '${t.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${t.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`,
      }),
        (this.data = t));
    }
  };
s(SE, 'MissingStoryAfterHmrError');
var _E = SE,
  AE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 2,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function',
        message: ve`
        We detected that you use an implicit action arg while ${t.phase} of your story.  
        ${
          t.deprecated
            ? `
This is deprecated and won't work in Storybook 8 anymore.
`
            : ''
        }
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${t.name}: fn()
          }`,
      }),
        (this.data = t));
    }
  };
s(AE, 'ImplicitActionsDuringRendering');
var RE = AE,
  xE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 3,
        message: ve`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`,
      });
    }
  };
s(xE, 'CalledExtractOnStoreError');
var PE = xE,
  OE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 4,
        message: ve`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field',
      });
    }
  };
s(OE, 'MissingRenderToCanvasError');
var CE = OE,
  IE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 5,
        message: ve`
        Called \`Preview.${t.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${t.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`,
      }),
        (this.data = t));
    }
  };
s(IE, 'CalledPreviewMethodBeforeInitializationError');
var Pt = IE,
  NE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 6,
        message: ve`
        Error fetching \`/index.json\`:
        
        ${t.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`,
      }),
        (this.data = t));
    }
  };
s(NE, 'StoryIndexFetchError');
var qE = NE,
  ME = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 7,
        message: ve`
        Tried to render docs entry ${t.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`,
      }),
        (this.data = t));
    }
  };
s(ME, 'MdxFileWithNoCsfReferencesError');
var jE = ME,
  $E = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 8,
        message: ve`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`,
      });
    }
  };
s($E, 'EmptyIndexError');
var kE = $E,
  DE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 9,
        message: ve`
        Couldn't find story matching '${t.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`,
      }),
        (this.data = t));
    }
  };
s(DE, 'NoStoryMatchError');
var LE = DE,
  FE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 10,
        message: ve`
        Couldn't find story matching id '${t.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`,
      }),
        (this.data = t));
    }
  };
s(FE, 'MissingStoryFromCsfFileError');
var BE = FE,
  JE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 11,
        message: ve`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`,
      });
    }
  };
s(JE, 'StoryStoreAccessedBeforeInitializationError');
var UE = JE,
  VE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 12,
        message: ve`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${t.playFunction}`,
      }),
        (this.data = t));
    }
  };
s(VE, 'MountMustBeDestructuredError');
var tf = VE,
  HE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 14,
        message: ve`
        No render function available for storyId '${t.id}'
      `,
      }),
        (this.data = t));
    }
  };
s(HE, 'NoRenderFunctionError');
var zE = HE,
  GE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 15,
        message: ve`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `,
      });
    }
  };
s(GE, 'NoStoryMountedError');
var WE = GE,
  KE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 16,
        message: `Status has typeId "${t.status.typeId}" but was added to store with typeId "${t.typeId}". Full status: ${JSON.stringify(t.status, null, 2)}`,
      }),
        (this.data = t));
    }
  };
s(KE, 'StatusTypeIdMismatchError');
var tL = KE,
  YE = class extends We {
    constructor() {
      super({
        category: 'FRAMEWORK_NEXTJS',
        code: 1,
        documentation: 'https://storybook.js.org/docs/get-started/nextjs#faq',
        message: ve`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `,
      });
    }
  };
s(YE, 'NextJsSharpError');
var rL = YE,
  XE = class extends We {
    constructor(t) {
      (super({
        category: 'FRAMEWORK_NEXTJS',
        code: 2,
        message: ve`
        Tried to access router mocks from "${t.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `,
      }),
        (this.data = t));
    }
  };
s(XE, 'NextjsRouterMocksNotAvailable');
var nL = XE,
  QE = class extends We {
    constructor(t) {
      (super({
        category: 'DOCS-TOOLS',
        code: 1,
        documentation: 'https://github.com/storybookjs/storybook/issues/26606',
        message: ve`
        There was a failure when generating detailed ArgTypes in ${t.language} for:
        ${JSON.stringify(t.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `,
      }),
        (this.data = t));
    }
  };
s(QE, 'UnknownArgTypesError');
var oL = QE,
  ZE = class extends We {
    constructor(t) {
      (super({
        category: 'ADDON_VITEST',
        code: 1,
        message: ve`
        Encountered an unsupported value "${t.value}" when setting the viewport ${t.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `,
      }),
        (this.data = t));
    }
  };
s(ZE, 'UnsupportedViewportDimensionError');
var sL = ZE,
  ew = class extends We {
    constructor() {
      super({
        category: 'ADDON_A11Y',
        code: 1,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter',
        message:
          'The "element" parameter in parameters.a11y has been removed. Use "context" instead.',
      });
    }
  };
s(ew, 'ElementA11yParameterError');
var iL = ew,
  tw = {};
St(tw, { Addon_TypesEnum: () => rw });
var rw = ((e) => (
    (e.TAB = 'tab'),
    (e.PANEL = 'panel'),
    (e.TOOL = 'tool'),
    (e.TOOLEXTRA = 'toolextra'),
    (e.PREVIEW = 'preview'),
    (e.experimental_PAGE = 'page'),
    (e.experimental_TEST_PROVIDER = 'test-provider'),
    e
  ))(rw || {}),
  nw = {};
St(nw, {
  ADDON_ID: () => wl,
  CLEAR_ID: () => cL,
  CYCLIC_KEY: () => uL,
  EVENT_ID: () => ow,
  PANEL_ID: () => lL,
  PARAM_KEY: () => aL,
  action: () => Ho,
  actions: () => U3,
  config: () => pi,
  configureActions: () => F3,
});
var aL = 'actions',
  wl = 'storybook/actions',
  lL = `${wl}/panel`,
  ow = `${wl}/action-event`,
  cL = `${wl}/action-clear`,
  uL = '$___storybook.isCyclic',
  Pu = {};
St(Pu, {
  DocsContext: () => Bh,
  HooksContext: () => nf,
  Preview: () => LI,
  PreviewWeb: () => N3,
  PreviewWithSelection: () => KI,
  ReporterAPI: () => Dh,
  StoryStore: () => MI,
  UrlStore: () => rN,
  WebView: () => sN,
  addons: () => Ft,
  applyHooks: () => lw,
  combineArgs: () => rl,
  combineParameters: () => $n,
  composeConfigs: () => kn,
  composeStepRunners: () => jh,
  composeStories: () => CI,
  composeStory: () => Fh,
  createPlaywrightTest: () => II,
  decorateStory: () => Ph,
  defaultDecorateStory: () => Ch,
  emitTransformCode: () => uN,
  filterArgTypes: () => _I,
  getCsfFactoryAnnotations: () => Lh,
  inferControls: () => Mh,
  makeDecorator: () => mL,
  mockChannel: () => rf,
  normalizeArrays: () => Ne,
  normalizeProjectAnnotations: () => di,
  normalizeStory: () => fo,
  pauseAnimations: () => kc,
  prepareMeta: () => Ih,
  prepareStory: () => $c,
  sanitizeStoryContextUpdate: () => Oh,
  setDefaultProjectAnnotations: () => xI,
  setProjectAnnotations: () => OI,
  simulateDOMContentLoaded: () => il,
  simulatePageLoad: () => lN,
  sortStoriesV7: () => v3,
  useArgs: () => hw,
  useCallback: () => yo,
  useChannel: () => mw,
  useEffect: () => Kr,
  useGlobals: () => gw,
  useMemo: () => af,
  useParameter: () => yw,
  useReducer: () => fw,
  useRef: () => uw,
  useState: () => pw,
  useStoryContext: () => vi,
  userOrAutoTitle: () => h3,
  userOrAutoTitleFromSpecifier: () => $I,
  waitForAnimations: () => Dc,
});
function rf() {
  const e = { setHandler: s(() => {}, 'setHandler'), send: s(() => {}, 'send') };
  return new gl({ transport: e });
}
s(rf, 'mockChannel');
var sw = class {
  constructor() {
    ((this.getChannel = s(() => {
      if (!this.channel) {
        const t = rf();
        return (this.setChannel(t), t);
      }
      return this.channel;
    }, 'getChannel')),
      (this.ready = s(() => this.promise, 'ready')),
      (this.hasChannel = s(() => !!this.channel, 'hasChannel')),
      (this.setChannel = s((t) => {
        ((this.channel = t), this.resolve());
      }, 'setChannel')),
      (this.promise = new Promise((t) => {
        this.resolve = () => t(this.getChannel());
      })));
  }
};
s(sw, 'AddonStore');
var dL = sw,
  Yc = '__STORYBOOK_ADDONS_PREVIEW';
function iw() {
  return (te[Yc] || (te[Yc] = new dL()), te[Yc]);
}
s(iw, 'getAddonsStore');
var Ft = iw(),
  aw = class {
    constructor() {
      ((this.hookListsMap = void 0),
        (this.mountedDecorators = void 0),
        (this.prevMountedDecorators = void 0),
        (this.currentHooks = void 0),
        (this.nextHookIndex = void 0),
        (this.currentPhase = void 0),
        (this.currentEffects = void 0),
        (this.prevEffects = void 0),
        (this.currentDecoratorName = void 0),
        (this.hasUpdates = void 0),
        (this.currentContext = void 0),
        (this.renderListener = s((t) => {
          t === this.currentContext?.id &&
            (this.triggerEffects(), (this.currentContext = null), this.removeRenderListeners());
        }, 'renderListener')),
        this.init());
    }
    init() {
      ((this.hookListsMap = new WeakMap()),
        (this.mountedDecorators = new Set()),
        (this.prevMountedDecorators = new Set()),
        (this.currentHooks = []),
        (this.nextHookIndex = 0),
        (this.currentPhase = 'NONE'),
        (this.currentEffects = []),
        (this.prevEffects = []),
        (this.currentDecoratorName = null),
        (this.hasUpdates = !1),
        (this.currentContext = null));
    }
    clean() {
      (this.prevEffects.forEach((t) => {
        t.destroy && t.destroy();
      }),
        this.init(),
        this.removeRenderListeners());
    }
    getNextHook() {
      const t = this.currentHooks[this.nextHookIndex];
      return ((this.nextHookIndex += 1), t);
    }
    triggerEffects() {
      (this.prevEffects.forEach((t) => {
        !this.currentEffects.includes(t) && t.destroy && t.destroy();
      }),
        this.currentEffects.forEach((t) => {
          this.prevEffects.includes(t) || (t.destroy = t.create());
        }),
        (this.prevEffects = this.currentEffects),
        (this.currentEffects = []));
    }
    addRenderListeners() {
      (this.removeRenderListeners(), Ft.getChannel().on(ma, this.renderListener));
    }
    removeRenderListeners() {
      Ft.getChannel().removeListener(ma, this.renderListener);
    }
  };
s(aw, 'HooksContext');
var nf = aw;
function Ou(e) {
  const t = s((...r) => {
    const { hooks: n } = typeof r[0] == 'function' ? r[1] : r[0],
      o = n.currentPhase,
      i = n.currentHooks,
      a = n.nextHookIndex,
      c = n.currentDecoratorName;
    ((n.currentDecoratorName = e.name),
      n.prevMountedDecorators.has(e)
        ? ((n.currentPhase = 'UPDATE'), (n.currentHooks = n.hookListsMap.get(e) || []))
        : ((n.currentPhase = 'MOUNT'),
          (n.currentHooks = []),
          n.hookListsMap.set(e, n.currentHooks),
          n.prevMountedDecorators.add(e)),
      (n.nextHookIndex = 0));
    const d = te.STORYBOOK_HOOKS_CONTEXT;
    te.STORYBOOK_HOOKS_CONTEXT = n;
    const u = e(...r);
    if (((te.STORYBOOK_HOOKS_CONTEXT = d), n.currentPhase === 'UPDATE' && n.getNextHook() != null))
      throw new Error(
        'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.',
      );
    return (
      (n.currentPhase = o),
      (n.currentHooks = i),
      (n.nextHookIndex = a),
      (n.currentDecoratorName = c),
      u
    );
  }, 'hookified');
  return ((t.originalFn = e), t);
}
s(Ou, 'hookify');
var Xc = 0,
  pL = 25,
  lw = s(
    (e) => (t, r) => {
      const n = e(
        Ou(t),
        r.map((o) => Ou(o)),
      );
      return (o) => {
        const { hooks: i } = o;
        (i.prevMountedDecorators ?? (i.prevMountedDecorators = new Set()),
          (i.mountedDecorators = new Set([t, ...r])),
          (i.currentContext = o),
          (i.hasUpdates = !1));
        let a = n(o);
        for (Xc = 1; i.hasUpdates; )
          if (((i.hasUpdates = !1), (i.currentEffects = []), (a = n(o)), (Xc += 1), Xc > pL))
            throw new Error(
              'Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.',
            );
        return (i.addRenderListeners(), a);
      };
    },
    'applyHooks',
  ),
  fL = s((e, t) => e.length === t.length && e.every((r, n) => r === t[n]), 'areDepsEqual'),
  of = s(
    () =>
      new Error(
        'Storybook preview hooks can only be called inside decorators and story functions.',
      ),
    'invalidHooksError',
  );
function sf() {
  return te.STORYBOOK_HOOKS_CONTEXT || null;
}
s(sf, 'getHooksContextOrNull');
function Sl() {
  const e = sf();
  if (e == null) throw of();
  return e;
}
s(Sl, 'getHooksContextOrThrow');
function cw(e, t, r) {
  const n = Sl();
  if (n.currentPhase === 'MOUNT') {
    r != null &&
      !Array.isArray(r) &&
      ke.warn(
        `${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`,
      );
    const o = { name: e, deps: r };
    return (n.currentHooks.push(o), t(o), o);
  }
  if (n.currentPhase === 'UPDATE') {
    const o = n.getNextHook();
    if (o == null) throw new Error('Rendered more hooks than during the previous render.');
    return (
      o.name !== e &&
        ke.warn(
          `Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ''}. This will lead to bugs and errors if not fixed.`,
        ),
      r != null &&
        o.deps == null &&
        ke.warn(
          `${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`,
        ),
      r != null &&
        o.deps != null &&
        r.length !== o.deps.length &&
        ke.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${r}`),
      (r == null || o.deps == null || !fL(r, o.deps)) && (t(o), (o.deps = r)),
      o
    );
  }
  throw of();
}
s(cw, 'useHook');
function bi(e, t, r) {
  const { memoizedState: n } = cw(
    e,
    (o) => {
      o.memoizedState = t();
    },
    r,
  );
  return n;
}
s(bi, 'useMemoLike');
function af(e, t) {
  return bi('useMemo', e, t);
}
s(af, 'useMemo');
function yo(e, t) {
  return bi('useCallback', () => e, t);
}
s(yo, 'useCallback');
function lf(e, t) {
  return bi(e, () => ({ current: t }), []);
}
s(lf, 'useRefLike');
function uw(e) {
  return lf('useRef', e);
}
s(uw, 'useRef');
function dw() {
  const e = sf();
  if (e != null && e.currentPhase !== 'NONE') e.hasUpdates = !0;
  else
    try {
      Ft.getChannel().emit(kp);
    } catch {
      ke.warn('State updates of Storybook preview hooks work only in browser');
    }
}
s(dw, 'triggerUpdate');
function cf(e, t) {
  const r = lf(e, typeof t == 'function' ? t() : t),
    n = s((o) => {
      ((r.current = typeof o == 'function' ? o(r.current) : o), dw());
    }, 'setState');
  return [r.current, n];
}
s(cf, 'useStateLike');
function pw(e) {
  return cf('useState', e);
}
s(pw, 'useState');
function fw(e, t, r) {
  const n = r != null ? () => r(t) : t,
    [o, i] = cf('useReducer', n);
  return [o, s((c) => i((d) => e(d, c)), 'dispatch')];
}
s(fw, 'useReducer');
function Kr(e, t) {
  const r = Sl(),
    n = bi('useEffect', () => ({ create: e }), t);
  r.currentEffects.includes(n) || r.currentEffects.push(n);
}
s(Kr, 'useEffect');
function mw(e, t = []) {
  const r = Ft.getChannel();
  return (
    Kr(
      () => (
        Object.entries(e).forEach(([n, o]) => r.on(n, o)),
        () => {
          Object.entries(e).forEach(([n, o]) => r.removeListener(n, o));
        }
      ),
      [...Object.keys(e), ...t],
    ),
    yo(r.emit.bind(r), [r])
  );
}
s(mw, 'useChannel');
function vi() {
  const { currentContext: e } = Sl();
  if (e == null) throw of();
  return e;
}
s(vi, 'useStoryContext');
function yw(e, t) {
  const { parameters: r } = vi();
  if (e) return r[e] ?? t;
}
s(yw, 'useParameter');
function hw() {
  const e = Ft.getChannel(),
    { id: t, args: r } = vi(),
    n = yo((i) => e.emit(Bp, { storyId: t, updatedArgs: i }), [e, t]),
    o = yo((i) => e.emit(Dp, { storyId: t, argNames: i }), [e, t]);
  return [r, n, o];
}
s(hw, 'useArgs');
function gw() {
  const e = Ft.getChannel(),
    { globals: t } = vi(),
    r = yo((n) => e.emit(Fp, { globals: n }), [e]);
  return [t, r];
}
s(gw, 'useGlobals');
var mL = s(({ name: e, parameterName: t, wrapper: r, skipIfNoParametersOrOptions: n = !1 }) => {
  const o = s(
    (i) => (a, c) => {
      const d = c.parameters && c.parameters[t];
      return (d && d.disable) || (n && !i && !d) ? a(c) : r(a, c, { options: i, parameters: d });
    },
    'decorator',
  );
  return (...i) =>
    typeof i[0] == 'function'
      ? o()(...i)
      : (...a) => {
          if (a.length > 1) return i.length > 1 ? o(i)(...a) : o(...i)(...a);
          throw new Error(`Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`);
        };
}, 'makeDecorator');
function bw(e) {
  return e
    .replace(/_/g, ' ')
    .replace(/-/g, ' ')
    .replace(/\./g, ' ')
    .replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, o) => `${r} ${n}${o}`)
    .replace(/([a-z])([A-Z])/g, (t, r, n) => `${r} ${n}`)
    .replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`)
    .replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`)
    .replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`)
    .replace(/ +/g, ' ')
    .trim();
}
s(bw, 'toStartCaseStr');
var vg = Ge(Vq(), 1),
  vw = s((e) => e.map((t) => typeof t < 'u').filter(Boolean).length, 'count'),
  yL = s((e, t) => {
    const { exists: r, eq: n, neq: o, truthy: i } = e;
    if (vw([r, n, o, i]) > 1)
      throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: o })}`);
    if (typeof n < 'u') return (0, vg.isEqual)(t, n);
    if (typeof o < 'u') return !(0, vg.isEqual)(t, o);
    if (typeof r < 'u') {
      const c = typeof t < 'u';
      return r ? c : !c;
    }
    return (typeof i > 'u' ? !0 : i) ? !!t : !t;
  }, 'testValue'),
  hL = s((e, t, r) => {
    if (!e.if) return !0;
    const { arg: n, global: o } = e.if;
    if (vw([n, o]) !== 1)
      throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n, global: o })}`);
    const i = n ? t[n] : r[o];
    return yL(e.if, i);
  }, 'includeConditionalArg');
function Tw(e) {
  return e != null && Ew(e).includes('mount');
}
s(Tw, 'mountDestructured');
function Ew(e) {
  const t = e.toString().match(/[^(]*\(([^)]*)/);
  if (!t) return [];
  const r = Cu(t[1]);
  if (!r.length) return [];
  const n = r[0];
  return n.startsWith('{') && n.endsWith('}')
    ? Cu(n.slice(1, -1).replace(/\s/g, '')).map((i) => i.replace(/:.*|=.*/g, ''))
    : [];
}
s(Ew, 'getUsedProps');
function Cu(e) {
  const t = [],
    r = [];
  let n = 0;
  for (let i = 0; i < e.length; i++)
    if (e[i] === '{' || e[i] === '[') r.push(e[i] === '{' ? '}' : ']');
    else if (e[i] === r[r.length - 1]) r.pop();
    else if (!r.length && e[i] === ',') {
      const a = e.substring(n, i).trim();
      (a && t.push(a), (n = i + 1));
    }
  const o = e.substring(n).trim();
  return (o && t.push(o), t);
}
s(Cu, 'splitByComma');
var ww = {};
St(ww, { argsEnhancers: () => vL });
var Sw = s((e, t) => typeof t[e] > 'u' && !(e in t), 'isInInitialArgs'),
  gL = s((e) => {
    const {
      initialArgs: t,
      argTypes: r,
      id: n,
      parameters: { actions: o },
    } = e;
    if (!o || o.disable || !o.argTypesRegex || !r) return {};
    const i = new RegExp(o.argTypesRegex);
    return Object.entries(r)
      .filter(([c]) => !!i.test(c))
      .reduce((c, [d, u]) => (Sw(d, t) && (c[d] = Ho(d, { implicit: !0, id: n })), c), {});
  }, 'inferActionsFromArgTypesRegex'),
  bL = s((e) => {
    const {
      initialArgs: t,
      argTypes: r,
      parameters: { actions: n },
    } = e;
    return n?.disable || !r
      ? {}
      : Object.entries(r)
          .filter(([i, a]) => !!a.action)
          .reduce(
            (i, [a, c]) => (Sw(a, t) && (i[a] = Ho(typeof c.action == 'string' ? c.action : a)), i),
            {},
          );
  }, 'addActionsFromArgTypes'),
  vL = [bL, gL],
  _w = {};
St(_w, { loaders: () => qV });
var Aw = {};
St(Aw, {
  buildQueries: () => pU,
  clearAllMocks: () => wy,
  configure: () => fU,
  createEvent: () => mU,
  expect: () => CV,
  findAllByAltText: () => hU,
  findAllByDisplayValue: () => gU,
  findAllByLabelText: () => bU,
  findAllByPlaceholderText: () => vU,
  findAllByRole: () => TU,
  findAllByTestId: () => EU,
  findAllByText: () => wU,
  findAllByTitle: () => SU,
  findByAltText: () => _U,
  findByDisplayValue: () => AU,
  findByLabelText: () => RU,
  findByPlaceholderText: () => xU,
  findByRole: () => PU,
  findByTestId: () => OU,
  findByText: () => CU,
  findByTitle: () => IU,
  fireEvent: () => yU,
  fn: () => Ty,
  getAllByAltText: () => NU,
  getAllByDisplayValue: () => qU,
  getAllByLabelText: () => MU,
  getAllByPlaceholderText: () => jU,
  getAllByRole: () => $U,
  getAllByTestId: () => kU,
  getAllByText: () => DU,
  getAllByTitle: () => LU,
  getByAltText: () => FU,
  getByDisplayValue: () => BU,
  getByLabelText: () => JU,
  getByPlaceholderText: () => UU,
  getByRole: () => VU,
  getByTestId: () => HU,
  getByText: () => zU,
  getByTitle: () => GU,
  getConfig: () => WU,
  getDefaultNormalizer: () => KU,
  getElementError: () => YU,
  getNodeText: () => XU,
  getQueriesForElement: () => QU,
  getRoles: () => ZU,
  getSuggestedQuery: () => eV,
  isInaccessible: () => tV,
  isMockFunction: () => wn,
  logDOM: () => rV,
  logRoles: () => nV,
  mocked: () => HA,
  mocks: () => Mi,
  onMockCall: () => vy,
  prettyDOM: () => oV,
  prettyFormat: () => PV,
  queries: () => sV,
  queryAllByAltText: () => iV,
  queryAllByAttribute: () => aV,
  queryAllByDisplayValue: () => lV,
  queryAllByLabelText: () => cV,
  queryAllByPlaceholderText: () => uV,
  queryAllByRole: () => dV,
  queryAllByTestId: () => pV,
  queryAllByText: () => fV,
  queryAllByTitle: () => mV,
  queryByAltText: () => yV,
  queryByAttribute: () => hV,
  queryByDisplayValue: () => gV,
  queryByLabelText: () => bV,
  queryByPlaceholderText: () => vV,
  queryByRole: () => TV,
  queryByTestId: () => EV,
  queryByText: () => wV,
  queryByTitle: () => SV,
  queryHelpers: () => _V,
  resetAllMocks: () => Sy,
  restoreAllMocks: () => _y,
  sb: () => IV,
  screen: () => AV,
  spyOn: () => sJ,
  uninstrumentedUserEvent: () => kC,
  userEvent: () => OV,
  waitFor: () => RV,
  waitForElementToBeRemoved: () => xV,
  within: () => $C,
});
var TL = {
    reset: [0, 0],
    bold: [1, 22, '\x1B[22m\x1B[1m'],
    dim: [2, 22, '\x1B[22m\x1B[2m'],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBright: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
    bgBlackBright: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49],
  },
  Rw = Object.entries(TL);
function Ti(e) {
  return String(e);
}
s(Ti, 'a');
Ti.open = '';
Ti.close = '';
Rw.reduce((e, [t]) => ((e[t] = Ti), e), { isColorSupported: !1 });
function xw(e = !1) {
  let t = typeof process < 'u' ? process : void 0,
    r = t?.env || {},
    n = t?.argv || [];
  return (
    (!('NO_COLOR' in r || n.includes('--no-color')) &&
      ('FORCE_COLOR' in r ||
        n.includes('--color') ||
        t?.platform === 'win32' ||
        (e && r.TERM !== 'dumb') ||
        'CI' in r)) ||
    (typeof window < 'u' && !!window.chrome)
  );
}
s(xw, 'C');
function Pw(e = !1) {
  let t = xw(e),
    r = s((a, c, d, u) => {
      let p = '',
        f = 0;
      do ((p += a.substring(f, u) + d), (f = u + c.length), (u = a.indexOf(c, f)));
      while (~u);
      return p + a.substring(f);
    }, 'i'),
    n = s((a, c, d = a) => {
      let u = s((p) => {
        let f = String(p),
          m = f.indexOf(c, a.length);
        return ~m ? a + r(f, c, d, m) + c : a + f + c;
      }, 'o');
      return ((u.open = a), (u.close = c), u);
    }, 'g'),
    o = { isColorSupported: t },
    i = s((a) => `\x1B[${a}m`, 'd');
  for (let [a, c] of Rw) o[a] = t ? n(i(c[0]), i(c[1]), c[2]) : Ti;
  return o;
}
s(Pw, 'p');
var Ue = Pw();
function uf(e, t) {
  return (
    t.forEach(function (r) {
      r &&
        typeof r != 'string' &&
        !Array.isArray(r) &&
        Object.keys(r).forEach(function (n) {
          if (n !== 'default' && !(n in e)) {
            var o = Object.getOwnPropertyDescriptor(r, n);
            Object.defineProperty(
              e,
              n,
              o.get
                ? o
                : {
                    enumerable: !0,
                    get: s(function () {
                      return r[n];
                    }, 'get'),
                  },
            );
          }
        });
    }),
    Object.freeze(e)
  );
}
s(uf, '_mergeNamespaces');
function Ow(e, t) {
  const r = Object.keys(e),
    n = t === null ? r : r.sort(t);
  if (Object.getOwnPropertySymbols)
    for (const o of Object.getOwnPropertySymbols(e))
      Object.getOwnPropertyDescriptor(e, o).enumerable && n.push(o);
  return n;
}
s(Ow, 'getKeysOfEnumerableProperties');
function Mo(e, t, r, n, o, i, a = ': ') {
  let c = '',
    d = 0,
    u = e.next();
  if (!u.done) {
    c += t.spacingOuter;
    const p = r + t.indent;
    for (; !u.done; ) {
      if (((c += p), d++ === t.maxWidth)) {
        c += '';
        break;
      }
      const f = i(u.value[0], t, p, n, o),
        m = i(u.value[1], t, p, n, o);
      ((c += f + a + m),
        (u = e.next()),
        u.done ? t.min || (c += ',') : (c += `,${t.spacingInner}`));
    }
    c += t.spacingOuter + r;
  }
  return c;
}
s(Mo, 'printIteratorEntries');
function _l(e, t, r, n, o, i) {
  let a = '',
    c = 0,
    d = e.next();
  if (!d.done) {
    a += t.spacingOuter;
    const u = r + t.indent;
    for (; !d.done; ) {
      if (((a += u), c++ === t.maxWidth)) {
        a += '';
        break;
      }
      ((a += i(d.value, t, u, n, o)),
        (d = e.next()),
        d.done ? t.min || (a += ',') : (a += `,${t.spacingInner}`));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
s(_l, 'printIteratorValues');
function Gs(e, t, r, n, o, i) {
  let a = '';
  e = e instanceof ArrayBuffer ? new DataView(e) : e;
  const c = s((u) => u instanceof DataView, 'isDataView'),
    d = c(e) ? e.byteLength : e.length;
  if (d > 0) {
    a += t.spacingOuter;
    const u = r + t.indent;
    for (let p = 0; p < d; p++) {
      if (((a += u), p === t.maxWidth)) {
        a += '';
        break;
      }
      ((c(e) || p in e) && (a += i(c(e) ? e.getInt8(p) : e[p], t, u, n, o)),
        p < d - 1 ? (a += `,${t.spacingInner}`) : t.min || (a += ','));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
s(Gs, 'printListItems');
function Al(e, t, r, n, o, i) {
  let a = '';
  const c = Ow(e, t.compareKeys);
  if (c.length > 0) {
    a += t.spacingOuter;
    const d = r + t.indent;
    for (let u = 0; u < c.length; u++) {
      const p = c[u],
        f = i(p, t, d, n, o),
        m = i(e[p], t, d, n, o);
      ((a += `${d + f}: ${m}`),
        u < c.length - 1 ? (a += `,${t.spacingInner}`) : t.min || (a += ','));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
s(Al, 'printObjectProperties');
var EL = typeof Symbol == 'function' && Symbol.for ? Symbol.for('jest.asymmetricMatcher') : 1267621,
  Fi = ' ',
  wL = s((e, t, r, n, o, i) => {
    const a = e.toString();
    if (a === 'ArrayContaining' || a === 'ArrayNotContaining')
      return ++n > t.maxDepth ? `[${a}]` : `${a + Fi}[${Gs(e.sample, t, r, n, o, i)}]`;
    if (a === 'ObjectContaining' || a === 'ObjectNotContaining')
      return ++n > t.maxDepth ? `[${a}]` : `${a + Fi}{${Al(e.sample, t, r, n, o, i)}}`;
    if (
      a === 'StringMatching' ||
      a === 'StringNotMatching' ||
      a === 'StringContaining' ||
      a === 'StringNotContaining'
    )
      return a + Fi + i(e.sample, t, r, n, o);
    if (typeof e.toAsymmetricMatcher != 'function')
      throw new TypeError(
        `Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`,
      );
    return e.toAsymmetricMatcher();
  }, 'serialize$5'),
  SL = s((e) => e && e.$$typeof === EL, 'test$5'),
  _L = { serialize: wL, test: SL },
  AL = ' ',
  Cw = new Set(['DOMStringMap', 'NamedNodeMap']),
  RL = /^(?:HTML\w*Collection|NodeList)$/;
function Iw(e) {
  return Cw.has(e) || RL.test(e);
}
s(Iw, 'testName');
var xL = s((e) => e && e.constructor && !!e.constructor.name && Iw(e.constructor.name), 'test$4');
function Nw(e) {
  return e.constructor.name === 'NamedNodeMap';
}
s(Nw, 'isNamedNodeMap');
var PL = s((e, t, r, n, o, i) => {
    const a = e.constructor.name;
    return ++n > t.maxDepth
      ? `[${a}]`
      : (t.min ? '' : a + AL) +
          (Cw.has(a)
            ? `{${Al(Nw(e) ? [...e].reduce((c, d) => ((c[d.name] = d.value), c), {}) : { ...e }, t, r, n, o, i)}}`
            : `[${Gs([...e], t, r, n, o, i)}]`);
  }, 'serialize$4'),
  OL = { serialize: PL, test: xL };
function df(e) {
  return e.replaceAll('<', '&lt;').replaceAll('>', '&gt;');
}
s(df, 'escapeHTML');
function Rl(e, t, r, n, o, i, a) {
  const c = n + r.indent,
    d = r.colors;
  return e
    .map((u) => {
      const p = t[u];
      let f = a(p, r, c, o, i);
      return (
        typeof p != 'string' &&
          (f.includes(`
`) && (f = r.spacingOuter + c + f + r.spacingOuter + n),
          (f = `{${f}}`)),
        `${r.spacingInner + n + d.prop.open + u + d.prop.close}=${d.value.open}${f}${d.value.close}`
      );
    })
    .join('');
}
s(Rl, 'printProps');
function xl(e, t, r, n, o, i) {
  return e
    .map((a) => t.spacingOuter + r + (typeof a == 'string' ? pf(a, t) : i(a, t, r, n, o)))
    .join('');
}
s(xl, 'printChildren');
function pf(e, t) {
  const r = t.colors.content;
  return r.open + df(e) + r.close;
}
s(pf, 'printText');
function qw(e, t) {
  const r = t.colors.comment;
  return `${r.open}<!--${df(e)}-->${r.close}`;
}
s(qw, 'printComment');
function Pl(e, t, r, n, o) {
  const i = n.colors.tag;
  return `${i.open}<${e}${t && i.close + t + n.spacingOuter + o + i.open}${r ? `>${i.close}${r}${n.spacingOuter}${o}${i.open}</${e}` : `${t && !n.min ? '' : ' '}/`}>${i.close}`;
}
s(Pl, 'printElement');
function Ol(e, t) {
  const r = t.colors.tag;
  return `${r.open}<${e}${r.close} ${r.open} />${r.close}`;
}
s(Ol, 'printElementAsLeaf');
var CL = 1,
  Mw = 3,
  jw = 8,
  $w = 11,
  IL = /^(?:(?:HTML|SVG)\w*)?Element$/;
function kw(e) {
  try {
    return typeof e.hasAttribute == 'function' && e.hasAttribute('is');
  } catch {
    return !1;
  }
}
s(kw, 'testHasAttribute');
function Dw(e) {
  const t = e.constructor.name,
    { nodeType: r, tagName: n } = e,
    o = (typeof n == 'string' && n.includes('-')) || kw(e);
  return (
    (r === CL && (IL.test(t) || o)) ||
    (r === Mw && t === 'Text') ||
    (r === jw && t === 'Comment') ||
    (r === $w && t === 'DocumentFragment')
  );
}
s(Dw, 'testNode');
var NL = s((e) => {
  var t;
  return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && Dw(e);
}, 'test$3');
function Lw(e) {
  return e.nodeType === Mw;
}
s(Lw, 'nodeIsText');
function Fw(e) {
  return e.nodeType === jw;
}
s(Fw, 'nodeIsComment');
function Ki(e) {
  return e.nodeType === $w;
}
s(Ki, 'nodeIsFragment');
var qL = s((e, t, r, n, o, i) => {
    if (Lw(e)) return pf(e.data, t);
    if (Fw(e)) return qw(e.data, t);
    const a = Ki(e) ? 'DocumentFragment' : e.tagName.toLowerCase();
    return ++n > t.maxDepth
      ? Ol(a, t)
      : Pl(
          a,
          Rl(
            Ki(e) ? [] : Array.from(e.attributes, (c) => c.name).sort(),
            Ki(e) ? {} : [...e.attributes].reduce((c, d) => ((c[d.name] = d.value), c), {}),
            t,
            r + t.indent,
            n,
            o,
            i,
          ),
          xl(Array.prototype.slice.call(e.childNodes || e.children), t, r + t.indent, n, o, i),
          t,
          r,
        );
  }, 'serialize$3'),
  ML = { serialize: qL, test: NL },
  jL = '@@__IMMUTABLE_ITERABLE__@@',
  $L = '@@__IMMUTABLE_LIST__@@',
  kL = '@@__IMMUTABLE_KEYED__@@',
  DL = '@@__IMMUTABLE_MAP__@@',
  Tg = '@@__IMMUTABLE_ORDERED__@@',
  LL = '@@__IMMUTABLE_RECORD__@@',
  FL = '@@__IMMUTABLE_SEQ__@@',
  BL = '@@__IMMUTABLE_SET__@@',
  JL = '@@__IMMUTABLE_STACK__@@',
  ho = s((e) => `Immutable.${e}`, 'getImmutableName'),
  Cl = s((e) => `[${e}]`, 'printAsLeaf'),
  Ws = ' ',
  Eg = '';
function Bw(e, t, r, n, o, i, a) {
  return ++n > t.maxDepth ? Cl(ho(a)) : `${ho(a) + Ws}{${Mo(e.entries(), t, r, n, o, i)}}`;
}
s(Bw, 'printImmutableEntries');
function Jw(e) {
  let t = 0;
  return {
    next() {
      if (t < e._keys.length) {
        const r = e._keys[t++];
        return { done: !1, value: [r, e.get(r)] };
      }
      return { done: !0, value: void 0 };
    },
  };
}
s(Jw, 'getRecordEntries');
function Uw(e, t, r, n, o, i) {
  const a = ho(e._name || 'Record');
  return ++n > t.maxDepth ? Cl(a) : `${a + Ws}{${Mo(Jw(e), t, r, n, o, i)}}`;
}
s(Uw, 'printImmutableRecord');
function Vw(e, t, r, n, o, i) {
  const a = ho('Seq');
  return ++n > t.maxDepth
    ? Cl(a)
    : e[kL]
      ? `${a + Ws}{${e._iter || e._object ? Mo(e.entries(), t, r, n, o, i) : Eg}}`
      : `${a + Ws}[${e._iter || e._array || e._collection || e._iterable ? _l(e.values(), t, r, n, o, i) : Eg}]`;
}
s(Vw, 'printImmutableSeq');
function Yi(e, t, r, n, o, i, a) {
  return ++n > t.maxDepth ? Cl(ho(a)) : `${ho(a) + Ws}[${_l(e.values(), t, r, n, o, i)}]`;
}
s(Yi, 'printImmutableValues');
var UL = s(
    (e, t, r, n, o, i) =>
      e[DL]
        ? Bw(e, t, r, n, o, i, e[Tg] ? 'OrderedMap' : 'Map')
        : e[$L]
          ? Yi(e, t, r, n, o, i, 'List')
          : e[BL]
            ? Yi(e, t, r, n, o, i, e[Tg] ? 'OrderedSet' : 'Set')
            : e[JL]
              ? Yi(e, t, r, n, o, i, 'Stack')
              : e[FL]
                ? Vw(e, t, r, n, o, i)
                : Uw(e, t, r, n, o, i),
    'serialize$2',
  ),
  VL = s((e) => e && (e[jL] === !0 || e[LL] === !0), 'test$2'),
  HL = { serialize: UL, test: VL };
function ff(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
s(ff, 'getDefaultExportFromCjs');
var Qc = { exports: {} },
  Ie = {},
  wg;
function Hw() {
  if (wg) return Ie;
  wg = 1;
  var e = Symbol.for('react.transitional.element'),
    t = Symbol.for('react.portal'),
    r = Symbol.for('react.fragment'),
    n = Symbol.for('react.strict_mode'),
    o = Symbol.for('react.profiler'),
    i = Symbol.for('react.consumer'),
    a = Symbol.for('react.context'),
    c = Symbol.for('react.forward_ref'),
    d = Symbol.for('react.suspense'),
    u = Symbol.for('react.suspense_list'),
    p = Symbol.for('react.memo'),
    f = Symbol.for('react.lazy'),
    m = Symbol.for('react.view_transition'),
    h = Symbol.for('react.client.reference');
  function g(v) {
    if (typeof v == 'object' && v !== null) {
      var E = v.$$typeof;
      switch (E) {
        case e:
          switch (((v = v.type), v)) {
            case r:
            case o:
            case n:
            case d:
            case u:
            case m:
              return v;
            default:
              switch (((v = v && v.$$typeof), v)) {
                case a:
                case c:
                case f:
                case p:
                  return v;
                case i:
                  return v;
                default:
                  return E;
              }
          }
        case t:
          return E;
      }
    }
  }
  return (
    s(g, 'typeOf'),
    (Ie.ContextConsumer = i),
    (Ie.ContextProvider = a),
    (Ie.Element = e),
    (Ie.ForwardRef = c),
    (Ie.Fragment = r),
    (Ie.Lazy = f),
    (Ie.Memo = p),
    (Ie.Portal = t),
    (Ie.Profiler = o),
    (Ie.StrictMode = n),
    (Ie.Suspense = d),
    (Ie.SuspenseList = u),
    (Ie.isContextConsumer = function (v) {
      return g(v) === i;
    }),
    (Ie.isContextProvider = function (v) {
      return g(v) === a;
    }),
    (Ie.isElement = function (v) {
      return typeof v == 'object' && v !== null && v.$$typeof === e;
    }),
    (Ie.isForwardRef = function (v) {
      return g(v) === c;
    }),
    (Ie.isFragment = function (v) {
      return g(v) === r;
    }),
    (Ie.isLazy = function (v) {
      return g(v) === f;
    }),
    (Ie.isMemo = function (v) {
      return g(v) === p;
    }),
    (Ie.isPortal = function (v) {
      return g(v) === t;
    }),
    (Ie.isProfiler = function (v) {
      return g(v) === o;
    }),
    (Ie.isStrictMode = function (v) {
      return g(v) === n;
    }),
    (Ie.isSuspense = function (v) {
      return g(v) === d;
    }),
    (Ie.isSuspenseList = function (v) {
      return g(v) === u;
    }),
    (Ie.isValidElementType = function (v) {
      return (
        typeof v == 'string' ||
        typeof v == 'function' ||
        v === r ||
        v === o ||
        v === n ||
        v === d ||
        v === u ||
        (typeof v == 'object' &&
          v !== null &&
          (v.$$typeof === f ||
            v.$$typeof === p ||
            v.$$typeof === a ||
            v.$$typeof === i ||
            v.$$typeof === c ||
            v.$$typeof === h ||
            v.getModuleId !== void 0))
      );
    }),
    (Ie.typeOf = g),
    Ie
  );
}
s(Hw, 'requireReactIs_production');
var Sg;
function zw() {
  return (Sg || ((Sg = 1), (Qc.exports = Hw())), Qc.exports);
}
s(zw, 'requireReactIs$1');
var Gw = zw(),
  zL = ff(Gw),
  GL = uf({ __proto__: null, default: zL }, [Gw]),
  Zc = { exports: {} },
  Oe = {},
  _g;
function Ww() {
  if (_g) return Oe;
  _g = 1;
  var e = Symbol.for('react.element'),
    t = Symbol.for('react.portal'),
    r = Symbol.for('react.fragment'),
    n = Symbol.for('react.strict_mode'),
    o = Symbol.for('react.profiler'),
    i = Symbol.for('react.provider'),
    a = Symbol.for('react.context'),
    c = Symbol.for('react.server_context'),
    d = Symbol.for('react.forward_ref'),
    u = Symbol.for('react.suspense'),
    p = Symbol.for('react.suspense_list'),
    f = Symbol.for('react.memo'),
    m = Symbol.for('react.lazy'),
    h = Symbol.for('react.offscreen'),
    g;
  g = Symbol.for('react.module.reference');
  function v(E) {
    if (typeof E == 'object' && E !== null) {
      var b = E.$$typeof;
      switch (b) {
        case e:
          switch (((E = E.type), E)) {
            case r:
            case o:
            case n:
            case u:
            case p:
              return E;
            default:
              switch (((E = E && E.$$typeof), E)) {
                case c:
                case a:
                case d:
                case m:
                case f:
                case i:
                  return E;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return (
    s(v, 'v'),
    (Oe.ContextConsumer = a),
    (Oe.ContextProvider = i),
    (Oe.Element = e),
    (Oe.ForwardRef = d),
    (Oe.Fragment = r),
    (Oe.Lazy = m),
    (Oe.Memo = f),
    (Oe.Portal = t),
    (Oe.Profiler = o),
    (Oe.StrictMode = n),
    (Oe.Suspense = u),
    (Oe.SuspenseList = p),
    (Oe.isAsyncMode = function () {
      return !1;
    }),
    (Oe.isConcurrentMode = function () {
      return !1;
    }),
    (Oe.isContextConsumer = function (E) {
      return v(E) === a;
    }),
    (Oe.isContextProvider = function (E) {
      return v(E) === i;
    }),
    (Oe.isElement = function (E) {
      return typeof E == 'object' && E !== null && E.$$typeof === e;
    }),
    (Oe.isForwardRef = function (E) {
      return v(E) === d;
    }),
    (Oe.isFragment = function (E) {
      return v(E) === r;
    }),
    (Oe.isLazy = function (E) {
      return v(E) === m;
    }),
    (Oe.isMemo = function (E) {
      return v(E) === f;
    }),
    (Oe.isPortal = function (E) {
      return v(E) === t;
    }),
    (Oe.isProfiler = function (E) {
      return v(E) === o;
    }),
    (Oe.isStrictMode = function (E) {
      return v(E) === n;
    }),
    (Oe.isSuspense = function (E) {
      return v(E) === u;
    }),
    (Oe.isSuspenseList = function (E) {
      return v(E) === p;
    }),
    (Oe.isValidElementType = function (E) {
      return (
        typeof E == 'string' ||
        typeof E == 'function' ||
        E === r ||
        E === o ||
        E === n ||
        E === u ||
        E === p ||
        E === h ||
        (typeof E == 'object' &&
          E !== null &&
          (E.$$typeof === m ||
            E.$$typeof === f ||
            E.$$typeof === i ||
            E.$$typeof === a ||
            E.$$typeof === d ||
            E.$$typeof === g ||
            E.getModuleId !== void 0))
      );
    }),
    (Oe.typeOf = v),
    Oe
  );
}
s(Ww, 'requireReactIs_production_min');
var Ag;
function Kw() {
  return (Ag || ((Ag = 1), (Zc.exports = Ww())), Zc.exports);
}
s(Kw, 'requireReactIs');
var Yw = Kw(),
  WL = ff(Yw),
  KL = uf({ __proto__: null, default: WL }, [Yw]),
  YL = [
    'isAsyncMode',
    'isConcurrentMode',
    'isContextConsumer',
    'isContextProvider',
    'isElement',
    'isForwardRef',
    'isFragment',
    'isLazy',
    'isMemo',
    'isPortal',
    'isProfiler',
    'isStrictMode',
    'isSuspense',
    'isSuspenseList',
    'isValidElementType',
  ],
  pn = Object.fromEntries(YL.map((e) => [e, (t) => KL[e](t) || GL[e](t)]));
function mf(e, t = []) {
  if (Array.isArray(e)) for (const r of e) mf(r, t);
  else e != null && e !== !1 && e !== '' && t.push(e);
  return t;
}
s(mf, 'getChildren');
function Iu(e) {
  const t = e.type;
  if (typeof t == 'string') return t;
  if (typeof t == 'function') return t.displayName || t.name || 'Unknown';
  if (pn.isFragment(e)) return 'React.Fragment';
  if (pn.isSuspense(e)) return 'React.Suspense';
  if (typeof t == 'object' && t !== null) {
    if (pn.isContextProvider(e)) return 'Context.Provider';
    if (pn.isContextConsumer(e)) return 'Context.Consumer';
    if (pn.isForwardRef(e)) {
      if (t.displayName) return t.displayName;
      const r = t.render.displayName || t.render.name || '';
      return r === '' ? 'ForwardRef' : `ForwardRef(${r})`;
    }
    if (pn.isMemo(e)) {
      const r = t.displayName || t.type.displayName || t.type.name || '';
      return r === '' ? 'Memo' : `Memo(${r})`;
    }
  }
  return 'UNDEFINED';
}
s(Iu, 'getType');
function Xw(e) {
  const { props: t } = e;
  return Object.keys(t)
    .filter((r) => r !== 'children' && t[r] !== void 0)
    .sort();
}
s(Xw, 'getPropKeys$1');
var XL = s(
    (e, t, r, n, o, i) =>
      ++n > t.maxDepth
        ? Ol(Iu(e), t)
        : Pl(
            Iu(e),
            Rl(Xw(e), e.props, t, r + t.indent, n, o, i),
            xl(mf(e.props.children), t, r + t.indent, n, o, i),
            t,
            r,
          ),
    'serialize$1',
  ),
  QL = s((e) => e != null && pn.isElement(e), 'test$1'),
  ZL = { serialize: XL, test: QL },
  eF = typeof Symbol == 'function' && Symbol.for ? Symbol.for('react.test.json') : 245830487;
function Qw(e) {
  const { props: t } = e;
  return t
    ? Object.keys(t)
        .filter((r) => t[r] !== void 0)
        .sort()
    : [];
}
s(Qw, 'getPropKeys');
var tF = s(
    (e, t, r, n, o, i) =>
      ++n > t.maxDepth
        ? Ol(e.type, t)
        : Pl(
            e.type,
            e.props ? Rl(Qw(e), e.props, t, r + t.indent, n, o, i) : '',
            e.children ? xl(e.children, t, r + t.indent, n, o, i) : '',
            t,
            r,
          ),
    'serialize',
  ),
  rF = s((e) => e && e.$$typeof === eF, 'test'),
  nF = { serialize: tF, test: rF },
  Zw = Object.prototype.toString,
  oF = Date.prototype.toISOString,
  sF = Error.prototype.toString,
  Rg = RegExp.prototype.toString;
function qs(e) {
  return (typeof e.constructor == 'function' && e.constructor.name) || 'Object';
}
s(qs, 'getConstructorName');
function eS(e) {
  return typeof window < 'u' && e === window;
}
s(eS, 'isWindow');
var iF = /^Symbol\((.*)\)(.*)$/,
  aF = /\n/g,
  tS = class extends Error {
    constructor(t, r) {
      (super(t), (this.stack = r), (this.name = this.constructor.name));
    }
  };
s(tS, 'PrettyFormatPluginError');
var rS = tS;
function nS(e) {
  return (
    e === '[object Array]' ||
    e === '[object ArrayBuffer]' ||
    e === '[object DataView]' ||
    e === '[object Float32Array]' ||
    e === '[object Float64Array]' ||
    e === '[object Int8Array]' ||
    e === '[object Int16Array]' ||
    e === '[object Int32Array]' ||
    e === '[object Uint8Array]' ||
    e === '[object Uint8ClampedArray]' ||
    e === '[object Uint16Array]' ||
    e === '[object Uint32Array]'
  );
}
s(nS, 'isToStringedArrayType');
function oS(e) {
  return Object.is(e, -0) ? '-0' : String(e);
}
s(oS, 'printNumber');
function sS(e) {
  return `${e}n`;
}
s(sS, 'printBigInt');
function Nu(e, t) {
  return t ? `[Function ${e.name || 'anonymous'}]` : '[Function]';
}
s(Nu, 'printFunction');
function qu(e) {
  return String(e).replace(iF, 'Symbol($1)');
}
s(qu, 'printSymbol');
function Mu(e) {
  return `[${sF.call(e)}]`;
}
s(Mu, 'printError');
function yf(e, t, r, n) {
  if (e === !0 || e === !1) return `${e}`;
  if (e === void 0) return 'undefined';
  if (e === null) return 'null';
  const o = typeof e;
  if (o === 'number') return oS(e);
  if (o === 'bigint') return sS(e);
  if (o === 'string') return n ? `"${e.replaceAll(/"|\\/g, '\\$&')}"` : `"${e}"`;
  if (o === 'function') return Nu(e, t);
  if (o === 'symbol') return qu(e);
  const i = Zw.call(e);
  return i === '[object WeakMap]'
    ? 'WeakMap {}'
    : i === '[object WeakSet]'
      ? 'WeakSet {}'
      : i === '[object Function]' || i === '[object GeneratorFunction]'
        ? Nu(e, t)
        : i === '[object Symbol]'
          ? qu(e)
          : i === '[object Date]'
            ? Number.isNaN(+e)
              ? 'Date { NaN }'
              : oF.call(e)
            : i === '[object Error]'
              ? Mu(e)
              : i === '[object RegExp]'
                ? r
                  ? Rg.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, '\\$&')
                  : Rg.call(e)
                : e instanceof Error
                  ? Mu(e)
                  : null;
}
s(yf, 'printBasicValue');
function hf(e, t, r, n, o, i) {
  if (o.includes(e)) return '[Circular]';
  ((o = [...o]), o.push(e));
  const a = ++n > t.maxDepth,
    c = t.min;
  if (t.callToJSON && !a && e.toJSON && typeof e.toJSON == 'function' && !i)
    return wr(e.toJSON(), t, r, n, o, !0);
  const d = Zw.call(e);
  return d === '[object Arguments]'
    ? a
      ? '[Arguments]'
      : `${c ? '' : 'Arguments '}[${Gs(e, t, r, n, o, wr)}]`
    : nS(d)
      ? a
        ? `[${e.constructor.name}]`
        : `${c || (!t.printBasicPrototype && e.constructor.name === 'Array') ? '' : `${e.constructor.name} `}[${Gs(e, t, r, n, o, wr)}]`
      : d === '[object Map]'
        ? a
          ? '[Map]'
          : `Map {${Mo(e.entries(), t, r, n, o, wr, ' => ')}}`
        : d === '[object Set]'
          ? a
            ? '[Set]'
            : `Set {${_l(e.values(), t, r, n, o, wr)}}`
          : a || eS(e)
            ? `[${qs(e)}]`
            : `${c || (!t.printBasicPrototype && qs(e) === 'Object') ? '' : `${qs(e)} `}{${Al(e, t, r, n, o, wr)}}`;
}
s(hf, 'printComplexValue');
var lF = {
  test: s((e) => e && e instanceof Error, 'test'),
  serialize(e, t, r, n, o, i) {
    if (o.includes(e)) return '[Circular]';
    o = [...o, e];
    const a = ++n > t.maxDepth,
      { message: c, cause: d, ...u } = e,
      p = {
        message: c,
        ...(typeof d < 'u' ? { cause: d } : {}),
        ...(e instanceof AggregateError ? { errors: e.errors } : {}),
        ...u,
      },
      f = e.name !== 'Error' ? e.name : qs(e);
    return a ? `[${f}]` : `${f} {${Mo(Object.entries(p).values(), t, r, n, o, i)}}`;
  },
};
function iS(e) {
  return e.serialize != null;
}
s(iS, 'isNewPlugin');
function gf(e, t, r, n, o, i) {
  let a;
  try {
    a = iS(e)
      ? e.serialize(t, r, n, o, i, wr)
      : e.print(
          t,
          (c) => wr(c, r, n, o, i),
          (c) => {
            const d = n + r.indent;
            return (
              d +
              c.replaceAll(
                aF,
                `
${d}`,
              )
            );
          },
          { edgeSpacing: r.spacingOuter, min: r.min, spacing: r.spacingInner },
          r.colors,
        );
  } catch (c) {
    throw new rS(c.message, c.stack);
  }
  if (typeof a != 'string')
    throw new TypeError(
      `pretty-format: Plugin must return type "string" but instead returned "${typeof a}".`,
    );
  return a;
}
s(gf, 'printPlugin');
function bf(e, t) {
  for (const r of e)
    try {
      if (r.test(t)) return r;
    } catch (n) {
      throw new rS(n.message, n.stack);
    }
  return null;
}
s(bf, 'findPlugin');
function wr(e, t, r, n, o, i) {
  const a = bf(t.plugins, e);
  if (a !== null) return gf(a, e, t, r, n, o);
  const c = yf(e, t.printFunctionName, t.escapeRegex, t.escapeString);
  return c !== null ? c : hf(e, t, r, n, o, i);
}
s(wr, 'printer');
var vf = { comment: 'gray', content: 'reset', prop: 'yellow', tag: 'cyan', value: 'green' },
  aS = Object.keys(vf),
  zt = {
    callToJSON: !0,
    compareKeys: void 0,
    escapeRegex: !1,
    escapeString: !0,
    highlight: !1,
    indent: 2,
    maxDepth: Number.POSITIVE_INFINITY,
    maxWidth: Number.POSITIVE_INFINITY,
    min: !1,
    plugins: [],
    printBasicPrototype: !0,
    printFunctionName: !0,
    theme: vf,
  };
function lS(e) {
  for (const t of Object.keys(e))
    if (!Object.prototype.hasOwnProperty.call(zt, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  if (e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
s(lS, 'validateOptions');
function cS() {
  return aS.reduce((e, t) => {
    const r = vf[t],
      n = r && Ue[r];
    if (n && typeof n.close == 'string' && typeof n.open == 'string') e[t] = n;
    else
      throw new Error(
        `pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`,
      );
    return e;
  }, Object.create(null));
}
s(cS, 'getColorsHighlight');
function uS() {
  return aS.reduce((e, t) => ((e[t] = { close: '', open: '' }), e), Object.create(null));
}
s(uS, 'getColorsEmpty');
function Tf(e) {
  return e?.printFunctionName ?? zt.printFunctionName;
}
s(Tf, 'getPrintFunctionName');
function Ef(e) {
  return e?.escapeRegex ?? zt.escapeRegex;
}
s(Ef, 'getEscapeRegex');
function wf(e) {
  return e?.escapeString ?? zt.escapeString;
}
s(wf, 'getEscapeString');
function ju(e) {
  return {
    callToJSON: e?.callToJSON ?? zt.callToJSON,
    colors: e?.highlight ? cS() : uS(),
    compareKeys:
      typeof e?.compareKeys == 'function' || e?.compareKeys === null
        ? e.compareKeys
        : zt.compareKeys,
    escapeRegex: Ef(e),
    escapeString: wf(e),
    indent: e?.min ? '' : dS(e?.indent ?? zt.indent),
    maxDepth: e?.maxDepth ?? zt.maxDepth,
    maxWidth: e?.maxWidth ?? zt.maxWidth,
    min: e?.min ?? zt.min,
    plugins: e?.plugins ?? zt.plugins,
    printBasicPrototype: e?.printBasicPrototype ?? !0,
    printFunctionName: Tf(e),
    spacingInner: e?.min
      ? ' '
      : `
`,
    spacingOuter: e?.min
      ? ''
      : `
`,
  };
}
s(ju, 'getConfig');
function dS(e) {
  return Array.from({ length: e + 1 }).join(' ');
}
s(dS, 'createIndent');
function Wt(e, t) {
  if (t && (lS(t), t.plugins)) {
    const n = bf(t.plugins, e);
    if (n !== null) return gf(n, e, ju(t), '', 0, []);
  }
  const r = yf(e, Tf(t), Ef(t), wf(t));
  return r !== null ? r : hf(e, ju(t), '', 0, []);
}
s(Wt, 'format');
var Sf = {
    AsymmetricMatcher: _L,
    DOMCollection: OL,
    DOMElement: ML,
    Immutable: HL,
    ReactElement: ZL,
    ReactTestComponent: nF,
    Error: lF,
  },
  xg = {
    bold: ['1', '22'],
    dim: ['2', '22'],
    italic: ['3', '23'],
    underline: ['4', '24'],
    inverse: ['7', '27'],
    hidden: ['8', '28'],
    strike: ['9', '29'],
    black: ['30', '39'],
    red: ['31', '39'],
    green: ['32', '39'],
    yellow: ['33', '39'],
    blue: ['34', '39'],
    magenta: ['35', '39'],
    cyan: ['36', '39'],
    white: ['37', '39'],
    brightblack: ['30;1', '39'],
    brightred: ['31;1', '39'],
    brightgreen: ['32;1', '39'],
    brightyellow: ['33;1', '39'],
    brightblue: ['34;1', '39'],
    brightmagenta: ['35;1', '39'],
    brightcyan: ['36;1', '39'],
    brightwhite: ['37;1', '39'],
    grey: ['90', '39'],
  },
  cF = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red',
  },
  go = '';
function pS(e, t) {
  const r = xg[cF[t]] || xg[t] || '';
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
s(pS, 'colorise');
function fS(
  {
    showHidden: e = !1,
    depth: t = 2,
    colors: r = !1,
    customInspect: n = !0,
    showProxy: o = !1,
    maxArrayLength: i = 1 / 0,
    breakLength: a = 1 / 0,
    seen: c = [],
    truncate: d = 1 / 0,
    stylize: u = String,
  } = {},
  p,
) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!o,
    maxArrayLength: Number(i),
    breakLength: Number(a),
    truncate: Number(d),
    seen: c,
    inspect: p,
    stylize: u,
  };
  return (f.colors && (f.stylize = pS), f);
}
s(fS, 'normaliseOptions');
function mS(e) {
  return e >= '\uD800' && e <= '\uDBFF';
}
s(mS, 'isHighSurrogate');
function Nr(e, t, r = go) {
  e = String(e);
  const n = r.length,
    o = e.length;
  if (n > t && o > n) return r;
  if (o > t && o > n) {
    let i = t - n;
    return (i > 0 && mS(e[i - 1]) && (i = i - 1), `${e.slice(0, i)}${r}`);
  }
  return e;
}
s(Nr, 'truncate');
function Bt(e, t, r, n = ', ') {
  r = r || t.inspect;
  const o = e.length;
  if (o === 0) return '';
  const i = t.truncate;
  let a = '',
    c = '',
    d = '';
  for (let u = 0; u < o; u += 1) {
    const p = u + 1 === e.length,
      f = u + 2 === e.length;
    d = `${go}(${e.length - u})`;
    const m = e[u];
    t.truncate = i - a.length - (p ? 0 : n.length);
    const h = c || r(m, t) + (p ? '' : n),
      g = a.length + h.length,
      v = g + d.length;
    if (
      (p && g > i && a.length + d.length <= i) ||
      (!p && !f && v > i) ||
      ((c = p ? '' : r(e[u + 1], t) + (f ? '' : n)), !p && f && v > i && g + c.length > i)
    )
      break;
    if (((a += h), !p && !f && g + c.length >= i)) {
      d = `${go}(${e.length - u - 1})`;
      break;
    }
    d = '';
  }
  return `${a}${d}`;
}
s(Bt, 'inspectList');
function yS(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
    ? e
    : JSON.stringify(e)
        .replace(/'/g, "\\'")
        .replace(/\\"/g, '"')
        .replace(/(^"|"$)/g, "'");
}
s(yS, 'quoteComplexKey');
function bo([e, t], r) {
  return (
    (r.truncate -= 2),
    typeof e == 'string' ? (e = yS(e)) : typeof e != 'number' && (e = `[${r.inspect(e, r)}]`),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e}: ${t}`
  );
}
s(bo, 'inspectProperty');
function hS(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length) return '[]';
  t.truncate -= 4;
  const n = Bt(e, t);
  t.truncate -= n.length;
  let o = '';
  return (
    r.length &&
      (o = Bt(
        r.map((i) => [i, e[i]]),
        t,
        bo,
      )),
    `[ ${n}${o ? `, ${o}` : ''} ]`
  );
}
s(hS, 'inspectArray');
var uF = s(
  (e) =>
    typeof Buffer == 'function' && e instanceof Buffer
      ? 'Buffer'
      : e[Symbol.toStringTag]
        ? e[Symbol.toStringTag]
        : e.constructor.name,
  'getArrayName',
);
function Zt(e, t) {
  const r = uF(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length) return `${r}[]`;
  let o = '';
  for (let a = 0; a < e.length; a++) {
    const c = `${t.stylize(Nr(e[a], t.truncate), 'number')}${a === e.length - 1 ? '' : ', '}`;
    if (((t.truncate -= c.length), e[a] !== e.length && t.truncate <= 3)) {
      o += `${go}(${e.length - e[a] + 1})`;
      break;
    }
    o += c;
  }
  let i = '';
  return (
    n.length &&
      (i = Bt(
        n.map((a) => [a, e[a]]),
        t,
        bo,
      )),
    `${r}[ ${o}${i ? `, ${i}` : ''} ]`
  );
}
s(Zt, 'inspectTypedArray');
function gS(e, t) {
  const r = e.toJSON();
  if (r === null) return 'Invalid Date';
  const n = r.split('T'),
    o = n[0];
  return t.stylize(`${o}T${Nr(n[1], t.truncate - o.length - 1)}`, 'date');
}
s(gS, 'inspectDate');
function $u(e, t) {
  const r = e[Symbol.toStringTag] || 'Function',
    n = e.name;
  return n
    ? t.stylize(`[${r} ${Nr(n, t.truncate - 11)}]`, 'special')
    : t.stylize(`[${r}]`, 'special');
}
s($u, 'inspectFunction');
function bS([e, t], r) {
  return (
    (r.truncate -= 4),
    (e = r.inspect(e, r)),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e} => ${t}`
  );
}
s(bS, 'inspectMapEntry');
function vS(e) {
  const t = [];
  return (
    e.forEach((r, n) => {
      t.push([n, r]);
    }),
    t
  );
}
s(vS, 'mapToEntries');
function TS(e, t) {
  return e.size === 0 ? 'Map{}' : ((t.truncate -= 7), `Map{ ${Bt(vS(e), t, bS)} }`);
}
s(TS, 'inspectMap');
var dF = Number.isNaN || ((e) => e !== e);
function ku(e, t) {
  return dF(e)
    ? t.stylize('NaN', 'number')
    : e === 1 / 0
      ? t.stylize('Infinity', 'number')
      : e === -1 / 0
        ? t.stylize('-Infinity', 'number')
        : e === 0
          ? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
          : t.stylize(Nr(String(e), t.truncate), 'number');
}
s(ku, 'inspectNumber');
function Du(e, t) {
  let r = Nr(e.toString(), t.truncate - 1);
  return (r !== go && (r += 'n'), t.stylize(r, 'bigint'));
}
s(Du, 'inspectBigInt');
function ES(e, t) {
  const r = e.toString().split('/')[2],
    n = t.truncate - (2 + r.length),
    o = e.source;
  return t.stylize(`/${Nr(o, n)}/${r}`, 'regexp');
}
s(ES, 'inspectRegExp');
function wS(e) {
  const t = [];
  return (
    e.forEach((r) => {
      t.push(r);
    }),
    t
  );
}
s(wS, 'arrayFromSet');
function SS(e, t) {
  return e.size === 0 ? 'Set{}' : ((t.truncate -= 7), `Set{ ${Bt(wS(e), t)} }`);
}
s(SS, 'inspectSet');
var Pg = new RegExp(
    "['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
    'g',
  ),
  pF = { '\b': '\\b', '	': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '\\': '\\\\' },
  fF = 16;
function _S(e) {
  return pF[e] || `\\u${`0000${e.charCodeAt(0).toString(fF)}`.slice(-4)}`;
}
s(_S, 'escape');
function Lu(e, t) {
  return (Pg.test(e) && (e = e.replace(Pg, _S)), t.stylize(`'${Nr(e, t.truncate - 2)}'`, 'string'));
}
s(Lu, 'inspectString');
function Fu(e) {
  return 'description' in Symbol.prototype
    ? e.description
      ? `Symbol(${e.description})`
      : 'Symbol()'
    : e.toString();
}
s(Fu, 'inspectSymbol');
var mF = s(() => 'Promise{}', 'getPromiseValue'),
  yF = mF;
function Ms(e, t) {
  const r = Object.getOwnPropertyNames(e),
    n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0) return '{}';
  if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e))) return '[Circular]';
  t.seen.push(e);
  const o = Bt(
      r.map((c) => [c, e[c]]),
      t,
      bo,
    ),
    i = Bt(
      n.map((c) => [c, e[c]]),
      t,
      bo,
    );
  t.seen.pop();
  let a = '';
  return (o && i && (a = ', '), `{ ${o}${a}${i} }`);
}
s(Ms, 'inspectObject');
var eu = typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1;
function AS(e, t) {
  let r = '';
  return (
    eu && eu in e && (r = e[eu]),
    (r = r || e.constructor.name),
    (!r || r === '_class') && (r = '<Anonymous Class>'),
    (t.truncate -= r.length),
    `${r}${Ms(e, t)}`
  );
}
s(AS, 'inspectClass');
function RS(e, t) {
  return e.length === 0 ? 'Arguments[]' : ((t.truncate -= 13), `Arguments[ ${Bt(e, t)} ]`);
}
s(RS, 'inspectArguments');
var hF = [
  'stack',
  'line',
  'column',
  'name',
  'message',
  'fileName',
  'lineNumber',
  'columnNumber',
  'number',
  'description',
  'cause',
];
function xS(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((a) => hF.indexOf(a) === -1),
    n = e.name;
  t.truncate -= n.length;
  let o = '';
  if (
    (typeof e.message == 'string' ? (o = Nr(e.message, t.truncate)) : r.unshift('message'),
    (o = o ? `: ${o}` : ''),
    (t.truncate -= o.length + 5),
    (t.seen = t.seen || []),
    t.seen.includes(e))
  )
    return '[Circular]';
  t.seen.push(e);
  const i = Bt(
    r.map((a) => [a, e[a]]),
    t,
    bo,
  );
  return `${n}${o}${i ? ` { ${i} }` : ''}`;
}
s(xS, 'inspectObject');
function PS([e, t], r) {
  return (
    (r.truncate -= 3),
    t
      ? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
      : `${r.stylize(String(e), 'yellow')}`
  );
}
s(PS, 'inspectAttribute');
function ya(e, t) {
  return Bt(
    e,
    t,
    OS,
    `
`,
  );
}
s(ya, 'inspectNodeCollection');
function OS(e, t) {
  switch (e.nodeType) {
    case 1:
      return _f(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
s(OS, 'inspectNode');
function _f(e, t) {
  const r = e.getAttributeNames(),
    n = e.tagName.toLowerCase(),
    o = t.stylize(`<${n}`, 'special'),
    i = t.stylize('>', 'special'),
    a = t.stylize(`</${n}>`, 'special');
  t.truncate -= n.length * 2 + 5;
  let c = '';
  (r.length > 0 &&
    ((c += ' '),
    (c += Bt(
      r.map((p) => [p, e.getAttribute(p)]),
      t,
      PS,
      ' ',
    ))),
    (t.truncate -= c.length));
  const d = t.truncate;
  let u = ya(e.children, t);
  return (u && u.length > d && (u = `${go}(${e.children.length})`), `${o}${c}${i}${u}${a}`);
}
s(_f, 'inspectHTML');
var gF = typeof Symbol == 'function' && typeof Symbol.for == 'function',
  tu = gF ? Symbol.for('chai/inspect') : '@@chai/inspect',
  ru = Symbol.for('nodejs.util.inspect.custom'),
  Og = new WeakMap(),
  Cg = {},
  Ig = {
    undefined: s((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
    null: s((e, t) => t.stylize('null', 'null'), 'null'),
    boolean: s((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
    Boolean: s((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
    number: ku,
    Number: ku,
    bigint: Du,
    BigInt: Du,
    string: Lu,
    String: Lu,
    function: $u,
    Function: $u,
    symbol: Fu,
    Symbol: Fu,
    Array: hS,
    Date: gS,
    Map: TS,
    Set: SS,
    RegExp: ES,
    Promise: yF,
    WeakSet: s((e, t) => t.stylize('WeakSet{}', 'special'), 'WeakSet'),
    WeakMap: s((e, t) => t.stylize('WeakMap{}', 'special'), 'WeakMap'),
    Arguments: RS,
    Int8Array: Zt,
    Uint8Array: Zt,
    Uint8ClampedArray: Zt,
    Int16Array: Zt,
    Uint16Array: Zt,
    Int32Array: Zt,
    Uint32Array: Zt,
    Float32Array: Zt,
    Float64Array: Zt,
    Generator: s(() => '', 'Generator'),
    DataView: s(() => '', 'DataView'),
    ArrayBuffer: s(() => '', 'ArrayBuffer'),
    Error: xS,
    HTMLCollection: ya,
    NodeList: ya,
  },
  bF = s(
    (e, t, r, n) =>
      tu in e && typeof e[tu] == 'function'
        ? e[tu](t)
        : ru in e && typeof e[ru] == 'function'
          ? e[ru](t.depth, t, n)
          : 'inspect' in e && typeof e.inspect == 'function'
            ? e.inspect(t.depth, t)
            : 'constructor' in e && Og.has(e.constructor)
              ? Og.get(e.constructor)(e, t)
              : Cg[r]
                ? Cg[r](e, t)
                : '',
    'inspectCustom',
  ),
  vF = Object.prototype.toString;
function js(e, t = {}) {
  const r = fS(t, js),
    { customInspect: n } = r;
  let o = e === null ? 'null' : typeof e;
  if ((o === 'object' && (o = vF.call(e).slice(8, -1)), o in Ig)) return Ig[o](e, r);
  if (n && e) {
    const a = bF(e, r, o, js);
    if (a) return typeof a == 'string' ? a : js(a, r);
  }
  const i = e ? Object.getPrototypeOf(e) : !1;
  return i === Object.prototype || i === null
    ? Ms(e, r)
    : e && typeof HTMLElement == 'function' && e instanceof HTMLElement
      ? _f(e, r)
      : 'constructor' in e
        ? e.constructor !== Object
          ? AS(e, r)
          : Ms(e, r)
        : e === Object(e)
          ? Ms(e, r)
          : r.stylize(String(e), o);
}
s(js, 'inspect');
var {
    AsymmetricMatcher: TF,
    DOMCollection: EF,
    DOMElement: wF,
    Immutable: SF,
    ReactElement: _F,
    ReactTestComponent: AF,
  } = Sf,
  Ng = [AF, _F, wF, EF, SF, TF];
function Et(e, t = 10, { maxLength: r, ...n } = {}) {
  const o = r ?? 1e4;
  let i;
  try {
    i = Wt(e, { maxDepth: t, escapeString: !1, plugins: Ng, ...n });
  } catch {
    i = Wt(e, { callToJSON: !1, maxDepth: t, escapeString: !1, plugins: Ng, ...n });
  }
  return i.length >= o && t > 1
    ? Et(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), { maxLength: r, ...n })
    : i;
}
s(Et, 'stringify');
var RF = /%[sdjifoOc%]/g;
function CS(...e) {
  if (typeof e[0] != 'string') {
    const i = [];
    for (let a = 0; a < e.length; a++) i.push(Wn(e[a], { depth: 0, colors: !1 }));
    return i.join(' ');
  }
  const t = e.length;
  let r = 1;
  const n = e[0];
  let o = String(n).replace(RF, (i) => {
    if (i === '%%') return '%';
    if (r >= t) return i;
    switch (i) {
      case '%s': {
        const a = e[r++];
        return typeof a == 'bigint'
          ? `${a.toString()}n`
          : typeof a == 'number' && a === 0 && 1 / a < 0
            ? '-0'
            : typeof a == 'object' && a !== null
              ? typeof a.toString == 'function' && a.toString !== Object.prototype.toString
                ? a.toString()
                : Wn(a, { depth: 0, colors: !1 })
              : String(a);
      }
      case '%d': {
        const a = e[r++];
        return typeof a == 'bigint' ? `${a.toString()}n` : Number(a).toString();
      }
      case '%i': {
        const a = e[r++];
        return typeof a == 'bigint' ? `${a.toString()}n` : Number.parseInt(String(a)).toString();
      }
      case '%f':
        return Number.parseFloat(String(e[r++])).toString();
      case '%o':
        return Wn(e[r++], { showHidden: !0, showProxy: !0 });
      case '%O':
        return Wn(e[r++]);
      case '%c':
        return (r++, '');
      case '%j':
        try {
          return JSON.stringify(e[r++]);
        } catch (a) {
          const c = a.message;
          if (
            c.includes('circular structure') ||
            c.includes('cyclic structures') ||
            c.includes('cyclic object')
          )
            return '[Circular]';
          throw a;
        }
      default:
        return i;
    }
  });
  for (let i = e[r]; r < t; i = e[++r])
    i === null || typeof i != 'object' ? (o += ` ${i}`) : (o += ` ${Wn(i)}`);
  return o;
}
s(CS, 'format');
function Wn(e, t = {}) {
  return (t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), js(e, t));
}
s(Wn, 'inspect');
function Af(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
s(Af, 'getDefaultExportFromCjs');
function er(e, t, r) {
  const n = typeof e;
  if (!r.includes(n)) throw new TypeError(`${t} value must be ${r.join(' or ')}, received "${n}"`);
}
s(er, 'assertTypes');
function $s(e) {
  return e != null && typeof e == 'object' && !Array.isArray(e);
}
s($s, 'isObject');
function IS(e) {
  return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
s(IS, 'isFinalObj');
function Ks(e) {
  return Object.prototype.toString.apply(e).slice(8, -1);
}
s(Ks, 'getType');
function NS(e, t) {
  const r = typeof t == 'function' ? t : (n) => t.add(n);
  (Object.getOwnPropertyNames(e).forEach(r), Object.getOwnPropertySymbols(e).forEach(r));
}
s(NS, 'collectOwnProperties');
function Rf(e) {
  const t = new Set();
  return IS(e) ? [] : (NS(e, t), Array.from(t));
}
s(Rf, 'getOwnProperties');
var qS = { forceWritable: !1 };
function Bu(e, t = qS) {
  return ha(e, new WeakMap(), t);
}
s(Bu, 'deepClone');
function ha(e, t, r = qS) {
  let n, o;
  if (t.has(e)) return t.get(e);
  if (Array.isArray(e)) {
    for (o = Array.from({ length: (n = e.length) }), t.set(e, o); n--; ) o[n] = ha(e[n], t, r);
    return o;
  }
  if (Object.prototype.toString.call(e) === '[object Object]') {
    ((o = Object.create(Object.getPrototypeOf(e))), t.set(e, o));
    const i = Rf(e);
    for (const a of i) {
      const c = Object.getOwnPropertyDescriptor(e, a);
      if (!c) continue;
      const d = ha(e[a], t, r);
      r.forceWritable
        ? Object.defineProperty(o, a, {
            enumerable: c.enumerable,
            configurable: !0,
            writable: !0,
            value: d,
          })
        : 'get' in c
          ? Object.defineProperty(o, a, {
              ...c,
              get() {
                return d;
              },
            })
          : Object.defineProperty(o, a, { ...c, value: d });
    }
    return o;
  }
  return e;
}
s(ha, 'clone');
function MS() {}
s(MS, 'noop');
var bt = -1,
  ct = 1,
  Je = 0,
  jS = class {
    constructor(t, r) {
      Be(this, 0);
      Be(this, 1);
      ((this[0] = t), (this[1] = r));
    }
  };
s(jS, 'Diff');
var Le = jS;
function $S(e, t) {
  if (!e || !t || e.charAt(0) !== t.charAt(0)) return 0;
  let r = 0,
    n = Math.min(e.length, t.length),
    o = n,
    i = 0;
  for (; r < o; )
    (e.substring(i, o) === t.substring(i, o) ? ((r = o), (i = r)) : (n = o),
      (o = Math.floor((n - r) / 2 + r)));
  return o;
}
s($S, 'diff_commonPrefix');
function xf(e, t) {
  if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1)) return 0;
  let r = 0,
    n = Math.min(e.length, t.length),
    o = n,
    i = 0;
  for (; r < o; )
    (e.substring(e.length - o, e.length - i) === t.substring(t.length - o, t.length - i)
      ? ((r = o), (i = r))
      : (n = o),
      (o = Math.floor((n - r) / 2 + r)));
  return o;
}
s(xf, 'diff_commonSuffix');
function Ju(e, t) {
  const r = e.length,
    n = t.length;
  if (r === 0 || n === 0) return 0;
  r > n ? (e = e.substring(r - n)) : r < n && (t = t.substring(0, r));
  const o = Math.min(r, n);
  if (e === t) return o;
  let i = 0,
    a = 1;
  for (;;) {
    const c = e.substring(o - a),
      d = t.indexOf(c);
    if (d === -1) return i;
    ((a += d), (d === 0 || e.substring(o - a) === t.substring(0, a)) && ((i = a), a++));
  }
}
s(Ju, 'diff_commonOverlap_');
function kS(e) {
  let t = !1;
  const r = [];
  let n = 0,
    o = null,
    i = 0,
    a = 0,
    c = 0,
    d = 0,
    u = 0;
  for (; i < e.length; )
    (e[i][0] === Je
      ? ((r[n++] = i), (a = d), (c = u), (d = 0), (u = 0), (o = e[i][1]))
      : (e[i][0] === ct ? (d += e[i][1].length) : (u += e[i][1].length),
        o &&
          o.length <= Math.max(a, c) &&
          o.length <= Math.max(d, u) &&
          (e.splice(r[n - 1], 0, new Le(bt, o)),
          (e[r[n - 1] + 1][0] = ct),
          n--,
          n--,
          (i = n > 0 ? r[n - 1] : -1),
          (a = 0),
          (c = 0),
          (d = 0),
          (u = 0),
          (o = null),
          (t = !0))),
      i++);
  for (t && Pf(e), DS(e), i = 1; i < e.length; ) {
    if (e[i - 1][0] === bt && e[i][0] === ct) {
      const p = e[i - 1][1],
        f = e[i][1],
        m = Ju(p, f),
        h = Ju(f, p);
      (m >= h
        ? (m >= p.length / 2 || m >= f.length / 2) &&
          (e.splice(i, 0, new Le(Je, f.substring(0, m))),
          (e[i - 1][1] = p.substring(0, p.length - m)),
          (e[i + 1][1] = f.substring(m)),
          i++)
        : (h >= p.length / 2 || h >= f.length / 2) &&
          (e.splice(i, 0, new Le(Je, p.substring(0, h))),
          (e[i - 1][0] = ct),
          (e[i - 1][1] = f.substring(0, f.length - h)),
          (e[i + 1][0] = bt),
          (e[i + 1][1] = p.substring(h)),
          i++),
        i++);
    }
    i++;
  }
}
s(kS, 'diff_cleanupSemantic');
var qg = /[^a-z0-9]/i,
  Mg = /\s/,
  jg = /[\r\n]/,
  xF = /\n\r?\n$/,
  PF = /^\r?\n\r?\n/;
function DS(e) {
  let t = 1;
  for (; t < e.length - 1; ) {
    if (e[t - 1][0] === Je && e[t + 1][0] === Je) {
      let r = e[t - 1][1],
        n = e[t][1],
        o = e[t + 1][1];
      const i = xf(r, n);
      if (i) {
        const p = n.substring(n.length - i);
        ((r = r.substring(0, r.length - i)), (n = p + n.substring(0, n.length - i)), (o = p + o));
      }
      let a = r,
        c = n,
        d = o,
        u = _s(r, n) + _s(n, o);
      for (; n.charAt(0) === o.charAt(0); ) {
        ((r += n.charAt(0)), (n = n.substring(1) + o.charAt(0)), (o = o.substring(1)));
        const p = _s(r, n) + _s(n, o);
        p >= u && ((u = p), (a = r), (c = n), (d = o));
      }
      e[t - 1][1] !== a &&
        (a ? (e[t - 1][1] = a) : (e.splice(t - 1, 1), t--),
        (e[t][1] = c),
        d ? (e[t + 1][1] = d) : (e.splice(t + 1, 1), t--));
    }
    t++;
  }
}
s(DS, 'diff_cleanupSemanticLossless');
function Pf(e) {
  e.push(new Le(Je, ''));
  let t = 0,
    r = 0,
    n = 0,
    o = '',
    i = '',
    a;
  for (; t < e.length; )
    switch (e[t][0]) {
      case ct:
        (n++, (i += e[t][1]), t++);
        break;
      case bt:
        (r++, (o += e[t][1]), t++);
        break;
      case Je:
        (r + n > 1
          ? (r !== 0 &&
              n !== 0 &&
              ((a = $S(i, o)),
              a !== 0 &&
                (t - r - n > 0 && e[t - r - n - 1][0] === Je
                  ? (e[t - r - n - 1][1] += i.substring(0, a))
                  : (e.splice(0, 0, new Le(Je, i.substring(0, a))), t++),
                (i = i.substring(a)),
                (o = o.substring(a))),
              (a = xf(i, o)),
              a !== 0 &&
                ((e[t][1] = i.substring(i.length - a) + e[t][1]),
                (i = i.substring(0, i.length - a)),
                (o = o.substring(0, o.length - a)))),
            (t -= r + n),
            e.splice(t, r + n),
            o.length && (e.splice(t, 0, new Le(bt, o)), t++),
            i.length && (e.splice(t, 0, new Le(ct, i)), t++),
            t++)
          : t !== 0 && e[t - 1][0] === Je
            ? ((e[t - 1][1] += e[t][1]), e.splice(t, 1))
            : t++,
          (n = 0),
          (r = 0),
          (o = ''),
          (i = ''));
        break;
    }
  e[e.length - 1][1] === '' && e.pop();
  let c = !1;
  for (t = 1; t < e.length - 1; )
    (e[t - 1][0] === Je &&
      e[t + 1][0] === Je &&
      (e[t][1].substring(e[t][1].length - e[t - 1][1].length) === e[t - 1][1]
        ? ((e[t][1] = e[t - 1][1] + e[t][1].substring(0, e[t][1].length - e[t - 1][1].length)),
          (e[t + 1][1] = e[t - 1][1] + e[t + 1][1]),
          e.splice(t - 1, 1),
          (c = !0))
        : e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] &&
          ((e[t - 1][1] += e[t + 1][1]),
          (e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1]),
          e.splice(t + 1, 1),
          (c = !0))),
      t++);
  c && Pf(e);
}
s(Pf, 'diff_cleanupMerge');
function _s(e, t) {
  if (!e || !t) return 6;
  const r = e.charAt(e.length - 1),
    n = t.charAt(0),
    o = r.match(qg),
    i = n.match(qg),
    a = o && r.match(Mg),
    c = i && n.match(Mg),
    d = a && r.match(jg),
    u = c && n.match(jg),
    p = d && e.match(xF),
    f = u && t.match(PF);
  return p || f ? 5 : d || u ? 4 : o && !a && c ? 3 : a || c ? 2 : o || i ? 1 : 0;
}
s(_s, 'diff_cleanupSemanticScore_');
var LS = 'Compared values have no visual difference.',
  OF =
    'Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.',
  Bi = {},
  $g;
function FS() {
  if ($g) return Bi;
  (($g = 1), Object.defineProperty(Bi, '__esModule', { value: !0 }), (Bi.default = m));
  const e = 'diff-sequences',
    t = 0,
    r = s((h, g, v, E, b) => {
      let S = 0;
      for (; h < g && v < E && b(h, v); ) ((h += 1), (v += 1), (S += 1));
      return S;
    }, 'countCommonItemsF'),
    n = s((h, g, v, E, b) => {
      let S = 0;
      for (; h <= g && v <= E && b(g, E); ) ((g -= 1), (E -= 1), (S += 1));
      return S;
    }, 'countCommonItemsR'),
    o = s((h, g, v, E, b, S, R) => {
      let I = 0,
        q = -h,
        P = S[I],
        A = P;
      S[I] += r(P + 1, g, E + P - q + 1, v, b);
      const w = h < R ? h : R;
      for (I += 1, q += 2; I <= w; I += 1, q += 2) {
        if (I !== h && A < S[I]) P = S[I];
        else if (((P = A + 1), g <= P)) return I - 1;
        ((A = S[I]), (S[I] = P + r(P + 1, g, E + P - q + 1, v, b)));
      }
      return R;
    }, 'extendPathsF'),
    i = s((h, g, v, E, b, S, R) => {
      let I = 0,
        q = h,
        P = S[I],
        A = P;
      S[I] -= n(g, P - 1, v, E + P - q - 1, b);
      const w = h < R ? h : R;
      for (I += 1, q -= 2; I <= w; I += 1, q -= 2) {
        if (I !== h && S[I] < A) P = S[I];
        else if (((P = A - 1), P < g)) return I - 1;
        ((A = S[I]), (S[I] = P - n(g, P - 1, v, E + P - q - 1, b)));
      }
      return R;
    }, 'extendPathsR'),
    a = s((h, g, v, E, b, S, R, I, q, P, A) => {
      const w = E - g,
        _ = v - g,
        N = b - E - _,
        V = -N - (h - 1),
        H = -N + (h - 1);
      let x = t;
      const D = h < I ? h : I;
      for (let F = 0, k = -h; F <= D; F += 1, k += 2) {
        const K = F === 0 || (F !== h && x < R[F]),
          X = K ? R[F] : x,
          se = K ? X : X + 1,
          ie = w + se - k,
          W = r(se + 1, v, ie + 1, b, S),
          ae = se + W;
        if (((x = R[F]), (R[F] = ae), V <= k && k <= H)) {
          const be = (h - 1 - (k + N)) / 2;
          if (be <= P && q[be] - 1 <= ae) {
            const ue = w + X - (K ? k + 1 : k - 1),
              ee = n(g, X, E, ue, S),
              xe = X - ee,
              Pe = ue - ee,
              He = xe + 1,
              Ke = Pe + 1;
            ((A.nChangePreceding = h - 1),
              h - 1 === He + Ke - g - E
                ? ((A.aEndPreceding = g), (A.bEndPreceding = E))
                : ((A.aEndPreceding = He), (A.bEndPreceding = Ke)),
              (A.nCommonPreceding = ee),
              ee !== 0 && ((A.aCommonPreceding = He), (A.bCommonPreceding = Ke)),
              (A.nCommonFollowing = W),
              W !== 0 && ((A.aCommonFollowing = se + 1), (A.bCommonFollowing = ie + 1)));
            const J = ae + 1,
              Q = ie + W + 1;
            return (
              (A.nChangeFollowing = h - 1),
              h - 1 === v + b - J - Q
                ? ((A.aStartFollowing = v), (A.bStartFollowing = b))
                : ((A.aStartFollowing = J), (A.bStartFollowing = Q)),
              !0
            );
          }
        }
      }
      return !1;
    }, 'extendOverlappablePathsF'),
    c = s((h, g, v, E, b, S, R, I, q, P, A) => {
      const w = b - v,
        _ = v - g,
        N = b - E - _,
        V = N - h,
        H = N + h;
      let x = t;
      const D = h < P ? h : P;
      for (let F = 0, k = h; F <= D; F += 1, k -= 2) {
        const K = F === 0 || (F !== h && q[F] < x),
          X = K ? q[F] : x,
          se = K ? X : X - 1,
          ie = w + se - k,
          W = n(g, se - 1, E, ie - 1, S),
          ae = se - W;
        if (((x = q[F]), (q[F] = ae), V <= k && k <= H)) {
          const be = (h + (k - N)) / 2;
          if (be <= I && ae - 1 <= R[be]) {
            const ue = ie - W;
            if (
              ((A.nChangePreceding = h),
              h === ae + ue - g - E
                ? ((A.aEndPreceding = g), (A.bEndPreceding = E))
                : ((A.aEndPreceding = ae), (A.bEndPreceding = ue)),
              (A.nCommonPreceding = W),
              W !== 0 && ((A.aCommonPreceding = ae), (A.bCommonPreceding = ue)),
              (A.nChangeFollowing = h - 1),
              h === 1)
            )
              ((A.nCommonFollowing = 0), (A.aStartFollowing = v), (A.bStartFollowing = b));
            else {
              const ee = w + X - (K ? k - 1 : k + 1),
                xe = r(X, v, ee, b, S);
              ((A.nCommonFollowing = xe),
                xe !== 0 && ((A.aCommonFollowing = X), (A.bCommonFollowing = ee)));
              const Pe = X + xe,
                He = ee + xe;
              h - 1 === v + b - Pe - He
                ? ((A.aStartFollowing = v), (A.bStartFollowing = b))
                : ((A.aStartFollowing = Pe), (A.bStartFollowing = He));
            }
            return !0;
          }
        }
      }
      return !1;
    }, 'extendOverlappablePathsR'),
    d = s((h, g, v, E, b, S, R, I, q) => {
      const P = E - g,
        A = b - v,
        w = v - g,
        _ = b - E,
        $ = _ - w;
      let N = w,
        V = w;
      if (((R[0] = g - 1), (I[0] = v), $ % 2 === 0)) {
        const H = (h || $) / 2,
          x = (w + _) / 2;
        for (let D = 1; D <= x; D += 1)
          if (((N = o(D, v, b, P, S, R, N)), D < H)) V = i(D, g, E, A, S, I, V);
          else if (c(D, g, v, E, b, S, R, N, I, V, q)) return;
      } else {
        const H = ((h || $) + 1) / 2,
          x = (w + _ + 1) / 2;
        let D = 1;
        for (N = o(D, v, b, P, S, R, N), D += 1; D <= x; D += 1)
          if (((V = i(D - 1, g, E, A, S, I, V)), D < H)) N = o(D, v, b, P, S, R, N);
          else if (a(D, g, v, E, b, S, R, N, I, V, q)) return;
      }
      throw new Error(`${e}: no overlap aStart=${g} aEnd=${v} bStart=${E} bEnd=${b}`);
    }, 'divide'),
    u = s((h, g, v, E, b, S, R, I, q, P) => {
      if (b - E < v - g) {
        if (((S = !S), S && R.length === 1)) {
          const { foundSubsequence: ae, isCommon: be } = R[0];
          R[1] = {
            foundSubsequence: s((ue, ee, xe) => {
              ae(ue, xe, ee);
            }, 'foundSubsequence'),
            isCommon: s((ue, ee) => be(ee, ue), 'isCommon'),
          };
        }
        const ie = g,
          W = v;
        ((g = E), (v = b), (E = ie), (b = W));
      }
      const { foundSubsequence: A, isCommon: w } = R[S ? 1 : 0];
      d(h, g, v, E, b, w, I, q, P);
      const {
        nChangePreceding: _,
        aEndPreceding: $,
        bEndPreceding: N,
        nCommonPreceding: V,
        aCommonPreceding: H,
        bCommonPreceding: x,
        nCommonFollowing: D,
        aCommonFollowing: F,
        bCommonFollowing: k,
        nChangeFollowing: K,
        aStartFollowing: X,
        bStartFollowing: se,
      } = P;
      (g < $ && E < N && u(_, g, $, E, N, S, R, I, q, P),
        V !== 0 && A(V, H, x),
        D !== 0 && A(D, F, k),
        X < v && se < b && u(K, X, v, se, b, S, R, I, q, P));
    }, 'findSubsequences'),
    p = s((h, g) => {
      if (typeof g != 'number')
        throw new TypeError(`${e}: ${h} typeof ${typeof g} is not a number`);
      if (!Number.isSafeInteger(g))
        throw new RangeError(`${e}: ${h} value ${g} is not a safe integer`);
      if (g < 0) throw new RangeError(`${e}: ${h} value ${g} is a negative integer`);
    }, 'validateLength'),
    f = s((h, g) => {
      const v = typeof g;
      if (v !== 'function') throw new TypeError(`${e}: ${h} typeof ${v} is not a function`);
    }, 'validateCallback');
  function m(h, g, v, E) {
    (p('aLength', h), p('bLength', g), f('isCommon', v), f('foundSubsequence', E));
    const b = r(0, h, 0, g, v);
    if ((b !== 0 && E(b, 0, 0), h !== b || g !== b)) {
      const S = b,
        R = b,
        I = n(S, h - 1, R, g - 1, v),
        q = h - I,
        P = g - I,
        A = b + I;
      (h !== A &&
        g !== A &&
        u(0, S, q, R, P, !1, [{ foundSubsequence: E, isCommon: v }], [t], [t], {
          aCommonFollowing: t,
          aCommonPreceding: t,
          aEndPreceding: t,
          aStartFollowing: t,
          bCommonFollowing: t,
          bCommonPreceding: t,
          bEndPreceding: t,
          bStartFollowing: t,
          nChangeFollowing: t,
          nChangePreceding: t,
          nCommonFollowing: t,
          nCommonPreceding: t,
        }),
        I !== 0 && E(I, q, P));
    }
  }
  return (s(m, 'diffSequence'), Bi);
}
s(FS, 'requireBuild');
var CF = FS(),
  BS = Af(CF);
function JS(e, t) {
  return e.replace(/\s+$/, (r) => t(r));
}
s(JS, 'formatTrailingSpaces');
function Il(e, t, r, n, o, i) {
  return e.length !== 0
    ? r(`${n} ${JS(e, o)}`)
    : n !== ' '
      ? r(n)
      : t && i.length !== 0
        ? r(`${n} ${i}`)
        : '';
}
s(Il, 'printDiffLine');
function Of(
  e,
  t,
  { aColor: r, aIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: i },
) {
  return Il(e, t, r, n, o, i);
}
s(Of, 'printDeleteLine');
function Cf(
  e,
  t,
  { bColor: r, bIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: i },
) {
  return Il(e, t, r, n, o, i);
}
s(Cf, 'printInsertLine');
function If(
  e,
  t,
  {
    commonColor: r,
    commonIndicator: n,
    commonLineTrailingSpaceColor: o,
    emptyFirstOrLastLinePlaceholder: i,
  },
) {
  return Il(e, t, r, n, o, i);
}
s(If, 'printCommonLine');
function Uu(e, t, r, n, { patchColor: o }) {
  return o(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`);
}
s(Uu, 'createPatchMark');
function US(e, t) {
  const r = e.length,
    n = t.contextLines,
    o = n + n;
  let i = r,
    a = !1,
    c = 0,
    d = 0;
  for (; d !== r; ) {
    const I = d;
    for (; d !== r && e[d][0] === Je; ) d += 1;
    if (I !== d)
      if (I === 0) d > n && ((i -= d - n), (a = !0));
      else if (d === r) {
        const q = d - I;
        q > n && ((i -= q - n), (a = !0));
      } else {
        const q = d - I;
        q > o && ((i -= q - o), (c += 1));
      }
    for (; d !== r && e[d][0] !== Je; ) d += 1;
  }
  const u = c !== 0 || a;
  c !== 0 ? (i += c + 1) : a && (i += 1);
  const p = i - 1,
    f = [];
  let m = 0;
  u && f.push('');
  let h = 0,
    g = 0,
    v = 0,
    E = 0;
  const b = s((I) => {
      const q = f.length;
      (f.push(If(I, q === 0 || q === p, t)), (v += 1), (E += 1));
    }, 'pushCommonLine'),
    S = s((I) => {
      const q = f.length;
      (f.push(Of(I, q === 0 || q === p, t)), (v += 1));
    }, 'pushDeleteLine'),
    R = s((I) => {
      const q = f.length;
      (f.push(Cf(I, q === 0 || q === p, t)), (E += 1));
    }, 'pushInsertLine');
  for (d = 0; d !== r; ) {
    let I = d;
    for (; d !== r && e[d][0] === Je; ) d += 1;
    if (I !== d)
      if (I === 0) {
        d > n && ((I = d - n), (h = I), (g = I), (v = h), (E = g));
        for (let q = I; q !== d; q += 1) b(e[q][1]);
      } else if (d === r) {
        const q = d - I > n ? I + n : d;
        for (let P = I; P !== q; P += 1) b(e[P][1]);
      } else {
        const q = d - I;
        if (q > o) {
          const P = I + n;
          for (let w = I; w !== P; w += 1) b(e[w][1]);
          ((f[m] = Uu(h, v, g, E, t)), (m = f.length), f.push(''));
          const A = q - o;
          ((h = v + A), (g = E + A), (v = h), (E = g));
          for (let w = d - n; w !== d; w += 1) b(e[w][1]);
        } else for (let P = I; P !== d; P += 1) b(e[P][1]);
      }
    for (; d !== r && e[d][0] === bt; ) (S(e[d][1]), (d += 1));
    for (; d !== r && e[d][0] === ct; ) (R(e[d][1]), (d += 1));
  }
  return (
    u && (f[m] = Uu(h, v, g, E, t)),
    f.join(`
`)
  );
}
s(US, 'joinAlignedDiffsNoExpand');
function VS(e, t) {
  return e.map((r, n, o) => {
    const i = r[1],
      a = n === 0 || n === o.length - 1;
    switch (r[0]) {
      case bt:
        return Of(i, a, t);
      case ct:
        return Cf(i, a, t);
      default:
        return If(i, a, t);
    }
  }).join(`
`);
}
s(VS, 'joinAlignedDiffsExpand');
var nu = s((e) => e, 'noColor'),
  HS = 5,
  IF = 0;
function zS() {
  return {
    aAnnotation: 'Expected',
    aColor: Ue.green,
    aIndicator: '-',
    bAnnotation: 'Received',
    bColor: Ue.red,
    bIndicator: '+',
    changeColor: Ue.inverse,
    changeLineTrailingSpaceColor: nu,
    commonColor: Ue.dim,
    commonIndicator: ' ',
    commonLineTrailingSpaceColor: nu,
    compareKeys: void 0,
    contextLines: HS,
    emptyFirstOrLastLinePlaceholder: '',
    expand: !1,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: Ue.yellow,
    printBasicPrototype: !1,
    truncateThreshold: IF,
    truncateAnnotation: '... Diff result is truncated',
    truncateAnnotationColor: nu,
  };
}
s(zS, 'getDefaultOptions');
function GS(e) {
  return e && typeof e == 'function' ? e : void 0;
}
s(GS, 'getCompareKeys');
function WS(e) {
  return typeof e == 'number' && Number.isSafeInteger(e) && e >= 0 ? e : HS;
}
s(WS, 'getContextLines');
function tn(e = {}) {
  return { ...zS(), ...e, compareKeys: GS(e.compareKeys), contextLines: WS(e.contextLines) };
}
s(tn, 'normalizeDiffOptions');
function yn(e) {
  return e.length === 1 && e[0].length === 0;
}
s(yn, 'isEmptyString');
function KS(e) {
  let t = 0,
    r = 0;
  return (
    e.forEach((n) => {
      switch (n[0]) {
        case bt:
          t += 1;
          break;
        case ct:
          r += 1;
          break;
      }
    }),
    { a: t, b: r }
  );
}
s(KS, 'countChanges');
function YS(
  {
    aAnnotation: e,
    aColor: t,
    aIndicator: r,
    bAnnotation: n,
    bColor: o,
    bIndicator: i,
    includeChangeCounts: a,
    omitAnnotationLines: c,
  },
  d,
) {
  if (c) return '';
  let u = '',
    p = '';
  if (a) {
    const h = String(d.a),
      g = String(d.b),
      v = n.length - e.length,
      E = ' '.repeat(Math.max(0, v)),
      b = ' '.repeat(Math.max(0, -v)),
      S = g.length - h.length,
      R = ' '.repeat(Math.max(0, S)),
      I = ' '.repeat(Math.max(0, -S));
    ((u = `${E}  ${r} ${R}${h}`), (p = `${b}  ${i} ${I}${g}`));
  }
  const f = `${r} ${e}${u}`,
    m = `${i} ${n}${p}`;
  return `${t(f)}
${o(m)}

`;
}
s(YS, 'printAnnotation');
function Nl(e, t, r) {
  return (
    YS(r, KS(e)) +
    (r.expand ? VS(e, r) : US(e, r)) +
    (t
      ? r.truncateAnnotationColor(`
${r.truncateAnnotation}`)
      : '')
  );
}
s(Nl, 'printDiffLines');
function Ei(e, t, r) {
  const n = tn(r),
    [o, i] = Nf(yn(e) ? [] : e, yn(t) ? [] : t, n);
  return Nl(o, i, n);
}
s(Ei, 'diffLinesUnified');
function XS(e, t, r, n, o) {
  if (
    (yn(e) && yn(r) && ((e = []), (r = [])),
    yn(t) && yn(n) && ((t = []), (n = [])),
    e.length !== r.length || t.length !== n.length)
  )
    return Ei(e, t, o);
  const [i, a] = Nf(r, n, o);
  let c = 0,
    d = 0;
  return (
    i.forEach((u) => {
      switch (u[0]) {
        case bt:
          ((u[1] = e[c]), (c += 1));
          break;
        case ct:
          ((u[1] = t[d]), (d += 1));
          break;
        default:
          ((u[1] = t[d]), (c += 1), (d += 1));
      }
    }),
    Nl(i, a, tn(o))
  );
}
s(XS, 'diffLinesUnified2');
function Nf(e, t, r) {
  const n = r?.truncateThreshold ?? !1,
    o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0),
    i = n ? Math.min(e.length, o) : e.length,
    a = n ? Math.min(t.length, o) : t.length,
    c = i !== e.length || a !== t.length,
    d = s((h, g) => e[h] === t[g], 'isCommon'),
    u = [];
  let p = 0,
    f = 0;
  for (
    BS(
      i,
      a,
      d,
      s((h, g, v) => {
        for (; p !== g; p += 1) u.push(new Le(bt, e[p]));
        for (; f !== v; f += 1) u.push(new Le(ct, t[f]));
        for (; h !== 0; h -= 1, p += 1, f += 1) u.push(new Le(Je, t[f]));
      }, 'foundSubsequence'),
    );
    p !== i;
    p += 1
  )
    u.push(new Le(bt, e[p]));
  for (; f !== a; f += 1) u.push(new Le(ct, t[f]));
  return [u, c];
}
s(Nf, 'diffLinesRaw');
function Vu(e) {
  if (e === void 0) return 'undefined';
  if (e === null) return 'null';
  if (Array.isArray(e)) return 'array';
  if (typeof e == 'boolean') return 'boolean';
  if (typeof e == 'function') return 'function';
  if (typeof e == 'number') return 'number';
  if (typeof e == 'string') return 'string';
  if (typeof e == 'bigint') return 'bigint';
  if (typeof e == 'object') {
    if (e != null) {
      if (e.constructor === RegExp) return 'regexp';
      if (e.constructor === Map) return 'map';
      if (e.constructor === Set) return 'set';
      if (e.constructor === Date) return 'date';
    }
    return 'object';
  } else if (typeof e == 'symbol') return 'symbol';
  throw new Error(`value of unknown type: ${e}`);
}
s(Vu, 'getType');
function Hu(e) {
  return e.includes(`\r
`)
    ? `\r
`
    : `
`;
}
s(Hu, 'getNewLineSymbol');
function QS(e, t, r) {
  const n = r?.truncateThreshold ?? !1,
    o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0);
  let i = e.length,
    a = t.length;
  if (n) {
    const h = e.includes(`
`),
      g = t.includes(`
`),
      v = Hu(e),
      E = Hu(t),
      b = h
        ? `${e.split(v, o).join(v)}
`
        : e,
      S = g
        ? `${t.split(E, o).join(E)}
`
        : t;
    ((i = b.length), (a = S.length));
  }
  const c = i !== e.length || a !== t.length,
    d = s((h, g) => e[h] === t[g], 'isCommon');
  let u = 0,
    p = 0;
  const f = [];
  return (
    BS(
      i,
      a,
      d,
      s((h, g, v) => {
        (u !== g && f.push(new Le(bt, e.slice(u, g))),
          p !== v && f.push(new Le(ct, t.slice(p, v))),
          (u = g + h),
          (p = v + h),
          f.push(new Le(Je, t.slice(v, p))));
      }, 'foundSubsequence'),
    ),
    u !== i && f.push(new Le(bt, e.slice(u))),
    p !== a && f.push(new Le(ct, t.slice(p))),
    [f, c]
  );
}
s(QS, 'diffStrings');
function ZS(e, t, r) {
  return t.reduce(
    (n, o) => n + (o[0] === Je ? o[1] : o[0] === e && o[1].length !== 0 ? r(o[1]) : ''),
    '',
  );
}
s(ZS, 'concatenateRelevantDiffs');
var e_ = class {
  constructor(t, r) {
    Be(this, 'op');
    Be(this, 'line');
    Be(this, 'lines');
    Be(this, 'changeColor');
    ((this.op = t), (this.line = []), (this.lines = []), (this.changeColor = r));
  }
  pushSubstring(t) {
    this.pushDiff(new Le(this.op, t));
  }
  pushLine() {
    (this.lines.push(
      this.line.length !== 1
        ? new Le(this.op, ZS(this.op, this.line, this.changeColor))
        : this.line[0][0] === this.op
          ? this.line[0]
          : new Le(this.op, this.line[0][1]),
    ),
      (this.line.length = 0));
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  pushDiff(t) {
    this.line.push(t);
  }
  align(t) {
    const r = t[1];
    if (
      r.includes(`
`)
    ) {
      const n = r.split(`
`),
        o = n.length - 1;
      n.forEach((i, a) => {
        a < o ? (this.pushSubstring(i), this.pushLine()) : i.length !== 0 && this.pushSubstring(i);
      });
    } else this.pushDiff(t);
  }
  moveLinesTo(t) {
    (this.isLineEmpty() || this.pushLine(), t.push(...this.lines), (this.lines.length = 0));
  }
};
s(e_, 'ChangeBuffer');
var kg = e_,
  t_ = class {
    constructor(t, r) {
      Be(this, 'deleteBuffer');
      Be(this, 'insertBuffer');
      Be(this, 'lines');
      ((this.deleteBuffer = t), (this.insertBuffer = r), (this.lines = []));
    }
    pushDiffCommonLine(t) {
      this.lines.push(t);
    }
    pushDiffChangeLines(t) {
      const r = t[1].length === 0;
      ((!r || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(t),
        (!r || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(t));
    }
    flushChangeLines() {
      (this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines));
    }
    align(t) {
      const r = t[0],
        n = t[1];
      if (
        n.includes(`
`)
      ) {
        const o = n.split(`
`),
          i = o.length - 1;
        o.forEach((a, c) => {
          if (c === 0) {
            const d = new Le(r, a);
            this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()
              ? (this.flushChangeLines(), this.pushDiffCommonLine(d))
              : (this.pushDiffChangeLines(d), this.flushChangeLines());
          } else
            c < i
              ? this.pushDiffCommonLine(new Le(r, a))
              : a.length !== 0 && this.pushDiffChangeLines(new Le(r, a));
        });
      } else this.pushDiffChangeLines(t);
    }
    getLines() {
      return (this.flushChangeLines(), this.lines);
    }
  };
s(t_, 'CommonBuffer');
var NF = t_;
function r_(e, t) {
  const r = new kg(bt, t),
    n = new kg(ct, t),
    o = new NF(r, n);
  return (
    e.forEach((i) => {
      switch (i[0]) {
        case bt:
          r.align(i);
          break;
        case ct:
          n.align(i);
          break;
        default:
          o.align(i);
      }
    }),
    o.getLines()
  );
}
s(r_, 'getAlignedDiffs');
function n_(e, t) {
  if (t) {
    const r = e.length - 1;
    return e.some(
      (n, o) =>
        n[0] === Je &&
        (o !== r ||
          n[1] !==
            `
`),
    );
  }
  return e.some((r) => r[0] === Je);
}
s(n_, 'hasCommonDiff');
function o_(e, t, r) {
  if (e !== t && e.length !== 0 && t.length !== 0) {
    const n =
        e.includes(`
`) ||
        t.includes(`
`),
      [o, i] = qf(
        n
          ? `${e}
`
          : e,
        n
          ? `${t}
`
          : t,
        !0,
        r,
      );
    if (n_(o, n)) {
      const a = tn(r),
        c = r_(o, a.changeColor);
      return Nl(c, i, a);
    }
  }
  return Ei(
    e.split(`
`),
    t.split(`
`),
    r,
  );
}
s(o_, 'diffStringsUnified');
function qf(e, t, r, n) {
  const [o, i] = QS(e, t, n);
  return (r && kS(o), [o, i]);
}
s(qf, 'diffStringsRaw');
function ga(e, t) {
  const { commonColor: r } = tn(t);
  return r(e);
}
s(ga, 'getCommonMessage');
var {
    AsymmetricMatcher: qF,
    DOMCollection: MF,
    DOMElement: jF,
    Immutable: $F,
    ReactElement: kF,
    ReactTestComponent: DF,
  } = Sf,
  s_ = [DF, kF, jF, MF, $F, qF, Sf.Error],
  zu = { maxDepth: 20, plugins: s_ },
  i_ = { callToJSON: !1, maxDepth: 8, plugins: s_ };
function Bn(e, t, r) {
  if (Object.is(e, t)) return '';
  const n = Vu(e);
  let o = n,
    i = !1;
  if (n === 'object' && typeof e.asymmetricMatch == 'function') {
    if (
      e.$$typeof !== Symbol.for('jest.asymmetricMatcher') ||
      typeof e.getExpectedType != 'function'
    )
      return;
    ((o = e.getExpectedType()), (i = o === 'string'));
  }
  if (o !== Vu(t)) {
    let a = function (R) {
      return R.length <= E ? R : `${R.slice(0, E)}...`;
    };
    s(a, 'truncate');
    const {
        aAnnotation: c,
        aColor: d,
        aIndicator: u,
        bAnnotation: p,
        bColor: f,
        bIndicator: m,
      } = tn(r),
      h = ba(i_, r);
    let g = Wt(e, h),
      v = Wt(t, h);
    const E = 1e5;
    ((g = a(g)), (v = a(v)));
    const b = `${d(`${u} ${c}:`)} 
${g}`,
      S = `${f(`${m} ${p}:`)} 
${v}`;
    return `${b}

${S}`;
  }
  if (!i)
    switch (n) {
      case 'string':
        return Ei(
          e.split(`
`),
          t.split(`
`),
          r,
        );
      case 'boolean':
      case 'number':
        return a_(e, t, r);
      case 'map':
        return Xi(Gu(e), Gu(t), r);
      case 'set':
        return Xi(Wu(e), Wu(t), r);
      default:
        return Xi(e, t, r);
    }
}
s(Bn, 'diff');
function a_(e, t, r) {
  const n = Wt(e, zu),
    o = Wt(t, zu);
  return n === o
    ? ''
    : Ei(
        n.split(`
`),
        o.split(`
`),
        r,
      );
}
s(a_, 'comparePrimitive');
function Gu(e) {
  return new Map(Array.from(e.entries()).sort());
}
s(Gu, 'sortMap');
function Wu(e) {
  return new Set(Array.from(e.values()).sort());
}
s(Wu, 'sortSet');
function Xi(e, t, r) {
  let n,
    o = !1;
  try {
    const a = ba(zu, r);
    n = Ku(e, t, a, r);
  } catch {
    o = !0;
  }
  const i = ga(LS, r);
  if (n === void 0 || n === i) {
    const a = ba(i_, r);
    ((n = Ku(e, t, a, r)),
      n !== i &&
        !o &&
        (n = `${ga(OF, r)}

${n}`));
  }
  return n;
}
s(Xi, 'compareObjects');
function ba(e, t) {
  const { compareKeys: r, printBasicPrototype: n, maxDepth: o } = tn(t);
  return { ...e, compareKeys: r, printBasicPrototype: n, maxDepth: o ?? e.maxDepth };
}
s(ba, 'getFormatOptions');
function Ku(e, t, r, n) {
  const o = { ...r, indent: 0 },
    i = Wt(e, o),
    a = Wt(t, o);
  if (i === a) return ga(LS, n);
  {
    const c = Wt(e, r),
      d = Wt(t, r);
    return XS(
      c.split(`
`),
      d.split(`
`),
      i.split(`
`),
      a.split(`
`),
      n,
    );
  }
}
s(Ku, 'getObjectsDifference');
var Dg = 2e4;
function Yu(e) {
  return Ks(e) === 'Object' && typeof e.asymmetricMatch == 'function';
}
s(Yu, 'isAsymmetricMatcher');
function Xu(e, t) {
  const r = Ks(e),
    n = Ks(t);
  return r === n && (r === 'Object' || r === 'Array');
}
s(Xu, 'isReplaceable');
function Mf(e, t, r) {
  const { aAnnotation: n, bAnnotation: o } = tn(r);
  if (
    typeof t == 'string' &&
    typeof e == 'string' &&
    t.length > 0 &&
    e.length > 0 &&
    t.length <= Dg &&
    e.length <= Dg &&
    t !== e
  ) {
    if (
      t.includes(`
`) ||
      e.includes(`
`)
    )
      return o_(t, e, r);
    const [p] = qf(t, e, !0),
      f = p.some((v) => v[0] === Je),
      m = l_(n, o),
      h = m(n) + u_(Qu(p, bt, f)),
      g = m(o) + c_(Qu(p, ct, f));
    return `${h}
${g}`;
  }
  const i = Bu(t, { forceWritable: !0 }),
    a = Bu(e, { forceWritable: !0 }),
    { replacedExpected: c, replacedActual: d } = jf(a, i);
  return Bn(c, d, r);
}
s(Mf, 'printDiffOrStringify');
function jf(e, t, r = new WeakSet(), n = new WeakSet()) {
  return e instanceof Error && t instanceof Error && typeof e.cause < 'u' && typeof t.cause > 'u'
    ? (delete e.cause, { replacedActual: e, replacedExpected: t })
    : Xu(e, t)
      ? r.has(e) || n.has(t)
        ? { replacedActual: e, replacedExpected: t }
        : (r.add(e),
          n.add(t),
          Rf(t).forEach((o) => {
            const i = t[o],
              a = e[o];
            if (Yu(i)) i.asymmetricMatch(a) && (e[o] = i);
            else if (Yu(a)) a.asymmetricMatch(i) && (t[o] = a);
            else if (Xu(a, i)) {
              const c = jf(a, i, r, n);
              ((e[o] = c.replacedActual), (t[o] = c.replacedExpected));
            }
          }),
          { replacedActual: e, replacedExpected: t })
      : { replacedActual: e, replacedExpected: t };
}
s(jf, 'replaceAsymmetricMatcher');
function l_(...e) {
  const t = e.reduce((r, n) => (n.length > r ? n.length : r), 0);
  return (r) => `${r}: ${' '.repeat(t - r.length)}`;
}
s(l_, 'getLabelPrinter');
var LF = '';
function $f(e) {
  return e.replace(/\s+$/gm, (t) => LF.repeat(t.length));
}
s($f, 'replaceTrailingSpaces');
function c_(e) {
  return Ue.red($f(Et(e)));
}
s(c_, 'printReceived');
function u_(e) {
  return Ue.green($f(Et(e)));
}
s(u_, 'printExpected');
function Qu(e, t, r) {
  return e.reduce(
    (n, o) => n + (o[0] === Je ? o[1] : o[0] === t ? (r ? Ue.inverse(o[1]) : o[1]) : ''),
    '',
  );
}
s(Qu, 'getCommonAndChangedSubstrings');
var FF = '@@__IMMUTABLE_RECORD__@@',
  BF = '@@__IMMUTABLE_ITERABLE__@@';
function d_(e) {
  return e && (e[BF] || e[FF]);
}
s(d_, 'isImmutable');
var JF = Object.getPrototypeOf({});
function Zu(e) {
  return e instanceof Error
    ? `<unserializable>: ${e.message}`
    : typeof e == 'string'
      ? `<unserializable>: ${e}`
      : '<unserializable>';
}
s(Zu, 'getUnserializableMessage');
function Sr(e, t = new WeakMap()) {
  if (!e || typeof e == 'string') return e;
  if (e instanceof Error && 'toJSON' in e && typeof e.toJSON == 'function') {
    const r = e.toJSON();
    return (
      r &&
        r !== e &&
        typeof r == 'object' &&
        (typeof e.message == 'string' && As(() => r.message ?? (r.message = e.message)),
        typeof e.stack == 'string' && As(() => r.stack ?? (r.stack = e.stack)),
        typeof e.name == 'string' && As(() => r.name ?? (r.name = e.name)),
        e.cause != null && As(() => r.cause ?? (r.cause = Sr(e.cause, t)))),
      Sr(r, t)
    );
  }
  if (typeof e == 'function') return `Function<${e.name || 'anonymous'}>`;
  if (typeof e == 'symbol') return e.toString();
  if (typeof e != 'object') return e;
  if (typeof Buffer < 'u' && e instanceof Buffer) return `<Buffer(${e.length}) ...>`;
  if (typeof Uint8Array < 'u' && e instanceof Uint8Array) return `<Uint8Array(${e.length}) ...>`;
  if (d_(e)) return Sr(e.toJSON(), t);
  if (e instanceof Promise || (e.constructor && e.constructor.prototype === 'AsyncFunction'))
    return 'Promise';
  if (typeof Element < 'u' && e instanceof Element) return e.tagName;
  if (typeof e.asymmetricMatch == 'function') return `${e.toString()} ${CS(e.sample)}`;
  if (typeof e.toJSON == 'function') return Sr(e.toJSON(), t);
  if (t.has(e)) return t.get(e);
  if (Array.isArray(e)) {
    const r = new Array(e.length);
    return (
      t.set(e, r),
      e.forEach((n, o) => {
        try {
          r[o] = Sr(n, t);
        } catch (i) {
          r[o] = Zu(i);
        }
      }),
      r
    );
  } else {
    const r = Object.create(null);
    t.set(e, r);
    let n = e;
    for (; n && n !== JF; )
      (Object.getOwnPropertyNames(n).forEach((o) => {
        if (!(o in r))
          try {
            r[o] = Sr(e[o], t);
          } catch (i) {
            (delete r[o], (r[o] = Zu(i)));
          }
      }),
        (n = Object.getPrototypeOf(n)));
    return r;
  }
}
s(Sr, 'serializeValue');
function As(e) {
  try {
    return e();
  } catch {}
}
s(As, 'safe');
function p_(e) {
  return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, '');
}
s(p_, 'normalizeErrorMessage');
function ql(e, t, r = new WeakSet()) {
  if (!e || typeof e != 'object') return { message: String(e) };
  const n = e;
  ((n.showDiff || (n.showDiff === void 0 && n.expected !== void 0 && n.actual !== void 0)) &&
    (n.diff = Mf(n.actual, n.expected, { ...t, ...n.diffOptions })),
    'expected' in n && typeof n.expected != 'string' && (n.expected = Et(n.expected, 10)),
    'actual' in n && typeof n.actual != 'string' && (n.actual = Et(n.actual, 10)));
  try {
    typeof n.message == 'string' && (n.message = p_(n.message));
  } catch {}
  try {
    !r.has(n) && typeof n.cause == 'object' && (r.add(n), (n.cause = ql(n.cause, t, r)));
  } catch {}
  try {
    return Sr(n);
  } catch (o) {
    return Sr(
      new Error(`Failed to fully serialize error: ${o?.message}
Inner error message: ${n?.message}`),
    );
  }
}
s(ql, 'processError');
var hr = {
    CALL: 'storybook/instrumenter/call',
    SYNC: 'storybook/instrumenter/sync',
    START: 'storybook/instrumenter/start',
    BACK: 'storybook/instrumenter/back',
    GOTO: 'storybook/instrumenter/goto',
    NEXT: 'storybook/instrumenter/next',
    END: 'storybook/instrumenter/end',
  },
  ou = globalThis.__STORYBOOK_ADDONS_PREVIEW,
  UF = new Error(
    'This function ran after the play function completed. Did you forget to `await` it?',
  ),
  Lg = s((e) => Object.prototype.toString.call(e) === '[object Object]', 'isObject'),
  VF = s((e) => Object.prototype.toString.call(e) === '[object Module]', 'isModule'),
  HF = s((e) => {
    if (!Lg(e) && !VF(e)) return !1;
    if (e.constructor === void 0) return !0;
    const t = e.constructor.prototype;
    return !!Lg(t);
  }, 'isInstrumentable'),
  zF = s((e) => {
    try {
      return new e.constructor();
    } catch {
      return {};
    }
  }, 'construct'),
  su = s(
    () => ({
      renderPhase: 'preparing',
      isDebugging: !1,
      isPlaying: !1,
      isLocked: !1,
      cursor: 0,
      calls: [],
      shadowCalls: [],
      callRefsByResult: new Map(),
      chainedCallIds: new Set(),
      ancestors: [],
      playUntil: void 0,
      resolvers: {},
      syncTimeout: void 0,
    }),
    'getInitialState',
  ),
  Fg = s((e, t = !1) => {
    const r = (t ? e.shadowCalls : e.calls).filter((o) => o.retain);
    if (!r.length) return;
    const n = new Map(Array.from(e.callRefsByResult.entries()).filter(([, o]) => o.retain));
    return { cursor: r.length, calls: r, callRefsByResult: n };
  }, 'getRetainedState'),
  f_ = class {
    constructor() {
      ((this.detached = !1),
        (this.initialized = !1),
        (this.state = {}),
        (this.loadParentWindowState = s(() => {
          try {
            this.state =
              te.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
          } catch {
            this.detached = !0;
          }
        }, 'loadParentWindowState')),
        (this.updateParentWindowState = s(() => {
          try {
            te.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
          } catch {
            this.detached = !0;
          }
        }, 'updateParentWindowState')),
        this.loadParentWindowState());
      const t = s(({ storyId: d, renderPhase: u, isPlaying: p = !0, isDebugging: f = !1 }) => {
          const m = this.getState(d);
          (this.setState(d, {
            ...su(),
            ...Fg(m, f),
            renderPhase: u || m.renderPhase,
            shadowCalls: f ? m.shadowCalls : [],
            chainedCallIds: f ? m.chainedCallIds : new Set(),
            playUntil: f ? m.playUntil : void 0,
            isPlaying: p,
            isDebugging: f,
          }),
            this.sync(d));
        }, 'resetState'),
        r = s(
          (d) =>
            ({ storyId: u, playUntil: p }) => {
              this.getState(u).isDebugging ||
                this.setState(u, ({ calls: m }) => ({
                  calls: [],
                  shadowCalls: m.map((h) => ({ ...h, status: 'waiting' })),
                  isDebugging: !0,
                }));
              const f = this.getLog(u);
              (this.setState(u, ({ shadowCalls: m }) => {
                if (p || !f.length) return { playUntil: p };
                const h = m.findIndex((g) => g.id === f[0].callId);
                return {
                  playUntil: m
                    .slice(0, h)
                    .filter((g) => g.interceptable && !g.ancestors?.length)
                    .slice(-1)[0]?.id,
                };
              }),
                d.emit(fa, { storyId: u, isDebugging: !0 }));
            },
          'start',
        ),
        n = s(
          (d) =>
            ({ storyId: u }) => {
              const p = this.getLog(u).filter((m) => !m.ancestors?.length),
                f = p.reduceRight((m, h, g) => (m >= 0 || h.status === 'waiting' ? m : g), -1);
              r(d)({ storyId: u, playUntil: p[f - 1]?.callId });
            },
          'back',
        ),
        o = s(
          (d) =>
            ({ storyId: u, callId: p }) => {
              const { calls: f, shadowCalls: m, resolvers: h } = this.getState(u),
                g = f.find(({ id: E }) => E === p),
                v = m.find(({ id: E }) => E === p);
              if (!g && v && Object.values(h).length > 0) {
                const E = this.getLog(u).find((b) => b.status === 'waiting')?.callId;
                (v.id !== E && this.setState(u, { playUntil: v.id }),
                  Object.values(h).forEach((b) => b()));
              } else r(d)({ storyId: u, playUntil: p });
            },
          'goto',
        ),
        i = s(
          (d) =>
            ({ storyId: u }) => {
              const { resolvers: p } = this.getState(u);
              if (Object.values(p).length > 0) Object.values(p).forEach((f) => f());
              else {
                const f = this.getLog(u).find((m) => m.status === 'waiting')?.callId;
                f ? r(d)({ storyId: u, playUntil: f }) : a({ storyId: u });
              }
            },
          'next',
        ),
        a = s(({ storyId: d }) => {
          (this.setState(d, { playUntil: void 0, isDebugging: !1 }),
            Object.values(this.getState(d).resolvers).forEach((u) => u()));
        }, 'end'),
        c = s(({ storyId: d, newPhase: u }) => {
          const { isDebugging: p } = this.getState(d);
          if (u === 'preparing' && p) return t({ storyId: d, renderPhase: u, isDebugging: p });
          if (u === 'playing') return t({ storyId: d, renderPhase: u, isDebugging: p });
          (u === 'played'
            ? this.setState(d, { renderPhase: u, isLocked: !1, isPlaying: !1, isDebugging: !1 })
            : u === 'errored'
              ? this.setState(d, { renderPhase: u, isLocked: !1, isPlaying: !1 })
              : u === 'aborted'
                ? this.setState(d, { renderPhase: u, isLocked: !0, isPlaying: !1 })
                : this.setState(d, { renderPhase: u }),
            this.sync(d));
        }, 'renderPhaseChanged');
      ou &&
        ou.ready().then(() => {
          ((this.channel = ou.getChannel()),
            this.channel.on(fa, t),
            this.channel.on(xn, c),
            this.channel.on(Lp, () => {
              this.initialized ? this.cleanup() : (this.initialized = !0);
            }),
            this.channel.on(hr.START, r(this.channel)),
            this.channel.on(hr.BACK, n(this.channel)),
            this.channel.on(hr.GOTO, o(this.channel)),
            this.channel.on(hr.NEXT, i(this.channel)),
            this.channel.on(hr.END, a));
        });
    }
    getState(t) {
      return this.state[t] || su();
    }
    setState(t, r) {
      if (t) {
        const n = this.getState(t),
          o = typeof r == 'function' ? r(n) : r;
        ((this.state = { ...this.state, [t]: { ...n, ...o } }), this.updateParentWindowState());
      }
    }
    cleanup() {
      this.state = Object.entries(this.state).reduce((n, [o, i]) => {
        const a = Fg(i);
        return (a && (n[o] = Object.assign(su(), a)), n);
      }, {});
      const r = {
        controlStates: {
          detached: this.detached,
          start: !1,
          back: !1,
          goto: !1,
          next: !1,
          end: !1,
        },
        logItems: [],
      };
      (this.channel?.emit(hr.SYNC, r), this.updateParentWindowState());
    }
    getLog(t) {
      const { calls: r, shadowCalls: n } = this.getState(t),
        o = [...n];
      r.forEach((a, c) => {
        o[c] = a;
      });
      const i = new Set();
      return o.reduceRight(
        (a, c) => (
          c.args.forEach((d) => {
            d?.__callId__ && i.add(d.__callId__);
          }),
          c.path.forEach((d) => {
            d.__callId__ && i.add(d.__callId__);
          }),
          (c.interceptable || c.exception) &&
            !i.has(c.id) &&
            (a.unshift({ callId: c.id, status: c.status, ancestors: c.ancestors }), i.add(c.id)),
          a
        ),
        [],
      );
    }
    instrument(t, r, n = 0) {
      if (!HF(t)) return t;
      const { mutate: o = !1, path: i = [] } = r,
        a = r.getKeys ? r.getKeys(t, n) : Object.keys(t);
      return (
        (n += 1),
        a.reduce(
          (c, d) => {
            const u = m_(t, d);
            if (typeof u?.get == 'function') {
              if (u.configurable) {
                const f = s(() => u?.get?.bind(t)?.(), 'getter');
                Object.defineProperty(c, d, {
                  get: s(() => this.instrument(f(), { ...r, path: i.concat(d) }, n), 'get'),
                });
              }
              return c;
            }
            const p = t[d];
            return typeof p != 'function'
              ? ((c[d] = this.instrument(p, { ...r, path: i.concat(d) }, n)), c)
              : '__originalFn__' in p && typeof p.__originalFn__ == 'function'
                ? ((c[d] = p), c)
                : ((c[d] = (...f) => this.track(d, p, t, f, r)),
                  (c[d].__originalFn__ = p),
                  Object.defineProperty(c[d], 'name', { value: d, writable: !1 }),
                  Object.keys(p).length > 0 &&
                    Object.assign(c[d], this.instrument({ ...p }, { ...r, path: i.concat(d) }, n)),
                  c);
          },
          o ? t : zF(t),
        )
      );
    }
    track(t, r, n, o, i) {
      const a = o?.[0]?.__storyId__ || te.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId,
        { cursor: c, ancestors: d } = this.getState(a);
      this.setState(a, { cursor: c + 1 });
      const u = `${d.slice(-1)[0] || a} [${c}] ${t}`,
        { path: p = [], intercept: f = !1, retain: m = !1 } = i,
        h = typeof f == 'function' ? f(t, p) : f,
        g = {
          id: u,
          cursor: c,
          storyId: a,
          ancestors: d,
          path: p,
          method: t,
          args: o,
          interceptable: h,
          retain: m,
        },
        E = (h && !d.length ? this.intercept : this.invoke).call(this, r, n, g, i);
      return this.instrument(E, { ...i, mutate: !0, path: [{ __callId__: g.id }] });
    }
    intercept(t, r, n, o) {
      const { chainedCallIds: i, isDebugging: a, playUntil: c } = this.getState(n.storyId),
        d = i.has(n.id);
      return !a || d || c
        ? (c === n.id && this.setState(n.storyId, { playUntil: void 0 }), this.invoke(t, r, n, o))
        : new Promise((u) => {
            this.setState(n.storyId, ({ resolvers: p }) => ({
              isLocked: !1,
              resolvers: { ...p, [n.id]: u },
            }));
          }).then(
            () => (
              this.setState(n.storyId, (u) => {
                const { [n.id]: p, ...f } = u.resolvers;
                return { isLocked: !0, resolvers: f };
              }),
              this.invoke(t, r, n, o)
            ),
          );
    }
    invoke(t, r, n, o) {
      const { callRefsByResult: i, renderPhase: a } = this.getState(n.storyId),
        c = 25,
        d = s((f, m, h) => {
          if (h.includes(f)) return '[Circular]';
          if (((h = [...h, f]), m > c)) return '...';
          if (i.has(f)) return i.get(f);
          if (f instanceof Array) return f.map((g) => d(g, ++m, h));
          if (f instanceof Date) return { __date__: { value: f.toISOString() } };
          if (f instanceof Error) {
            const { name: g, message: v, stack: E } = f;
            return { __error__: { name: g, message: v, stack: E } };
          }
          if (f instanceof RegExp) {
            const { flags: g, source: v } = f;
            return { __regexp__: { flags: g, source: v } };
          }
          if (f instanceof te.window?.HTMLElement) {
            const { prefix: g, localName: v, id: E, classList: b, innerText: S } = f,
              R = Array.from(b);
            return { __element__: { prefix: g, localName: v, id: E, classNames: R, innerText: S } };
          }
          return typeof f == 'function'
            ? { __function__: { name: 'getMockName' in f ? f.getMockName() : f.name } }
            : typeof f == 'symbol'
              ? { __symbol__: { description: f.description } }
              : typeof f == 'object' && f?.constructor?.name && f?.constructor?.name !== 'Object'
                ? { __class__: { name: f.constructor.name } }
                : Object.prototype.toString.call(f) === '[object Object]'
                  ? Object.fromEntries(Object.entries(f).map(([g, v]) => [g, d(v, ++m, h)]))
                  : f;
        }, 'serializeValues'),
        u = { ...n, args: n.args.map((f) => d(f, 0, [])) };
      n.path.forEach((f) => {
        f?.__callId__ &&
          this.setState(n.storyId, ({ chainedCallIds: m }) => ({
            chainedCallIds: new Set(Array.from(m).concat(f.__callId__)),
          }));
      });
      const p = s((f) => {
        if (f instanceof Error) {
          const { name: m, message: h, stack: g, callId: v = n.id } = f,
            {
              showDiff: E = void 0,
              diff: b = void 0,
              actual: S = void 0,
              expected: R = void 0,
            } = f.name === 'AssertionError' ? ql(f) : f,
            I = {
              name: m,
              message: h,
              stack: g,
              callId: v,
              showDiff: E,
              diff: b,
              actual: S,
              expected: R,
            };
          if (
            (this.update({ ...u, status: 'error', exception: I }),
            this.setState(n.storyId, (q) => ({
              callRefsByResult: new Map([
                ...Array.from(q.callRefsByResult.entries()),
                [f, { __callId__: n.id, retain: n.retain }],
              ]),
            })),
            n.ancestors?.length)
          )
            throw (
              Object.prototype.hasOwnProperty.call(f, 'callId') ||
                Object.defineProperty(f, 'callId', { value: n.id }),
              f
            );
        }
        throw f;
      }, 'handleException');
      try {
        if (a === 'played' && !n.retain) throw UF;
        const m = (o.getArgs ? o.getArgs(n, this.getState(n.storyId)) : n.args).map((g) =>
            typeof g != 'function' || y_(g) || Object.keys(g).length
              ? g
              : (...v) => {
                  const { cursor: E, ancestors: b } = this.getState(n.storyId);
                  this.setState(n.storyId, { cursor: 0, ancestors: [...b, n.id] });
                  const S = s(
                    () => this.setState(n.storyId, { cursor: E, ancestors: b }),
                    'restore',
                  );
                  let R = !1;
                  try {
                    const I = g(...v);
                    return I instanceof Promise ? ((R = !0), I.finally(S)) : I;
                  } finally {
                    R || S();
                  }
                },
          ),
          h = t.apply(r, m);
        return (
          h &&
            ['object', 'function', 'symbol'].includes(typeof h) &&
            this.setState(n.storyId, (g) => ({
              callRefsByResult: new Map([
                ...Array.from(g.callRefsByResult.entries()),
                [h, { __callId__: n.id, retain: n.retain }],
              ]),
            })),
          this.update({ ...u, status: h instanceof Promise ? 'active' : 'done' }),
          h instanceof Promise ? h.then((g) => (this.update({ ...u, status: 'done' }), g), p) : h
        );
      } catch (f) {
        return p(f);
      }
    }
    update(t) {
      (this.channel?.emit(hr.CALL, t),
        this.setState(t.storyId, ({ calls: r }) => {
          const n = r.concat(t).reduce((o, i) => Object.assign(o, { [i.id]: i }), {});
          return {
            calls: Object.values(n).sort((o, i) =>
              o.id.localeCompare(i.id, void 0, { numeric: !0 }),
            ),
          };
        }),
        this.sync(t.storyId));
    }
    sync(t) {
      const r = s(() => {
        const { isLocked: n, isPlaying: o } = this.getState(t),
          i = this.getLog(t),
          a = i.filter(({ ancestors: f }) => !f.length).find((f) => f.status === 'waiting')?.callId,
          c = i.some((f) => f.status === 'active');
        if (this.detached || n || c || i.length === 0) {
          const m = {
            controlStates: {
              detached: this.detached,
              start: !1,
              back: !1,
              goto: !1,
              next: !1,
              end: !1,
            },
            logItems: i,
          };
          this.channel?.emit(hr.SYNC, m);
          return;
        }
        const d = i.some((f) => f.status === 'done' || f.status === 'error'),
          p = {
            controlStates: {
              detached: this.detached,
              start: d,
              back: d,
              goto: !0,
              next: o,
              end: o,
            },
            logItems: i,
            pausedAt: a,
          };
        this.channel?.emit(hr.SYNC, p);
      }, 'synchronize');
      this.setState(
        t,
        ({ syncTimeout: n }) => (clearTimeout(n), { syncTimeout: setTimeout(r, 0) }),
      );
    }
  };
s(f_, 'Instrumenter');
var GF = f_;
function jo(e, t = {}) {
  try {
    let r = !1,
      n = !1;
    return (
      te.window?.location?.search?.includes('instrument=true')
        ? (r = !0)
        : te.window?.location?.search?.includes('instrument=false') && (n = !0),
      (te.window?.parent === te.window && !r) || n
        ? e
        : (te.window &&
            !te.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ &&
            (te.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new GF()),
          (te.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(e, t))
    );
  } catch (r) {
    return (Ve.warn(r), e);
  }
}
s(jo, 'instrument');
function m_(e, t) {
  let r = e;
  for (; r != null; ) {
    const n = Object.getOwnPropertyDescriptor(r, t);
    if (n) return n;
    r = Object.getPrototypeOf(r);
  }
}
s(m_, 'getPropertyDescriptor');
function y_(e) {
  if (typeof e != 'function') return !1;
  const t = Object.getOwnPropertyDescriptor(e, 'prototype');
  return t ? !t.writable : !1;
}
s(y_, 'isClass');
var h_ = Object.defineProperty,
  z = s((e, t) => h_(e, 'name', { value: t, configurable: !0 }), '__name'),
  kf = s((e, t) => {
    for (var r in t) h_(e, r, { get: t[r], enumerable: !0 });
  }, '__export'),
  rr = {};
kf(rr, {
  addChainableMethod: s(() => Hl, 'addChainableMethod'),
  addLengthGuard: s(() => Do, 'addLengthGuard'),
  addMethod: s(() => Jl, 'addMethod'),
  addProperty: s(() => Bl, 'addProperty'),
  checkError: s(() => xt, 'checkError'),
  compareByInspect: s(() => Zs, 'compareByInspect'),
  eql: s(() => b_, 'eql'),
  expectTypes: s(() => Vf, 'expectTypes'),
  flag: s(() => me, 'flag'),
  getActual: s(() => Si, 'getActual'),
  getMessage: s(() => $l, 'getMessage'),
  getName: s(() => Ai, 'getName'),
  getOperator: s(() => Kl, 'getOperator'),
  getOwnEnumerableProperties: s(() => Wl, 'getOwnEnumerableProperties'),
  getOwnEnumerablePropertySymbols: s(() => Gl, 'getOwnEnumerablePropertySymbols'),
  getPathInfo: s(() => Fl, 'getPathInfo'),
  hasProperty: s(() => _i, 'hasProperty'),
  inspect: s(() => Se, 'inspect'),
  isNaN: s(() => qa, 'isNaN'),
  isNumeric: s(() => rt, 'isNumeric'),
  isProxyEnabled: s(() => ko, 'isProxyEnabled'),
  isRegExp: s(() => ei, 'isRegExp'),
  objDisplay: s(() => Jr, 'objDisplay'),
  overwriteChainableMethod: s(() => zl, 'overwriteChainableMethod'),
  overwriteMethod: s(() => Vl, 'overwriteMethod'),
  overwriteProperty: s(() => Ul, 'overwriteProperty'),
  proxify: s(() => Jn, 'proxify'),
  test: s(() => Ml, 'test'),
  transferFlags: s(() => Jt, 'transferFlags'),
  type: s(() => Ce, 'type'),
});
var xt = {};
kf(xt, {
  compatibleConstructor: s(() => Ff, 'compatibleConstructor'),
  compatibleInstance: s(() => Lf, 'compatibleInstance'),
  compatibleMessage: s(() => Bf, 'compatibleMessage'),
  getConstructorName: s(() => Jf, 'getConstructorName'),
  getMessage: s(() => Uf, 'getMessage'),
});
function wi(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === '[object Error]';
}
s(wi, 'isErrorInstance');
z(wi, 'isErrorInstance');
function Df(e) {
  return Object.prototype.toString.call(e) === '[object RegExp]';
}
s(Df, 'isRegExp');
z(Df, 'isRegExp');
function Lf(e, t) {
  return wi(t) && e === t;
}
s(Lf, 'compatibleInstance');
z(Lf, 'compatibleInstance');
function Ff(e, t) {
  return wi(t)
    ? e.constructor === t.constructor || e instanceof t.constructor
    : (typeof t == 'object' || typeof t == 'function') && t.prototype
      ? e.constructor === t || e instanceof t
      : !1;
}
s(Ff, 'compatibleConstructor');
z(Ff, 'compatibleConstructor');
function Bf(e, t) {
  const r = typeof e == 'string' ? e : e.message;
  return Df(t) ? t.test(r) : typeof t == 'string' ? r.indexOf(t) !== -1 : !1;
}
s(Bf, 'compatibleMessage');
z(Bf, 'compatibleMessage');
function Jf(e) {
  let t = e;
  return (
    wi(e)
      ? (t = e.constructor.name)
      : typeof e == 'function' && ((t = e.name), t === '' && (t = new e().name || t)),
    t
  );
}
s(Jf, 'getConstructorName');
z(Jf, 'getConstructorName');
function Uf(e) {
  let t = '';
  return (e && e.message ? (t = e.message) : typeof e == 'string' && (t = e), t);
}
s(Uf, 'getMessage');
z(Uf, 'getMessage');
function me(e, t, r) {
  let n = e.__flags || (e.__flags = Object.create(null));
  if (arguments.length === 3) n[t] = r;
  else return n[t];
}
s(me, 'flag');
z(me, 'flag');
function Ml(e, t) {
  let r = me(e, 'negate'),
    n = t[0];
  return r ? !n : n;
}
s(Ml, 'test');
z(Ml, 'test');
function Ce(e) {
  if (typeof e > 'u') return 'undefined';
  if (e === null) return 'null';
  const t = e[Symbol.toStringTag];
  return typeof t == 'string' ? t : Object.prototype.toString.call(e).slice(8, -1);
}
s(Ce, 'type');
z(Ce, 'type');
var WF = 'captureStackTrace' in Error,
  vs,
  Re =
    ((vs = class extends Error {
      constructor(t = 'Unspecified AssertionError', r, n) {
        super(t);
        Be(this, 'message');
        ((this.message = t), WF && Error.captureStackTrace(this, n || vs));
        for (const o in r) o in this || (this[o] = r[o]);
      }
      get name() {
        return 'AssertionError';
      }
      get ok() {
        return !1;
      }
      toJSON(t) {
        return {
          ...this,
          name: this.name,
          message: this.message,
          ok: !1,
          stack: t !== !1 ? this.stack : void 0,
        };
      }
    }),
    s(vs, '_AssertionError'),
    z(vs, 'AssertionError'),
    vs);
function Vf(e, t) {
  let r = me(e, 'message'),
    n = me(e, 'ssfi');
  ((r = r ? r + ': ' : ''),
    (e = me(e, 'object')),
    (t = t.map(function (a) {
      return a.toLowerCase();
    })),
    t.sort());
  let o = t
      .map(function (a, c) {
        let d = ~['a', 'e', 'i', 'o', 'u'].indexOf(a.charAt(0)) ? 'an' : 'a';
        return (t.length > 1 && c === t.length - 1 ? 'or ' : '') + d + ' ' + a;
      })
      .join(', '),
    i = Ce(e).toLowerCase();
  if (
    !t.some(function (a) {
      return i === a;
    })
  )
    throw new Re(r + 'object tested must be ' + o + ', but ' + i + ' given', void 0, n);
}
s(Vf, 'expectTypes');
z(Vf, 'expectTypes');
function Si(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
s(Si, 'getActual');
z(Si, 'getActual');
var Bg = {
    bold: ['1', '22'],
    dim: ['2', '22'],
    italic: ['3', '23'],
    underline: ['4', '24'],
    inverse: ['7', '27'],
    hidden: ['8', '28'],
    strike: ['9', '29'],
    black: ['30', '39'],
    red: ['31', '39'],
    green: ['32', '39'],
    yellow: ['33', '39'],
    blue: ['34', '39'],
    magenta: ['35', '39'],
    cyan: ['36', '39'],
    white: ['37', '39'],
    brightblack: ['30;1', '39'],
    brightred: ['31;1', '39'],
    brightgreen: ['32;1', '39'],
    brightyellow: ['33;1', '39'],
    brightblue: ['34;1', '39'],
    brightmagenta: ['35;1', '39'],
    brightcyan: ['36;1', '39'],
    brightwhite: ['37;1', '39'],
    grey: ['90', '39'],
  },
  KF = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red',
  },
  vo = '';
function Hf(e, t) {
  const r = Bg[KF[t]] || Bg[t] || '';
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
s(Hf, 'colorise');
z(Hf, 'colorise');
function zf(
  {
    showHidden: e = !1,
    depth: t = 2,
    colors: r = !1,
    customInspect: n = !0,
    showProxy: o = !1,
    maxArrayLength: i = 1 / 0,
    breakLength: a = 1 / 0,
    seen: c = [],
    truncate: d = 1 / 0,
    stylize: u = String,
  } = {},
  p,
) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!o,
    maxArrayLength: Number(i),
    breakLength: Number(a),
    truncate: Number(d),
    seen: c,
    inspect: p,
    stylize: u,
  };
  return (f.colors && (f.stylize = Hf), f);
}
s(zf, 'normaliseOptions');
z(zf, 'normaliseOptions');
function Gf(e) {
  return e >= '\uD800' && e <= '\uDBFF';
}
s(Gf, 'isHighSurrogate');
z(Gf, 'isHighSurrogate');
function cr(e, t, r = vo) {
  e = String(e);
  const n = r.length,
    o = e.length;
  if (n > t && o > n) return r;
  if (o > t && o > n) {
    let i = t - n;
    return (i > 0 && Gf(e[i - 1]) && (i = i - 1), `${e.slice(0, i)}${r}`);
  }
  return e;
}
s(cr, 'truncate');
z(cr, 'truncate');
function Nt(e, t, r, n = ', ') {
  r = r || t.inspect;
  const o = e.length;
  if (o === 0) return '';
  const i = t.truncate;
  let a = '',
    c = '',
    d = '';
  for (let u = 0; u < o; u += 1) {
    const p = u + 1 === e.length,
      f = u + 2 === e.length;
    d = `${vo}(${e.length - u})`;
    const m = e[u];
    t.truncate = i - a.length - (p ? 0 : n.length);
    const h = c || r(m, t) + (p ? '' : n),
      g = a.length + h.length,
      v = g + d.length;
    if (
      (p && g > i && a.length + d.length <= i) ||
      (!p && !f && v > i) ||
      ((c = p ? '' : r(e[u + 1], t) + (f ? '' : n)), !p && f && v > i && g + c.length > i)
    )
      break;
    if (((a += h), !p && !f && g + c.length >= i)) {
      d = `${vo}(${e.length - u - 1})`;
      break;
    }
    d = '';
  }
  return `${a}${d}`;
}
s(Nt, 'inspectList');
z(Nt, 'inspectList');
function Wf(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
    ? e
    : JSON.stringify(e)
        .replace(/'/g, "\\'")
        .replace(/\\"/g, '"')
        .replace(/(^"|"$)/g, "'");
}
s(Wf, 'quoteComplexKey');
z(Wf, 'quoteComplexKey');
function Pn([e, t], r) {
  return (
    (r.truncate -= 2),
    typeof e == 'string' ? (e = Wf(e)) : typeof e != 'number' && (e = `[${r.inspect(e, r)}]`),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e}: ${t}`
  );
}
s(Pn, 'inspectProperty');
z(Pn, 'inspectProperty');
function Kf(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length) return '[]';
  t.truncate -= 4;
  const n = Nt(e, t);
  t.truncate -= n.length;
  let o = '';
  return (
    r.length &&
      (o = Nt(
        r.map((i) => [i, e[i]]),
        t,
        Pn,
      )),
    `[ ${n}${o ? `, ${o}` : ''} ]`
  );
}
s(Kf, 'inspectArray');
z(Kf, 'inspectArray');
var YF = z(
  (e) =>
    typeof Buffer == 'function' && e instanceof Buffer
      ? 'Buffer'
      : e[Symbol.toStringTag]
        ? e[Symbol.toStringTag]
        : e.constructor.name,
  'getArrayName',
);
function Ht(e, t) {
  const r = YF(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length) return `${r}[]`;
  let o = '';
  for (let a = 0; a < e.length; a++) {
    const c = `${t.stylize(cr(e[a], t.truncate), 'number')}${a === e.length - 1 ? '' : ', '}`;
    if (((t.truncate -= c.length), e[a] !== e.length && t.truncate <= 3)) {
      o += `${vo}(${e.length - e[a] + 1})`;
      break;
    }
    o += c;
  }
  let i = '';
  return (
    n.length &&
      (i = Nt(
        n.map((a) => [a, e[a]]),
        t,
        Pn,
      )),
    `${r}[ ${o}${i ? `, ${i}` : ''} ]`
  );
}
s(Ht, 'inspectTypedArray');
z(Ht, 'inspectTypedArray');
function Yf(e, t) {
  const r = e.toJSON();
  if (r === null) return 'Invalid Date';
  const n = r.split('T'),
    o = n[0];
  return t.stylize(`${o}T${cr(n[1], t.truncate - o.length - 1)}`, 'date');
}
s(Yf, 'inspectDate');
z(Yf, 'inspectDate');
function va(e, t) {
  const r = e[Symbol.toStringTag] || 'Function',
    n = e.name;
  return n
    ? t.stylize(`[${r} ${cr(n, t.truncate - 11)}]`, 'special')
    : t.stylize(`[${r}]`, 'special');
}
s(va, 'inspectFunction');
z(va, 'inspectFunction');
function Xf([e, t], r) {
  return (
    (r.truncate -= 4),
    (e = r.inspect(e, r)),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e} => ${t}`
  );
}
s(Xf, 'inspectMapEntry');
z(Xf, 'inspectMapEntry');
function Qf(e) {
  const t = [];
  return (
    e.forEach((r, n) => {
      t.push([n, r]);
    }),
    t
  );
}
s(Qf, 'mapToEntries');
z(Qf, 'mapToEntries');
function Zf(e, t) {
  return e.size === 0 ? 'Map{}' : ((t.truncate -= 7), `Map{ ${Nt(Qf(e), t, Xf)} }`);
}
s(Zf, 'inspectMap');
z(Zf, 'inspectMap');
var XF = Number.isNaN || ((e) => e !== e);
function Ta(e, t) {
  return XF(e)
    ? t.stylize('NaN', 'number')
    : e === 1 / 0
      ? t.stylize('Infinity', 'number')
      : e === -1 / 0
        ? t.stylize('-Infinity', 'number')
        : e === 0
          ? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
          : t.stylize(cr(String(e), t.truncate), 'number');
}
s(Ta, 'inspectNumber');
z(Ta, 'inspectNumber');
function Ea(e, t) {
  let r = cr(e.toString(), t.truncate - 1);
  return (r !== vo && (r += 'n'), t.stylize(r, 'bigint'));
}
s(Ea, 'inspectBigInt');
z(Ea, 'inspectBigInt');
function em(e, t) {
  const r = e.toString().split('/')[2],
    n = t.truncate - (2 + r.length),
    o = e.source;
  return t.stylize(`/${cr(o, n)}/${r}`, 'regexp');
}
s(em, 'inspectRegExp');
z(em, 'inspectRegExp');
function tm(e) {
  const t = [];
  return (
    e.forEach((r) => {
      t.push(r);
    }),
    t
  );
}
s(tm, 'arrayFromSet');
z(tm, 'arrayFromSet');
function rm(e, t) {
  return e.size === 0 ? 'Set{}' : ((t.truncate -= 7), `Set{ ${Nt(tm(e), t)} }`);
}
s(rm, 'inspectSet');
z(rm, 'inspectSet');
var Jg = new RegExp(
    "['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
    'g',
  ),
  QF = { '\b': '\\b', '	': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '\\': '\\\\' },
  ZF = 16;
function nm(e) {
  return QF[e] || `\\u${`0000${e.charCodeAt(0).toString(ZF)}`.slice(-4)}`;
}
s(nm, 'escape');
z(nm, 'escape');
function wa(e, t) {
  return (Jg.test(e) && (e = e.replace(Jg, nm)), t.stylize(`'${cr(e, t.truncate - 2)}'`, 'string'));
}
s(wa, 'inspectString');
z(wa, 'inspectString');
function Sa(e) {
  return 'description' in Symbol.prototype
    ? e.description
      ? `Symbol(${e.description})`
      : 'Symbol()'
    : e.toString();
}
s(Sa, 'inspectSymbol');
z(Sa, 'inspectSymbol');
var eB = z(() => 'Promise{}', 'getPromiseValue'),
  tB = eB;
function io(e, t) {
  const r = Object.getOwnPropertyNames(e),
    n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0) return '{}';
  if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e))) return '[Circular]';
  t.seen.push(e);
  const o = Nt(
      r.map((c) => [c, e[c]]),
      t,
      Pn,
    ),
    i = Nt(
      n.map((c) => [c, e[c]]),
      t,
      Pn,
    );
  t.seen.pop();
  let a = '';
  return (o && i && (a = ', '), `{ ${o}${a}${i} }`);
}
s(io, 'inspectObject');
z(io, 'inspectObject');
var iu = typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1;
function om(e, t) {
  let r = '';
  return (
    iu && iu in e && (r = e[iu]),
    (r = r || e.constructor.name),
    (!r || r === '_class') && (r = '<Anonymous Class>'),
    (t.truncate -= r.length),
    `${r}${io(e, t)}`
  );
}
s(om, 'inspectClass');
z(om, 'inspectClass');
function sm(e, t) {
  return e.length === 0 ? 'Arguments[]' : ((t.truncate -= 13), `Arguments[ ${Nt(e, t)} ]`);
}
s(sm, 'inspectArguments');
z(sm, 'inspectArguments');
var rB = [
  'stack',
  'line',
  'column',
  'name',
  'message',
  'fileName',
  'lineNumber',
  'columnNumber',
  'number',
  'description',
  'cause',
];
function im(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((a) => rB.indexOf(a) === -1),
    n = e.name;
  t.truncate -= n.length;
  let o = '';
  if (
    (typeof e.message == 'string' ? (o = cr(e.message, t.truncate)) : r.unshift('message'),
    (o = o ? `: ${o}` : ''),
    (t.truncate -= o.length + 5),
    (t.seen = t.seen || []),
    t.seen.includes(e))
  )
    return '[Circular]';
  t.seen.push(e);
  const i = Nt(
    r.map((a) => [a, e[a]]),
    t,
    Pn,
  );
  return `${n}${o}${i ? ` { ${i} }` : ''}`;
}
s(im, 'inspectObject2');
z(im, 'inspectObject');
function am([e, t], r) {
  return (
    (r.truncate -= 3),
    t
      ? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
      : `${r.stylize(String(e), 'yellow')}`
  );
}
s(am, 'inspectAttribute');
z(am, 'inspectAttribute');
function Ys(e, t) {
  return Nt(
    e,
    t,
    lm,
    `
`,
  );
}
s(Ys, 'inspectNodeCollection');
z(Ys, 'inspectNodeCollection');
function lm(e, t) {
  switch (e.nodeType) {
    case 1:
      return jl(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
s(lm, 'inspectNode');
z(lm, 'inspectNode');
function jl(e, t) {
  const r = e.getAttributeNames(),
    n = e.tagName.toLowerCase(),
    o = t.stylize(`<${n}`, 'special'),
    i = t.stylize('>', 'special'),
    a = t.stylize(`</${n}>`, 'special');
  t.truncate -= n.length * 2 + 5;
  let c = '';
  (r.length > 0 &&
    ((c += ' '),
    (c += Nt(
      r.map((p) => [p, e.getAttribute(p)]),
      t,
      am,
      ' ',
    ))),
    (t.truncate -= c.length));
  const d = t.truncate;
  let u = Ys(e.children, t);
  return (u && u.length > d && (u = `${vo}(${e.children.length})`), `${o}${c}${i}${u}${a}`);
}
s(jl, 'inspectHTML');
z(jl, 'inspectHTML');
var nB = typeof Symbol == 'function' && typeof Symbol.for == 'function',
  au = nB ? Symbol.for('chai/inspect') : '@@chai/inspect',
  lu = Symbol.for('nodejs.util.inspect.custom'),
  Ug = new WeakMap(),
  Vg = {},
  Hg = {
    undefined: z((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
    null: z((e, t) => t.stylize('null', 'null'), 'null'),
    boolean: z((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
    Boolean: z((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
    number: Ta,
    Number: Ta,
    bigint: Ea,
    BigInt: Ea,
    string: wa,
    String: wa,
    function: va,
    Function: va,
    symbol: Sa,
    Symbol: Sa,
    Array: Kf,
    Date: Yf,
    Map: Zf,
    Set: rm,
    RegExp: em,
    Promise: tB,
    WeakSet: z((e, t) => t.stylize('WeakSet{}', 'special'), 'WeakSet'),
    WeakMap: z((e, t) => t.stylize('WeakMap{}', 'special'), 'WeakMap'),
    Arguments: sm,
    Int8Array: Ht,
    Uint8Array: Ht,
    Uint8ClampedArray: Ht,
    Int16Array: Ht,
    Uint16Array: Ht,
    Int32Array: Ht,
    Uint32Array: Ht,
    Float32Array: Ht,
    Float64Array: Ht,
    Generator: z(() => '', 'Generator'),
    DataView: z(() => '', 'DataView'),
    ArrayBuffer: z(() => '', 'ArrayBuffer'),
    Error: im,
    HTMLCollection: Ys,
    NodeList: Ys,
  },
  oB = z(
    (e, t, r) =>
      au in e && typeof e[au] == 'function'
        ? e[au](t)
        : lu in e && typeof e[lu] == 'function'
          ? e[lu](t.depth, t)
          : 'inspect' in e && typeof e.inspect == 'function'
            ? e.inspect(t.depth, t)
            : 'constructor' in e && Ug.has(e.constructor)
              ? Ug.get(e.constructor)(e, t)
              : Vg[r]
                ? Vg[r](e, t)
                : '',
    'inspectCustom',
  ),
  sB = Object.prototype.toString;
function Xs(e, t = {}) {
  const r = zf(t, Xs),
    { customInspect: n } = r;
  let o = e === null ? 'null' : typeof e;
  if ((o === 'object' && (o = sB.call(e).slice(8, -1)), o in Hg)) return Hg[o](e, r);
  if (n && e) {
    const a = oB(e, r, o);
    if (a) return typeof a == 'string' ? a : Xs(a, r);
  }
  const i = e ? Object.getPrototypeOf(e) : !1;
  return i === Object.prototype || i === null
    ? io(e, r)
    : e && typeof HTMLElement == 'function' && e instanceof HTMLElement
      ? jl(e, r)
      : 'constructor' in e
        ? e.constructor !== Object
          ? om(e, r)
          : io(e, r)
        : e === Object(e)
          ? io(e, r)
          : r.stylize(String(e), o);
}
s(Xs, 'inspect');
z(Xs, 'inspect');
var vt = {
  includeStack: !1,
  showDiff: !0,
  truncateThreshold: 40,
  useProxy: !0,
  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON'],
  deepEqual: null,
};
function Se(e, t, r, n) {
  let o = {
    colors: n,
    depth: typeof r > 'u' ? 2 : r,
    showHidden: t,
    truncate: vt.truncateThreshold ? vt.truncateThreshold : 1 / 0,
  };
  return Xs(e, o);
}
s(Se, 'inspect2');
z(Se, 'inspect');
function Jr(e) {
  let t = Se(e),
    r = Object.prototype.toString.call(e);
  if (vt.truncateThreshold && t.length >= vt.truncateThreshold) {
    if (r === '[object Function]')
      return !e.name || e.name === '' ? '[Function]' : '[Function: ' + e.name + ']';
    if (r === '[object Array]') return '[ Array(' + e.length + ') ]';
    if (r === '[object Object]') {
      let n = Object.keys(e);
      return (
        '{ Object (' + (n.length > 2 ? n.splice(0, 2).join(', ') + ', ...' : n.join(', ')) + ') }'
      );
    } else return t;
  } else return t;
}
s(Jr, 'objDisplay');
z(Jr, 'objDisplay');
function $l(e, t) {
  let r = me(e, 'negate'),
    n = me(e, 'object'),
    o = t[3],
    i = Si(e, t),
    a = r ? t[2] : t[1],
    c = me(e, 'message');
  return (
    typeof a == 'function' && (a = a()),
    (a = a || ''),
    (a = a
      .replace(/#\{this\}/g, function () {
        return Jr(n);
      })
      .replace(/#\{act\}/g, function () {
        return Jr(i);
      })
      .replace(/#\{exp\}/g, function () {
        return Jr(o);
      })),
    c ? c + ': ' + a : a
  );
}
s($l, 'getMessage2');
z($l, 'getMessage');
function Jt(e, t, r) {
  let n = e.__flags || (e.__flags = Object.create(null));
  (t.__flags || (t.__flags = Object.create(null)), (r = arguments.length === 3 ? r : !0));
  for (let o in n)
    (r || (o !== 'object' && o !== 'ssfi' && o !== 'lockSsfi' && o != 'message')) &&
      (t.__flags[o] = n[o]);
}
s(Jt, 'transferFlags');
z(Jt, 'transferFlags');
function _a(e) {
  if (typeof e > 'u') return 'undefined';
  if (e === null) return 'null';
  const t = e[Symbol.toStringTag];
  return typeof t == 'string' ? t : Object.prototype.toString.call(e).slice(8, -1);
}
s(_a, 'type2');
z(_a, 'type');
function kl() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}
s(kl, 'FakeMap');
z(kl, 'FakeMap');
kl.prototype = {
  get: z(
    s(function (t) {
      return t[this._key];
    }, 'get'),
    'get',
  ),
  set: z(
    s(function (t, r) {
      Object.isExtensible(t) && Object.defineProperty(t, this._key, { value: r, configurable: !0 });
    }, 'set'),
    'set',
  ),
};
var g_ = typeof WeakMap == 'function' ? WeakMap : kl;
function Aa(e, t, r) {
  if (!r || Yr(e) || Yr(t)) return null;
  var n = r.get(e);
  if (n) {
    var o = n.get(t);
    if (typeof o == 'boolean') return o;
  }
  return null;
}
s(Aa, 'memoizeCompare');
z(Aa, 'memoizeCompare');
function eo(e, t, r, n) {
  if (!(!r || Yr(e) || Yr(t))) {
    var o = r.get(e);
    o ? o.set(t, n) : ((o = new g_()), o.set(t, n), r.set(e, o));
  }
}
s(eo, 'memoizeSet');
z(eo, 'memoizeSet');
var b_ = $o;
function $o(e, t, r) {
  if (r && r.comparator) return Ra(e, t, r);
  var n = Dl(e, t);
  return n !== null ? n : Ra(e, t, r);
}
s($o, 'deepEqual');
z($o, 'deepEqual');
function Dl(e, t) {
  return e === t
    ? e !== 0 || 1 / e === 1 / t
    : e !== e && t !== t
      ? !0
      : Yr(e) || Yr(t)
        ? !1
        : null;
}
s(Dl, 'simpleEqual');
z(Dl, 'simpleEqual');
function Ra(e, t, r) {
  ((r = r || {}), (r.memoize = r.memoize === !1 ? !1 : r.memoize || new g_()));
  var n = r && r.comparator,
    o = Aa(e, t, r.memoize);
  if (o !== null) return o;
  var i = Aa(t, e, r.memoize);
  if (i !== null) return i;
  if (n) {
    var a = n(e, t);
    if (a === !1 || a === !0) return (eo(e, t, r.memoize, a), a);
    var c = Dl(e, t);
    if (c !== null) return c;
  }
  var d = _a(e);
  if (d !== _a(t)) return (eo(e, t, r.memoize, !1), !1);
  eo(e, t, r.memoize, !0);
  var u = cm(e, t, d, r);
  return (eo(e, t, r.memoize, u), u);
}
s(Ra, 'extensiveDeepEqual');
z(Ra, 'extensiveDeepEqual');
function cm(e, t, r, n) {
  switch (r) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      return $o(e.valueOf(), t.valueOf());
    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
      return e === t;
    case 'Error':
      return Ll(e, t, ['name', 'message', 'code'], n);
    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return Pr(e, t, n);
    case 'RegExp':
      return um(e, t);
    case 'Generator':
      return dm(e, t, n);
    case 'DataView':
      return Pr(new Uint8Array(e.buffer), new Uint8Array(t.buffer), n);
    case 'ArrayBuffer':
      return Pr(new Uint8Array(e), new Uint8Array(t), n);
    case 'Set':
      return xa(e, t, n);
    case 'Map':
      return xa(e, t, n);
    case 'Temporal.PlainDate':
    case 'Temporal.PlainTime':
    case 'Temporal.PlainDateTime':
    case 'Temporal.Instant':
    case 'Temporal.ZonedDateTime':
    case 'Temporal.PlainYearMonth':
    case 'Temporal.PlainMonthDay':
      return e.equals(t);
    case 'Temporal.Duration':
      return e.total('nanoseconds') === t.total('nanoseconds');
    case 'Temporal.TimeZone':
    case 'Temporal.Calendar':
      return e.toString() === t.toString();
    default:
      return fm(e, t, n);
  }
}
s(cm, 'extensiveDeepEqualByType');
z(cm, 'extensiveDeepEqualByType');
function um(e, t) {
  return e.toString() === t.toString();
}
s(um, 'regexpEqual');
z(um, 'regexpEqual');
function xa(e, t, r) {
  try {
    if (e.size !== t.size) return !1;
    if (e.size === 0) return !0;
  } catch {
    return !1;
  }
  var n = [],
    o = [];
  return (
    e.forEach(
      z(
        s(function (a, c) {
          n.push([a, c]);
        }, 'gatherEntries'),
        'gatherEntries',
      ),
    ),
    t.forEach(
      z(
        s(function (a, c) {
          o.push([a, c]);
        }, 'gatherEntries'),
        'gatherEntries',
      ),
    ),
    Pr(n.sort(), o.sort(), r)
  );
}
s(xa, 'entriesEqual');
z(xa, 'entriesEqual');
function Pr(e, t, r) {
  var n = e.length;
  if (n !== t.length) return !1;
  if (n === 0) return !0;
  for (var o = -1; ++o < n; ) if ($o(e[o], t[o], r) === !1) return !1;
  return !0;
}
s(Pr, 'iterableEqual');
z(Pr, 'iterableEqual');
function dm(e, t, r) {
  return Pr(Qs(e), Qs(t), r);
}
s(dm, 'generatorEqual');
z(dm, 'generatorEqual');
function pm(e) {
  return (
    typeof Symbol < 'u' &&
    typeof e == 'object' &&
    typeof Symbol.iterator < 'u' &&
    typeof e[Symbol.iterator] == 'function'
  );
}
s(pm, 'hasIteratorFunction');
z(pm, 'hasIteratorFunction');
function Pa(e) {
  if (pm(e))
    try {
      return Qs(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
s(Pa, 'getIteratorEntries');
z(Pa, 'getIteratorEntries');
function Qs(e) {
  for (var t = e.next(), r = [t.value]; t.done === !1; ) ((t = e.next()), r.push(t.value));
  return r;
}
s(Qs, 'getGeneratorEntries');
z(Qs, 'getGeneratorEntries');
function Oa(e) {
  var t = [];
  for (var r in e) t.push(r);
  return t;
}
s(Oa, 'getEnumerableKeys');
z(Oa, 'getEnumerableKeys');
function Ca(e) {
  for (var t = [], r = Object.getOwnPropertySymbols(e), n = 0; n < r.length; n += 1) {
    var o = r[n];
    Object.getOwnPropertyDescriptor(e, o).enumerable && t.push(o);
  }
  return t;
}
s(Ca, 'getEnumerableSymbols');
z(Ca, 'getEnumerableSymbols');
function Ll(e, t, r, n) {
  var o = r.length;
  if (o === 0) return !0;
  for (var i = 0; i < o; i += 1) if ($o(e[r[i]], t[r[i]], n) === !1) return !1;
  return !0;
}
s(Ll, 'keysEqual');
z(Ll, 'keysEqual');
function fm(e, t, r) {
  var n = Oa(e),
    o = Oa(t),
    i = Ca(e),
    a = Ca(t);
  if (((n = n.concat(i)), (o = o.concat(a)), n.length && n.length === o.length))
    return Pr(Ia(n).sort(), Ia(o).sort()) === !1 ? !1 : Ll(e, t, n, r);
  var c = Pa(e),
    d = Pa(t);
  return c.length && c.length === d.length
    ? (c.sort(), d.sort(), Pr(c, d, r))
    : n.length === 0 && c.length === 0 && o.length === 0 && d.length === 0;
}
s(fm, 'objectEqual');
z(fm, 'objectEqual');
function Yr(e) {
  return e === null || typeof e != 'object';
}
s(Yr, 'isPrimitive');
z(Yr, 'isPrimitive');
function Ia(e) {
  return e.map(
    z(
      s(function (r) {
        return typeof r == 'symbol' ? r.toString() : r;
      }, 'mapSymbol'),
      'mapSymbol',
    ),
  );
}
s(Ia, 'mapSymbols');
z(Ia, 'mapSymbols');
function _i(e, t) {
  return typeof e > 'u' || e === null ? !1 : t in Object(e);
}
s(_i, 'hasProperty');
z(_i, 'hasProperty');
function mm(e) {
  return e
    .replace(/([^\\])\[/g, '$1.[')
    .match(/(\\\.|[^.]+?)+/g)
    .map((n) => {
      if (n === 'constructor' || n === '__proto__' || n === 'prototype') return {};
      const i = /^\[(\d+)\]$/.exec(n);
      let a = null;
      return (i ? (a = { i: parseFloat(i[1]) }) : (a = { p: n.replace(/\\([.[\]])/g, '$1') }), a);
    });
}
s(mm, 'parsePath');
z(mm, 'parsePath');
function Na(e, t, r) {
  let n = e,
    o = null;
  r = typeof r > 'u' ? t.length : r;
  for (let i = 0; i < r; i++) {
    const a = t[i];
    n && (typeof a.p > 'u' ? (n = n[a.i]) : (n = n[a.p]), i === r - 1 && (o = n));
  }
  return o;
}
s(Na, 'internalGetPathValue');
z(Na, 'internalGetPathValue');
function Fl(e, t) {
  const r = mm(t),
    n = r[r.length - 1],
    o = { parent: r.length > 1 ? Na(e, r, r.length - 1) : e, name: n.p || n.i, value: Na(e, r) };
  return ((o.exists = _i(o.parent, o.name)), o);
}
s(Fl, 'getPathInfo');
z(Fl, 'getPathInfo');
var Ts,
  j =
    ((Ts = class {
      constructor(e, t, r, n) {
        Be(this, '__flags', {});
        return (
          me(this, 'ssfi', r || Ts),
          me(this, 'lockSsfi', n),
          me(this, 'object', e),
          me(this, 'message', t),
          me(this, 'eql', vt.deepEqual || b_),
          Jn(this)
        );
      }
      static get includeStack() {
        return (
          console.warn(
            'Assertion.includeStack is deprecated, use chai.config.includeStack instead.',
          ),
          vt.includeStack
        );
      }
      static set includeStack(e) {
        (console.warn(
          'Assertion.includeStack is deprecated, use chai.config.includeStack instead.',
        ),
          (vt.includeStack = e));
      }
      static get showDiff() {
        return (
          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.'),
          vt.showDiff
        );
      }
      static set showDiff(e) {
        (console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.'),
          (vt.showDiff = e));
      }
      static addProperty(e, t) {
        Bl(this.prototype, e, t);
      }
      static addMethod(e, t) {
        Jl(this.prototype, e, t);
      }
      static addChainableMethod(e, t, r) {
        Hl(this.prototype, e, t, r);
      }
      static overwriteProperty(e, t) {
        Ul(this.prototype, e, t);
      }
      static overwriteMethod(e, t) {
        Vl(this.prototype, e, t);
      }
      static overwriteChainableMethod(e, t, r) {
        zl(this.prototype, e, t, r);
      }
      assert(e, t, r, n, o, i) {
        const a = Ml(this, arguments);
        if (
          (i !== !1 && (i = !0),
          n === void 0 && o === void 0 && (i = !1),
          vt.showDiff !== !0 && (i = !1),
          !a)
        ) {
          t = $l(this, arguments);
          const d = { actual: Si(this, arguments), expected: n, showDiff: i },
            u = Kl(this, arguments);
          throw (
            u && (d.operator = u),
            new Re(t, d, vt.includeStack ? this.assert : me(this, 'ssfi'))
          );
        }
      }
      get _obj() {
        return me(this, 'object');
      }
      set _obj(e) {
        me(this, 'object', e);
      }
    }),
    s(Ts, '_Assertion'),
    z(Ts, 'Assertion'),
    Ts);
function ko() {
  return vt.useProxy && typeof Proxy < 'u' && typeof Reflect < 'u';
}
s(ko, 'isProxyEnabled');
z(ko, 'isProxyEnabled');
function Bl(e, t, r) {
  ((r = r === void 0 ? function () {} : r),
    Object.defineProperty(e, t, {
      get: z(
        s(function n() {
          !ko() && !me(this, 'lockSsfi') && me(this, 'ssfi', n);
          let o = r.call(this);
          if (o !== void 0) return o;
          let i = new j();
          return (Jt(this, i), i);
        }, 'propertyGetter'),
        'propertyGetter',
      ),
      configurable: !0,
    }));
}
s(Bl, 'addProperty');
z(Bl, 'addProperty');
var iB = Object.getOwnPropertyDescriptor(function () {}, 'length');
function Do(e, t, r) {
  return (
    iB.configurable &&
      Object.defineProperty(e, 'length', {
        get: z(function () {
          throw Error(
            r
              ? 'Invalid Chai property: ' +
                  t +
                  '.length. Due to a compatibility issue, "length" cannot directly follow "' +
                  t +
                  '". Use "' +
                  t +
                  '.lengthOf" instead.'
              : 'Invalid Chai property: ' +
                  t +
                  '.length. See docs for proper usage of "' +
                  t +
                  '".',
          );
        }, 'get'),
      }),
    e
  );
}
s(Do, 'addLengthGuard');
z(Do, 'addLengthGuard');
function ym(e) {
  let t = Object.getOwnPropertyNames(e);
  function r(o) {
    t.indexOf(o) === -1 && t.push(o);
  }
  (s(r, 'addProperty2'), z(r, 'addProperty'));
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) (Object.getOwnPropertyNames(n).forEach(r), (n = Object.getPrototypeOf(n)));
  return t;
}
s(ym, 'getProperties');
z(ym, 'getProperties');
var zg = ['__flags', '__methods', '_obj', 'assert'];
function Jn(e, t) {
  return ko()
    ? new Proxy(e, {
        get: z(
          s(function r(n, o) {
            if (
              typeof o == 'string' &&
              vt.proxyExcludedKeys.indexOf(o) === -1 &&
              !Reflect.has(n, o)
            ) {
              if (t)
                throw Error(
                  'Invalid Chai property: ' +
                    t +
                    '.' +
                    o +
                    '. See docs for proper usage of "' +
                    t +
                    '".',
                );
              let i = null,
                a = 4;
              throw (
                ym(n).forEach(function (c) {
                  if (!Object.prototype.hasOwnProperty(c) && zg.indexOf(c) === -1) {
                    let d = hm(o, c, a);
                    d < a && ((i = c), (a = d));
                  }
                }),
                Error(
                  i !== null
                    ? 'Invalid Chai property: ' + o + '. Did you mean "' + i + '"?'
                    : 'Invalid Chai property: ' + o,
                )
              );
            }
            return (
              zg.indexOf(o) === -1 && !me(n, 'lockSsfi') && me(n, 'ssfi', r),
              Reflect.get(n, o)
            );
          }, 'proxyGetter'),
          'proxyGetter',
        ),
      })
    : e;
}
s(Jn, 'proxify');
z(Jn, 'proxify');
function hm(e, t, r) {
  if (Math.abs(e.length - t.length) >= r) return r;
  let n = [];
  for (let o = 0; o <= e.length; o++) ((n[o] = Array(t.length + 1).fill(0)), (n[o][0] = o));
  for (let o = 0; o < t.length; o++) n[0][o] = o;
  for (let o = 1; o <= e.length; o++) {
    let i = e.charCodeAt(o - 1);
    for (let a = 1; a <= t.length; a++) {
      if (Math.abs(o - a) >= r) {
        n[o][a] = r;
        continue;
      }
      n[o][a] = Math.min(
        n[o - 1][a] + 1,
        n[o][a - 1] + 1,
        n[o - 1][a - 1] + (i === t.charCodeAt(a - 1) ? 0 : 1),
      );
    }
  }
  return n[e.length][t.length];
}
s(hm, 'stringDistanceCapped');
z(hm, 'stringDistanceCapped');
function Jl(e, t, r) {
  let n = z(function () {
    me(this, 'lockSsfi') || me(this, 'ssfi', n);
    let o = r.apply(this, arguments);
    if (o !== void 0) return o;
    let i = new j();
    return (Jt(this, i), i);
  }, 'methodWrapper');
  (Do(n, t, !1), (e[t] = Jn(n, t)));
}
s(Jl, 'addMethod');
z(Jl, 'addMethod');
function Ul(e, t, r) {
  let n = Object.getOwnPropertyDescriptor(e, t),
    o = z(function () {}, '_super');
  (n && typeof n.get == 'function' && (o = n.get),
    Object.defineProperty(e, t, {
      get: z(
        s(function i() {
          !ko() && !me(this, 'lockSsfi') && me(this, 'ssfi', i);
          let a = me(this, 'lockSsfi');
          me(this, 'lockSsfi', !0);
          let c = r(o).call(this);
          if ((me(this, 'lockSsfi', a), c !== void 0)) return c;
          let d = new j();
          return (Jt(this, d), d);
        }, 'overwritingPropertyGetter'),
        'overwritingPropertyGetter',
      ),
      configurable: !0,
    }));
}
s(Ul, 'overwriteProperty');
z(Ul, 'overwriteProperty');
function Vl(e, t, r) {
  let n = e[t],
    o = z(function () {
      throw new Error(t + ' is not a function');
    }, '_super');
  n && typeof n == 'function' && (o = n);
  let i = z(function () {
    me(this, 'lockSsfi') || me(this, 'ssfi', i);
    let a = me(this, 'lockSsfi');
    me(this, 'lockSsfi', !0);
    let c = r(o).apply(this, arguments);
    if ((me(this, 'lockSsfi', a), c !== void 0)) return c;
    let d = new j();
    return (Jt(this, d), d);
  }, 'overwritingMethodWrapper');
  (Do(i, t, !1), (e[t] = Jn(i, t)));
}
s(Vl, 'overwriteMethod');
z(Vl, 'overwriteMethod');
var aB = typeof Object.setPrototypeOf == 'function',
  Gg = z(function () {}, 'testFn'),
  lB = Object.getOwnPropertyNames(Gg).filter(function (e) {
    let t = Object.getOwnPropertyDescriptor(Gg, e);
    return typeof t != 'object' ? !0 : !t.configurable;
  }),
  cB = Function.prototype.call,
  uB = Function.prototype.apply;
function Hl(e, t, r, n) {
  typeof n != 'function' && (n = z(function () {}, 'chainingBehavior'));
  let o = { method: r, chainingBehavior: n };
  (e.__methods || (e.__methods = {}),
    (e.__methods[t] = o),
    Object.defineProperty(e, t, {
      get: z(
        s(function () {
          o.chainingBehavior.call(this);
          let a = z(function () {
            me(this, 'lockSsfi') || me(this, 'ssfi', a);
            let c = o.method.apply(this, arguments);
            if (c !== void 0) return c;
            let d = new j();
            return (Jt(this, d), d);
          }, 'chainableMethodWrapper');
          if ((Do(a, t, !0), aB)) {
            let c = Object.create(this);
            ((c.call = cB), (c.apply = uB), Object.setPrototypeOf(a, c));
          } else
            Object.getOwnPropertyNames(e).forEach(function (d) {
              if (lB.indexOf(d) !== -1) return;
              let u = Object.getOwnPropertyDescriptor(e, d);
              Object.defineProperty(a, d, u);
            });
          return (Jt(this, a), Jn(a));
        }, 'chainableMethodGetter'),
        'chainableMethodGetter',
      ),
      configurable: !0,
    }));
}
s(Hl, 'addChainableMethod');
z(Hl, 'addChainableMethod');
function zl(e, t, r, n) {
  let o = e.__methods[t],
    i = o.chainingBehavior;
  o.chainingBehavior = z(
    s(function () {
      let d = n(i).call(this);
      if (d !== void 0) return d;
      let u = new j();
      return (Jt(this, u), u);
    }, 'overwritingChainableMethodGetter'),
    'overwritingChainableMethodGetter',
  );
  let a = o.method;
  o.method = z(
    s(function () {
      let d = r(a).apply(this, arguments);
      if (d !== void 0) return d;
      let u = new j();
      return (Jt(this, u), u);
    }, 'overwritingChainableMethodWrapper'),
    'overwritingChainableMethodWrapper',
  );
}
s(zl, 'overwriteChainableMethod');
z(zl, 'overwriteChainableMethod');
function Zs(e, t) {
  return Se(e) < Se(t) ? -1 : 1;
}
s(Zs, 'compareByInspect');
z(Zs, 'compareByInspect');
function Gl(e) {
  return typeof Object.getOwnPropertySymbols != 'function'
    ? []
    : Object.getOwnPropertySymbols(e).filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable;
      });
}
s(Gl, 'getOwnEnumerablePropertySymbols');
z(Gl, 'getOwnEnumerablePropertySymbols');
function Wl(e) {
  return Object.keys(e).concat(Gl(e));
}
s(Wl, 'getOwnEnumerableProperties');
z(Wl, 'getOwnEnumerableProperties');
var qa = Number.isNaN;
function gm(e) {
  let t = Ce(e);
  return ['Array', 'Object', 'Function'].indexOf(t) !== -1;
}
s(gm, 'isObjectType');
z(gm, 'isObjectType');
function Kl(e, t) {
  let r = me(e, 'operator'),
    n = me(e, 'negate'),
    o = t[3],
    i = n ? t[2] : t[1];
  if (r) return r;
  if ((typeof i == 'function' && (i = i()), (i = i || ''), !i || /\shave\s/.test(i))) return;
  let a = gm(o);
  return /\snot\s/.test(i)
    ? a
      ? 'notDeepStrictEqual'
      : 'notStrictEqual'
    : a
      ? 'deepStrictEqual'
      : 'strictEqual';
}
s(Kl, 'getOperator');
z(Kl, 'getOperator');
function Ai(e) {
  return e.name;
}
s(Ai, 'getName');
z(Ai, 'getName');
function ei(e) {
  return Object.prototype.toString.call(e) === '[object RegExp]';
}
s(ei, 'isRegExp2');
z(ei, 'isRegExp');
function rt(e) {
  return ['Number', 'BigInt'].includes(Ce(e));
}
s(rt, 'isNumeric');
z(rt, 'isNumeric');
var { flag: U } = rr;
[
  'to',
  'be',
  'been',
  'is',
  'and',
  'has',
  'have',
  'with',
  'that',
  'which',
  'at',
  'of',
  'same',
  'but',
  'does',
  'still',
  'also',
].forEach(function (e) {
  j.addProperty(e);
});
j.addProperty('not', function () {
  U(this, 'negate', !0);
});
j.addProperty('deep', function () {
  U(this, 'deep', !0);
});
j.addProperty('nested', function () {
  U(this, 'nested', !0);
});
j.addProperty('own', function () {
  U(this, 'own', !0);
});
j.addProperty('ordered', function () {
  U(this, 'ordered', !0);
});
j.addProperty('any', function () {
  (U(this, 'any', !0), U(this, 'all', !1));
});
j.addProperty('all', function () {
  (U(this, 'all', !0), U(this, 'any', !1));
});
var Wg = {
  function: ['function', 'asyncfunction', 'generatorfunction', 'asyncgeneratorfunction'],
  asyncfunction: ['asyncfunction', 'asyncgeneratorfunction'],
  generatorfunction: ['generatorfunction', 'asyncgeneratorfunction'],
  asyncgeneratorfunction: ['asyncgeneratorfunction'],
};
function Yl(e, t) {
  (t && U(this, 'message', t), (e = e.toLowerCase()));
  let r = U(this, 'object'),
    n = ~['a', 'e', 'i', 'o', 'u'].indexOf(e.charAt(0)) ? 'an ' : 'a ';
  const o = Ce(r).toLowerCase();
  Wg.function.includes(e)
    ? this.assert(
        Wg[e].includes(o),
        'expected #{this} to be ' + n + e,
        'expected #{this} not to be ' + n + e,
      )
    : this.assert(
        e === o,
        'expected #{this} to be ' + n + e,
        'expected #{this} not to be ' + n + e,
      );
}
s(Yl, 'an');
z(Yl, 'an');
j.addChainableMethod('an', Yl);
j.addChainableMethod('a', Yl);
function bm(e, t) {
  return (qa(e) && qa(t)) || e === t;
}
s(bm, 'SameValueZero');
z(bm, 'SameValueZero');
function Lo() {
  U(this, 'contains', !0);
}
s(Lo, 'includeChainingBehavior');
z(Lo, 'includeChainingBehavior');
function Fo(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = Ce(r).toLowerCase(),
    o = U(this, 'message'),
    i = U(this, 'negate'),
    a = U(this, 'ssfi'),
    c = U(this, 'deep'),
    d = c ? 'deep ' : '',
    u = c ? U(this, 'eql') : bm;
  o = o ? o + ': ' : '';
  let p = !1;
  switch (n) {
    case 'string':
      p = r.indexOf(e) !== -1;
      break;
    case 'weakset':
      if (c) throw new Re(o + 'unable to use .deep.include with WeakSet', void 0, a);
      p = r.has(e);
      break;
    case 'map':
      r.forEach(function (f) {
        p = p || u(f, e);
      });
      break;
    case 'set':
      c
        ? r.forEach(function (f) {
            p = p || u(f, e);
          })
        : (p = r.has(e));
      break;
    case 'array':
      c
        ? (p = r.some(function (f) {
            return u(f, e);
          }))
        : (p = r.indexOf(e) !== -1);
      break;
    default: {
      if (e !== Object(e))
        throw new Re(
          o +
            'the given combination of arguments (' +
            n +
            ' and ' +
            Ce(e).toLowerCase() +
            ') is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a ' +
            Ce(e).toLowerCase(),
          void 0,
          a,
        );
      let f = Object.keys(e),
        m = null,
        h = 0;
      if (
        (f.forEach(function (g) {
          let v = new j(r);
          if ((Jt(this, v, !0), U(v, 'lockSsfi', !0), !i || f.length === 1)) {
            v.property(g, e[g]);
            return;
          }
          try {
            v.property(g, e[g]);
          } catch (E) {
            if (!xt.compatibleConstructor(E, Re)) throw E;
            (m === null && (m = E), h++);
          }
        }, this),
        i && f.length > 1 && h === f.length)
      )
        throw m;
      return;
    }
  }
  this.assert(
    p,
    'expected #{this} to ' + d + 'include ' + Se(e),
    'expected #{this} to not ' + d + 'include ' + Se(e),
  );
}
s(Fo, 'include');
z(Fo, 'include');
j.addChainableMethod('include', Fo, Lo);
j.addChainableMethod('contain', Fo, Lo);
j.addChainableMethod('contains', Fo, Lo);
j.addChainableMethod('includes', Fo, Lo);
j.addProperty('ok', function () {
  this.assert(U(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
});
j.addProperty('true', function () {
  this.assert(
    U(this, 'object') === !0,
    'expected #{this} to be true',
    'expected #{this} to be false',
    !U(this, 'negate'),
  );
});
j.addProperty('numeric', function () {
  const e = U(this, 'object');
  this.assert(
    ['Number', 'BigInt'].includes(Ce(e)),
    'expected #{this} to be numeric',
    'expected #{this} to not be numeric',
    !U(this, 'negate'),
  );
});
j.addProperty('callable', function () {
  const e = U(this, 'object'),
    t = U(this, 'ssfi'),
    r = U(this, 'message'),
    n = r ? `${r}: ` : '',
    o = U(this, 'negate'),
    i = o
      ? `${n}expected ${Se(e)} not to be a callable function`
      : `${n}expected ${Se(e)} to be a callable function`,
    a = ['Function', 'AsyncFunction', 'GeneratorFunction', 'AsyncGeneratorFunction'].includes(
      Ce(e),
    );
  if ((a && o) || (!a && !o)) throw new Re(i, void 0, t);
});
j.addProperty('false', function () {
  this.assert(
    U(this, 'object') === !1,
    'expected #{this} to be false',
    'expected #{this} to be true',
    !!U(this, 'negate'),
  );
});
j.addProperty('null', function () {
  this.assert(
    U(this, 'object') === null,
    'expected #{this} to be null',
    'expected #{this} not to be null',
  );
});
j.addProperty('undefined', function () {
  this.assert(
    U(this, 'object') === void 0,
    'expected #{this} to be undefined',
    'expected #{this} not to be undefined',
  );
});
j.addProperty('NaN', function () {
  this.assert(
    qa(U(this, 'object')),
    'expected #{this} to be NaN',
    'expected #{this} not to be NaN',
  );
});
function Xl() {
  let e = U(this, 'object');
  this.assert(e != null, 'expected #{this} to exist', 'expected #{this} to not exist');
}
s(Xl, 'assertExist');
z(Xl, 'assertExist');
j.addProperty('exist', Xl);
j.addProperty('exists', Xl);
j.addProperty('empty', function () {
  let e = U(this, 'object'),
    t = U(this, 'ssfi'),
    r = U(this, 'message'),
    n;
  switch (((r = r ? r + ': ' : ''), Ce(e).toLowerCase())) {
    case 'array':
    case 'string':
      n = e.length;
      break;
    case 'map':
    case 'set':
      n = e.size;
      break;
    case 'weakmap':
    case 'weakset':
      throw new Re(r + '.empty was passed a weak collection', void 0, t);
    case 'function': {
      const o = r + '.empty was passed a function ' + Ai(e);
      throw new Re(o.trim(), void 0, t);
    }
    default:
      if (e !== Object(e))
        throw new Re(r + '.empty was passed non-string primitive ' + Se(e), void 0, t);
      n = Object.keys(e).length;
  }
  this.assert(n === 0, 'expected #{this} to be empty', 'expected #{this} not to be empty');
});
function Ql() {
  let e = U(this, 'object'),
    t = Ce(e);
  this.assert(
    t === 'Arguments',
    'expected #{this} to be arguments but got ' + t,
    'expected #{this} to not be arguments',
  );
}
s(Ql, 'checkArguments');
z(Ql, 'checkArguments');
j.addProperty('arguments', Ql);
j.addProperty('Arguments', Ql);
function Ri(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object');
  if (U(this, 'deep')) {
    let n = U(this, 'lockSsfi');
    (U(this, 'lockSsfi', !0), this.eql(e), U(this, 'lockSsfi', n));
  } else
    this.assert(
      e === r,
      'expected #{this} to equal #{exp}',
      'expected #{this} to not equal #{exp}',
      e,
      this._obj,
      !0,
    );
}
s(Ri, 'assertEqual');
z(Ri, 'assertEqual');
j.addMethod('equal', Ri);
j.addMethod('equals', Ri);
j.addMethod('eq', Ri);
function Zl(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'eql');
  this.assert(
    r(e, U(this, 'object')),
    'expected #{this} to deeply equal #{exp}',
    'expected #{this} to not deeply equal #{exp}',
    e,
    this._obj,
    !0,
  );
}
s(Zl, 'assertEql');
z(Zl, 'assertEql');
j.addMethod('eql', Zl);
j.addMethod('eqls', Zl);
function xi(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    o = U(this, 'message'),
    i = o ? o + ': ' : '',
    a = U(this, 'ssfi'),
    c = Ce(r).toLowerCase(),
    d = Ce(e).toLowerCase();
  if (
    (n && c !== 'map' && c !== 'set' && new j(r, o, a, !0).to.have.property('length'),
    !n && c === 'date' && d !== 'date')
  )
    throw new Re(i + 'the argument to above must be a date', void 0, a);
  if (!rt(e) && (n || rt(r))) throw new Re(i + 'the argument to above must be a number', void 0, a);
  if (!n && c !== 'date' && !rt(r)) {
    let u = c === 'string' ? "'" + r + "'" : r;
    throw new Re(i + 'expected ' + u + ' to be a number or a date', void 0, a);
  }
  if (n) {
    let u = 'length',
      p;
    (c === 'map' || c === 'set' ? ((u = 'size'), (p = r.size)) : (p = r.length),
      this.assert(
        p > e,
        'expected #{this} to have a ' + u + ' above #{exp} but got #{act}',
        'expected #{this} to not have a ' + u + ' above #{exp}',
        e,
        p,
      ));
  } else
    this.assert(
      r > e,
      'expected #{this} to be above #{exp}',
      'expected #{this} to be at most #{exp}',
      e,
    );
}
s(xi, 'assertAbove');
z(xi, 'assertAbove');
j.addMethod('above', xi);
j.addMethod('gt', xi);
j.addMethod('greaterThan', xi);
function Pi(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    o = U(this, 'message'),
    i = o ? o + ': ' : '',
    a = U(this, 'ssfi'),
    c = Ce(r).toLowerCase(),
    d = Ce(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && c !== 'map' && c !== 'set' && new j(r, o, a, !0).to.have.property('length'),
    !n && c === 'date' && d !== 'date')
  )
    u = i + 'the argument to least must be a date';
  else if (!rt(e) && (n || rt(r))) u = i + 'the argument to least must be a number';
  else if (!n && c !== 'date' && !rt(r)) {
    let f = c === 'string' ? "'" + r + "'" : r;
    u = i + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Re(u, void 0, a);
  if (n) {
    let f = 'length',
      m;
    (c === 'map' || c === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
      this.assert(
        m >= e,
        'expected #{this} to have a ' + f + ' at least #{exp} but got #{act}',
        'expected #{this} to have a ' + f + ' below #{exp}',
        e,
        m,
      ));
  } else
    this.assert(
      r >= e,
      'expected #{this} to be at least #{exp}',
      'expected #{this} to be below #{exp}',
      e,
    );
}
s(Pi, 'assertLeast');
z(Pi, 'assertLeast');
j.addMethod('least', Pi);
j.addMethod('gte', Pi);
j.addMethod('greaterThanOrEqual', Pi);
function Oi(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    o = U(this, 'message'),
    i = o ? o + ': ' : '',
    a = U(this, 'ssfi'),
    c = Ce(r).toLowerCase(),
    d = Ce(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && c !== 'map' && c !== 'set' && new j(r, o, a, !0).to.have.property('length'),
    !n && c === 'date' && d !== 'date')
  )
    u = i + 'the argument to below must be a date';
  else if (!rt(e) && (n || rt(r))) u = i + 'the argument to below must be a number';
  else if (!n && c !== 'date' && !rt(r)) {
    let f = c === 'string' ? "'" + r + "'" : r;
    u = i + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Re(u, void 0, a);
  if (n) {
    let f = 'length',
      m;
    (c === 'map' || c === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
      this.assert(
        m < e,
        'expected #{this} to have a ' + f + ' below #{exp} but got #{act}',
        'expected #{this} to not have a ' + f + ' below #{exp}',
        e,
        m,
      ));
  } else
    this.assert(
      r < e,
      'expected #{this} to be below #{exp}',
      'expected #{this} to be at least #{exp}',
      e,
    );
}
s(Oi, 'assertBelow');
z(Oi, 'assertBelow');
j.addMethod('below', Oi);
j.addMethod('lt', Oi);
j.addMethod('lessThan', Oi);
function Ci(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    o = U(this, 'message'),
    i = o ? o + ': ' : '',
    a = U(this, 'ssfi'),
    c = Ce(r).toLowerCase(),
    d = Ce(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && c !== 'map' && c !== 'set' && new j(r, o, a, !0).to.have.property('length'),
    !n && c === 'date' && d !== 'date')
  )
    u = i + 'the argument to most must be a date';
  else if (!rt(e) && (n || rt(r))) u = i + 'the argument to most must be a number';
  else if (!n && c !== 'date' && !rt(r)) {
    let f = c === 'string' ? "'" + r + "'" : r;
    u = i + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Re(u, void 0, a);
  if (n) {
    let f = 'length',
      m;
    (c === 'map' || c === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
      this.assert(
        m <= e,
        'expected #{this} to have a ' + f + ' at most #{exp} but got #{act}',
        'expected #{this} to have a ' + f + ' above #{exp}',
        e,
        m,
      ));
  } else
    this.assert(
      r <= e,
      'expected #{this} to be at most #{exp}',
      'expected #{this} to be above #{exp}',
      e,
    );
}
s(Ci, 'assertMost');
z(Ci, 'assertMost');
j.addMethod('most', Ci);
j.addMethod('lte', Ci);
j.addMethod('lessThanOrEqual', Ci);
j.addMethod('within', function (e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'doLength'),
    i = U(this, 'message'),
    a = i ? i + ': ' : '',
    c = U(this, 'ssfi'),
    d = Ce(n).toLowerCase(),
    u = Ce(e).toLowerCase(),
    p = Ce(t).toLowerCase(),
    f,
    m = !0,
    h = u === 'date' && p === 'date' ? e.toISOString() + '..' + t.toISOString() : e + '..' + t;
  if (
    (o && d !== 'map' && d !== 'set' && new j(n, i, c, !0).to.have.property('length'),
    !o && d === 'date' && (u !== 'date' || p !== 'date'))
  )
    f = a + 'the arguments to within must be dates';
  else if ((!rt(e) || !rt(t)) && (o || rt(n))) f = a + 'the arguments to within must be numbers';
  else if (!o && d !== 'date' && !rt(n)) {
    let g = d === 'string' ? "'" + n + "'" : n;
    f = a + 'expected ' + g + ' to be a number or a date';
  } else m = !1;
  if (m) throw new Re(f, void 0, c);
  if (o) {
    let g = 'length',
      v;
    (d === 'map' || d === 'set' ? ((g = 'size'), (v = n.size)) : (v = n.length),
      this.assert(
        v >= e && v <= t,
        'expected #{this} to have a ' + g + ' within ' + h,
        'expected #{this} to not have a ' + g + ' within ' + h,
      ));
  } else
    this.assert(
      n >= e && n <= t,
      'expected #{this} to be within ' + h,
      'expected #{this} to not be within ' + h,
    );
});
function ec(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'ssfi'),
    o = U(this, 'message'),
    i;
  try {
    i = r instanceof e;
  } catch (c) {
    throw c instanceof TypeError
      ? ((o = o ? o + ': ' : ''),
        new Re(
          o + 'The instanceof assertion needs a constructor but ' + Ce(e) + ' was given.',
          void 0,
          n,
        ))
      : c;
  }
  let a = Ai(e);
  (a == null && (a = 'an unnamed constructor'),
    this.assert(
      i,
      'expected #{this} to be an instance of ' + a,
      'expected #{this} to not be an instance of ' + a,
    ));
}
s(ec, 'assertInstanceOf');
z(ec, 'assertInstanceOf');
j.addMethod('instanceof', ec);
j.addMethod('instanceOf', ec);
function tc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'nested'),
    o = U(this, 'own'),
    i = U(this, 'message'),
    a = U(this, 'object'),
    c = U(this, 'ssfi'),
    d = typeof e;
  if (((i = i ? i + ': ' : ''), n)) {
    if (d !== 'string')
      throw new Re(
        i + 'the argument to property must be a string when using nested syntax',
        void 0,
        c,
      );
  } else if (d !== 'string' && d !== 'number' && d !== 'symbol')
    throw new Re(i + 'the argument to property must be a string, number, or symbol', void 0, c);
  if (n && o) throw new Re(i + 'The "nested" and "own" flags cannot be combined.', void 0, c);
  if (a == null) throw new Re(i + 'Target cannot be null or undefined.', void 0, c);
  let u = U(this, 'deep'),
    p = U(this, 'negate'),
    f = n ? Fl(a, e) : null,
    m = n ? f.value : a[e],
    h = u ? U(this, 'eql') : (E, b) => E === b,
    g = '';
  (u && (g += 'deep '), o && (g += 'own '), n && (g += 'nested '), (g += 'property '));
  let v;
  (o ? (v = Object.prototype.hasOwnProperty.call(a, e)) : n ? (v = f.exists) : (v = _i(a, e)),
    (!p || arguments.length === 1) &&
      this.assert(
        v,
        'expected #{this} to have ' + g + Se(e),
        'expected #{this} to not have ' + g + Se(e),
      ),
    arguments.length > 1 &&
      this.assert(
        v && h(t, m),
        'expected #{this} to have ' + g + Se(e) + ' of #{exp}, but got #{act}',
        'expected #{this} to not have ' + g + Se(e) + ' of #{act}',
        t,
        m,
      ),
    U(this, 'object', m));
}
s(tc, 'assertProperty');
z(tc, 'assertProperty');
j.addMethod('property', tc);
function rc(e, t, r) {
  (U(this, 'own', !0), tc.apply(this, arguments));
}
s(rc, 'assertOwnProperty');
z(rc, 'assertOwnProperty');
j.addMethod('ownProperty', rc);
j.addMethod('haveOwnProperty', rc);
function nc(e, t, r) {
  (typeof t == 'string' && ((r = t), (t = null)), r && U(this, 'message', r));
  let n = U(this, 'object'),
    o = Object.getOwnPropertyDescriptor(Object(n), e),
    i = U(this, 'eql');
  (o && t
    ? this.assert(
        i(t, o),
        'expected the own property descriptor for ' +
          Se(e) +
          ' on #{this} to match ' +
          Se(t) +
          ', got ' +
          Se(o),
        'expected the own property descriptor for ' + Se(e) + ' on #{this} to not match ' + Se(t),
        t,
        o,
        !0,
      )
    : this.assert(
        o,
        'expected #{this} to have an own property descriptor for ' + Se(e),
        'expected #{this} to not have an own property descriptor for ' + Se(e),
      ),
    U(this, 'object', o));
}
s(nc, 'assertOwnPropertyDescriptor');
z(nc, 'assertOwnPropertyDescriptor');
j.addMethod('ownPropertyDescriptor', nc);
j.addMethod('haveOwnPropertyDescriptor', nc);
function oc() {
  U(this, 'doLength', !0);
}
s(oc, 'assertLengthChain');
z(oc, 'assertLengthChain');
function sc(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = Ce(r).toLowerCase(),
    o = U(this, 'message'),
    i = U(this, 'ssfi'),
    a = 'length',
    c;
  switch (n) {
    case 'map':
    case 'set':
      ((a = 'size'), (c = r.size));
      break;
    default:
      (new j(r, o, i, !0).to.have.property('length'), (c = r.length));
  }
  this.assert(
    c == e,
    'expected #{this} to have a ' + a + ' of #{exp} but got #{act}',
    'expected #{this} to not have a ' + a + ' of #{act}',
    e,
    c,
  );
}
s(sc, 'assertLength');
z(sc, 'assertLength');
j.addChainableMethod('length', sc, oc);
j.addChainableMethod('lengthOf', sc, oc);
function ic(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object');
  this.assert(e.exec(r), 'expected #{this} to match ' + e, 'expected #{this} not to match ' + e);
}
s(ic, 'assertMatch');
z(ic, 'assertMatch');
j.addMethod('match', ic);
j.addMethod('matches', ic);
j.addMethod('string', function (e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    o = U(this, 'ssfi');
  (new j(r, n, o, !0).is.a('string'),
    this.assert(
      ~r.indexOf(e),
      'expected #{this} to contain ' + Se(e),
      'expected #{this} to not contain ' + Se(e),
    ));
});
function ac(e) {
  let t = U(this, 'object'),
    r = Ce(t),
    n = Ce(e),
    o = U(this, 'ssfi'),
    i = U(this, 'deep'),
    a,
    c = '',
    d,
    u = !0,
    p = U(this, 'message');
  p = p ? p + ': ' : '';
  let f =
    p +
    'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';
  if (r === 'Map' || r === 'Set')
    ((c = i ? 'deeply ' : ''),
      (d = []),
      t.forEach(function (b, S) {
        d.push(S);
      }),
      n !== 'Array' && (e = Array.prototype.slice.call(arguments)));
  else {
    switch (((d = Wl(t)), n)) {
      case 'Array':
        if (arguments.length > 1) throw new Re(f, void 0, o);
        break;
      case 'Object':
        if (arguments.length > 1) throw new Re(f, void 0, o);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function (b) {
      return typeof b == 'symbol' ? b : String(b);
    });
  }
  if (!e.length) throw new Re(p + 'keys required', void 0, o);
  let m = e.length,
    h = U(this, 'any'),
    g = U(this, 'all'),
    v = e,
    E = i ? U(this, 'eql') : (b, S) => b === S;
  if (
    (!h && !g && (g = !0),
    h &&
      (u = v.some(function (b) {
        return d.some(function (S) {
          return E(b, S);
        });
      })),
    g &&
      ((u = v.every(function (b) {
        return d.some(function (S) {
          return E(b, S);
        });
      })),
      U(this, 'contains') || (u = u && e.length == d.length)),
    m > 1)
  ) {
    e = e.map(function (S) {
      return Se(S);
    });
    let b = e.pop();
    (g && (a = e.join(', ') + ', and ' + b), h && (a = e.join(', ') + ', or ' + b));
  } else a = Se(e[0]);
  ((a = (m > 1 ? 'keys ' : 'key ') + a),
    (a = (U(this, 'contains') ? 'contain ' : 'have ') + a),
    this.assert(
      u,
      'expected #{this} to ' + c + a,
      'expected #{this} to not ' + c + a,
      v.slice(0).sort(Zs),
      d.sort(Zs),
      !0,
    ));
}
s(ac, 'assertKeys');
z(ac, 'assertKeys');
j.addMethod('keys', ac);
j.addMethod('key', ac);
function Ii(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'ssfi'),
    i = U(this, 'message'),
    a = U(this, 'negate') || !1;
  (new j(n, i, o, !0).is.a('function'), (ei(e) || typeof e == 'string') && ((t = e), (e = null)));
  let c,
    d = !1;
  try {
    n();
  } catch (h) {
    ((d = !0), (c = h));
  }
  let u = e === void 0 && t === void 0,
    p = !!(e && t),
    f = !1,
    m = !1;
  if (u || (!u && !a)) {
    let h = 'an error';
    e instanceof Error ? (h = '#{exp}') : e && (h = xt.getConstructorName(e));
    let g = c;
    if (c instanceof Error) g = c.toString();
    else if (typeof c == 'string') g = c;
    else if (c && (typeof c == 'object' || typeof c == 'function'))
      try {
        g = xt.getConstructorName(c);
      } catch {}
    this.assert(
      d,
      'expected #{this} to throw ' + h,
      'expected #{this} to not throw an error but #{act} was thrown',
      e && e.toString(),
      g,
    );
  }
  if (
    (e &&
      c &&
      (e instanceof Error &&
        xt.compatibleInstance(c, e) === a &&
        (p && a
          ? (f = !0)
          : this.assert(
              a,
              'expected #{this} to throw #{exp} but #{act} was thrown',
              'expected #{this} to not throw #{exp}' + (c && !a ? ' but #{act} was thrown' : ''),
              e.toString(),
              c.toString(),
            )),
      xt.compatibleConstructor(c, e) === a &&
        (p && a
          ? (f = !0)
          : this.assert(
              a,
              'expected #{this} to throw #{exp} but #{act} was thrown',
              'expected #{this} to not throw #{exp}' + (c ? ' but #{act} was thrown' : ''),
              e instanceof Error ? e.toString() : e && xt.getConstructorName(e),
              c instanceof Error ? c.toString() : c && xt.getConstructorName(c),
            ))),
    c && t !== void 0 && t !== null)
  ) {
    let h = 'including';
    (ei(t) && (h = 'matching'),
      xt.compatibleMessage(c, t) === a &&
        (p && a
          ? (m = !0)
          : this.assert(
              a,
              'expected #{this} to throw error ' + h + ' #{exp} but got #{act}',
              'expected #{this} to throw error not ' + h + ' #{exp}',
              t,
              xt.getMessage(c),
            )));
  }
  (f &&
    m &&
    this.assert(
      a,
      'expected #{this} to throw #{exp} but #{act} was thrown',
      'expected #{this} to not throw #{exp}' + (c ? ' but #{act} was thrown' : ''),
      e instanceof Error ? e.toString() : e && xt.getConstructorName(e),
      c instanceof Error ? c.toString() : c && xt.getConstructorName(c),
    ),
    U(this, 'object', c));
}
s(Ii, 'assertThrows');
z(Ii, 'assertThrows');
j.addMethod('throw', Ii);
j.addMethod('throws', Ii);
j.addMethod('Throw', Ii);
function lc(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'itself'),
    o = typeof r == 'function' && !n ? r.prototype[e] : r[e];
  this.assert(
    typeof o == 'function',
    'expected #{this} to respond to ' + Se(e),
    'expected #{this} to not respond to ' + Se(e),
  );
}
s(lc, 'respondTo');
z(lc, 'respondTo');
j.addMethod('respondTo', lc);
j.addMethod('respondsTo', lc);
j.addProperty('itself', function () {
  U(this, 'itself', !0);
});
function cc(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = e(r);
  this.assert(
    n,
    'expected #{this} to satisfy ' + Jr(e),
    'expected #{this} to not satisfy' + Jr(e),
    !U(this, 'negate'),
    n,
  );
}
s(cc, 'satisfy');
z(cc, 'satisfy');
j.addMethod('satisfy', cc);
j.addMethod('satisfies', cc);
function uc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'message'),
    i = U(this, 'ssfi');
  new j(n, o, i, !0).is.numeric;
  let a = 'A `delta` value is required for `closeTo`';
  if (t == null) throw new Re(o ? `${o}: ${a}` : a, void 0, i);
  if (
    (new j(t, o, i, !0).is.numeric, (a = 'A `expected` value is required for `closeTo`'), e == null)
  )
    throw new Re(o ? `${o}: ${a}` : a, void 0, i);
  new j(e, o, i, !0).is.numeric;
  const c = z((u) => (u < 0n ? -u : u), 'abs'),
    d = z((u) => parseFloat(parseFloat(u).toPrecision(12)), 'strip');
  this.assert(
    d(c(n - e)) <= t,
    'expected #{this} to be close to ' + e + ' +/- ' + t,
    'expected #{this} not to be close to ' + e + ' +/- ' + t,
  );
}
s(uc, 'closeTo');
z(uc, 'closeTo');
j.addMethod('closeTo', uc);
j.addMethod('approximately', uc);
function vm(e, t, r, n, o) {
  let i = Array.from(t),
    a = Array.from(e);
  if (!n) {
    if (a.length !== i.length) return !1;
    i = i.slice();
  }
  return a.every(function (c, d) {
    if (o) return r ? r(c, i[d]) : c === i[d];
    if (!r) {
      let u = i.indexOf(c);
      return u === -1 ? !1 : (n || i.splice(u, 1), !0);
    }
    return i.some(function (u, p) {
      return r(c, u) ? (n || i.splice(p, 1), !0) : !1;
    });
  });
}
s(vm, 'isSubsetOf');
z(vm, 'isSubsetOf');
j.addMethod('members', function (e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    o = U(this, 'ssfi');
  (new j(r, n, o, !0).to.be.iterable, new j(e, n, o, !0).to.be.iterable);
  let i = U(this, 'contains'),
    a = U(this, 'ordered'),
    c,
    d,
    u;
  i
    ? ((c = a ? 'an ordered superset' : 'a superset'),
      (d = 'expected #{this} to be ' + c + ' of #{exp}'),
      (u = 'expected #{this} to not be ' + c + ' of #{exp}'))
    : ((c = a ? 'ordered members' : 'members'),
      (d = 'expected #{this} to have the same ' + c + ' as #{exp}'),
      (u = 'expected #{this} to not have the same ' + c + ' as #{exp}'));
  let p = U(this, 'deep') ? U(this, 'eql') : void 0;
  this.assert(vm(e, r, p, i, a), d, u, e, r, !0);
});
j.addProperty('iterable', function (e) {
  e && U(this, 'message', e);
  let t = U(this, 'object');
  this.assert(
    t != null && t[Symbol.iterator],
    'expected #{this} to be an iterable',
    'expected #{this} to not be an iterable',
    t,
  );
});
function Tm(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    o = U(this, 'ssfi'),
    i = U(this, 'contains'),
    a = U(this, 'deep'),
    c = U(this, 'eql');
  (new j(e, n, o, !0).to.be.an('array'),
    i
      ? this.assert(
          e.some(function (d) {
            return r.indexOf(d) > -1;
          }),
          'expected #{this} to contain one of #{exp}',
          'expected #{this} to not contain one of #{exp}',
          e,
          r,
        )
      : a
        ? this.assert(
            e.some(function (d) {
              return c(r, d);
            }),
            'expected #{this} to deeply equal one of #{exp}',
            'expected #{this} to deeply equal one of #{exp}',
            e,
            r,
          )
        : this.assert(
            e.indexOf(r) > -1,
            'expected #{this} to be one of #{exp}',
            'expected #{this} to not be one of #{exp}',
            e,
            r,
          ));
}
s(Tm, 'oneOf');
z(Tm, 'oneOf');
j.addMethod('oneOf', Tm);
function dc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'message'),
    i = U(this, 'ssfi');
  new j(n, o, i, !0).is.a('function');
  let a;
  (t
    ? (new j(e, o, i, !0).to.have.property(t), (a = e[t]))
    : (new j(e, o, i, !0).is.a('function'), (a = e())),
    n());
  let c = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', c),
    U(this, 'deltaBehavior', 'change'),
    U(this, 'realDelta', c !== a),
    this.assert(a !== c, 'expected ' + d + ' to change', 'expected ' + d + ' to not change'));
}
s(dc, 'assertChanges');
z(dc, 'assertChanges');
j.addMethod('change', dc);
j.addMethod('changes', dc);
function pc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'message'),
    i = U(this, 'ssfi');
  new j(n, o, i, !0).is.a('function');
  let a;
  (t
    ? (new j(e, o, i, !0).to.have.property(t), (a = e[t]))
    : (new j(e, o, i, !0).is.a('function'), (a = e())),
    new j(a, o, i, !0).is.a('number'),
    n());
  let c = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', c),
    U(this, 'deltaBehavior', 'increase'),
    U(this, 'realDelta', c - a),
    this.assert(c - a > 0, 'expected ' + d + ' to increase', 'expected ' + d + ' to not increase'));
}
s(pc, 'assertIncreases');
z(pc, 'assertIncreases');
j.addMethod('increase', pc);
j.addMethod('increases', pc);
function fc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'message'),
    i = U(this, 'ssfi');
  new j(n, o, i, !0).is.a('function');
  let a;
  (t
    ? (new j(e, o, i, !0).to.have.property(t), (a = e[t]))
    : (new j(e, o, i, !0).is.a('function'), (a = e())),
    new j(a, o, i, !0).is.a('number'),
    n());
  let c = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', c),
    U(this, 'deltaBehavior', 'decrease'),
    U(this, 'realDelta', a - c),
    this.assert(c - a < 0, 'expected ' + d + ' to decrease', 'expected ' + d + ' to not decrease'));
}
s(fc, 'assertDecreases');
z(fc, 'assertDecreases');
j.addMethod('decrease', fc);
j.addMethod('decreases', fc);
function Em(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'deltaMsgObj'),
    n = U(this, 'initialDeltaValue'),
    o = U(this, 'finalDeltaValue'),
    i = U(this, 'deltaBehavior'),
    a = U(this, 'realDelta'),
    c;
  (i === 'change' ? (c = Math.abs(o - n) === Math.abs(e)) : (c = a === Math.abs(e)),
    this.assert(
      c,
      'expected ' + r + ' to ' + i + ' by ' + e,
      'expected ' + r + ' to not ' + i + ' by ' + e,
    ));
}
s(Em, 'assertDelta');
z(Em, 'assertDelta');
j.addMethod('by', Em);
j.addProperty('extensible', function () {
  let e = U(this, 'object'),
    t = e === Object(e) && Object.isExtensible(e);
  this.assert(t, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
});
j.addProperty('sealed', function () {
  let e = U(this, 'object'),
    t = e === Object(e) ? Object.isSealed(e) : !0;
  this.assert(t, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
});
j.addProperty('frozen', function () {
  let e = U(this, 'object'),
    t = e === Object(e) ? Object.isFrozen(e) : !0;
  this.assert(t, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
});
j.addProperty('finite', function (e) {
  let t = U(this, 'object');
  this.assert(
    typeof t == 'number' && isFinite(t),
    'expected #{this} to be a finite number',
    'expected #{this} to not be a finite number',
  );
});
function ti(e, t) {
  return e === t
    ? !0
    : typeof t != typeof e
      ? !1
      : typeof e != 'object' || e === null
        ? e === t
        : t
          ? Array.isArray(e)
            ? Array.isArray(t)
              ? e.every(function (r) {
                  return t.some(function (n) {
                    return ti(r, n);
                  });
                })
              : !1
            : e instanceof Date
              ? t instanceof Date
                ? e.getTime() === t.getTime()
                : !1
              : Object.keys(e).every(function (r) {
                  let n = e[r],
                    o = t[r];
                  return typeof n == 'object' && n !== null && o !== null
                    ? ti(n, o)
                    : typeof n == 'function'
                      ? n(o)
                      : o === n;
                })
          : !1;
}
s(ti, 'compareSubset');
z(ti, 'compareSubset');
j.addMethod('containSubset', function (e) {
  const t = me(this, 'object'),
    r = vt.showDiff;
  this.assert(
    ti(e, t),
    'expected #{act} to contain subset #{exp}',
    'expected #{act} to not contain subset #{exp}',
    e,
    t,
    r,
  );
});
function Ur(e, t) {
  return new j(e, t);
}
s(Ur, 'expect');
z(Ur, 'expect');
Ur.fail = function (e, t, r, n) {
  throw (
    arguments.length < 2 && ((r = e), (e = void 0)),
    (r = r || 'expect.fail()'),
    new Re(r, { actual: e, expected: t, operator: n }, Ur.fail)
  );
};
var v_ = {};
kf(v_, { Should: s(() => pB, 'Should'), should: s(() => dB, 'should') });
function mc() {
  function e() {
    return this instanceof String ||
      this instanceof Number ||
      this instanceof Boolean ||
      (typeof Symbol == 'function' && this instanceof Symbol) ||
      (typeof BigInt == 'function' && this instanceof BigInt)
      ? new j(this.valueOf(), null, e)
      : new j(this, null, e);
  }
  (s(e, 'shouldGetter'), z(e, 'shouldGetter'));
  function t(n) {
    Object.defineProperty(this, 'should', {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0,
    });
  }
  (s(t, 'shouldSetter'),
    z(t, 'shouldSetter'),
    Object.defineProperty(Object.prototype, 'should', { set: t, get: e, configurable: !0 }));
  let r = {};
  return (
    (r.fail = function (n, o, i, a) {
      throw (
        arguments.length < 2 && ((i = n), (n = void 0)),
        (i = i || 'should.fail()'),
        new Re(i, { actual: n, expected: o, operator: a }, r.fail)
      );
    }),
    (r.equal = function (n, o, i) {
      new j(n, i).to.equal(o);
    }),
    (r.Throw = function (n, o, i, a) {
      new j(n, a).to.Throw(o, i);
    }),
    (r.exist = function (n, o) {
      new j(n, o).to.exist;
    }),
    (r.not = {}),
    (r.not.equal = function (n, o, i) {
      new j(n, i).to.not.equal(o);
    }),
    (r.not.Throw = function (n, o, i, a) {
      new j(n, a).to.not.Throw(o, i);
    }),
    (r.not.exist = function (n, o) {
      new j(n, o).to.not.exist;
    }),
    (r.throw = r.Throw),
    (r.not.throw = r.not.Throw),
    r
  );
}
s(mc, 'loadShould');
z(mc, 'loadShould');
var dB = mc,
  pB = mc;
function M(e, t) {
  new j(null, null, M, !0).assert(e, t, '[ negation message unavailable ]');
}
s(M, 'assert');
z(M, 'assert');
M.fail = function (e, t, r, n) {
  throw (
    arguments.length < 2 && ((r = e), (e = void 0)),
    (r = r || 'assert.fail()'),
    new Re(r, { actual: e, expected: t, operator: n }, M.fail)
  );
};
M.isOk = function (e, t) {
  new j(e, t, M.isOk, !0).is.ok;
};
M.isNotOk = function (e, t) {
  new j(e, t, M.isNotOk, !0).is.not.ok;
};
M.equal = function (e, t, r) {
  let n = new j(e, r, M.equal, !0);
  n.assert(
    t == me(n, 'object'),
    'expected #{this} to equal #{exp}',
    'expected #{this} to not equal #{act}',
    t,
    e,
    !0,
  );
};
M.notEqual = function (e, t, r) {
  let n = new j(e, r, M.notEqual, !0);
  n.assert(
    t != me(n, 'object'),
    'expected #{this} to not equal #{exp}',
    'expected #{this} to equal #{act}',
    t,
    e,
    !0,
  );
};
M.strictEqual = function (e, t, r) {
  new j(e, r, M.strictEqual, !0).to.equal(t);
};
M.notStrictEqual = function (e, t, r) {
  new j(e, r, M.notStrictEqual, !0).to.not.equal(t);
};
M.deepEqual = M.deepStrictEqual = function (e, t, r) {
  new j(e, r, M.deepEqual, !0).to.eql(t);
};
M.notDeepEqual = function (e, t, r) {
  new j(e, r, M.notDeepEqual, !0).to.not.eql(t);
};
M.isAbove = function (e, t, r) {
  new j(e, r, M.isAbove, !0).to.be.above(t);
};
M.isAtLeast = function (e, t, r) {
  new j(e, r, M.isAtLeast, !0).to.be.least(t);
};
M.isBelow = function (e, t, r) {
  new j(e, r, M.isBelow, !0).to.be.below(t);
};
M.isAtMost = function (e, t, r) {
  new j(e, r, M.isAtMost, !0).to.be.most(t);
};
M.isTrue = function (e, t) {
  new j(e, t, M.isTrue, !0).is.true;
};
M.isNotTrue = function (e, t) {
  new j(e, t, M.isNotTrue, !0).to.not.equal(!0);
};
M.isFalse = function (e, t) {
  new j(e, t, M.isFalse, !0).is.false;
};
M.isNotFalse = function (e, t) {
  new j(e, t, M.isNotFalse, !0).to.not.equal(!1);
};
M.isNull = function (e, t) {
  new j(e, t, M.isNull, !0).to.equal(null);
};
M.isNotNull = function (e, t) {
  new j(e, t, M.isNotNull, !0).to.not.equal(null);
};
M.isNaN = function (e, t) {
  new j(e, t, M.isNaN, !0).to.be.NaN;
};
M.isNotNaN = function (e, t) {
  new j(e, t, M.isNotNaN, !0).not.to.be.NaN;
};
M.exists = function (e, t) {
  new j(e, t, M.exists, !0).to.exist;
};
M.notExists = function (e, t) {
  new j(e, t, M.notExists, !0).to.not.exist;
};
M.isUndefined = function (e, t) {
  new j(e, t, M.isUndefined, !0).to.equal(void 0);
};
M.isDefined = function (e, t) {
  new j(e, t, M.isDefined, !0).to.not.equal(void 0);
};
M.isCallable = function (e, t) {
  new j(e, t, M.isCallable, !0).is.callable;
};
M.isNotCallable = function (e, t) {
  new j(e, t, M.isNotCallable, !0).is.not.callable;
};
M.isObject = function (e, t) {
  new j(e, t, M.isObject, !0).to.be.a('object');
};
M.isNotObject = function (e, t) {
  new j(e, t, M.isNotObject, !0).to.not.be.a('object');
};
M.isArray = function (e, t) {
  new j(e, t, M.isArray, !0).to.be.an('array');
};
M.isNotArray = function (e, t) {
  new j(e, t, M.isNotArray, !0).to.not.be.an('array');
};
M.isString = function (e, t) {
  new j(e, t, M.isString, !0).to.be.a('string');
};
M.isNotString = function (e, t) {
  new j(e, t, M.isNotString, !0).to.not.be.a('string');
};
M.isNumber = function (e, t) {
  new j(e, t, M.isNumber, !0).to.be.a('number');
};
M.isNotNumber = function (e, t) {
  new j(e, t, M.isNotNumber, !0).to.not.be.a('number');
};
M.isNumeric = function (e, t) {
  new j(e, t, M.isNumeric, !0).is.numeric;
};
M.isNotNumeric = function (e, t) {
  new j(e, t, M.isNotNumeric, !0).is.not.numeric;
};
M.isFinite = function (e, t) {
  new j(e, t, M.isFinite, !0).to.be.finite;
};
M.isBoolean = function (e, t) {
  new j(e, t, M.isBoolean, !0).to.be.a('boolean');
};
M.isNotBoolean = function (e, t) {
  new j(e, t, M.isNotBoolean, !0).to.not.be.a('boolean');
};
M.typeOf = function (e, t, r) {
  new j(e, r, M.typeOf, !0).to.be.a(t);
};
M.notTypeOf = function (e, t, r) {
  new j(e, r, M.notTypeOf, !0).to.not.be.a(t);
};
M.instanceOf = function (e, t, r) {
  new j(e, r, M.instanceOf, !0).to.be.instanceOf(t);
};
M.notInstanceOf = function (e, t, r) {
  new j(e, r, M.notInstanceOf, !0).to.not.be.instanceOf(t);
};
M.include = function (e, t, r) {
  new j(e, r, M.include, !0).include(t);
};
M.notInclude = function (e, t, r) {
  new j(e, r, M.notInclude, !0).not.include(t);
};
M.deepInclude = function (e, t, r) {
  new j(e, r, M.deepInclude, !0).deep.include(t);
};
M.notDeepInclude = function (e, t, r) {
  new j(e, r, M.notDeepInclude, !0).not.deep.include(t);
};
M.nestedInclude = function (e, t, r) {
  new j(e, r, M.nestedInclude, !0).nested.include(t);
};
M.notNestedInclude = function (e, t, r) {
  new j(e, r, M.notNestedInclude, !0).not.nested.include(t);
};
M.deepNestedInclude = function (e, t, r) {
  new j(e, r, M.deepNestedInclude, !0).deep.nested.include(t);
};
M.notDeepNestedInclude = function (e, t, r) {
  new j(e, r, M.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
M.ownInclude = function (e, t, r) {
  new j(e, r, M.ownInclude, !0).own.include(t);
};
M.notOwnInclude = function (e, t, r) {
  new j(e, r, M.notOwnInclude, !0).not.own.include(t);
};
M.deepOwnInclude = function (e, t, r) {
  new j(e, r, M.deepOwnInclude, !0).deep.own.include(t);
};
M.notDeepOwnInclude = function (e, t, r) {
  new j(e, r, M.notDeepOwnInclude, !0).not.deep.own.include(t);
};
M.match = function (e, t, r) {
  new j(e, r, M.match, !0).to.match(t);
};
M.notMatch = function (e, t, r) {
  new j(e, r, M.notMatch, !0).to.not.match(t);
};
M.property = function (e, t, r) {
  new j(e, r, M.property, !0).to.have.property(t);
};
M.notProperty = function (e, t, r) {
  new j(e, r, M.notProperty, !0).to.not.have.property(t);
};
M.propertyVal = function (e, t, r, n) {
  new j(e, n, M.propertyVal, !0).to.have.property(t, r);
};
M.notPropertyVal = function (e, t, r, n) {
  new j(e, n, M.notPropertyVal, !0).to.not.have.property(t, r);
};
M.deepPropertyVal = function (e, t, r, n) {
  new j(e, n, M.deepPropertyVal, !0).to.have.deep.property(t, r);
};
M.notDeepPropertyVal = function (e, t, r, n) {
  new j(e, n, M.notDeepPropertyVal, !0).to.not.have.deep.property(t, r);
};
M.ownProperty = function (e, t, r) {
  new j(e, r, M.ownProperty, !0).to.have.own.property(t);
};
M.notOwnProperty = function (e, t, r) {
  new j(e, r, M.notOwnProperty, !0).to.not.have.own.property(t);
};
M.ownPropertyVal = function (e, t, r, n) {
  new j(e, n, M.ownPropertyVal, !0).to.have.own.property(t, r);
};
M.notOwnPropertyVal = function (e, t, r, n) {
  new j(e, n, M.notOwnPropertyVal, !0).to.not.have.own.property(t, r);
};
M.deepOwnPropertyVal = function (e, t, r, n) {
  new j(e, n, M.deepOwnPropertyVal, !0).to.have.deep.own.property(t, r);
};
M.notDeepOwnPropertyVal = function (e, t, r, n) {
  new j(e, n, M.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, r);
};
M.nestedProperty = function (e, t, r) {
  new j(e, r, M.nestedProperty, !0).to.have.nested.property(t);
};
M.notNestedProperty = function (e, t, r) {
  new j(e, r, M.notNestedProperty, !0).to.not.have.nested.property(t);
};
M.nestedPropertyVal = function (e, t, r, n) {
  new j(e, n, M.nestedPropertyVal, !0).to.have.nested.property(t, r);
};
M.notNestedPropertyVal = function (e, t, r, n) {
  new j(e, n, M.notNestedPropertyVal, !0).to.not.have.nested.property(t, r);
};
M.deepNestedPropertyVal = function (e, t, r, n) {
  new j(e, n, M.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, r);
};
M.notDeepNestedPropertyVal = function (e, t, r, n) {
  new j(e, n, M.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, r);
};
M.lengthOf = function (e, t, r) {
  new j(e, r, M.lengthOf, !0).to.have.lengthOf(t);
};
M.hasAnyKeys = function (e, t, r) {
  new j(e, r, M.hasAnyKeys, !0).to.have.any.keys(t);
};
M.hasAllKeys = function (e, t, r) {
  new j(e, r, M.hasAllKeys, !0).to.have.all.keys(t);
};
M.containsAllKeys = function (e, t, r) {
  new j(e, r, M.containsAllKeys, !0).to.contain.all.keys(t);
};
M.doesNotHaveAnyKeys = function (e, t, r) {
  new j(e, r, M.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
M.doesNotHaveAllKeys = function (e, t, r) {
  new j(e, r, M.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
M.hasAnyDeepKeys = function (e, t, r) {
  new j(e, r, M.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
M.hasAllDeepKeys = function (e, t, r) {
  new j(e, r, M.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
M.containsAllDeepKeys = function (e, t, r) {
  new j(e, r, M.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
M.doesNotHaveAnyDeepKeys = function (e, t, r) {
  new j(e, r, M.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
M.doesNotHaveAllDeepKeys = function (e, t, r) {
  new j(e, r, M.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
M.throws = function (e, t, r, n) {
  (typeof t == 'string' || t instanceof RegExp) && ((r = t), (t = null));
  let o = new j(e, n, M.throws, !0).to.throw(t, r);
  return me(o, 'object');
};
M.doesNotThrow = function (e, t, r, n) {
  ((typeof t == 'string' || t instanceof RegExp) && ((r = t), (t = null)),
    new j(e, n, M.doesNotThrow, !0).to.not.throw(t, r));
};
M.operator = function (e, t, r, n) {
  let o;
  switch (t) {
    case '==':
      o = e == r;
      break;
    case '===':
      o = e === r;
      break;
    case '>':
      o = e > r;
      break;
    case '>=':
      o = e >= r;
      break;
    case '<':
      o = e < r;
      break;
    case '<=':
      o = e <= r;
      break;
    case '!=':
      o = e != r;
      break;
    case '!==':
      o = e !== r;
      break;
    default:
      throw ((n = n && n + ': '), new Re(n + 'Invalid operator "' + t + '"', void 0, M.operator));
  }
  let i = new j(o, n, M.operator, !0);
  i.assert(
    me(i, 'object') === !0,
    'expected ' + Se(e) + ' to be ' + t + ' ' + Se(r),
    'expected ' + Se(e) + ' to not be ' + t + ' ' + Se(r),
  );
};
M.closeTo = function (e, t, r, n) {
  new j(e, n, M.closeTo, !0).to.be.closeTo(t, r);
};
M.approximately = function (e, t, r, n) {
  new j(e, n, M.approximately, !0).to.be.approximately(t, r);
};
M.sameMembers = function (e, t, r) {
  new j(e, r, M.sameMembers, !0).to.have.same.members(t);
};
M.notSameMembers = function (e, t, r) {
  new j(e, r, M.notSameMembers, !0).to.not.have.same.members(t);
};
M.sameDeepMembers = function (e, t, r) {
  new j(e, r, M.sameDeepMembers, !0).to.have.same.deep.members(t);
};
M.notSameDeepMembers = function (e, t, r) {
  new j(e, r, M.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
M.sameOrderedMembers = function (e, t, r) {
  new j(e, r, M.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
M.notSameOrderedMembers = function (e, t, r) {
  new j(e, r, M.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
M.sameDeepOrderedMembers = function (e, t, r) {
  new j(e, r, M.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
M.notSameDeepOrderedMembers = function (e, t, r) {
  new j(e, r, M.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
M.includeMembers = function (e, t, r) {
  new j(e, r, M.includeMembers, !0).to.include.members(t);
};
M.notIncludeMembers = function (e, t, r) {
  new j(e, r, M.notIncludeMembers, !0).to.not.include.members(t);
};
M.includeDeepMembers = function (e, t, r) {
  new j(e, r, M.includeDeepMembers, !0).to.include.deep.members(t);
};
M.notIncludeDeepMembers = function (e, t, r) {
  new j(e, r, M.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
M.includeOrderedMembers = function (e, t, r) {
  new j(e, r, M.includeOrderedMembers, !0).to.include.ordered.members(t);
};
M.notIncludeOrderedMembers = function (e, t, r) {
  new j(e, r, M.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
M.includeDeepOrderedMembers = function (e, t, r) {
  new j(e, r, M.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
M.notIncludeDeepOrderedMembers = function (e, t, r) {
  new j(e, r, M.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
M.oneOf = function (e, t, r) {
  new j(e, r, M.oneOf, !0).to.be.oneOf(t);
};
M.isIterable = function (e, t) {
  if (e == null || !e[Symbol.iterator])
    throw (
      (t = t ? `${t} expected ${Se(e)} to be an iterable` : `expected ${Se(e)} to be an iterable`),
      new Re(t, void 0, M.isIterable)
    );
};
M.changes = function (e, t, r, n) {
  (arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new j(e, n, M.changes, !0).to.change(t, r));
};
M.changesBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new j(e, o, M.changesBy, !0).to.change(t, r).by(n);
};
M.doesNotChange = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new j(e, n, M.doesNotChange, !0).to.not.change(t, r)
  );
};
M.changesButNotBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new j(e, o, M.changesButNotBy, !0).to.change(t, r).but.not.by(n);
};
M.increases = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new j(e, n, M.increases, !0).to.increase(t, r)
  );
};
M.increasesBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new j(e, o, M.increasesBy, !0).to.increase(t, r).by(n);
};
M.doesNotIncrease = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new j(e, n, M.doesNotIncrease, !0).to.not.increase(t, r)
  );
};
M.increasesButNotBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new j(e, o, M.increasesButNotBy, !0).to.increase(t, r).but.not.by(n);
};
M.decreases = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new j(e, n, M.decreases, !0).to.decrease(t, r)
  );
};
M.decreasesBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new j(e, o, M.decreasesBy, !0).to.decrease(t, r).by(n);
};
M.doesNotDecrease = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new j(e, n, M.doesNotDecrease, !0).to.not.decrease(t, r)
  );
};
M.doesNotDecreaseBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  return new j(e, o, M.doesNotDecreaseBy, !0).to.not.decrease(t, r).by(n);
};
M.decreasesButNotBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new j(e, o, M.decreasesButNotBy, !0).to.decrease(t, r).but.not.by(n);
};
M.ifError = function (e) {
  if (e) throw e;
};
M.isExtensible = function (e, t) {
  new j(e, t, M.isExtensible, !0).to.be.extensible;
};
M.isNotExtensible = function (e, t) {
  new j(e, t, M.isNotExtensible, !0).to.not.be.extensible;
};
M.isSealed = function (e, t) {
  new j(e, t, M.isSealed, !0).to.be.sealed;
};
M.isNotSealed = function (e, t) {
  new j(e, t, M.isNotSealed, !0).to.not.be.sealed;
};
M.isFrozen = function (e, t) {
  new j(e, t, M.isFrozen, !0).to.be.frozen;
};
M.isNotFrozen = function (e, t) {
  new j(e, t, M.isNotFrozen, !0).to.not.be.frozen;
};
M.isEmpty = function (e, t) {
  new j(e, t, M.isEmpty, !0).to.be.empty;
};
M.isNotEmpty = function (e, t) {
  new j(e, t, M.isNotEmpty, !0).to.not.be.empty;
};
M.containsSubset = function (e, t, r) {
  new j(e, r).to.containSubset(t);
};
M.doesNotContainSubset = function (e, t, r) {
  new j(e, r).to.not.containSubset(t);
};
var fB = [
  ['isOk', 'ok'],
  ['isNotOk', 'notOk'],
  ['throws', 'throw'],
  ['throws', 'Throw'],
  ['isExtensible', 'extensible'],
  ['isNotExtensible', 'notExtensible'],
  ['isSealed', 'sealed'],
  ['isNotSealed', 'notSealed'],
  ['isFrozen', 'frozen'],
  ['isNotFrozen', 'notFrozen'],
  ['isEmpty', 'empty'],
  ['isNotEmpty', 'notEmpty'],
  ['isCallable', 'isFunction'],
  ['isNotCallable', 'isNotFunction'],
  ['containsSubset', 'containSubset'],
];
for (const [e, t] of fB) M[t] = M[e];
var Kg = [];
function Tn(e) {
  const t = {
    use: Tn,
    AssertionError: Re,
    util: rr,
    config: vt,
    expect: Ur,
    assert: M,
    Assertion: j,
    ...v_,
  };
  return (~Kg.indexOf(e) || (e(t, rr), Kg.push(e)), t);
}
s(Tn, 'use');
z(Tn, 'use');
var T_ = {};
St(T_, {
  toAppearAfter: () => Q0,
  toAppearBefore: () => Ba,
  toBeChecked: () => ry,
  toBeDisabled: () => Wm,
  toBeEmpty: () => qm,
  toBeEmptyDOMElement: () => Mm,
  toBeEnabled: () => Km,
  toBeInTheDOM: () => ja,
  toBeInTheDocument: () => Nm,
  toBeInvalid: () => Qm,
  toBePartiallyChecked: () => oy,
  toBePartiallyPressed: () => cy,
  toBePressed: () => ly,
  toBeRequired: () => Ym,
  toBeValid: () => Zm,
  toBeVisible: () => Um,
  toContainElement: () => $a,
  toContainHTML: () => jm,
  toHaveAccessibleDescription: () => ka,
  toHaveAccessibleErrorMessage: () => km,
  toHaveAccessibleName: () => La,
  toHaveAttribute: () => Dm,
  toHaveClass: () => Lm,
  toHaveDescription: () => sy,
  toHaveDisplayValue: () => ty,
  toHaveErrorMessage: () => iy,
  toHaveFocus: () => Fm,
  toHaveFormValues: () => Bm,
  toHaveRole: () => Da,
  toHaveSelection: () => ay,
  toHaveStyle: () => Fa,
  toHaveTextContent: () => $m,
  toHaveValue: () => ey,
});
var Yg = Ge(wv(), 1),
  E_ = class extends Error {
    constructor(r, n, o, i, a) {
      super(`${r}:${o}:${i}: ${n}`);
      Be(this, 'reason');
      Be(this, 'filename');
      Be(this, 'line');
      Be(this, 'column');
      Be(this, 'source');
      ((this.reason = n),
        (this.filename = r),
        (this.line = o),
        (this.column = i),
        (this.source = a));
    }
  };
s(E_, 't');
var mB = E_,
  w_ = class {
    constructor(t, r, n) {
      Be(this, 'start');
      Be(this, 'end');
      Be(this, 'source');
      ((this.start = t), (this.end = r), (this.source = n));
    }
  };
s(w_, 'e');
var yB = w_,
  Ze;
(function (e) {
  ((e.stylesheet = 'stylesheet'),
    (e.rule = 'rule'),
    (e.declaration = 'declaration'),
    (e.comment = 'comment'),
    (e.container = 'container'),
    (e.charset = 'charset'),
    (e.document = 'document'),
    (e.customMedia = 'custom-media'),
    (e.fontFace = 'font-face'),
    (e.host = 'host'),
    (e.import = 'import'),
    (e.keyframes = 'keyframes'),
    (e.keyframe = 'keyframe'),
    (e.layer = 'layer'),
    (e.media = 'media'),
    (e.namespace = 'namespace'),
    (e.page = 'page'),
    (e.startingStyle = 'starting-style'),
    (e.supports = 'supports'));
})(Ze || (Ze = {}));
var Xg = s((e, t, r) => {
    let n = r,
      o = 1e4;
    do {
      const i = t.map((d) => e.indexOf(d, n));
      i.push(e.indexOf('\\', n));
      const a = i.filter((d) => d !== -1);
      if (a.length === 0) return -1;
      const c = Math.min(...a);
      if (e[c] !== '\\') return c;
      ((n = c + 2), o--);
    } while (o > 0);
    throw new Error('Too many escaping');
  }, 's'),
  ed = s((e, t, r) => {
    let n = r,
      o = 1e4;
    do {
      const i = t.map((d) => e.indexOf(d, n));
      (i.push(e.indexOf('(', n)),
        i.push(e.indexOf('"', n)),
        i.push(e.indexOf("'", n)),
        i.push(e.indexOf('\\', n)));
      const a = i.filter((d) => d !== -1);
      if (a.length === 0) return -1;
      const c = Math.min(...a);
      switch (e[c]) {
        case '\\':
          n = c + 2;
          break;
        case '(':
          {
            const d = ed(e, [')'], c + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        case '"':
          {
            const d = Xg(e, ['"'], c + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        case "'":
          {
            const d = Xg(e, ["'"], c + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        default:
          return c;
      }
      o--;
    } while (o > 0);
    throw new Error('Too many escaping');
  }, 'n'),
  cu = /\/\*[^]*?(?:\*\/|$)/g;
function At(e) {
  return e ? e.trim() : '';
}
s(At, 'o');
function Ma(e, t) {
  const r = e && typeof e.type == 'string',
    n = r ? e : t;
  for (const o in e) {
    const i = e[o];
    Array.isArray(i)
      ? i.forEach((a) => {
          Ma(a, n);
        })
      : i && typeof i == 'object' && Ma(i, n);
  }
  return (
    r &&
      Object.defineProperty(e, 'parent', {
        configurable: !0,
        writable: !0,
        enumerable: !1,
        value: t || null,
      }),
    e
  );
}
s(Ma, 'c');
var hB = s((e, t) => {
    t = t || {};
    let r = 1,
      n = 1;
    function o() {
      const w = { line: r, column: n };
      return (_) => ((_.position = new yB(w, { line: r, column: n }, t?.source || '')), f(), _);
    }
    s(o, 'u');
    const i = [];
    function a(w) {
      const _ = new mB(t?.source || '', w, r, n, e);
      if (!t?.silent) throw _;
      i.push(_);
    }
    s(a, 'l');
    function c() {
      const w = /^{\s*/.exec(e);
      return !!w && (p(w), !0);
    }
    s(c, 'f');
    function d() {
      const w = /^}/.exec(e);
      return !!w && (p(w), !0);
    }
    s(d, 'd');
    function u() {
      let w;
      const _ = [];
      for (f(), m(_); e.length && e.charAt(0) !== '}' && ((w = P() || A()), w); ) (_.push(w), m(_));
      return _;
    }
    s(u, 'y');
    function p(w) {
      const _ = w[0];
      return (
        (function ($) {
          const N = $.match(/\n/g);
          N && (r += N.length);
          const V = $.lastIndexOf(`
`);
          n = ~V ? $.length - V : n + $.length;
        })(_),
        (e = e.slice(_.length)),
        w
      );
    }
    s(p, 'g');
    function f() {
      const w = /^\s*/.exec(e);
      w && p(w);
    }
    s(f, '$');
    function m(w) {
      w = w || [];
      let _ = h();
      for (; _; ) (w.push(_), (_ = h()));
      return w;
    }
    s(m, 'x');
    function h() {
      const w = o();
      if (e.charAt(0) !== '/' || e.charAt(1) !== '*') return;
      const _ = /^\/\*[^]*?\*\//.exec(e);
      return _
        ? (p(_), w({ type: Ze.comment, comment: _[0].slice(2, -2) }))
        : a('End of comment missing');
    }
    s(h, 'V');
    function g() {
      const w = /^([^{]+)/.exec(e);
      if (w)
        return (
          p(w),
          ((_, $) => {
            const N = [];
            let V = 0;
            for (; V < _.length; ) {
              const H = ed(_, $, V);
              if (H === -1) return (N.push(_.substring(V)), N);
              (N.push(_.substring(V, H)), (V = H + 1));
            }
            return N;
          })(At(w[0]).replace(cu, ''), [',']).map((_) => At(_))
        );
    }
    s(g, 'k');
    function v() {
      const w = o(),
        _ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(e);
      if (!_) return;
      p(_);
      const $ = At(_[0]),
        N = /^:\s*/.exec(e);
      if (!N) return a("property missing ':'");
      p(N);
      let V = '';
      const H = ed(e, [';', '}']);
      H !== -1 && ((V = e.substring(0, H)), p([V]), (V = At(V).replace(cu, '')));
      const x = w({ type: Ze.declaration, property: $.replace(cu, ''), value: V }),
        D = /^[;\s]*/.exec(e);
      return (D && p(D), x);
    }
    s(v, 'v');
    function E() {
      const w = [];
      if (!c()) return a("missing '{'");
      m(w);
      let _ = v();
      for (; _; ) (w.push(_), m(w), (_ = v()));
      return d() ? w : a("missing '}'");
    }
    s(E, 'w');
    function b() {
      const w = [],
        _ = o();
      let $ = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
      for (; $; ) {
        const N = p($);
        w.push(N[1]);
        const V = /^,\s*/.exec(e);
        (V && p(V), ($ = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e)));
      }
      if (w.length) return _({ type: Ze.keyframe, values: w, declarations: E() || [] });
    }
    s(b, 'b');
    const S = q('import'),
      R = q('charset'),
      I = q('namespace');
    function q(w) {
      const _ = new RegExp(
        '^@' + w + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`,
      );
      return () => {
        const $ = o(),
          N = _.exec(e);
        if (!N) return;
        const V = p(N),
          H = { type: w };
        return ((H[w] = V[1].trim()), $(H));
      };
    }
    s(q, 'M');
    function P() {
      if (e[0] === '@')
        return (
          (function () {
            const w = o(),
              _ = /^@([-\w]+)?keyframes\s*/.exec(e);
            if (!_) return;
            const $ = p(_)[1],
              N = /^([-\w]+)\s*/.exec(e);
            if (!N) return a('@keyframes missing name');
            const V = p(N)[1];
            if (!c()) return a("@keyframes missing '{'");
            let H = m(),
              x = b();
            for (; x; ) (H.push(x), (H = H.concat(m())), (x = b()));
            return d()
              ? w({ type: Ze.keyframes, name: V, vendor: $, keyframes: H })
              : a("@keyframes missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@media *([^{]+)/.exec(e);
            if (!_) return;
            const $ = At(p(_)[1]);
            if (!c()) return a("@media missing '{'");
            const N = m().concat(u());
            return d() ? w({ type: Ze.media, media: $, rules: N }) : a("@media missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(e);
            if (!_) return;
            const $ = p(_);
            return w({ type: Ze.customMedia, name: At($[1]), media: At($[2]) });
          })() ||
          (function () {
            const w = o(),
              _ = /^@supports *([^{]+)/.exec(e);
            if (!_) return;
            const $ = At(p(_)[1]);
            if (!c()) return a("@supports missing '{'");
            const N = m().concat(u());
            return d()
              ? w({ type: Ze.supports, supports: $, rules: N })
              : a("@supports missing '}'");
          })() ||
          S() ||
          R() ||
          I() ||
          (function () {
            const w = o(),
              _ = /^@([-\w]+)?document *([^{]+)/.exec(e);
            if (!_) return;
            const $ = p(_),
              N = At($[1]),
              V = At($[2]);
            if (!c()) return a("@document missing '{'");
            const H = m().concat(u());
            return d()
              ? w({ type: Ze.document, document: V, vendor: N, rules: H })
              : a("@document missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@page */.exec(e);
            if (!_) return;
            p(_);
            const $ = g() || [];
            if (!c()) return a("@page missing '{'");
            let N = m(),
              V = v();
            for (; V; ) (N.push(V), (N = N.concat(m())), (V = v()));
            return d()
              ? w({ type: Ze.page, selectors: $, declarations: N })
              : a("@page missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@host\s*/.exec(e);
            if (!_) return;
            if ((p(_), !c())) return a("@host missing '{'");
            const $ = m().concat(u());
            return d() ? w({ type: Ze.host, rules: $ }) : a("@host missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@font-face\s*/.exec(e);
            if (!_) return;
            if ((p(_), !c())) return a("@font-face missing '{'");
            let $ = m(),
              N = v();
            for (; N; ) ($.push(N), ($ = $.concat(m())), (N = v()));
            return d() ? w({ type: Ze.fontFace, declarations: $ }) : a("@font-face missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@container *([^{]+)/.exec(e);
            if (!_) return;
            const $ = At(p(_)[1]);
            if (!c()) return a("@container missing '{'");
            const N = m().concat(u());
            return d()
              ? w({ type: Ze.container, container: $, rules: N })
              : a("@container missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@starting-style\s*/.exec(e);
            if (!_) return;
            if ((p(_), !c())) return a("@starting-style missing '{'");
            const $ = m().concat(u());
            return d() ? w({ type: Ze.startingStyle, rules: $ }) : a("@starting-style missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@layer *([^{;@]+)/.exec(e);
            if (!_) return;
            const $ = At(p(_)[1]);
            if (!c()) {
              const V = /^[;\s]*/.exec(e);
              return (V && p(V), w({ type: Ze.layer, layer: $ }));
            }
            const N = m().concat(u());
            return d() ? w({ type: Ze.layer, layer: $, rules: N }) : a("@layer missing '}'");
          })()
        );
    }
    s(P, 'A');
    function A() {
      const w = o(),
        _ = g();
      return _
        ? (m(), w({ type: Ze.rule, selectors: _, declarations: E() || [] }))
        : a('selector missing');
    }
    return (
      s(A, 'S'),
      Ma(
        (function () {
          const w = u();
          return {
            type: Ze.stylesheet,
            stylesheet: { source: t?.source, rules: w, parsingErrors: i },
          };
        })(),
      )
    );
  }, 'm'),
  gB = Object.prototype.toString;
function td(e) {
  return typeof e == 'function' || gB.call(e) === '[object Function]';
}
s(td, 'isCallable');
function S_(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
s(S_, 'toInteger');
var bB = Math.pow(2, 53) - 1;
function __(e) {
  var t = S_(e);
  return Math.min(Math.max(t, 0), bB);
}
s(__, 'toLength');
function kt(e, t) {
  var r = Array,
    n = Object(e);
  if (e == null)
    throw new TypeError('Array.from requires an array-like object - not null or undefined');
  if (typeof t < 'u' && !td(t))
    throw new TypeError('Array.from: when provided, the second argument must be a function');
  for (var o = __(n.length), i = td(r) ? Object(new r(o)) : new Array(o), a = 0, c; a < o; )
    ((c = n[a]), t ? (i[a] = t(c, a)) : (i[a] = c), (a += 1));
  return ((i.length = o), i);
}
s(kt, 'arrayFrom');
function To(e) {
  '@babel/helpers - typeof';
  return (
    (To =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    To(e)
  );
}
s(To, '_typeof');
function A_(e, t) {
  if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
s(A_, '_classCallCheck');
function rd(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    ((n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      'value' in n && (n.writable = !0),
      Object.defineProperty(e, wm(n.key), n));
  }
}
s(rd, '_defineProperties');
function R_(e, t, r) {
  return (
    t && rd(e.prototype, t),
    r && rd(e, r),
    Object.defineProperty(e, 'prototype', { writable: !1 }),
    e
  );
}
s(R_, '_createClass');
function x_(e, t, r) {
  return (
    (t = wm(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(x_, '_defineProperty');
function wm(e) {
  var t = P_(e, 'string');
  return To(t) === 'symbol' ? t : String(t);
}
s(wm, '_toPropertyKey');
function P_(e, t) {
  if (To(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (To(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
s(P_, '_toPrimitive');
var vB = (function () {
    function e() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      (A_(this, e), x_(this, 'items', void 0), (this.items = t));
    }
    return (
      s(e, 'SetLike'),
      R_(e, [
        {
          key: 'add',
          value: s(function (r) {
            return (this.has(r) === !1 && this.items.push(r), this);
          }, 'add'),
        },
        {
          key: 'clear',
          value: s(function () {
            this.items = [];
          }, 'clear'),
        },
        {
          key: 'delete',
          value: s(function (r) {
            var n = this.items.length;
            return (
              (this.items = this.items.filter(function (o) {
                return o !== r;
              })),
              n !== this.items.length
            );
          }, '_delete'),
        },
        {
          key: 'forEach',
          value: s(function (r) {
            var n = this;
            this.items.forEach(function (o) {
              r(o, o, n);
            });
          }, 'forEach'),
        },
        {
          key: 'has',
          value: s(function (r) {
            return this.items.indexOf(r) !== -1;
          }, 'has'),
        },
        {
          key: 'size',
          get: s(function () {
            return this.items.length;
          }, 'get'),
        },
      ]),
      e
    );
  })(),
  TB = typeof Set > 'u' ? Set : vB;
function ut(e) {
  var t;
  return (t = e.localName) !== null && t !== void 0 ? t : e.tagName.toLowerCase();
}
s(ut, 'getLocalName');
var EB = {
    article: 'article',
    aside: 'complementary',
    button: 'button',
    datalist: 'listbox',
    dd: 'definition',
    details: 'group',
    dialog: 'dialog',
    dt: 'term',
    fieldset: 'group',
    figure: 'figure',
    form: 'form',
    footer: 'contentinfo',
    h1: 'heading',
    h2: 'heading',
    h3: 'heading',
    h4: 'heading',
    h5: 'heading',
    h6: 'heading',
    header: 'banner',
    hr: 'separator',
    html: 'document',
    legend: 'legend',
    li: 'listitem',
    math: 'math',
    main: 'main',
    menu: 'list',
    nav: 'navigation',
    ol: 'list',
    optgroup: 'group',
    option: 'option',
    output: 'status',
    progress: 'progressbar',
    section: 'region',
    summary: 'button',
    table: 'table',
    tbody: 'rowgroup',
    textarea: 'textbox',
    tfoot: 'rowgroup',
    td: 'cell',
    th: 'columnheader',
    thead: 'rowgroup',
    tr: 'row',
    ul: 'list',
  },
  wB = {
    caption: new Set(['aria-label', 'aria-labelledby']),
    code: new Set(['aria-label', 'aria-labelledby']),
    deletion: new Set(['aria-label', 'aria-labelledby']),
    emphasis: new Set(['aria-label', 'aria-labelledby']),
    generic: new Set(['aria-label', 'aria-labelledby', 'aria-roledescription']),
    insertion: new Set(['aria-label', 'aria-labelledby']),
    none: new Set(['aria-label', 'aria-labelledby']),
    paragraph: new Set(['aria-label', 'aria-labelledby']),
    presentation: new Set(['aria-label', 'aria-labelledby']),
    strong: new Set(['aria-label', 'aria-labelledby']),
    subscript: new Set(['aria-label', 'aria-labelledby']),
    superscript: new Set(['aria-label', 'aria-labelledby']),
  };
function O_(e, t) {
  return [
    'aria-atomic',
    'aria-busy',
    'aria-controls',
    'aria-current',
    'aria-description',
    'aria-describedby',
    'aria-details',
    'aria-dropeffect',
    'aria-flowto',
    'aria-grabbed',
    'aria-hidden',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-live',
    'aria-owns',
    'aria-relevant',
    'aria-roledescription',
  ].some(function (r) {
    var n;
    return e.hasAttribute(r) && !((n = wB[t]) !== null && n !== void 0 && n.has(r));
  });
}
s(O_, 'hasGlobalAriaAttributes');
function Sm(e, t) {
  return O_(e, t);
}
s(Sm, 'ignorePresentationalRole');
function C_(e) {
  var t = N_(e);
  if (t === null || nd.indexOf(t) !== -1) {
    var r = I_(e);
    if (nd.indexOf(t || '') === -1 || Sm(e, r || '')) return r;
  }
  return t;
}
s(C_, 'getRole');
function I_(e) {
  var t = EB[ut(e)];
  if (t !== void 0) return t;
  switch (ut(e)) {
    case 'a':
    case 'area':
    case 'link':
      if (e.hasAttribute('href')) return 'link';
      break;
    case 'img':
      return e.getAttribute('alt') === '' && !Sm(e, 'img') ? 'presentation' : 'img';
    case 'input': {
      var r = e,
        n = r.type;
      switch (n) {
        case 'button':
        case 'image':
        case 'reset':
        case 'submit':
          return 'button';
        case 'checkbox':
        case 'radio':
          return n;
        case 'range':
          return 'slider';
        case 'email':
        case 'tel':
        case 'text':
        case 'url':
          return e.hasAttribute('list') ? 'combobox' : 'textbox';
        case 'search':
          return e.hasAttribute('list') ? 'combobox' : 'searchbox';
        case 'number':
          return 'spinbutton';
        default:
          return null;
      }
    }
    case 'select':
      return e.hasAttribute('multiple') || e.size > 1 ? 'listbox' : 'combobox';
  }
  return null;
}
s(I_, 'getImplicitRole');
function N_(e) {
  var t = e.getAttribute('role');
  if (t !== null) {
    var r = t.trim().split(' ')[0];
    if (r.length > 0) return r;
  }
  return null;
}
s(N_, 'getExplicitRole');
var nd = ['presentation', 'none'];
function je(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
s(je, 'isElement');
function _m(e) {
  return je(e) && ut(e) === 'caption';
}
s(_m, 'isHTMLTableCaptionElement');
function ks(e) {
  return je(e) && ut(e) === 'input';
}
s(ks, 'isHTMLInputElement');
function q_(e) {
  return je(e) && ut(e) === 'optgroup';
}
s(q_, 'isHTMLOptGroupElement');
function M_(e) {
  return je(e) && ut(e) === 'select';
}
s(M_, 'isHTMLSelectElement');
function j_(e) {
  return je(e) && ut(e) === 'table';
}
s(j_, 'isHTMLTableElement');
function $_(e) {
  return je(e) && ut(e) === 'textarea';
}
s($_, 'isHTMLTextAreaElement');
function k_(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument,
    r = t.defaultView;
  if (r === null) throw new TypeError('no window available');
  return r;
}
s(k_, 'safeWindow');
function D_(e) {
  return je(e) && ut(e) === 'fieldset';
}
s(D_, 'isHTMLFieldSetElement');
function L_(e) {
  return je(e) && ut(e) === 'legend';
}
s(L_, 'isHTMLLegendElement');
function F_(e) {
  return je(e) && ut(e) === 'slot';
}
s(F_, 'isHTMLSlotElement');
function B_(e) {
  return je(e) && e.ownerSVGElement !== void 0;
}
s(B_, 'isSVGElement');
function J_(e) {
  return je(e) && ut(e) === 'svg';
}
s(J_, 'isSVGSVGElement');
function U_(e) {
  return B_(e) && ut(e) === 'title';
}
s(U_, 'isSVGTitleElement');
function ri(e, t) {
  if (je(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(' '),
      n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r
      .map(function (o) {
        return n.getElementById(o);
      })
      .filter(function (o) {
        return o !== null;
      });
  }
  return [];
}
s(ri, 'queryIdRefs');
function nr(e, t) {
  return je(e) ? t.indexOf(C_(e)) !== -1 : !1;
}
s(nr, 'hasAnyConcreteRoles');
function V_(e) {
  return e.trim().replace(/\s\s+/g, ' ');
}
s(V_, 'asFlatString');
function H_(e, t) {
  if (!je(e)) return !1;
  if (e.hasAttribute('hidden') || e.getAttribute('aria-hidden') === 'true') return !0;
  var r = t(e);
  return r.getPropertyValue('display') === 'none' || r.getPropertyValue('visibility') === 'hidden';
}
s(H_, 'isHidden');
function z_(e) {
  return nr(e, ['button', 'combobox', 'listbox', 'textbox']) || Am(e, 'range');
}
s(z_, 'isControl');
function Am(e, t) {
  if (!je(e)) return !1;
  switch (t) {
    case 'range':
      return nr(e, ['meter', 'progressbar', 'scrollbar', 'slider', 'spinbutton']);
    default:
      throw new TypeError(
        "No knowledge about abstract role '".concat(t, "'. This is likely a bug :("),
      );
  }
}
s(Am, 'hasAbstractRole');
function od(e, t) {
  var r = kt(e.querySelectorAll(t));
  return (
    ri(e, 'aria-owns').forEach(function (n) {
      r.push.apply(r, kt(n.querySelectorAll(t)));
    }),
    r
  );
}
s(od, 'querySelectorAllSubtree');
function G_(e) {
  return M_(e) ? e.selectedOptions || od(e, '[selected]') : od(e, '[aria-selected="true"]');
}
s(G_, 'querySelectedOptions');
function W_(e) {
  return nr(e, nd);
}
s(W_, 'isMarkedPresentational');
function K_(e) {
  return _m(e);
}
s(K_, 'isNativeHostLanguageTextAlternativeElement');
function Y_(e) {
  return nr(e, [
    'button',
    'cell',
    'checkbox',
    'columnheader',
    'gridcell',
    'heading',
    'label',
    'legend',
    'link',
    'menuitem',
    'menuitemcheckbox',
    'menuitemradio',
    'option',
    'radio',
    'row',
    'rowheader',
    'switch',
    'tab',
    'tooltip',
    'treeitem',
  ]);
}
s(Y_, 'allowsNameFromContent');
function X_(e) {
  return !1;
}
s(X_, 'isDescendantOfNativeHostLanguageTextAlternativeElement');
function Q_(e) {
  return ks(e) || $_(e) ? e.value : e.textContent || '';
}
s(Q_, 'getValueOfTextbox');
function sd(e) {
  var t = e.getPropertyValue('content');
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : '';
}
s(sd, 'getTextualContent');
function Rm(e) {
  var t = ut(e);
  return (
    t === 'button' ||
    (t === 'input' && e.getAttribute('type') !== 'hidden') ||
    t === 'meter' ||
    t === 'output' ||
    t === 'progress' ||
    t === 'select' ||
    t === 'textarea'
  );
}
s(Rm, 'isLabelableElement');
function xm(e) {
  if (Rm(e)) return e;
  var t = null;
  return (
    e.childNodes.forEach(function (r) {
      if (t === null && je(r)) {
        var n = xm(r);
        n !== null && (t = n);
      }
    }),
    t
  );
}
s(xm, 'findLabelableElement');
function Z_(e) {
  if (e.control !== void 0) return e.control;
  var t = e.getAttribute('for');
  return t !== null ? e.ownerDocument.getElementById(t) : xm(e);
}
s(Z_, 'getControlOfLabel');
function e0(e) {
  var t = e.labels;
  if (t === null) return t;
  if (t !== void 0) return kt(t);
  if (!Rm(e)) return null;
  var r = e.ownerDocument;
  return kt(r.querySelectorAll('label')).filter(function (n) {
    return Z_(n) === e;
  });
}
s(e0, 'getLabels');
function t0(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? kt(e.childNodes) : t;
}
s(t0, 'getSlotContents');
function Pm(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = new TB(),
    n = k_(e),
    o = t.compute,
    i = o === void 0 ? 'name' : o,
    a = t.computedStyleSupportsPseudoElements,
    c = a === void 0 ? t.getComputedStyle !== void 0 : a,
    d = t.getComputedStyle,
    u = d === void 0 ? n.getComputedStyle.bind(n) : d,
    p = t.hidden,
    f = p === void 0 ? !1 : p;
  function m(b, S) {
    var R = '';
    if (je(b) && c) {
      var I = u(b, '::before'),
        q = sd(I);
      R = ''.concat(q, ' ').concat(R);
    }
    var P = F_(b) ? t0(b) : kt(b.childNodes).concat(ri(b, 'aria-owns'));
    if (
      (P.forEach(function (_) {
        var $ = E(_, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !1, recursion: !0 }),
          N = je(_) ? u(_).getPropertyValue('display') : 'inline',
          V = N !== 'inline' ? ' ' : '';
        R += ''.concat(V).concat($).concat(V);
      }),
      je(b) && c)
    ) {
      var A = u(b, '::after'),
        w = sd(A);
      R = ''.concat(R, ' ').concat(w);
    }
    return R.trim();
  }
  s(m, 'computeMiscTextAlternative');
  function h(b, S) {
    var R = b.getAttributeNode(S);
    return R !== null && !r.has(R) && R.value.trim() !== '' ? (r.add(R), R.value) : null;
  }
  s(h, 'useAttribute');
  function g(b) {
    return je(b) ? h(b, 'title') : null;
  }
  s(g, 'computeTooltipAttributeValue');
  function v(b) {
    if (!je(b)) return null;
    if (D_(b)) {
      r.add(b);
      for (var S = kt(b.childNodes), R = 0; R < S.length; R += 1) {
        var I = S[R];
        if (L_(I)) return E(I, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (j_(b)) {
      r.add(b);
      for (var q = kt(b.childNodes), P = 0; P < q.length; P += 1) {
        var A = q[P];
        if (_m(A)) return E(A, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (J_(b)) {
      r.add(b);
      for (var w = kt(b.childNodes), _ = 0; _ < w.length; _ += 1) {
        var $ = w[_];
        if (U_($)) return $.textContent;
      }
      return null;
    } else if (ut(b) === 'img' || ut(b) === 'area') {
      var N = h(b, 'alt');
      if (N !== null) return N;
    } else if (q_(b)) {
      var V = h(b, 'label');
      if (V !== null) return V;
    }
    if (ks(b) && (b.type === 'button' || b.type === 'submit' || b.type === 'reset')) {
      var H = h(b, 'value');
      if (H !== null) return H;
      if (b.type === 'submit') return 'Submit';
      if (b.type === 'reset') return 'Reset';
    }
    var x = e0(b);
    if (x !== null && x.length !== 0)
      return (
        r.add(b),
        kt(x)
          .map(function (K) {
            return E(K, { isEmbeddedInLabel: !0, isReferenced: !1, recursion: !0 });
          })
          .filter(function (K) {
            return K.length > 0;
          })
          .join(' ')
      );
    if (ks(b) && b.type === 'image') {
      var D = h(b, 'alt');
      if (D !== null) return D;
      var F = h(b, 'title');
      return F !== null ? F : 'Submit Query';
    }
    if (nr(b, ['button'])) {
      var k = m(b, { isEmbeddedInLabel: !1 });
      if (k !== '') return k;
    }
    return null;
  }
  s(v, 'computeElementTextAlternative');
  function E(b, S) {
    if (r.has(b)) return '';
    if (!f && H_(b, u) && !S.isReferenced) return (r.add(b), '');
    var R = je(b) ? b.getAttributeNode('aria-labelledby') : null,
      I = R !== null && !r.has(R) ? ri(b, 'aria-labelledby') : [];
    if (i === 'name' && !S.isReferenced && I.length > 0)
      return (
        r.add(R),
        I.map(function (N) {
          return E(N, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !0, recursion: !1 });
        }).join(' ')
      );
    var q = S.recursion && z_(b) && i === 'name';
    if (!q) {
      var P = ((je(b) && b.getAttribute('aria-label')) || '').trim();
      if (P !== '' && i === 'name') return (r.add(b), P);
      if (!W_(b)) {
        var A = v(b);
        if (A !== null) return (r.add(b), A);
      }
    }
    if (nr(b, ['menu'])) return (r.add(b), '');
    if (q || S.isEmbeddedInLabel || S.isReferenced) {
      if (nr(b, ['combobox', 'listbox'])) {
        r.add(b);
        var w = G_(b);
        return w.length === 0
          ? ks(b)
            ? b.value
            : ''
          : kt(w)
              .map(function (N) {
                return E(N, {
                  isEmbeddedInLabel: S.isEmbeddedInLabel,
                  isReferenced: !1,
                  recursion: !0,
                });
              })
              .join(' ');
      }
      if (Am(b, 'range'))
        return (
          r.add(b),
          b.hasAttribute('aria-valuetext')
            ? b.getAttribute('aria-valuetext')
            : b.hasAttribute('aria-valuenow')
              ? b.getAttribute('aria-valuenow')
              : b.getAttribute('value') || ''
        );
      if (nr(b, ['textbox'])) return (r.add(b), Q_(b));
    }
    if (Y_(b) || (je(b) && S.isReferenced) || K_(b) || X_()) {
      var _ = m(b, { isEmbeddedInLabel: S.isEmbeddedInLabel });
      if (_ !== '') return (r.add(b), _);
    }
    if (b.nodeType === b.TEXT_NODE) return (r.add(b), b.textContent || '');
    if (S.recursion) return (r.add(b), m(b, { isEmbeddedInLabel: S.isEmbeddedInLabel }));
    var $ = g(b);
    return $ !== null ? (r.add(b), $) : (r.add(b), '');
  }
  return (
    s(E, 'computeTextAlternative'),
    V_(E(e, { isEmbeddedInLabel: !1, isReferenced: i === 'description', recursion: !1 }))
  );
}
s(Pm, 'computeTextAlternative');
function Eo(e) {
  '@babel/helpers - typeof';
  return (
    (Eo =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    Eo(e)
  );
}
s(Eo, '_typeof');
function id(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    (t &&
      (n = n.filter(function (o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })),
      r.push.apply(r, n));
  }
  return r;
}
s(id, 'ownKeys');
function ad(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? id(Object(r), !0).forEach(function (n) {
          r0(e, n, r[n]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : id(Object(r)).forEach(function (n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
          });
  }
  return e;
}
s(ad, '_objectSpread');
function r0(e, t, r) {
  return (
    (t = n0(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(r0, '_defineProperty');
function n0(e) {
  var t = o0(e, 'string');
  return Eo(t) === 'symbol' ? t : String(t);
}
s(n0, '_toPropertyKey');
function o0(e, t) {
  if (Eo(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (Eo(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
s(o0, '_toPrimitive');
function s0(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = ri(e, 'aria-describedby')
      .map(function (i) {
        return Pm(i, ad(ad({}, t), {}, { compute: 'description' }));
      })
      .join(' ');
  if (r === '') {
    var n = e.getAttribute('aria-description');
    r = n === null ? '' : n;
  }
  if (r === '') {
    var o = e.getAttribute('title');
    r = o === null ? '' : o;
  }
  return r;
}
s(s0, 'computeAccessibleDescription');
function i0(e) {
  return nr(e, [
    'caption',
    'code',
    'deletion',
    'emphasis',
    'generic',
    'insertion',
    'none',
    'paragraph',
    'presentation',
    'strong',
    'subscript',
    'superscript',
  ]);
}
s(i0, 'prohibitsNaming');
function a0(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return i0(e) ? '' : Pm(e, t);
}
s(a0, 'computeAccessibleName');
var Om = Ge(Cp(), 1),
  SB = Ge(Sv(), 1),
  _B = Ge(_v(), 1),
  l0 = class extends Error {
    constructor(t, r, n, o) {
      (super(), Error.captureStackTrace && Error.captureStackTrace(this, n));
      let i = '';
      try {
        i = o.utils.printWithType('Received', r, o.utils.printReceived);
      } catch {}
      this.message = [
        o.utils.matcherHint(`${o.isNot ? '.not' : ''}.${n.name}`, 'received', ''),
        '',
        `${o.utils.RECEIVED_COLOR('received')} value must ${t}.`,
        i,
      ].join(`
`);
    }
  };
s(l0, 'GenericTypeError');
var c0 = l0,
  u0 = class extends c0 {
    constructor(...t) {
      super('be an HTMLElement or an SVGElement', ...t);
    }
  };
s(u0, 'HtmlElementTypeError');
var Qg = u0,
  d0 = class extends c0 {
    constructor(...t) {
      super('be a Node', ...t);
    }
  };
s(d0, 'NodeTypeError');
var Zg = d0;
function Cm(e, t, ...r) {
  if (!e || !e.ownerDocument || !e.ownerDocument.defaultView) throw new t(e, ...r);
}
s(Cm, 'checkHasWindow');
function p0(e, ...t) {
  Cm(e, Zg, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.Node)) throw new Zg(e, ...t);
}
s(p0, 'checkNode');
function we(e, ...t) {
  Cm(e, Qg, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.HTMLElement) && !(e instanceof r.SVGElement)) throw new Qg(e, ...t);
}
s(we, 'checkHtmlElement');
var f0 = class extends Error {
  constructor(t, r, n) {
    (super(),
      Error.captureStackTrace && Error.captureStackTrace(this, r),
      (this.message = [
        t.message,
        '',
        n.utils.RECEIVED_COLOR('Failing css:'),
        n.utils.RECEIVED_COLOR(`${t.css}`),
      ].join(`
`)));
  }
};
s(f0, 'InvalidCSSError');
var AB = f0;
function m0(e, ...t) {
  const r = hB(`selector { ${e} }`, { silent: !0 }).stylesheet;
  if (r.parsingErrors && r.parsingErrors.length > 0) {
    const { reason: o, line: i } = r.parsingErrors[0];
    throw new AB(
      { css: e, message: `Syntax error parsing expected css: ${o} on line: ${i}` },
      ...t,
    );
  }
  return r.rules[0].declarations
    .filter((o) => o.type === 'declaration')
    .reduce((o, { property: i, value: a }) => Object.assign(o, { [i]: a }), {});
}
s(m0, 'parseCSS');
function ld(e, t) {
  return typeof t == 'string' ? t : e.utils.stringify(t);
}
s(ld, 'display');
function ze(e, t, r, n, o, i) {
  return [
    `${t}
`,
    `${r}:
${e.utils.EXPECTED_COLOR((0, Yg.default)(ld(e, n), 2))}`,
    `${o}:
${e.utils.RECEIVED_COLOR((0, Yg.default)(ld(e, i), 2))}`,
  ].join(`
`);
}
s(ze, 'getMessage');
function y0(e, t) {
  return t instanceof RegExp ? t.test(e) : e.includes(String(t));
}
s(y0, 'matches');
function Ni(e, t) {
  console.warn(`Warning: ${e} has been deprecated and will be removed in future updates.`, t);
}
s(Ni, 'deprecate');
function qi(e) {
  return e.replace(/\s+/g, ' ').trim();
}
s(qi, 'normalize');
function Or(e) {
  return e.tagName && e.tagName.toLowerCase();
}
s(Or, 'getTag');
function h0({ multiple: e, options: t }) {
  const r = [...t].filter((n) => n.selected);
  if (e) return [...r].map((n) => n.value);
  if (r.length !== 0) return r[0].value;
}
s(h0, 'getSelectValue');
function g0(e) {
  switch (e.type) {
    case 'number':
      return e.value === '' ? null : Number(e.value);
    case 'checkbox':
      return e.checked;
    default:
      return e.value;
  }
}
s(g0, 'getInputValue');
var RB = ['meter', 'progressbar', 'slider', 'spinbutton'];
function b0(e) {
  if (RB.includes(e.getAttribute('role'))) return Number(e.getAttribute('aria-valuenow'));
}
s(b0, 'getAccessibleValue');
function Im(e) {
  if (e)
    switch (e.tagName.toLowerCase()) {
      case 'input':
        return g0(e);
      case 'select':
        return h0(e);
      default:
        return e.value ?? b0(e);
    }
}
s(Im, 'getSingleElementValue');
function v0(e, { wordConnector: t = ', ', lastWordConnector: r = ' and ' } = {}) {
  return [e.slice(0, -1).join(t), e[e.length - 1]].join(e.length > 1 ? r : '');
}
s(v0, 'toSentence');
function yc(e, t) {
  return Array.isArray(e) && Array.isArray(t)
    ? [...new Set(e)].every((r) => new Set(t).has(r))
    : e === t;
}
s(yc, 'compareAsSet');
function ja(e, t) {
  return (
    Ni(
      'toBeInTheDOM',
      'Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container.',
    ),
    e && we(e, ja, this),
    t && we(t, ja, this),
    {
      pass: t ? t.contains(e) : !!e,
      message: s(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInTheDOM`, 'element', ''),
            '',
            'Received:',
            `  ${this.utils.printReceived(e && e.cloneNode(!1))}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(ja, 'toBeInTheDOM');
function Nm(e) {
  (e !== null || !this.isNot) && we(e, Nm, this);
  const t = e === null ? !1 : e.ownerDocument === e.getRootNode({ composed: !0 }),
    r = s(
      () =>
        `expected document not to contain element, found ${this.utils.stringify(e.cloneNode(!0))} instead`,
      'errorFound',
    ),
    n = s(() => 'element could not be found in the document', 'errorNotFound');
  return {
    pass: t,
    message: s(
      () =>
        [
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInTheDocument`, 'element', ''),
          '',
          this.utils.RECEIVED_COLOR(this.isNot ? r() : n()),
        ].join(`
`),
      'message',
    ),
  };
}
s(Nm, 'toBeInTheDocument');
function qm(e) {
  return (
    Ni('toBeEmpty', 'Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM.'),
    we(e, qm, this),
    {
      pass: e.innerHTML === '',
      message: s(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeEmpty`, 'element', ''),
            '',
            'Received:',
            `  ${this.utils.printReceived(e.innerHTML)}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(qm, 'toBeEmpty');
function Mm(e) {
  return (
    we(e, Mm, this),
    {
      pass: T0(e),
      message: s(
        () =>
          [
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toBeEmptyDOMElement`,
              'element',
              '',
            ),
            '',
            'Received:',
            `  ${this.utils.printReceived(e.innerHTML)}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(Mm, 'toBeEmptyDOMElement');
function T0(e) {
  return [...e.childNodes].filter((r) => r.nodeType !== 8).length === 0;
}
s(T0, 'isEmptyElement');
function $a(e, t) {
  return (
    we(e, $a, this),
    t !== null && we(t, $a, this),
    {
      pass: e.contains(t),
      message: s(
        () =>
          [
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toContainElement`,
              'element',
              'element',
            ),
            '',
            this.utils
              .RECEIVED_COLOR(`${this.utils.stringify(e.cloneNode(!1))} ${this.isNot ? 'contains:' : 'does not contain:'} ${this.utils.stringify(t && t.cloneNode(!1))}
        `),
          ].join(`
`),
        'message',
      ),
    }
  );
}
s($a, 'toContainElement');
function E0(e, t) {
  const r = e.ownerDocument.createElement('div');
  return ((r.innerHTML = t), r.innerHTML);
}
s(E0, 'getNormalizedHtml');
function jm(e, t) {
  if ((we(e, jm, this), typeof t != 'string'))
    throw new Error(`.toContainHTML() expects a string value, got ${t}`);
  return {
    pass: e.outerHTML.includes(E0(e, t)),
    message: s(
      () =>
        [
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toContainHTML`, 'element', ''),
          'Expected:',
          `  ${this.utils.EXPECTED_COLOR(t)}`,
          'Received:',
          `  ${this.utils.printReceived(e.cloneNode(!0))}`,
        ].join(`
`),
      'message',
    ),
  };
}
s(jm, 'toContainHTML');
function $m(e, t, r = { normalizeWhitespace: !0 }) {
  p0(e, $m, this);
  const n = r.normalizeWhitespace ? qi(e.textContent) : e.textContent.replace(/\u00a0/g, ' '),
    o = n !== '' && t === '';
  return {
    pass: !o && y0(n, t),
    message: s(() => {
      const i = this.isNot ? 'not to' : 'to';
      return ze(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveTextContent`, 'element', ''),
        o
          ? 'Checking with empty string will always match, use .toBeEmptyDOMElement() instead'
          : `Expected element ${i} have text content`,
        t,
        'Received',
        n,
      );
    }, 'message'),
  };
}
s($m, 'toHaveTextContent');
function ka(e, t) {
  we(e, ka, this);
  const r = s0(e),
    n = arguments.length === 1;
  let o = !1;
  return (
    n ? (o = r !== '') : (o = t instanceof RegExp ? t.test(r) : this.equals(r, t)),
    {
      pass: o,
      message: s(() => {
        const i = this.isNot ? 'not to' : 'to';
        return ze(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${ka.name}`, 'element', ''),
          `Expected element ${i} have accessible description`,
          t,
          'Received',
          r,
        );
      }, 'message'),
    }
  );
}
s(ka, 'toHaveAccessibleDescription');
var Es = 'aria-invalid',
  xB = ['false'];
function km(e, t) {
  we(e, km, this);
  const r = this.isNot ? 'not to' : 'to',
    n = this.isNot ? '.not.toHaveAccessibleErrorMessage' : '.toHaveAccessibleErrorMessage',
    o = e.getAttribute('aria-errormessage');
  if (!!o && /\s+/.test(o))
    return {
      pass: !1,
      message: s(
        () =>
          ze(
            this,
            this.utils.matcherHint(n, 'element'),
            "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
            '',
            'Received',
            `aria-errormessage="${o}"`,
          ),
        'message',
      ),
    };
  const a = e.getAttribute(Es);
  if (!e.hasAttribute(Es) || xB.includes(a))
    return {
      pass: !1,
      message: s(
        () =>
          ze(
            this,
            this.utils.matcherHint(n, 'element'),
            'Expected element to be marked as invalid with attribute',
            `${Es}="${String(!0)}"`,
            'Received',
            e.hasAttribute('aria-invalid') ? `${Es}="${e.getAttribute(Es)}` : null,
          ),
        'message',
      ),
    };
  const d = qi(e.ownerDocument.getElementById(o)?.textContent ?? '');
  return {
    pass: t === void 0 ? !!d : t instanceof RegExp ? t.test(d) : this.equals(d, t),
    message: s(
      () =>
        ze(
          this,
          this.utils.matcherHint(n, 'element'),
          `Expected element ${r} have accessible error message`,
          t ?? '',
          'Received',
          d,
        ),
      'message',
    ),
  };
}
s(km, 'toHaveAccessibleErrorMessage');
var PB = _0(Om.elementRoles);
function Da(e, t) {
  we(e, Da, this);
  const r = w0(e);
  return {
    pass: r.some((o) => o === t),
    message: s(() => {
      const o = this.isNot ? 'not to' : 'to';
      return ze(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${Da.name}`, 'element', ''),
        `Expected element ${o} have role`,
        t,
        'Received',
        r.join(', '),
      );
    }, 'message'),
  };
}
s(Da, 'toHaveRole');
function w0(e) {
  return e.hasAttribute('role') ? e.getAttribute('role').split(' ').filter(Boolean) : S0(e);
}
s(w0, 'getExplicitOrImplicitRoles');
function S0(e) {
  for (const { match: t, roles: r } of PB) if (t(e)) return [...r];
  return [];
}
s(S0, 'getImplicitAriaRoles');
function _0(e) {
  function t({ name: a, attributes: c }) {
    return `${a}${c.map(({ name: d, value: u, constraints: p = [] }) => (p.indexOf('undefined') !== -1 ? `:not([${d}])` : u ? `[${d}="${u}"]` : `[${d}]`)).join('')}`;
  }
  s(t, 'makeElementSelector');
  function r({ attributes: a = [] }) {
    return a.length;
  }
  s(r, 'getSelectorSpecificity');
  function n({ specificity: a }, { specificity: c }) {
    return c - a;
  }
  s(n, 'bySelectorSpecificity');
  function o(a) {
    let { attributes: c = [] } = a;
    const d = c.findIndex((p) => p.value && p.name === 'type' && p.value === 'text');
    d >= 0 && (c = [...c.slice(0, d), ...c.slice(d + 1)]);
    const u = t({ ...a, attributes: c });
    return (p) => (d >= 0 && p.type !== 'text' ? !1 : p.matches(u));
  }
  s(o, 'match');
  let i = [];
  for (const [a, c] of e.entries())
    i = [...i, { match: o(a), roles: Array.from(c), specificity: r(a) }];
  return i.sort(n);
}
s(_0, 'buildElementRoleList');
function La(e, t) {
  we(e, La, this);
  const r = a0(e),
    n = arguments.length === 1;
  let o = !1;
  return (
    n ? (o = r !== '') : (o = t instanceof RegExp ? t.test(r) : this.equals(r, t)),
    {
      pass: o,
      message: s(() => {
        const i = this.isNot ? 'not to' : 'to';
        return ze(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${La.name}`, 'element', ''),
          `Expected element ${i} have accessible name`,
          t,
          'Received',
          r,
        );
      }, 'message'),
    }
  );
}
s(La, 'toHaveAccessibleName');
function cd(e, t, r) {
  return r === void 0 ? t : `${t}=${e(r)}`;
}
s(cd, 'printAttribute');
function A0(e, t, r) {
  return r === void 0
    ? `element.hasAttribute(${e(t)})`
    : `element.getAttribute(${e(t)}) === ${e(r)}`;
}
s(A0, 'getAttributeComment');
function Dm(e, t, r) {
  we(e, Dm, this);
  const n = r !== void 0,
    o = e.hasAttribute(t),
    i = e.getAttribute(t);
  return {
    pass: n ? o && this.equals(i, r) : o,
    message: s(() => {
      const a = this.isNot ? 'not to' : 'to',
        c = o ? cd(this.utils.stringify, t, i) : null,
        d = this.utils.matcherHint(
          `${this.isNot ? '.not' : ''}.toHaveAttribute`,
          'element',
          this.utils.printExpected(t),
          {
            secondArgument: n ? this.utils.printExpected(r) : void 0,
            comment: A0(this.utils.stringify, t, r),
          },
        );
      return ze(
        this,
        d,
        `Expected the element ${a} have attribute`,
        cd(this.utils.stringify, t, r),
        'Received',
        c,
      );
    }, 'message'),
  };
}
s(Dm, 'toHaveAttribute');
function R0(e) {
  const t = e.pop();
  let r, n;
  return (
    typeof t == 'object' && !(t instanceof RegExp)
      ? ((r = e), (n = t))
      : ((r = e.concat(t)), (n = { exact: !1 })),
    { expectedClassNames: r, options: n }
  );
}
s(R0, 'getExpectedClassNamesAndOptions');
function ud(e) {
  return e ? e.split(/\s+/).filter((t) => t.length > 0) : [];
}
s(ud, 'splitClassNames');
function dd(e, t) {
  return e.every((r) => (typeof r == 'string' ? t.includes(r) : t.some((n) => r.test(n))));
}
s(dd, 'isSubset$1');
function Lm(e, ...t) {
  we(e, Lm, this);
  const { expectedClassNames: r, options: n } = R0(t),
    o = ud(e.getAttribute('class')),
    i = r.reduce((c, d) => c.concat(typeof d == 'string' || !d ? ud(d) : d), []),
    a = i.some((c) => c instanceof RegExp);
  if (n.exact && a) throw new Error('Exact option does not support RegExp expected class names');
  return n.exact
    ? {
        pass: dd(i, o) && i.length === o.length,
        message: s(() => {
          const c = this.isNot ? 'not to' : 'to';
          return ze(
            this,
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toHaveClass`,
              'element',
              this.utils.printExpected(i.join(' ')),
            ),
            `Expected the element ${c} have EXACTLY defined classes`,
            i.join(' '),
            'Received',
            o.join(' '),
          );
        }, 'message'),
      }
    : i.length > 0
      ? {
          pass: dd(i, o),
          message: s(() => {
            const c = this.isNot ? 'not to' : 'to';
            return ze(
              this,
              this.utils.matcherHint(
                `${this.isNot ? '.not' : ''}.toHaveClass`,
                'element',
                this.utils.printExpected(i.join(' ')),
              ),
              `Expected the element ${c} have class`,
              i.join(' '),
              'Received',
              o.join(' '),
            );
          }, 'message'),
        }
      : {
          pass: this.isNot ? o.length > 0 : !1,
          message: s(
            () =>
              this.isNot
                ? ze(
                    this,
                    this.utils.matcherHint('.not.toHaveClass', 'element', ''),
                    'Expected the element to have classes',
                    '(none)',
                    'Received',
                    o.join(' '),
                  )
                : [
                    this.utils.matcherHint('.toHaveClass', 'element'),
                    'At least one expected class must be provided.',
                  ].join(`
`),
            'message',
          ),
        };
}
s(Lm, 'toHaveClass');
function x0(e, t) {
  const r = {},
    n = e.createElement('div');
  return (
    Object.keys(t).forEach((o) => {
      ((n.style[o] = t[o]), (r[o] = n.style[o]));
    }),
    r
  );
}
s(x0, 'getStyleDeclaration');
function P0(e, t) {
  return (
    !!Object.keys(e).length &&
    Object.entries(e).every(([r, n]) => {
      const o = r.startsWith('--'),
        i = [r];
      return (
        o || i.push(r.toLowerCase()),
        i.some((a) => t[a] === n || t.getPropertyValue(a) === n)
      );
    })
  );
}
s(P0, 'isSubset');
function pd(e) {
  return Object.keys(e)
    .sort()
    .map((t) => `${t}: ${e[t]};`).join(`
`);
}
s(pd, 'printoutStyles');
function O0(e, t, r) {
  const n = Array.from(r)
    .filter((i) => t[i] !== void 0)
    .reduce((i, a) => Object.assign(i, { [a]: r.getPropertyValue(a) }), {});
  return e(pd(t), pd(n)).replace(
    `${SB.default.red('+ Received')}
`,
    '',
  );
}
s(O0, 'expectedDiff');
function Fa(e, t) {
  we(e, Fa, this);
  const r = typeof t == 'object' ? t : m0(t, Fa, this),
    { getComputedStyle: n } = e.ownerDocument.defaultView,
    o = x0(e.ownerDocument, r),
    i = n(e);
  return {
    pass: P0(o, i),
    message: s(() => {
      const a = `${this.isNot ? '.not' : ''}.toHaveStyle`;
      return [this.utils.matcherHint(a, 'element', ''), O0(this.utils.diff, o, i)].join(`

`);
    }, 'message'),
  };
}
s(Fa, 'toHaveStyle');
function Fm(e) {
  return (
    we(e, Fm, this),
    {
      pass: e.ownerDocument.activeElement === e,
      message: s(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveFocus`, 'element', ''),
            '',
            ...(this.isNot
              ? ['Received element is focused:', `  ${this.utils.printReceived(e)}`]
              : [
                  'Expected element with focus:',
                  `  ${this.utils.printExpected(e)}`,
                  'Received element with focus:',
                  `  ${this.utils.printReceived(e.ownerDocument.activeElement)}`,
                ]),
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(Fm, 'toHaveFocus');
function C0(e) {
  const t = [...new Set(e.map((r) => r.type))];
  if (t.length !== 1)
    throw new Error('Multiple form elements with the same name must be of the same type');
  switch (t[0]) {
    case 'radio': {
      const r = e.find((n) => n.checked);
      return r ? r.value : void 0;
    }
    case 'checkbox':
      return e.filter((r) => r.checked).map((r) => r.value);
    default:
      return e.map((r) => r.value);
  }
}
s(C0, 'getMultiElementValue');
function I0(e, t) {
  const r = [...e.querySelectorAll(`[name="${(0, _B.default)(t)}"]`)];
  if (r.length !== 0)
    switch (r.length) {
      case 1:
        return Im(r[0]);
      default:
        return C0(r);
    }
}
s(I0, 'getFormValue');
function N0(e) {
  return /\[\]$/.test(e) ? e.slice(0, -2) : e;
}
s(N0, 'getPureName');
function q0(e) {
  return Array.from(e.elements)
    .map((r) => r.name)
    .reduce((r, n) => ({ ...r, [N0(n)]: I0(e, n) }), {});
}
s(q0, 'getAllFormValues');
function Bm(e, t) {
  if ((we(e, Bm, this), !e.elements))
    throw new Error('toHaveFormValues must be called on a form or a fieldset');
  const r = q0(e);
  return {
    pass: Object.entries(t).every(([n, o]) => yc(r[n], o)),
    message: s(() => {
      const n = this.isNot ? 'not to' : 'to',
        o = `${this.isNot ? '.not' : ''}.toHaveFormValues`,
        i = Object.keys(r)
          .filter((a) => t.hasOwnProperty(a))
          .reduce((a, c) => ({ ...a, [c]: r[c] }), {});
      return [
        this.utils.matcherHint(o, 'element', ''),
        `Expected the element ${n} have form values`,
        this.utils.diff(t, i),
      ].join(`

`);
    }, 'message'),
  };
}
s(Bm, 'toHaveFormValues');
function M0(e) {
  const { getComputedStyle: t } = e.ownerDocument.defaultView,
    { display: r, visibility: n, opacity: o } = t(e);
  return r !== 'none' && n !== 'hidden' && n !== 'collapse' && o !== '0' && o !== 0;
}
s(M0, 'isStyleVisible');
function j0(e, t) {
  let r;
  return (
    t
      ? (r = e.nodeName === 'DETAILS' && t.nodeName !== 'SUMMARY' ? e.hasAttribute('open') : !0)
      : (r = e.nodeName === 'DETAILS' ? e.hasAttribute('open') : !0),
    !e.hasAttribute('hidden') && r
  );
}
s(j0, 'isAttributeVisible');
function Jm(e, t) {
  return M0(e) && j0(e, t) && (!e.parentElement || Jm(e.parentElement, e));
}
s(Jm, 'isElementVisible');
function Um(e) {
  we(e, Um, this);
  const t = e.ownerDocument === e.getRootNode({ composed: !0 }),
    r = t && Jm(e);
  return {
    pass: r,
    message: s(() => {
      const n = r ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeVisible`, 'element', ''),
        '',
        `Received element ${n} visible${t ? '' : ' (element is not in the document)'}:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(Um, 'toBeVisible');
var OB = ['fieldset', 'input', 'select', 'optgroup', 'option', 'button', 'textarea'];
function $0(e, t) {
  return (
    Or(e) === 'legend' &&
    Or(t) === 'fieldset' &&
    e.isSameNode(Array.from(t.children).find((r) => Or(r) === 'legend'))
  );
}
s($0, 'isFirstLegendChildOfFieldset');
function k0(e, t) {
  return Hm(t) && !$0(e, t);
}
s(k0, 'isElementDisabledByParent');
function D0(e) {
  return e.includes('-');
}
s(D0, 'isCustomElement');
function Vm(e) {
  const t = Or(e);
  return OB.includes(t) || D0(t);
}
s(Vm, 'canElementBeDisabled');
function Hm(e) {
  return Vm(e) && e.hasAttribute('disabled');
}
s(Hm, 'isElementDisabled');
function zm(e) {
  const t = e.parentElement;
  return !!t && (k0(e, t) || zm(t));
}
s(zm, 'isAncestorDisabled');
function Gm(e) {
  return Vm(e) && (Hm(e) || zm(e));
}
s(Gm, 'isElementOrAncestorDisabled');
function Wm(e) {
  we(e, Wm, this);
  const t = Gm(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeDisabled`, 'element', ''),
        '',
        `Received element ${r} disabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(Wm, 'toBeDisabled');
function Km(e) {
  we(e, Km, this);
  const t = !Gm(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeEnabled`, 'element', ''),
        '',
        `Received element ${r} enabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(Km, 'toBeEnabled');
var CB = ['select', 'textarea'],
  IB = ['input', 'select', 'textarea'],
  NB = ['color', 'hidden', 'range', 'submit', 'image', 'reset'],
  qB = [
    'checkbox',
    'combobox',
    'gridcell',
    'listbox',
    'radiogroup',
    'spinbutton',
    'textbox',
    'tree',
  ];
function L0(e) {
  return CB.includes(Or(e)) && e.hasAttribute('required');
}
s(L0, 'isRequiredOnFormTagsExceptInput');
function F0(e) {
  return (
    Or(e) === 'input' &&
    e.hasAttribute('required') &&
    ((e.hasAttribute('type') && !NB.includes(e.getAttribute('type'))) || !e.hasAttribute('type'))
  );
}
s(F0, 'isRequiredOnSupportedInput');
function B0(e) {
  return (
    e.hasAttribute('aria-required') &&
    e.getAttribute('aria-required') === 'true' &&
    (IB.includes(Or(e)) || (e.hasAttribute('role') && qB.includes(e.getAttribute('role'))))
  );
}
s(B0, 'isElementRequiredByARIA');
function Ym(e) {
  we(e, Ym, this);
  const t = L0(e) || F0(e) || B0(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeRequired`, 'element', ''),
        '',
        `Received element ${r} required:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(Ym, 'toBeRequired');
var MB = ['form', 'input', 'select', 'textarea'];
function J0(e) {
  return e.hasAttribute('aria-invalid') && e.getAttribute('aria-invalid') !== 'false';
}
s(J0, 'isElementHavingAriaInvalid');
function U0(e) {
  return MB.includes(Or(e));
}
s(U0, 'isSupportsValidityMethod');
function Xm(e) {
  const t = J0(e);
  return U0(e) ? t || !e.checkValidity() : t;
}
s(Xm, 'isElementInvalid');
function Qm(e) {
  we(e, Qm, this);
  const t = Xm(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInvalid`, 'element', ''),
        '',
        `Received element ${r} currently invalid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(Qm, 'toBeInvalid');
function Zm(e) {
  we(e, Zm, this);
  const t = !Xm(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeValid`, 'element', ''),
        '',
        `Received element ${r} currently valid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(Zm, 'toBeValid');
function ey(e, t) {
  if (
    (we(e, ey, this), e.tagName.toLowerCase() === 'input' && ['checkbox', 'radio'].includes(e.type))
  )
    throw new Error(
      'input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead',
    );
  const r = Im(e),
    n = t !== void 0;
  let o = t,
    i = r;
  return (
    t == r && t !== r && ((o = `${t} (${typeof t})`), (i = `${r} (${typeof r})`)),
    {
      pass: n ? yc(r, t) : !!r,
      message: s(() => {
        const a = this.isNot ? 'not to' : 'to',
          c = this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveValue`, 'element', t);
        return ze(this, c, `Expected the element ${a} have value`, n ? o : '(any)', 'Received', i);
      }, 'message'),
    }
  );
}
s(ey, 'toHaveValue');
function ty(e, t) {
  we(e, ty, this);
  const r = e.tagName.toLowerCase();
  if (!['select', 'input', 'textarea'].includes(r))
    throw new Error(
      '.toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead.',
    );
  if (r === 'input' && ['radio', 'checkbox'].includes(e.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${e.type}"], try with another matcher instead.`,
    );
  const n = V0(r, e),
    o = H0(t),
    i = o.filter((d) =>
      n.some((u) => (d instanceof RegExp ? d.test(u) : this.equals(u, String(d)))),
    ).length,
    a = i === n.length,
    c = i === o.length;
  return {
    pass: a && c,
    message: s(
      () =>
        ze(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveDisplayValue`, 'element', ''),
          `Expected element ${this.isNot ? 'not ' : ''}to have display value`,
          t,
          'Received',
          n,
        ),
      'message',
    ),
  };
}
s(ty, 'toHaveDisplayValue');
function V0(e, t) {
  return e === 'select'
    ? Array.from(t)
        .filter((r) => r.selected)
        .map((r) => r.textContent)
    : [t.value];
}
s(V0, 'getValues');
function H0(e) {
  return e instanceof Array ? e : [e];
}
s(H0, 'getExpectedValues');
function ry(e) {
  we(e, ry, this);
  const t = s(
      () => e.tagName.toLowerCase() === 'input' && ['checkbox', 'radio'].includes(e.type),
      'isValidInput',
    ),
    r = s(
      () =>
        ny(e.getAttribute('role')) && ['true', 'false'].includes(e.getAttribute('aria-checked')),
      'isValidAriaElement',
    );
  if (!t() && !r())
    return {
      pass: !1,
      message: s(
        () =>
          `only inputs with type="checkbox" or type="radio" or elements with ${z0()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`,
        'message',
      ),
    };
  const n = s(() => (t() ? e.checked : e.getAttribute('aria-checked') === 'true'), 'isChecked');
  return {
    pass: n(),
    message: s(() => {
      const o = n() ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeChecked`, 'element', ''),
        '',
        `Received element ${o} checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(ry, 'toBeChecked');
function z0() {
  return v0(
    G0().map((e) => `role="${e}"`),
    { lastWordConnector: ' or ' },
  );
}
s(z0, 'supportedRolesSentence');
function G0() {
  return Om.roles.keys().filter(ny);
}
s(G0, 'supportedRoles');
function ny(e) {
  return Om.roles.get(e)?.props['aria-checked'] !== void 0;
}
s(ny, 'roleSupportsChecked');
function oy(e) {
  we(e, oy, this);
  const t = s(() => e.tagName.toLowerCase() === 'input' && e.type === 'checkbox', 'isValidInput'),
    r = s(() => e.getAttribute('role') === 'checkbox', 'isValidAriaElement');
  if (!t() && !r())
    return {
      pass: !1,
      message: s(
        () =>
          'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead',
        'message',
      ),
    };
  const n = s(() => {
    const o = e.getAttribute('aria-checked') === 'mixed';
    return (t() && e.indeterminate) || o;
  }, 'isPartiallyChecked');
  return {
    pass: n(),
    message: s(() => {
      const o = n() ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBePartiallyChecked`, 'element', ''),
        '',
        `Received element ${o} partially checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(oy, 'toBePartiallyChecked');
function sy(e, t) {
  (Ni('toHaveDescription', 'Please use toHaveAccessibleDescription.'), we(e, sy, this));
  const r = t !== void 0,
    o = (e.getAttribute('aria-describedby') || '').split(/\s+/).filter(Boolean);
  let i = '';
  if (o.length > 0) {
    const a = e.ownerDocument,
      c = o.map((d) => a.getElementById(d)).filter(Boolean);
    i = qi(c.map((d) => d.textContent).join(' '));
  }
  return {
    pass: r ? (t instanceof RegExp ? t.test(i) : this.equals(i, t)) : !!i,
    message: s(() => {
      const a = this.isNot ? 'not to' : 'to';
      return ze(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveDescription`, 'element', ''),
        `Expected the element ${a} have description`,
        this.utils.printExpected(t),
        'Received',
        this.utils.printReceived(i),
      );
    }, 'message'),
  };
}
s(sy, 'toHaveDescription');
function iy(e, t) {
  if (
    (Ni('toHaveErrorMessage', 'Please use toHaveAccessibleErrorMessage.'),
    we(e, iy, this),
    !e.hasAttribute('aria-invalid') || e.getAttribute('aria-invalid') === 'false')
  ) {
    const a = this.isNot ? '.not' : '';
    return {
      pass: !1,
      message: s(
        () =>
          ze(
            this,
            this.utils.matcherHint(`${a}.toHaveErrorMessage`, 'element', ''),
            'Expected the element to have invalid state indicated by',
            'aria-invalid="true"',
            'Received',
            e.hasAttribute('aria-invalid')
              ? `aria-invalid="${e.getAttribute('aria-invalid')}"`
              : this.utils.printReceived(''),
          ),
        'message',
      ),
    };
  }
  const r = t !== void 0,
    o = (e.getAttribute('aria-errormessage') || '').split(/\s+/).filter(Boolean);
  let i = '';
  if (o.length > 0) {
    const a = e.ownerDocument,
      c = o.map((d) => a.getElementById(d)).filter(Boolean);
    i = qi(c.map((d) => d.textContent).join(' '));
  }
  return {
    pass: r ? (t instanceof RegExp ? t.test(i) : this.equals(i, t)) : !!i,
    message: s(() => {
      const a = this.isNot ? 'not to' : 'to';
      return ze(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveErrorMessage`, 'element', ''),
        `Expected the element ${a} have error message`,
        this.utils.printExpected(t),
        'Received',
        this.utils.printReceived(i),
      );
    }, 'message'),
  };
}
s(iy, 'toHaveErrorMessage');
function W0(e) {
  const t = e.ownerDocument.getSelection();
  if (['input', 'textarea'].includes(e.tagName.toLowerCase()))
    return ['radio', 'checkbox'].includes(e.type)
      ? ''
      : e.value.toString().substring(e.selectionStart, e.selectionEnd);
  if (t.anchorNode === null || t.focusNode === null) return '';
  const r = t.getRangeAt(0),
    n = e.ownerDocument.createRange();
  if (t.containsNode(e, !1)) (n.selectNodeContents(e), t.removeAllRanges(), t.addRange(n));
  else if (!(e.contains(t.anchorNode) && e.contains(t.focusNode))) {
    const i = e === r.startContainer || e.contains(r.startContainer),
      a = e === r.endContainer || e.contains(r.endContainer);
    (t.removeAllRanges(),
      (i || a) &&
        (n.selectNodeContents(e),
        i && n.setStart(r.startContainer, r.startOffset),
        a && n.setEnd(r.endContainer, r.endOffset),
        t.addRange(n)));
  }
  const o = t.toString();
  return (t.removeAllRanges(), t.addRange(r), o);
}
s(W0, 'getSelection');
function ay(e, t) {
  we(e, ay, this);
  const r = t !== void 0;
  if (r && typeof t != 'string')
    throw new Error('expected selection must be a string or undefined');
  const n = W0(e);
  return {
    pass: r ? yc(n, t) : !!n,
    message: s(() => {
      const o = this.isNot ? 'not to' : 'to',
        i = this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveSelection`, 'element', t);
      return ze(
        this,
        i,
        `Expected the element ${o} have selection`,
        r ? t : '(any)',
        'Received',
        n,
      );
    }, 'message'),
  };
}
s(ay, 'toHaveSelection');
function ly(e) {
  we(e, ly, this);
  const t = (e.getAttribute('role') || '').split(' ').map((a) => a.trim()),
    r =
      e.tagName.toLowerCase() === 'button' ||
      (e.tagName.toLowerCase() === 'input' && e.type === 'button') ||
      t.includes('button'),
    n = e.getAttribute('aria-pressed');
  return !r || !(n === 'true' || n === 'false')
    ? {
        pass: !1,
        message: s(
          () =>
            'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()',
          'message',
        ),
      }
    : {
        pass: r && n === 'true',
        message: s(() => {
          const a = this.utils.matcherHint(
            `${this.isNot ? '.not' : ''}.toBePressed`,
            'element',
            '',
          );
          return ze(
            this,
            a,
            'Expected element to have',
            `aria-pressed="${this.isNot ? 'false' : 'true'}"`,
            'Received',
            `aria-pressed="${n}"`,
          );
        }, 'message'),
      };
}
s(ly, 'toBePressed');
function cy(e) {
  we(e, cy, this);
  const t = (e.getAttribute('role') || '').split(' ').map((a) => a.trim()),
    r =
      e.tagName.toLowerCase() === 'button' ||
      (e.tagName.toLowerCase() === 'input' && e.type === 'button') ||
      t.includes('button'),
    n = e.getAttribute('aria-pressed');
  return !r || !(n === 'true' || n === 'false' || n === 'mixed')
    ? {
        pass: !1,
        message: s(
          () =>
            'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()',
          'message',
        ),
      }
    : {
        pass: r && n === 'mixed',
        message: s(() => {
          const a = this.isNot ? 'not to' : 'to',
            c = this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toBePartiallyPressed`,
              'element',
              '',
            );
          return ze(
            this,
            c,
            `Expected element ${a} have`,
            'aria-pressed="mixed"',
            'Received',
            `aria-pressed="${n}"`,
          );
        }, 'message'),
      };
}
s(cy, 'toBePartiallyPressed');
var jB = 1,
  K0 = 2,
  Y0 = 4,
  $B = 8,
  kB = 16,
  DB = 32,
  eb = {
    [jB]: 'Node.DOCUMENT_POSITION_DISCONNECTED',
    [K0]: 'Node.DOCUMENT_POSITION_PRECEDING',
    [Y0]: 'Node.DOCUMENT_POSITION_FOLLOWING',
    [$B]: 'Node.DOCUMENT_POSITION_CONTAINS',
    [kB]: 'Node.DOCUMENT_POSITION_CONTAINED_BY',
    [DB]: 'Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
  };
function X0(e) {
  return e in eb ? `${eb[e]} (${e})` : `Unknown document position (${e})`;
}
s(X0, 'makeDocumentPositionErrorString');
function uy(e, t) {
  return function (r, n) {
    (we(r, Ba, this), we(n, Ba, this));
    const o = r.compareDocumentPosition(n);
    return {
      pass: o === t,
      message: s(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${e}`, 'element', 'secondElement'),
            '',
            `Received: ${X0(o)}`,
          ].join(`
`),
        'message',
      ),
    };
  };
}
s(uy, 'checkToAppear');
function Ba(e, t) {
  return uy('toAppearBefore', Y0).apply(this, [e, t]);
}
s(Ba, 'toAppearBefore');
function Q0(e, t) {
  return uy('toAppearAfter', K0).apply(this, [e, t]);
}
s(Q0, 'toAppearAfter');
Ge(wv(), 1);
Ge(Cp(), 1);
Ge(Sv(), 1);
Ge(_v(), 1);
var uu, tb;
function Z0() {
  if (tb) return uu;
  tb = 1;
  var e, t, r, n, o, i, a, c, d, u, p, f, m, h, g, v, E, b, S;
  return (
    (m =
      /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy),
    (f =
      /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y),
    (e =
      /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy),
    (g = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y),
    (p =
      /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y),
    (v = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y),
    (S = /[\t\v\f\ufeff\p{Zs}]+/uy),
    (c = /\r?\n|[\r\u2028\u2029]/y),
    (d = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y),
    (h = /\/\/.*/y),
    (r = /[<>.:={}]|\/(?![\/*])/y),
    (t = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy),
    (n = /(['"])(?:(?!\1)[^])*(\1)?/y),
    (o = /[^<>{}]+/y),
    (b =
      /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/),
    (E = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/),
    (i = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/),
    (a = /^(?:return|throw|yield)$/),
    (u = RegExp(c.source)),
    (uu = s(function* (R, { jsx: I = !1 } = {}) {
      var q, P, A, w, _, $, N, V, H, x, D, F, k, K;
      for ({ length: $ } = R, w = 0, _ = '', K = [{ tag: 'JS' }], q = [], D = 0, F = !1; w < $; ) {
        switch (((V = K[K.length - 1]), V.tag)) {
          case 'JS':
          case 'JSNonExpressionParen':
          case 'InterpolationInTemplate':
          case 'InterpolationInJSX':
            if (R[w] === '/' && (b.test(_) || i.test(_)) && ((m.lastIndex = w), (N = m.exec(R)))) {
              ((w = m.lastIndex),
                (_ = N[0]),
                (F = !0),
                yield {
                  type: 'RegularExpressionLiteral',
                  value: N[0],
                  closed: N[1] !== void 0 && N[1] !== '\\',
                });
              continue;
            }
            if (((f.lastIndex = w), (N = f.exec(R)))) {
              switch (((k = N[0]), (H = f.lastIndex), (x = k), k)) {
                case '(':
                  (_ === '?NonExpressionParenKeyword' &&
                    K.push({ tag: 'JSNonExpressionParen', nesting: D }),
                    D++,
                    (F = !1));
                  break;
                case ')':
                  (D--,
                    (F = !0),
                    V.tag === 'JSNonExpressionParen' &&
                      D === V.nesting &&
                      (K.pop(), (x = '?NonExpressionParenEnd'), (F = !1)));
                  break;
                case '{':
                  ((f.lastIndex = 0),
                    (A = !E.test(_) && (b.test(_) || i.test(_))),
                    q.push(A),
                    (F = !1));
                  break;
                case '}':
                  switch (V.tag) {
                    case 'InterpolationInTemplate':
                      if (q.length === V.nesting) {
                        ((v.lastIndex = w),
                          (N = v.exec(R)),
                          (w = v.lastIndex),
                          (_ = N[0]),
                          N[1] === '${'
                            ? ((_ = '?InterpolationInTemplate'),
                              (F = !1),
                              yield { type: 'TemplateMiddle', value: N[0] })
                            : (K.pop(),
                              (F = !0),
                              yield { type: 'TemplateTail', value: N[0], closed: N[1] === '`' }));
                        continue;
                      }
                      break;
                    case 'InterpolationInJSX':
                      if (q.length === V.nesting) {
                        (K.pop(), (w += 1), (_ = '}'), yield { type: 'JSXPunctuator', value: '}' });
                        continue;
                      }
                  }
                  ((F = q.pop()), (x = F ? '?ExpressionBraceEnd' : '}'));
                  break;
                case ']':
                  F = !0;
                  break;
                case '++':
                case '--':
                  x = F ? '?PostfixIncDec' : '?UnaryIncDec';
                  break;
                case '<':
                  if (I && (b.test(_) || i.test(_))) {
                    (K.push({ tag: 'JSXTag' }),
                      (w += 1),
                      (_ = '<'),
                      yield { type: 'JSXPunctuator', value: k });
                    continue;
                  }
                  F = !1;
                  break;
                default:
                  F = !1;
              }
              ((w = H), (_ = x), yield { type: 'Punctuator', value: k });
              continue;
            }
            if (((e.lastIndex = w), (N = e.exec(R)))) {
              switch (((w = e.lastIndex), (x = N[0]), N[0])) {
                case 'for':
                case 'if':
                case 'while':
                case 'with':
                  _ !== '.' && _ !== '?.' && (x = '?NonExpressionParenKeyword');
              }
              ((_ = x),
                (F = !i.test(N[0])),
                yield { type: N[1] === '#' ? 'PrivateIdentifier' : 'IdentifierName', value: N[0] });
              continue;
            }
            if (((g.lastIndex = w), (N = g.exec(R)))) {
              ((w = g.lastIndex),
                (_ = N[0]),
                (F = !0),
                yield { type: 'StringLiteral', value: N[0], closed: N[2] !== void 0 });
              continue;
            }
            if (((p.lastIndex = w), (N = p.exec(R)))) {
              ((w = p.lastIndex),
                (_ = N[0]),
                (F = !0),
                yield { type: 'NumericLiteral', value: N[0] });
              continue;
            }
            if (((v.lastIndex = w), (N = v.exec(R)))) {
              ((w = v.lastIndex),
                (_ = N[0]),
                N[1] === '${'
                  ? ((_ = '?InterpolationInTemplate'),
                    K.push({ tag: 'InterpolationInTemplate', nesting: q.length }),
                    (F = !1),
                    yield { type: 'TemplateHead', value: N[0] })
                  : ((F = !0),
                    yield { type: 'NoSubstitutionTemplate', value: N[0], closed: N[1] === '`' }));
              continue;
            }
            break;
          case 'JSXTag':
          case 'JSXTagEnd':
            if (((r.lastIndex = w), (N = r.exec(R)))) {
              switch (((w = r.lastIndex), (x = N[0]), N[0])) {
                case '<':
                  K.push({ tag: 'JSXTag' });
                  break;
                case '>':
                  (K.pop(),
                    _ === '/' || V.tag === 'JSXTagEnd'
                      ? ((x = '?JSX'), (F = !0))
                      : K.push({ tag: 'JSXChildren' }));
                  break;
                case '{':
                  (K.push({ tag: 'InterpolationInJSX', nesting: q.length }),
                    (x = '?InterpolationInJSX'),
                    (F = !1));
                  break;
                case '/':
                  _ === '<' &&
                    (K.pop(),
                    K[K.length - 1].tag === 'JSXChildren' && K.pop(),
                    K.push({ tag: 'JSXTagEnd' }));
              }
              ((_ = x), yield { type: 'JSXPunctuator', value: N[0] });
              continue;
            }
            if (((t.lastIndex = w), (N = t.exec(R)))) {
              ((w = t.lastIndex), (_ = N[0]), yield { type: 'JSXIdentifier', value: N[0] });
              continue;
            }
            if (((n.lastIndex = w), (N = n.exec(R)))) {
              ((w = n.lastIndex),
                (_ = N[0]),
                yield { type: 'JSXString', value: N[0], closed: N[2] !== void 0 });
              continue;
            }
            break;
          case 'JSXChildren':
            if (((o.lastIndex = w), (N = o.exec(R)))) {
              ((w = o.lastIndex), (_ = N[0]), yield { type: 'JSXText', value: N[0] });
              continue;
            }
            switch (R[w]) {
              case '<':
                (K.push({ tag: 'JSXTag' }),
                  w++,
                  (_ = '<'),
                  yield { type: 'JSXPunctuator', value: '<' });
                continue;
              case '{':
                (K.push({ tag: 'InterpolationInJSX', nesting: q.length }),
                  w++,
                  (_ = '?InterpolationInJSX'),
                  (F = !1),
                  yield { type: 'JSXPunctuator', value: '{' });
                continue;
            }
        }
        if (((S.lastIndex = w), (N = S.exec(R)))) {
          ((w = S.lastIndex), yield { type: 'WhiteSpace', value: N[0] });
          continue;
        }
        if (((c.lastIndex = w), (N = c.exec(R)))) {
          ((w = c.lastIndex),
            (F = !1),
            a.test(_) && (_ = '?NoLineTerminatorHere'),
            yield { type: 'LineTerminatorSequence', value: N[0] });
          continue;
        }
        if (((d.lastIndex = w), (N = d.exec(R)))) {
          ((w = d.lastIndex),
            u.test(N[0]) && ((F = !1), a.test(_) && (_ = '?NoLineTerminatorHere')),
            yield { type: 'MultiLineComment', value: N[0], closed: N[1] !== void 0 });
          continue;
        }
        if (((h.lastIndex = w), (N = h.exec(R)))) {
          ((w = h.lastIndex), (F = !1), yield { type: 'SingleLineComment', value: N[0] });
          continue;
        }
        ((P = String.fromCodePoint(R.codePointAt(w))),
          (w += P.length),
          (_ = P),
          (F = !1),
          yield { type: V.tag.startsWith('JSX') ? 'JSXInvalid' : 'Invalid', value: P });
      }
    }, 'jsTokens_1')),
    uu
  );
}
s(Z0, 'requireJsTokens');
var LB = Z0();
Af(LB);
var eA = {
  keyword: [
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
  ],
  strict: [
    'implements',
    'interface',
    'let',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
  ],
};
new Set(eA.keyword);
new Set(eA.strict);
function Ds(e, t) {
  if (!e) throw new Error(t);
}
s(Ds, 'S');
function hn(e, t) {
  return typeof t === e;
}
s(hn, 'f');
function tA(e) {
  return e instanceof Promise;
}
s(tA, 'w');
function wo(e, t, r) {
  Object.defineProperty(e, t, r);
}
s(wo, 'u');
function En(e, t, r) {
  wo(e, t, { value: r, configurable: !0, writable: !0 });
}
s(En, 'l');
var Vr = Symbol.for('tinyspy:spy'),
  FB = new Set(),
  BB = s((e) => {
    ((e.called = !1),
      (e.callCount = 0),
      (e.calls = []),
      (e.results = []),
      (e.resolves = []),
      (e.next = []));
  }, 'h'),
  JB = s((e) => (wo(e, Vr, { value: { reset: s(() => BB(e[Vr]), 'reset') } }), e[Vr]), 'k'),
  fd = s((e) => e[Vr] || JB(e), 'T');
function rA(e) {
  Ds(hn('function', e) || hn('undefined', e), 'cannot spy on a non-function value');
  let t = s(function (...n) {
    let o = fd(t);
    ((o.called = !0), o.callCount++, o.calls.push(n));
    let i = o.next.shift();
    if (i) {
      o.results.push(i);
      let [p, f] = i;
      if (p === 'ok') return f;
      throw f;
    }
    let a,
      c = 'ok',
      d = o.results.length;
    if (o.impl)
      try {
        (new.target ? (a = Reflect.construct(o.impl, n, new.target)) : (a = o.impl.apply(this, n)),
          (c = 'ok'));
      } catch (p) {
        throw ((a = p), (c = 'error'), o.results.push([c, p]), p);
      }
    let u = [c, a];
    return (
      tA(a) &&
        a.then(
          (p) => (o.resolves[d] = ['ok', p]),
          (p) => (o.resolves[d] = ['error', p]),
        ),
      o.results.push(u),
      a
    );
  }, 't');
  (En(t, '_isMockFunction', !0),
    En(t, 'length', e ? e.length : 0),
    En(t, 'name', (e && e.name) || 'spy'));
  let r = fd(t);
  return (r.reset(), (r.impl = e), t);
}
s(rA, 'R');
function nA(e) {
  return !!e && e._isMockFunction === !0;
}
s(nA, 'v');
var oA = s((e, t) => {
    let r = Object.getOwnPropertyDescriptor(e, t);
    if (r) return [e, r];
    let n = Object.getPrototypeOf(e);
    for (; n !== null; ) {
      let o = Object.getOwnPropertyDescriptor(n, t);
      if (o) return [n, o];
      n = Object.getPrototypeOf(n);
    }
  }, 'b'),
  rb = s((e, t) => {
    t != null &&
      typeof t == 'function' &&
      t.prototype != null &&
      Object.setPrototypeOf(e.prototype, t.prototype);
  }, 'P');
function dy(e, t, r) {
  (Ds(!hn('undefined', e), 'spyOn could not find an object to spy upon'),
    Ds(hn('object', e) || hn('function', e), 'cannot spyOn on a primitive value'));
  let [n, o] = (() => {
      if (!hn('object', t)) return [t, 'value'];
      if ('getter' in t && 'setter' in t) throw new Error('cannot spy on both getter and setter');
      if ('getter' in t) return [t.getter, 'get'];
      if ('setter' in t) return [t.setter, 'set'];
      throw new Error('specify getter or setter to spy on');
    })(),
    [i, a] = oA(e, n) || [];
  Ds(a || n in e, `${String(n)} does not exist`);
  let c = !1;
  o === 'value' && a && !a.value && a.get && ((o = 'get'), (c = !0), (r = a.get()));
  let d;
  (a ? (d = a[o]) : o !== 'value' ? (d = s(() => e[n], 'p')) : (d = e[n]),
    d && aA(d) && (d = d[Vr].getOriginal()));
  let u = s((h) => {
      let { value: g, ...v } = a || { configurable: !0, writable: !0 };
      (o !== 'value' && delete v.writable, (v[o] = h), wo(e, n, v));
    }, 'g'),
    p = s(() => {
      i !== e ? Reflect.deleteProperty(e, n) : a && !d ? wo(e, n, a) : u(d);
    }, 'a');
  r || (r = d);
  let f = iA(rA(r), r);
  o === 'value' && rb(f, d);
  let m = f[Vr];
  return (
    En(m, 'restore', p),
    En(m, 'getOriginal', () => (c ? d() : d)),
    En(m, 'willCall', (h) => ((m.impl = h), f)),
    u(c ? () => (rb(f, r), f) : f),
    FB.add(f),
    f
  );
}
s(dy, 'M');
var UB = new Set(['length', 'name', 'prototype']);
function sA(e) {
  let t = new Set(),
    r = {};
  for (; e && e !== Object.prototype && e !== Function.prototype; ) {
    let n = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
    for (let o of n)
      r[o] || UB.has(o) || (t.add(o), (r[o] = Object.getOwnPropertyDescriptor(e, o)));
    e = Object.getPrototypeOf(e);
  }
  return { properties: t, descriptors: r };
}
s(sA, 'D');
function iA(e, t) {
  if (!t || Vr in t) return e;
  let { properties: r, descriptors: n } = sA(t);
  for (let o of r) {
    let i = n[o];
    oA(e, o) || wo(e, o, i);
  }
  return e;
}
s(iA, 'E');
function aA(e) {
  return nA(e) && 'getOriginal' in e[Vr];
}
s(aA, 'j');
var Mi = new Set();
function wn(e) {
  return typeof e == 'function' && '_isMockFunction' in e && e._isMockFunction;
}
s(wn, 'isMockFunction');
function lA(e, t, r) {
  const o = r ? { [{ get: 'getter', set: 'setter' }[r]]: t } : t;
  let i;
  const a = cA(e, t),
    c = a && a[r || 'value'];
  wn(c) && (i = c.mock._state());
  try {
    const d = dy(e, o),
      u = py(d);
    return (i && u.mock._state(i), u);
  } catch (d) {
    throw d instanceof TypeError &&
      Symbol.toStringTag &&
      e[Symbol.toStringTag] === 'Module' &&
      (d.message.includes('Cannot redefine property') ||
        d.message.includes('Cannot replace module namespace') ||
        d.message.includes("can't redefine non-configurable property"))
      ? new TypeError(
          `Cannot spy on export "${String(o)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`,
          { cause: d },
        )
      : d;
  }
}
s(lA, 'spyOn');
var VB = 0;
function py(e) {
  const t = e;
  let r,
    n = [],
    o = !1,
    i = [],
    a = [],
    c = [];
  const d = fd(e),
    u = {
      get calls() {
        return d.calls;
      },
      get contexts() {
        return a;
      },
      get instances() {
        return i;
      },
      get invocationCallOrder() {
        return c;
      },
      get results() {
        return d.results.map(([h, g]) => ({ type: h === 'error' ? 'throw' : 'return', value: g }));
      },
      get settledResults() {
        return d.resolves.map(([h, g]) => ({
          type: h === 'error' ? 'rejected' : 'fulfilled',
          value: g,
        }));
      },
      get lastCall() {
        return d.calls[d.calls.length - 1];
      },
      _state(h) {
        return (
          h &&
            ((r = h.implementation),
            (n = h.onceImplementations),
            (o = h.implementationChangedTemporarily)),
          { implementation: r, onceImplementations: n, implementationChangedTemporarily: o }
        );
      },
    };
  function p(...h) {
    return (
      i.push(this),
      a.push(this),
      c.push(++VB),
      (o ? r : n.shift() || r || d.getOriginal() || (() => {})).apply(this, h)
    );
  }
  s(p, 'mockCall');
  let f = t.name;
  ((t.getMockName = () => f || 'vi.fn()'),
    (t.mockName = (h) => ((f = h), t)),
    (t.mockClear = () => (d.reset(), (i = []), (a = []), (c = []), t)),
    (t.mockReset = () => (t.mockClear(), (r = void 0), (n = []), t)),
    (t.mockRestore = () => (t.mockReset(), d.restore(), t)),
    Symbol.dispose && (t[Symbol.dispose] = () => t.mockRestore()),
    (t.getMockImplementation = () => (o ? r : n.at(0) || r)),
    (t.mockImplementation = (h) => ((r = h), d.willCall(p), t)),
    (t.mockImplementationOnce = (h) => (n.push(h), t)));
  function m(h, g) {
    const v = r;
    ((r = h), d.willCall(p), (o = !0));
    const E = s(() => {
        ((r = v), (o = !1));
      }, 'reset'),
      b = g();
    return typeof b == 'object' && b && typeof b.then == 'function'
      ? b.then(() => (E(), t))
      : (E(), t);
  }
  return (
    s(m, 'withImplementation'),
    (t.withImplementation = m),
    (t.mockReturnThis = () =>
      t.mockImplementation(function () {
        return this;
      })),
    (t.mockReturnValue = (h) => t.mockImplementation(() => h)),
    (t.mockReturnValueOnce = (h) => t.mockImplementationOnce(() => h)),
    (t.mockResolvedValue = (h) => t.mockImplementation(() => Promise.resolve(h))),
    (t.mockResolvedValueOnce = (h) => t.mockImplementationOnce(() => Promise.resolve(h))),
    (t.mockRejectedValue = (h) => t.mockImplementation(() => Promise.reject(h))),
    (t.mockRejectedValueOnce = (h) => t.mockImplementationOnce(() => Promise.reject(h))),
    Object.defineProperty(t, 'mock', { get: s(() => u, 'get') }),
    d.willCall(p),
    Mi.add(t),
    t
  );
}
s(py, 'enhanceSpy');
function md(e) {
  const t = py(dy({ spy: e || function () {} }, 'spy'));
  return (e && t.mockImplementation(e), t);
}
s(md, 'fn');
function cA(e, t) {
  const r = Object.getOwnPropertyDescriptor(e, t);
  if (r) return r;
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    const o = Object.getOwnPropertyDescriptor(n, t);
    if (o) return o;
    n = Object.getPrototypeOf(n);
  }
}
s(cA, 'getDescriptor');
var ni = Symbol.for('matchers-object'),
  oi = Symbol.for('$$jest-matchers-object-storybook'),
  fy = Symbol.for('expect-global'),
  yd = Symbol.for('asymmetric-matchers-object'),
  HB = {
    toSatisfy(e, t, r) {
      const { printReceived: n, printExpected: o, matcherHint: i } = this.utils,
        a = t(e);
      return {
        pass: a,
        message: s(
          () =>
            a
              ? `${i('.not.toSatisfy', 'received', '')}

Expected value to not satisfy:
${r || o(t)}
Received:
${n(e)}`
              : `${i('.toSatisfy', 'received', '')}

Expected value to satisfy:
${r || o(t)}

Received:
${n(e)}`,
          'message',
        ),
      };
    },
    toBeOneOf(e, t) {
      const { equals: r, customTesters: n } = this,
        { printReceived: o, printExpected: i, matcherHint: a } = this.utils;
      if (!Array.isArray(t))
        throw new TypeError(`You must provide an array to ${a('.toBeOneOf')}, not '${typeof t}'.`);
      const c = t.length === 0 || t.some((d) => r(d, e, n));
      return {
        pass: c,
        message: s(
          () =>
            c
              ? `${a('.not.toBeOneOf', 'received', '')}

Expected value to not be one of:
${i(t)}
Received:
${o(e)}`
              : `${a('.toBeOneOf', 'received', '')}

Expected value to be one of:
${i(t)}

Received:
${o(e)}`,
          'message',
        ),
      };
    },
  },
  Ja = Ue.green,
  my = Ue.red,
  zB = Ue.inverse,
  GB = Ue.bold,
  jr = Ue.dim;
function uA(e, t = 'received', r = 'expected', n = {}) {
  const {
    comment: o = '',
    isDirectExpectCall: i = !1,
    isNot: a = !1,
    promise: c = '',
    secondArgument: d = '',
    expectedColor: u = Ja,
    receivedColor: p = my,
    secondArgumentColor: f = Ja,
  } = n;
  let m = '',
    h = 'expect';
  return (
    !i && t !== '' && ((m += jr(`${h}(`) + p(t)), (h = ')')),
    c !== '' && ((m += jr(`${h}.`) + c), (h = '')),
    a && ((m += `${jr(`${h}.`)}not`), (h = '')),
    e.includes('.') ? (h += e) : ((m += jr(`${h}.`) + e), (h = '')),
    r === '' ? (h += '()') : ((m += jr(`${h}(`) + u(r)), d && (m += jr(', ') + f(d)), (h = ')')),
    o !== '' && (h += ` // ${o}`),
    h !== '' && (m += jr(h)),
    m
  );
}
s(uA, 'matcherHint');
var WB = '';
function yy(e) {
  return e.replace(/\s+$/gm, (t) => WB.repeat(t.length));
}
s(yy, 'replaceTrailingSpaces');
function dA(e) {
  return my(yy(Et(e)));
}
s(dA, 'printReceived');
function pA(e) {
  return Ja(yy(Et(e)));
}
s(pA, 'printExpected');
function hy() {
  return {
    EXPECTED_COLOR: Ja,
    RECEIVED_COLOR: my,
    INVERTED_COLOR: zB,
    BOLD_WEIGHT: GB,
    DIM_COLOR: jr,
    diff: Bn,
    matcherHint: uA,
    printReceived: dA,
    printExpected: pA,
    printDiffOrStringify: Mf,
    printWithType: fA,
  };
}
s(hy, 'getMatcherUtils');
function fA(e, t, r) {
  const n = Ks(t),
    o =
      n !== 'null' && n !== 'undefined'
        ? `${e} has type:  ${n}
`
        : '',
    i = `${e} has value: ${r(t)}`;
  return o + i;
}
s(fA, 'printWithType');
function hc() {
  return globalThis[oi].customEqualityTesters;
}
s(hc, 'getCustomEqualityTesters');
function Ae(e, t, r, n) {
  return ((r = r || []), ao(e, t, [], [], r, n ? gy : hA));
}
s(Ae, 'equals');
function hd(e) {
  return !!e && typeof e == 'object' && 'asymmetricMatch' in e && Lt('Function', e.asymmetricMatch);
}
s(hd, 'isAsymmetric');
function mA(e, t) {
  const r = hd(e),
    n = hd(t);
  if (!(r && n)) {
    if (r) return e.asymmetricMatch(t);
    if (n) return t.asymmetricMatch(e);
  }
}
s(mA, 'asymmetricMatch');
function ao(e, t, r, n, o, i) {
  let a = !0;
  const c = mA(e, t);
  if (c !== void 0) return c;
  const d = { equals: Ae };
  for (let g = 0; g < o.length; g++) {
    const v = o[g].call(d, e, t, o);
    if (v !== void 0) return v;
  }
  if (typeof URL == 'function' && e instanceof URL && t instanceof URL) return e.href === t.href;
  if (Object.is(e, t)) return !0;
  if (e === null || t === null) return e === t;
  const u = Object.prototype.toString.call(e);
  if (u !== Object.prototype.toString.call(t)) return !1;
  switch (u) {
    case '[object Boolean]':
    case '[object String]':
    case '[object Number]':
      return typeof e != typeof t
        ? !1
        : typeof e != 'object' && typeof t != 'object'
          ? Object.is(e, t)
          : Object.is(e.valueOf(), t.valueOf());
    case '[object Date]': {
      const g = +e,
        v = +t;
      return g === v || (Number.isNaN(g) && Number.isNaN(v));
    }
    case '[object RegExp]':
      return e.source === t.source && e.flags === t.flags;
    case '[object Temporal.Instant]':
    case '[object Temporal.ZonedDateTime]':
    case '[object Temporal.PlainDateTime]':
    case '[object Temporal.PlainDate]':
    case '[object Temporal.PlainTime]':
    case '[object Temporal.PlainYearMonth]':
    case '[object Temporal.PlainMonthDay]':
      return e.equals(t);
    case '[object Temporal.Duration]':
      return e.toString() === t.toString();
  }
  if (typeof e != 'object' || typeof t != 'object') return !1;
  if (bd(e) && bd(t)) return e.isEqualNode(t);
  let p = r.length;
  for (; p--; ) {
    if (r[p] === e) return n[p] === t;
    if (n[p] === t) return !1;
  }
  if ((r.push(e), n.push(t), u === '[object Array]' && e.length !== t.length)) return !1;
  if (e instanceof Error && t instanceof Error)
    try {
      return yA(e, t, r, n, o, i);
    } finally {
      (r.pop(), n.pop());
    }
  const f = gd(e, i);
  let m,
    h = f.length;
  if (gd(t, i).length !== h) return !1;
  for (; h--; ) if (((m = f[h]), (a = i(t, m) && ao(e[m], t[m], r, n, o, i)), !a)) return !1;
  return (r.pop(), n.pop(), a);
}
s(ao, 'eq');
function yA(e, t, r, n, o, i) {
  let a =
    Object.getPrototypeOf(e) === Object.getPrototypeOf(t) &&
    e.name === t.name &&
    e.message === t.message;
  return (
    typeof t.cause < 'u' && a && (a = ao(e.cause, t.cause, r, n, o, i)),
    e instanceof AggregateError &&
      t instanceof AggregateError &&
      a &&
      (a = ao(e.errors, t.errors, r, n, o, i)),
    a && (a = ao({ ...e }, { ...t }, r, n, o, i)),
    a
  );
}
s(yA, 'isErrorEqual');
function gd(e, t) {
  const r = [];
  for (const n in e) t(e, n) && r.push(n);
  return r.concat(
    Object.getOwnPropertySymbols(e).filter((n) => Object.getOwnPropertyDescriptor(e, n).enumerable),
  );
}
s(gd, 'keys');
function hA(e, t) {
  return gy(e, t) && e[t] !== void 0;
}
s(hA, 'hasDefinedKey');
function gy(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
s(gy, 'hasKey');
function Lt(e, t) {
  return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
s(Lt, 'isA');
function bd(e) {
  return (
    e !== null &&
    typeof e == 'object' &&
    'nodeType' in e &&
    typeof e.nodeType == 'number' &&
    'nodeName' in e &&
    typeof e.nodeName == 'string' &&
    'isEqualNode' in e &&
    typeof e.isEqualNode == 'function'
  );
}
s(bd, 'isDomNode');
var gA = '@@__IMMUTABLE_KEYED__@@',
  bA = '@@__IMMUTABLE_SET__@@',
  KB = '@@__IMMUTABLE_LIST__@@',
  gc = '@@__IMMUTABLE_ORDERED__@@',
  YB = '@@__IMMUTABLE_RECORD__@@';
function vA(e) {
  return !!(e && e[gA] && !e[gc]);
}
s(vA, 'isImmutableUnorderedKeyed');
function TA(e) {
  return !!(e && e[bA] && !e[gc]);
}
s(TA, 'isImmutableUnorderedSet');
function ji(e) {
  return e != null && typeof e == 'object' && !Array.isArray(e);
}
s(ji, 'isObjectLiteral');
function EA(e) {
  return !!(e && ji(e) && e[KB]);
}
s(EA, 'isImmutableList');
function wA(e) {
  return !!(e && ji(e) && e[gA] && e[gc]);
}
s(wA, 'isImmutableOrderedKeyed');
function SA(e) {
  return !!(e && ji(e) && e[bA] && e[gc]);
}
s(SA, 'isImmutableOrderedSet');
function _A(e) {
  return !!(e && ji(e) && e[YB]);
}
s(_A, 'isImmutableRecord');
var AA = Symbol.iterator;
function vd(e) {
  return !!(e != null && e[AA]);
}
s(vd, 'hasIterator');
function Ct(e, t, r = [], n = [], o = []) {
  if (
    typeof e != 'object' ||
    typeof t != 'object' ||
    Array.isArray(e) ||
    Array.isArray(t) ||
    !vd(e) ||
    !vd(t)
  )
    return;
  if (e.constructor !== t.constructor) return !1;
  let i = n.length;
  for (; i--; ) if (n[i] === e) return o[i] === t;
  (n.push(e), o.push(t));
  const a = [...r.filter((u) => u !== Ct), c];
  function c(u, p) {
    return Ct(u, p, [...r], [...n], [...o]);
  }
  if ((s(c, 'iterableEqualityWithStack'), e.size !== void 0)) {
    if (e.size !== t.size) return !1;
    if (Lt('Set', e) || TA(e)) {
      let u = !0;
      for (const p of e)
        if (!t.has(p)) {
          let f = !1;
          for (const m of t) Ae(p, m, a) === !0 && (f = !0);
          if (f === !1) {
            u = !1;
            break;
          }
        }
      return (n.pop(), o.pop(), u);
    } else if (Lt('Map', e) || vA(e)) {
      let u = !0;
      for (const p of e)
        if (!t.has(p[0]) || !Ae(p[1], t.get(p[0]), a)) {
          let f = !1;
          for (const m of t) {
            const h = Ae(p[0], m[0], a);
            let g = !1;
            (h === !0 && (g = Ae(p[1], m[1], a)), g === !0 && (f = !0));
          }
          if (f === !1) {
            u = !1;
            break;
          }
        }
      return (n.pop(), o.pop(), u);
    }
  }
  const d = t[AA]();
  for (const u of e) {
    const p = d.next();
    if (p.done || !Ae(u, p.value, a)) return !1;
  }
  if (!d.next().done) return !1;
  if (!EA(e) && !wA(e) && !SA(e) && !_A(e)) {
    const u = Object.entries(e),
      p = Object.entries(t);
    if (!Ae(u, p, a)) return !1;
  }
  return (n.pop(), o.pop(), !0);
}
s(Ct, 'iterableEquality');
function bc(e, t) {
  return !e || typeof e != 'object' || e === Object.prototype
    ? !1
    : Object.prototype.hasOwnProperty.call(e, t) || bc(Object.getPrototypeOf(e), t);
}
s(bc, 'hasPropertyInObject');
function RA(e) {
  return $s(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
s(RA, 'isObjectWithKeys');
function Bo(e, t, r = []) {
  const n = r.filter((i) => i !== Bo),
    o = s(
      (i = new WeakMap()) =>
        (a, c) => {
          if (RA(c))
            return Object.keys(c).every((d) => {
              if (c[d] != null && typeof c[d] == 'object') {
                if (i.has(c[d])) return Ae(a[d], c[d], n);
                i.set(c[d], !0);
              }
              const u = a != null && bc(a, d) && Ae(a[d], c[d], [...n, o(i)]);
              return (i.delete(c[d]), u);
            });
        },
      'subsetEqualityWithContext',
    );
  return o()(e, t);
}
s(Bo, 'subsetEquality');
function Td(e, t) {
  if (!(e == null || t == null || e.constructor === t.constructor)) return !1;
}
s(Td, 'typeEquality');
function Ed(e, t) {
  let r = e,
    n = t;
  if (!(e instanceof DataView && t instanceof DataView)) {
    if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer)) return;
    try {
      ((r = new DataView(e)), (n = new DataView(t)));
    } catch {
      return;
    }
  }
  if (r.byteLength !== n.byteLength) return !1;
  for (let o = 0; o < r.byteLength; o++) if (r.getUint8(o) !== n.getUint8(o)) return !1;
  return !0;
}
s(Ed, 'arrayBufferEquality');
function Ua(e, t, r = []) {
  if (!Array.isArray(e) || !Array.isArray(t)) return;
  const n = Object.keys(e),
    o = Object.keys(t),
    i = r.filter((a) => a !== Ua);
  return Ae(e, t, i, !0) && Ae(n, o);
}
s(Ua, 'sparseArrayEquality');
function xA(e, t = '#{this}', r = '#{exp}') {
  const n = `expected ${t} to be ${r} // Object.is equality`;
  return ['toStrictEqual', 'toEqual'].includes(e)
    ? `${n}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
`
    : n;
}
s(xA, 'generateToBeMessage');
function PA(e, t) {
  return `${t} ${e}${t === 1 ? '' : 's'}`;
}
s(PA, 'pluralize');
function Qi(e) {
  return [
    ...Object.keys(e),
    ...Object.getOwnPropertySymbols(e).filter((t) => {
      var r;
      return (r = Object.getOwnPropertyDescriptor(e, t)) === null || r === void 0
        ? void 0
        : r.enumerable;
    }),
  ];
}
s(Qi, 'getObjectKeys');
function OA(e, t, r) {
  let n = 0;
  const o = s(
    (i = new WeakMap()) =>
      (a, c) => {
        if (Array.isArray(a)) {
          if (Array.isArray(c) && c.length === a.length) return c.map((d, u) => o(i)(a[u], d));
        } else {
          if (a instanceof Date) return a;
          if ($s(a) && $s(c)) {
            if (Ae(a, c, [...r, Ct, Bo])) return c;
            const d = {};
            (i.set(a, d),
              typeof a.constructor == 'function' &&
                typeof a.constructor.name == 'string' &&
                Object.defineProperty(d, 'constructor', { enumerable: !1, value: a.constructor }));
            for (const u of Qi(a))
              bc(c, u)
                ? (d[u] = i.has(a[u]) ? i.get(a[u]) : o(i)(a[u], c[u]))
                : i.has(a[u]) || ((n += 1), $s(a[u]) && (n += Qi(a[u]).length), o(i)(a[u], c[u]));
            if (Qi(d).length > 0) return d;
          }
        }
        return a;
      },
    'getObjectSubsetWithContext',
  );
  return { subset: o()(e, t), stripped: n };
}
s(OA, 'getObjectSubset');
if (!Object.prototype.hasOwnProperty.call(globalThis, ni)) {
  const e = new WeakMap();
  Object.defineProperty(globalThis, ni, { get: s(() => e, 'get') });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, oi)) {
  const e = Object.create(null),
    t = [];
  Object.defineProperty(globalThis, oi, {
    configurable: !0,
    get: s(
      () => ({ state: globalThis[ni].get(globalThis[fy]), matchers: e, customEqualityTesters: t }),
      'get',
    ),
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, yd)) {
  const e = Object.create(null);
  Object.defineProperty(globalThis, yd, { get: s(() => e, 'get') });
}
function si(e) {
  return globalThis[ni].get(e);
}
s(si, 'getState');
function Zi(e, t) {
  const r = globalThis[ni],
    n = r.get(t) || {},
    o = Object.defineProperties(n, {
      ...Object.getOwnPropertyDescriptors(n),
      ...Object.getOwnPropertyDescriptors(e),
    });
  r.set(t, o);
}
s(Zi, 'setState');
var CA = class {
  constructor(t, r = !1) {
    Be(this, '$$typeof', Symbol.for('jest.asymmetricMatcher'));
    ((this.sample = t), (this.inverse = r));
  }
  getMatcherContext(t) {
    return {
      ...si(t || globalThis[fy]),
      equals: Ae,
      isNot: this.inverse,
      customTesters: hc(),
      utils: { ...hy(), diff: Bn, stringify: Et, iterableEquality: Ct, subsetEquality: Bo },
    };
  }
};
s(CA, 'AsymmetricMatcher');
var qr = CA;
qr.prototype[Symbol.for('chai/inspect')] = function (e) {
  const t = Et(this, e.depth, { min: !0 });
  return t.length <= e.truncate ? t : `${this.toString()}{}`;
};
var IA = class extends qr {
  constructor(t, r = !1) {
    if (!Lt('String', t)) throw new Error('Expected is not a string');
    super(t, r);
  }
  asymmetricMatch(t) {
    const r = Lt('String', t) && t.includes(this.sample);
    return this.inverse ? !r : r;
  }
  toString() {
    return `String${this.inverse ? 'Not' : ''}Containing`;
  }
  getExpectedType() {
    return 'string';
  }
};
s(IA, 'StringContaining');
var nb = IA,
  NA = class extends qr {
    asymmetricMatch(t) {
      return t != null;
    }
    toString() {
      return 'Anything';
    }
    toAsymmetricMatcher() {
      return 'Anything';
    }
  };
s(NA, 'Anything');
var XB = NA,
  qA = class extends qr {
    constructor(t, r = !1) {
      super(t, r);
    }
    getPrototype(t) {
      return Object.getPrototypeOf
        ? Object.getPrototypeOf(t)
        : t.constructor.prototype === t
          ? null
          : t.constructor.prototype;
    }
    hasProperty(t, r) {
      return t
        ? Object.prototype.hasOwnProperty.call(t, r)
          ? !0
          : this.hasProperty(this.getPrototype(t), r)
        : !1;
    }
    asymmetricMatch(t) {
      if (typeof this.sample != 'object')
        throw new TypeError(
          `You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`,
        );
      let r = !0;
      const n = this.getMatcherContext();
      for (const o in this.sample)
        if (!this.hasProperty(t, o) || !Ae(this.sample[o], t[o], n.customTesters)) {
          r = !1;
          break;
        }
      return this.inverse ? !r : r;
    }
    toString() {
      return `Object${this.inverse ? 'Not' : ''}Containing`;
    }
    getExpectedType() {
      return 'object';
    }
  };
s(qA, 'ObjectContaining');
var ob = qA,
  MA = class extends qr {
    constructor(t, r = !1) {
      super(t, r);
    }
    asymmetricMatch(t) {
      if (!Array.isArray(this.sample))
        throw new TypeError(
          `You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`,
        );
      const r = this.getMatcherContext(),
        n =
          this.sample.length === 0 ||
          (Array.isArray(t) && this.sample.every((o) => t.some((i) => Ae(o, i, r.customTesters))));
      return this.inverse ? !n : n;
    }
    toString() {
      return `Array${this.inverse ? 'Not' : ''}Containing`;
    }
    getExpectedType() {
      return 'array';
    }
  };
s(MA, 'ArrayContaining');
var sb = MA,
  jA = class extends qr {
    constructor(t) {
      if (typeof t > 'u')
        throw new TypeError(
          'any() expects to be passed a constructor function. Please pass one or use anything() to match any object.',
        );
      super(t);
    }
    fnNameFor(t) {
      if (t.name) return t.name;
      const n = Function.prototype.toString
        .call(t)
        .match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
      return n ? n[1] : '<anonymous>';
    }
    asymmetricMatch(t) {
      return this.sample === String
        ? typeof t == 'string' || t instanceof String
        : this.sample === Number
          ? typeof t == 'number' || t instanceof Number
          : this.sample === Function
            ? typeof t == 'function' || typeof t == 'function'
            : this.sample === Boolean
              ? typeof t == 'boolean' || t instanceof Boolean
              : this.sample === BigInt
                ? typeof t == 'bigint' || t instanceof BigInt
                : this.sample === Symbol
                  ? typeof t == 'symbol' || t instanceof Symbol
                  : this.sample === Object
                    ? typeof t == 'object'
                    : t instanceof this.sample;
    }
    toString() {
      return 'Any';
    }
    getExpectedType() {
      return this.sample === String
        ? 'string'
        : this.sample === Number
          ? 'number'
          : this.sample === Function
            ? 'function'
            : this.sample === Object
              ? 'object'
              : this.sample === Boolean
                ? 'boolean'
                : this.fnNameFor(this.sample);
    }
    toAsymmetricMatcher() {
      return `Any<${this.fnNameFor(this.sample)}>`;
    }
  };
s(jA, 'Any');
var QB = jA,
  $A = class extends qr {
    constructor(t, r = !1) {
      if (!Lt('String', t) && !Lt('RegExp', t))
        throw new Error('Expected is not a String or a RegExp');
      super(new RegExp(t), r);
    }
    asymmetricMatch(t) {
      const r = Lt('String', t) && this.sample.test(t);
      return this.inverse ? !r : r;
    }
    toString() {
      return `String${this.inverse ? 'Not' : ''}Matching`;
    }
    getExpectedType() {
      return 'string';
    }
  };
s($A, 'StringMatching');
var ib = $A,
  kA = class extends qr {
    constructor(r, n = 2, o = !1) {
      if (!Lt('Number', r)) throw new Error('Expected is not a Number');
      if (!Lt('Number', n)) throw new Error('Precision is not a Number');
      super(r);
      Be(this, 'precision');
      ((this.inverse = o), (this.precision = n));
    }
    asymmetricMatch(r) {
      if (!Lt('Number', r)) return !1;
      let n = !1;
      return (
        (r === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY) ||
        (r === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY)
          ? (n = !0)
          : (n = Math.abs(this.sample - r) < 10 ** -this.precision / 2),
        this.inverse ? !n : n
      );
    }
    toString() {
      return `Number${this.inverse ? 'Not' : ''}CloseTo`;
    }
    getExpectedType() {
      return 'number';
    }
    toAsymmetricMatcher() {
      return [this.toString(), this.sample, `(${PA('digit', this.precision)})`].join(' ');
    }
  };
s(kA, 'CloseTo');
var ab = kA,
  ZB = s((e, t) => {
    (t.addMethod(e.expect, 'anything', () => new XB()),
      t.addMethod(e.expect, 'any', (r) => new QB(r)),
      t.addMethod(e.expect, 'stringContaining', (r) => new nb(r)),
      t.addMethod(e.expect, 'objectContaining', (r) => new ob(r)),
      t.addMethod(e.expect, 'arrayContaining', (r) => new sb(r)),
      t.addMethod(e.expect, 'stringMatching', (r) => new ib(r)),
      t.addMethod(e.expect, 'closeTo', (r, n) => new ab(r, n)),
      (e.expect.not = {
        stringContaining: s((r) => new nb(r, !0), 'stringContaining'),
        objectContaining: s((r) => new ob(r, !0), 'objectContaining'),
        arrayContaining: s((r) => new sb(r, !0), 'arrayContaining'),
        stringMatching: s((r) => new ib(r, !0), 'stringMatching'),
        closeTo: s((r, n) => new ab(r, n, !0), 'closeTo'),
      }));
  }, 'JestAsymmetricMatchers');
function wd(e, t, r) {
  const n = e.flag(t, 'negate') ? 'not.' : '',
    o = `${e.flag(t, '_name')}(${r ? 'expected' : ''})`,
    i = e.flag(t, 'promise');
  return `expect(actual)${i ? `.${i}` : ''}.${n}${o}`;
}
s(wd, 'createAssertionMessage');
function Sd(e, t, r, n) {
  const o = e;
  if (o && t instanceof Promise) {
    ((t = t.finally(() => {
      if (!o.promises) return;
      const a = o.promises.indexOf(t);
      a !== -1 && o.promises.splice(a, 1);
    })),
      o.promises || (o.promises = []),
      o.promises.push(t));
    let i = !1;
    return (
      o.onFinished ?? (o.onFinished = []),
      o.onFinished.push(() => {
        if (!i) {
          var a;
          const d = (
            ((a = globalThis.__vitest_worker__) === null || a === void 0
              ? void 0
              : a.onFilterStackTrace) || ((u) => u || '')
          )(n.stack);
          console.warn(
            [
              `Promise returned by \`${r}\` was not awaited. `,
              'Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ',
              `Please remember to await the assertion.
`,
              d,
            ].join(''),
          );
        }
      }),
      {
        then(a, c) {
          return ((i = !0), t.then(a, c));
        },
        catch(a) {
          return t.catch(a);
        },
        finally(a) {
          return t.finally(a);
        },
        [Symbol.toStringTag]: 'Promise',
      }
    );
  }
  return t;
}
s(Sd, 'recordAsyncExpect');
function _d(e, t) {
  var r;
  (e.result || (e.result = { state: 'fail' }),
    (e.result.state = 'fail'),
    (r = e.result).errors || (r.errors = []),
    e.result.errors.push(ql(t)));
}
s(_d, 'handleTestError');
function by(e, t, r) {
  return function (...n) {
    if ((t !== 'withTest' && e.flag(this, '_name', t), !e.flag(this, 'soft')))
      return r.apply(this, n);
    const o = e.flag(this, 'vitest-test');
    if (!o) throw new Error('expect.soft() can only be used inside a test');
    try {
      const i = r.apply(this, n);
      return i && typeof i == 'object' && typeof i.then == 'function'
        ? i.then(MS, (a) => {
            _d(o, a);
          })
        : i;
    } catch (i) {
      _d(o, i);
    }
  };
}
s(by, 'wrapAssertion');
var eJ = s((e, t) => {
  const { AssertionError: r } = e,
    n = hc();
  function o(u, p) {
    const f = s((m) => {
      const h = by(t, m, p);
      (t.addMethod(e.Assertion.prototype, m, h), t.addMethod(globalThis[oi].matchers, m, h));
    }, 'addMethod');
    Array.isArray(u) ? u.forEach((m) => f(m)) : f(u);
  }
  (s(o, 'def'),
    ['throw', 'throws', 'Throw'].forEach((u) => {
      t.overwriteMethod(
        e.Assertion.prototype,
        u,
        (p) =>
          function (...f) {
            const m = t.flag(this, 'promise'),
              h = t.flag(this, 'object'),
              g = t.flag(this, 'negate');
            if (m === 'rejects')
              t.flag(this, 'object', () => {
                throw h;
              });
            else if (m === 'resolves' && typeof h != 'function') {
              if (g) return;
              {
                const v =
                    t.flag(this, 'message') || "expected promise to throw an error, but it didn't",
                  E = { showDiff: !1 };
                throw new r(v, E, t.flag(this, 'ssfi'));
              }
            }
            p.apply(this, f);
          },
      );
    }),
    o('withTest', function (u) {
      return (t.flag(this, 'vitest-test', u), this);
    }),
    o('toEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Ae(p, u, [...n, Ct]);
      return this.assert(
        f,
        'expected #{this} to deeply equal #{exp}',
        'expected #{this} to not deeply equal #{exp}',
        u,
        p,
      );
    }),
    o('toStrictEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Ae(p, u, [...n, Ct, Td, Ua, Ed], !0);
      return this.assert(
        f,
        'expected #{this} to strictly equal #{exp}',
        'expected #{this} to not strictly equal #{exp}',
        u,
        p,
      );
    }),
    o('toBe', function (u) {
      const p = this._obj,
        f = Object.is(p, u);
      let m = '';
      return (
        f ||
          (Ae(p, u, [...n, Ct, Td, Ua, Ed], !0)
            ? (m = 'toStrictEqual')
            : Ae(p, u, [...n, Ct]) && (m = 'toEqual')),
        this.assert(f, xA(m), 'expected #{this} not to be #{exp} // Object.is equality', u, p)
      );
    }),
    o('toMatchObject', function (u) {
      const p = this._obj,
        f = Ae(p, u, [...n, Ct, Bo]),
        m = t.flag(this, 'negate'),
        { subset: h, stripped: g } = OA(p, u, n);
      if ((f && m) || (!f && !m)) {
        const v = t.getMessage(this, [
            f,
            'expected #{this} to match object #{exp}',
            'expected #{this} to not match object #{exp}',
            u,
            h,
            !1,
          ]),
          E =
            g === 0
              ? v
              : `${v}
(${g} matching ${g === 1 ? 'property' : 'properties'} omitted from actual)`;
        throw new r(E, { showDiff: !0, expected: u, actual: h });
      }
    }),
    o('toMatch', function (u) {
      const p = this._obj;
      if (typeof p != 'string')
        throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof p}`);
      return this.assert(
        typeof u == 'string' ? p.includes(u) : p.match(u),
        'expected #{this} to match #{exp}',
        'expected #{this} not to match #{exp}',
        u,
        p,
      );
    }),
    o('toContain', function (u) {
      const p = this._obj;
      if (typeof Node < 'u' && p instanceof Node) {
        if (!(u instanceof Node))
          throw new TypeError(
            `toContain() expected a DOM node as the argument, but got ${typeof u}`,
          );
        return this.assert(
          p.contains(u),
          'expected #{this} to contain element #{exp}',
          'expected #{this} not to contain element #{exp}',
          u,
          p,
        );
      }
      if (typeof DOMTokenList < 'u' && p instanceof DOMTokenList) {
        er(u, 'class name', ['string']);
        const m = t.flag(this, 'negate') ? p.value.replace(u, '').trim() : `${p.value} ${u}`;
        return this.assert(
          p.contains(u),
          `expected "${p.value}" to contain "${u}"`,
          `expected "${p.value}" not to contain "${u}"`,
          m,
          p.value,
        );
      }
      return typeof p == 'string' && typeof u == 'string'
        ? this.assert(
            p.includes(u),
            'expected #{this} to contain #{exp}',
            'expected #{this} not to contain #{exp}',
            u,
            p,
          )
        : (p != null && typeof p != 'string' && t.flag(this, 'object', Array.from(p)),
          this.contain(u));
    }),
    o('toContainEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Array.from(p).findIndex((m) => Ae(m, u, n));
      this.assert(
        f !== -1,
        'expected #{this} to deep equally contain #{exp}',
        'expected #{this} to not deep equally contain #{exp}',
        u,
      );
    }),
    o('toBeTruthy', function () {
      const u = t.flag(this, 'object');
      this.assert(!!u, 'expected #{this} to be truthy', 'expected #{this} to not be truthy', !0, u);
    }),
    o('toBeFalsy', function () {
      const u = t.flag(this, 'object');
      this.assert(!u, 'expected #{this} to be falsy', 'expected #{this} to not be falsy', !1, u);
    }),
    o('toBeGreaterThan', function (u) {
      const p = this._obj;
      return (
        er(p, 'actual', ['number', 'bigint']),
        er(u, 'expected', ['number', 'bigint']),
        this.assert(
          p > u,
          `expected ${p} to be greater than ${u}`,
          `expected ${p} to be not greater than ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    o('toBeGreaterThanOrEqual', function (u) {
      const p = this._obj;
      return (
        er(p, 'actual', ['number', 'bigint']),
        er(u, 'expected', ['number', 'bigint']),
        this.assert(
          p >= u,
          `expected ${p} to be greater than or equal to ${u}`,
          `expected ${p} to be not greater than or equal to ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    o('toBeLessThan', function (u) {
      const p = this._obj;
      return (
        er(p, 'actual', ['number', 'bigint']),
        er(u, 'expected', ['number', 'bigint']),
        this.assert(
          p < u,
          `expected ${p} to be less than ${u}`,
          `expected ${p} to be not less than ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    o('toBeLessThanOrEqual', function (u) {
      const p = this._obj;
      return (
        er(p, 'actual', ['number', 'bigint']),
        er(u, 'expected', ['number', 'bigint']),
        this.assert(
          p <= u,
          `expected ${p} to be less than or equal to ${u}`,
          `expected ${p} to be not less than or equal to ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    o('toBeNaN', function () {
      const u = t.flag(this, 'object');
      this.assert(
        Number.isNaN(u),
        'expected #{this} to be NaN',
        'expected #{this} not to be NaN',
        Number.NaN,
        u,
      );
    }),
    o('toBeUndefined', function () {
      const u = t.flag(this, 'object');
      this.assert(
        u === void 0,
        'expected #{this} to be undefined',
        'expected #{this} not to be undefined',
        void 0,
        u,
      );
    }),
    o('toBeNull', function () {
      const u = t.flag(this, 'object');
      this.assert(
        u === null,
        'expected #{this} to be null',
        'expected #{this} not to be null',
        null,
        u,
      );
    }),
    o('toBeDefined', function () {
      const u = t.flag(this, 'object');
      this.assert(
        typeof u < 'u',
        'expected #{this} to be defined',
        'expected #{this} to be undefined',
        u,
      );
    }),
    o('toBeTypeOf', function (u) {
      const p = typeof this._obj,
        f = u === p;
      return this.assert(
        f,
        'expected #{this} to be type of #{exp}',
        'expected #{this} not to be type of #{exp}',
        u,
        p,
      );
    }),
    o('toBeInstanceOf', function (u) {
      return this.instanceOf(u);
    }),
    o('toHaveLength', function (u) {
      return this.have.length(u);
    }),
    o('toHaveProperty', function (...u) {
      Array.isArray(u[0]) &&
        (u[0] = u[0].map((S) => String(S).replace(/([.[\]])/g, '\\$1')).join('.'));
      const p = this._obj,
        [f, m] = u,
        h = s(
          () =>
            Object.prototype.hasOwnProperty.call(p, f)
              ? { value: p[f], exists: !0 }
              : t.getPathInfo(p, f),
          'getValue',
        ),
        { value: g, exists: v } = h(),
        E = v && (u.length === 1 || Ae(m, g, n)),
        b = u.length === 1 ? '' : ` with value ${t.objDisplay(m)}`;
      return this.assert(
        E,
        `expected #{this} to have property "${f}"${b}`,
        `expected #{this} to not have property "${f}"${b}`,
        m,
        v ? g : void 0,
      );
    }),
    o('toBeCloseTo', function (u, p = 2) {
      const f = this._obj;
      let m = !1,
        h = 0,
        g = 0;
      return (
        (u === Number.POSITIVE_INFINITY && f === Number.POSITIVE_INFINITY) ||
        (u === Number.NEGATIVE_INFINITY && f === Number.NEGATIVE_INFINITY)
          ? (m = !0)
          : ((h = 10 ** -p / 2), (g = Math.abs(f - u)), (m = g < h)),
        this.assert(
          m,
          `expected #{this} to be close to #{exp}, received difference is ${g}, but expected ${h}`,
          `expected #{this} to not be close to #{exp}, received difference is ${g}, but expected ${h}`,
          u,
          f,
          !1,
        )
      );
    }));
  function i(u) {
    if (!wn(u._obj)) throw new TypeError(`${t.inspect(u._obj)} is not a spy or a call to a spy!`);
  }
  s(i, 'assertIsMock');
  function a(u) {
    return (i(u), u._obj);
  }
  (s(a, 'getSpy'),
    o(['toHaveBeenCalledTimes', 'toBeCalledTimes'], function (u) {
      const p = a(this),
        f = p.getMockName(),
        m = p.mock.calls.length;
      return this.assert(
        m === u,
        `expected "${f}" to be called #{exp} times, but got ${m} times`,
        `expected "${f}" to not be called #{exp} times`,
        u,
        m,
        !1,
      );
    }),
    o('toHaveBeenCalledOnce', function () {
      const u = a(this),
        p = u.getMockName(),
        f = u.mock.calls.length;
      return this.assert(
        f === 1,
        `expected "${p}" to be called once, but got ${f} times`,
        `expected "${p}" to not be called once`,
        1,
        f,
        !1,
      );
    }),
    o(['toHaveBeenCalled', 'toBeCalled'], function () {
      const u = a(this),
        p = u.getMockName(),
        f = u.mock.calls.length,
        m = f > 0,
        h = t.flag(this, 'negate');
      let g = t.getMessage(this, [
        m,
        `expected "${p}" to be called at least once`,
        `expected "${p}" to not be called at all, but actually been called ${f} times`,
        !0,
        m,
      ]);
      if ((m && h && (g = ea(u, g)), (m && h) || (!m && !h))) throw new r(g);
    }));
  function c(u, p) {
    return u.length === p.length && u.every((f, m) => Ae(f, p[m], [...n, Ct]));
  }
  (s(c, 'equalsArgumentArray'),
    o(['toHaveBeenCalledWith', 'toBeCalledWith'], function (...u) {
      const p = a(this),
        f = p.getMockName(),
        m = p.mock.calls.some((v) => c(v, u)),
        h = t.flag(this, 'negate'),
        g = t.getMessage(this, [
          m,
          `expected "${f}" to be called with arguments: #{exp}`,
          `expected "${f}" to not be called with arguments: #{exp}`,
          u,
        ]);
      if ((m && h) || (!m && !h)) throw new r(ea(p, g, u));
    }),
    o('toHaveBeenCalledExactlyOnceWith', function (...u) {
      const p = a(this),
        f = p.getMockName(),
        m = p.mock.calls.length,
        g = p.mock.calls.some((b) => c(b, u)) && m === 1,
        v = t.flag(this, 'negate'),
        E = t.getMessage(this, [
          g,
          `expected "${f}" to be called once with arguments: #{exp}`,
          `expected "${f}" to not be called once with arguments: #{exp}`,
          u,
        ]);
      if ((g && v) || (!g && !v)) throw new r(ea(p, E, u));
    }),
    o(['toHaveBeenNthCalledWith', 'nthCalledWith'], function (u, ...p) {
      const f = a(this),
        m = f.getMockName(),
        h = f.mock.calls[u - 1],
        g = f.mock.calls.length,
        v = u <= g;
      this.assert(
        h && c(h, p),
        `expected ${lo(u)} "${m}" call to have been called with #{exp}${v ? '' : `, but called only ${g} times`}`,
        `expected ${lo(u)} "${m}" call to not have been called with #{exp}`,
        p,
        h,
        v,
      );
    }),
    o(['toHaveBeenLastCalledWith', 'lastCalledWith'], function (...u) {
      const p = a(this),
        f = p.getMockName(),
        m = p.mock.calls[p.mock.calls.length - 1];
      this.assert(
        m && c(m, u),
        `expected last "${f}" call to have been called with #{exp}`,
        `expected last "${f}" call to not have been called with #{exp}`,
        u,
        m,
      );
    }));
  function d(u, p, f) {
    const m = u.mock.invocationCallOrder,
      h = p.mock.invocationCallOrder;
    return m.length === 0 ? !f : h.length === 0 ? !1 : m[0] < h[0];
  }
  (s(d, 'isSpyCalledBeforeAnotherSpy'),
    o(['toHaveBeenCalledBefore'], function (u, p = !0) {
      const f = a(this);
      if (!wn(u)) throw new TypeError(`${t.inspect(u)} is not a spy or a call to a spy`);
      this.assert(
        d(f, u, p),
        `expected "${f.getMockName()}" to have been called before "${u.getMockName()}"`,
        `expected "${f.getMockName()}" to not have been called before "${u.getMockName()}"`,
        u,
        f,
      );
    }),
    o(['toHaveBeenCalledAfter'], function (u, p = !0) {
      const f = a(this);
      if (!wn(u)) throw new TypeError(`${t.inspect(u)} is not a spy or a call to a spy`);
      this.assert(
        d(u, f, p),
        `expected "${f.getMockName()}" to have been called after "${u.getMockName()}"`,
        `expected "${f.getMockName()}" to not have been called after "${u.getMockName()}"`,
        u,
        f,
      );
    }),
    o(['toThrow', 'toThrowError'], function (u) {
      if (typeof u == 'string' || typeof u > 'u' || u instanceof RegExp)
        return this.throws(u === '' ? /^$/ : u);
      const p = this._obj,
        f = t.flag(this, 'promise'),
        m = t.flag(this, 'negate');
      let h = null;
      if (f === 'rejects') h = p;
      else if (f === 'resolves' && typeof p != 'function') {
        if (m) return;
        {
          const g = t.flag(this, 'message') || "expected promise to throw an error, but it didn't",
            v = { showDiff: !1 };
          throw new r(g, v, t.flag(this, 'ssfi'));
        }
      } else {
        let g = !1;
        try {
          p();
        } catch (v) {
          ((g = !0), (h = v));
        }
        if (!g && !m) {
          const v = t.flag(this, 'message') || "expected function to throw an error, but it didn't",
            E = { showDiff: !1 };
          throw new r(v, E, t.flag(this, 'ssfi'));
        }
      }
      if (typeof u == 'function') {
        const g = u.name || u.prototype.constructor.name;
        return this.assert(
          h && h instanceof u,
          `expected error to be instance of ${g}`,
          `expected error not to be instance of ${g}`,
          u,
          h,
        );
      }
      if (u instanceof Error) {
        const g = Ae(h, u, [...n, Ct]);
        return this.assert(
          g,
          'expected a thrown error to be #{exp}',
          'expected a thrown error not to be #{exp}',
          u,
          h,
        );
      }
      if (
        typeof u == 'object' &&
        'asymmetricMatch' in u &&
        typeof u.asymmetricMatch == 'function'
      ) {
        const g = u;
        return this.assert(
          h && g.asymmetricMatch(h),
          'expected error to match asymmetric matcher',
          'expected error not to match asymmetric matcher',
          g,
          h,
        );
      }
      throw new Error(
        `"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof u}"`,
      );
    }),
    [
      {
        name: 'toHaveResolved',
        condition: s(
          (u) =>
            u.mock.settledResults.length > 0 &&
            u.mock.settledResults.some(({ type: p }) => p === 'fulfilled'),
          'condition',
        ),
        action: 'resolved',
      },
      {
        name: ['toHaveReturned', 'toReturn'],
        condition: s(
          (u) => u.mock.calls.length > 0 && u.mock.results.some(({ type: p }) => p !== 'throw'),
          'condition',
        ),
        action: 'called',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function () {
        const m = a(this),
          h = m.getMockName(),
          g = p(m);
        this.assert(
          g,
          `expected "${h}" to be successfully ${f} at least once`,
          `expected "${h}" to not be successfully ${f}`,
          g,
          !g,
          !1,
        );
      });
    }),
    [
      {
        name: 'toHaveResolvedTimes',
        condition: s(
          (u, p) =>
            u.mock.settledResults.reduce((f, { type: m }) => (m === 'fulfilled' ? ++f : f), 0) ===
            p,
          'condition',
        ),
        action: 'resolved',
      },
      {
        name: ['toHaveReturnedTimes', 'toReturnTimes'],
        condition: s(
          (u, p) => u.mock.results.reduce((f, { type: m }) => (m === 'throw' ? f : ++f), 0) === p,
          'condition',
        ),
        action: 'called',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function (m) {
        const h = a(this),
          g = h.getMockName(),
          v = p(h, m);
        this.assert(
          v,
          `expected "${g}" to be successfully ${f} ${m} times`,
          `expected "${g}" to not be successfully ${f} ${m} times`,
          `expected resolved times: ${m}`,
          `received resolved times: ${v}`,
          !1,
        );
      });
    }),
    [
      {
        name: 'toHaveResolvedWith',
        condition: s(
          (u, p) =>
            u.mock.settledResults.some(({ type: f, value: m }) => f === 'fulfilled' && Ae(p, m)),
          'condition',
        ),
        action: 'resolve',
      },
      {
        name: ['toHaveReturnedWith', 'toReturnWith'],
        condition: s(
          (u, p) => u.mock.results.some(({ type: f, value: m }) => f === 'return' && Ae(p, m)),
          'condition',
        ),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function (m) {
        const h = a(this),
          g = p(h, m),
          v = t.flag(this, 'negate');
        if ((g && v) || (!g && !v)) {
          const E = h.getMockName(),
            b = t.getMessage(this, [
              g,
              `expected "${E}" to ${f} with: #{exp} at least once`,
              `expected "${E}" to not ${f} with: #{exp}`,
              m,
            ]),
            S = f === 'return' ? h.mock.results : h.mock.settledResults;
          throw new r(DA(h, S, b, m));
        }
      });
    }),
    [
      {
        name: 'toHaveLastResolvedWith',
        condition: s((u, p) => {
          const f = u.mock.settledResults[u.mock.settledResults.length - 1];
          return f && f.type === 'fulfilled' && Ae(f.value, p);
        }, 'condition'),
        action: 'resolve',
      },
      {
        name: ['toHaveLastReturnedWith', 'lastReturnedWith'],
        condition: s((u, p) => {
          const f = u.mock.results[u.mock.results.length - 1];
          return f && f.type === 'return' && Ae(f.value, p);
        }, 'condition'),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function (m) {
        const h = a(this),
          g = f === 'return' ? h.mock.results : h.mock.settledResults,
          v = g[g.length - 1],
          E = h.getMockName();
        this.assert(
          p(h, m),
          `expected last "${E}" call to ${f} #{exp}`,
          `expected last "${E}" call to not ${f} #{exp}`,
          m,
          v?.value,
        );
      });
    }),
    [
      {
        name: 'toHaveNthResolvedWith',
        condition: s((u, p, f) => {
          const m = u.mock.settledResults[p - 1];
          return m && m.type === 'fulfilled' && Ae(m.value, f);
        }, 'condition'),
        action: 'resolve',
      },
      {
        name: ['toHaveNthReturnedWith', 'nthReturnedWith'],
        condition: s((u, p, f) => {
          const m = u.mock.results[p - 1];
          return m && m.type === 'return' && Ae(m.value, f);
        }, 'condition'),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function (m, h) {
        const g = a(this),
          v = g.getMockName(),
          b = (f === 'return' ? g.mock.results : g.mock.settledResults)[m - 1],
          S = `${lo(m)} call`;
        this.assert(
          p(g, m, h),
          `expected ${S} "${v}" call to ${f} #{exp}`,
          `expected ${S} "${v}" call to not ${f} #{exp}`,
          h,
          b?.value,
        );
      });
    }),
    o('withContext', function (u) {
      for (const p in u) t.flag(this, p, u[p]);
      return this;
    }),
    t.addProperty(
      e.Assertion.prototype,
      'resolves',
      s(function () {
        const p = new Error('resolves');
        (t.flag(this, 'promise', 'resolves'), t.flag(this, 'error', p));
        const f = t.flag(this, 'vitest-test'),
          m = t.flag(this, 'object');
        if (t.flag(this, 'poll'))
          throw new SyntaxError('expect.poll() is not supported in combination with .resolves');
        if (typeof m?.then != 'function')
          throw new TypeError(
            `You must provide a Promise to expect() when using .resolves, not '${typeof m}'.`,
          );
        const h = new Proxy(this, {
          get: s((g, v, E) => {
            const b = Reflect.get(g, v, E);
            return typeof b != 'function'
              ? b instanceof e.Assertion
                ? h
                : b
              : (...S) => {
                  t.flag(this, '_name', v);
                  const R = m.then(
                    (I) => (t.flag(this, 'object', I), b.call(this, ...S)),
                    (I) => {
                      const q = new r(`promise rejected "${t.inspect(I)}" instead of resolving`, {
                        showDiff: !1,
                      });
                      throw ((q.cause = I), (q.stack = p.stack.replace(p.message, q.message)), q);
                    },
                  );
                  return Sd(f, R, wd(t, this, !!S.length), p);
                };
          }, 'get'),
        });
        return h;
      }, '__VITEST_RESOLVES__'),
    ),
    t.addProperty(
      e.Assertion.prototype,
      'rejects',
      s(function () {
        const p = new Error('rejects');
        (t.flag(this, 'promise', 'rejects'), t.flag(this, 'error', p));
        const f = t.flag(this, 'vitest-test'),
          m = t.flag(this, 'object'),
          h = typeof m == 'function' ? m() : m;
        if (t.flag(this, 'poll'))
          throw new SyntaxError('expect.poll() is not supported in combination with .rejects');
        if (typeof h?.then != 'function')
          throw new TypeError(
            `You must provide a Promise to expect() when using .rejects, not '${typeof h}'.`,
          );
        const g = new Proxy(this, {
          get: s((v, E, b) => {
            const S = Reflect.get(v, E, b);
            return typeof S != 'function'
              ? S instanceof e.Assertion
                ? g
                : S
              : (...R) => {
                  t.flag(this, '_name', E);
                  const I = h.then(
                    (q) => {
                      const P = new r(`promise resolved "${t.inspect(q)}" instead of rejecting`, {
                        showDiff: !0,
                        expected: new Error('rejected promise'),
                        actual: q,
                      });
                      throw ((P.stack = p.stack.replace(p.message, P.message)), P);
                    },
                    (q) => (t.flag(this, 'object', q), S.call(this, ...R)),
                  );
                  return Sd(f, I, wd(t, this, !!R.length), p);
                };
          }, 'get'),
        });
        return g;
      }, '__VITEST_REJECTS__'),
    ));
}, 'JestChaiExpect');
function lo(e) {
  const t = e % 10,
    r = e % 100;
  return t === 1 && r !== 11
    ? `${e}st`
    : t === 2 && r !== 12
      ? `${e}nd`
      : t === 3 && r !== 13
        ? `${e}rd`
        : `${e}th`;
}
s(lo, 'ordinalOf');
function ea(e, t, r) {
  return (
    e.mock.calls.length &&
      (t += Ue.gray(`

Received: 

${e.mock.calls.map((n, o) => {
  let i = Ue.bold(`  ${lo(o + 1)} ${e.getMockName()} call:

`);
  return (
    r
      ? (i += Bn(r, n, { omitAnnotationLines: !0 }))
      : (i += Et(n)
          .split(
            `
`,
          )
          .map((a) => `    ${a}`).join(`
`)),
    (i += `
`),
    i
  );
}).join(`
`)}`)),
    (t += Ue.gray(`

Number of calls: ${Ue.bold(e.mock.calls.length)}
`)),
    t
  );
}
s(ea, 'formatCalls');
function DA(e, t, r, n) {
  return (
    t.length &&
      (r += Ue.gray(`

Received: 

${t.map((o, i) => {
  let a = Ue.bold(`  ${lo(i + 1)} ${e.getMockName()} call return:

`);
  return (
    n
      ? (a += Bn(n, o.value, { omitAnnotationLines: !0 }))
      : (a += Et(o)
          .split(
            `
`,
          )
          .map((c) => `    ${c}`).join(`
`)),
    (a += `
`),
    a
  );
}).join(`
`)}`)),
    (r += Ue.gray(`

Number of calls: ${Ue.bold(e.mock.calls.length)}
`)),
    r
  );
}
s(DA, 'formatReturns');
function LA(e, t) {
  const r = e._obj,
    n = rr.flag(e, 'negate'),
    o = rr.flag(e, 'promise') || '',
    i = { ...hy(), diff: Bn, stringify: Et, iterableEquality: Ct, subsetEquality: Bo };
  return {
    state: {
      ...si(t),
      customTesters: hc(),
      isNot: n,
      utils: i,
      promise: o,
      equals: Ae,
      suppressedErrors: [],
      soft: rr.flag(e, 'soft'),
      poll: rr.flag(e, 'poll'),
    },
    isNot: n,
    obj: r,
  };
}
s(LA, 'getMatcherState');
var FA = class extends Error {
  constructor(t, r, n) {
    (super(t), (this.actual = r), (this.expected = n));
  }
};
s(FA, 'JestExtendError');
var lb = FA;
function BA(e, t, r) {
  return (n, o) => {
    Object.entries(r).forEach(([i, a]) => {
      function c(...m) {
        const { state: h, isNot: g, obj: v } = LA(this, t),
          E = a.call(h, v, ...m);
        if (E && typeof E == 'object' && typeof E.then == 'function')
          return E.then(({ pass: P, message: A, actual: w, expected: _ }) => {
            if ((P && g) || (!P && !g)) throw new lb(A(), w, _);
          });
        const { pass: b, message: S, actual: R, expected: I } = E;
        if ((b && g) || (!b && !g)) throw new lb(S(), R, I);
      }
      s(c, 'expectWrapper');
      const d = by(o, i, c);
      (o.addMethod(globalThis[oi].matchers, i, d), o.addMethod(e.Assertion.prototype, i, d));
      const u = class extends qr {
        constructor(h = !1, ...g) {
          super(g, h);
        }
        asymmetricMatch(h) {
          const { pass: g } = a.call(this.getMatcherContext(t), h, ...this.sample);
          return this.inverse ? !g : g;
        }
        toString() {
          return `${this.inverse ? 'not.' : ''}${i}`;
        }
        getExpectedType() {
          return 'any';
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((h) => Et(h)).join(', ')}>`;
        }
      };
      s(u, 'CustomMatcher');
      let p = u;
      const f = s((...m) => new p(!1, ...m), 'customMatcher');
      (Object.defineProperty(t, i, { configurable: !0, enumerable: !0, value: f, writable: !0 }),
        Object.defineProperty(t.not, i, {
          configurable: !0,
          enumerable: !0,
          value: s((...m) => new p(!0, ...m), 'value'),
          writable: !0,
        }),
        Object.defineProperty(globalThis[yd], i, {
          configurable: !0,
          enumerable: !0,
          value: f,
          writable: !0,
        }));
    });
  };
}
s(BA, 'JestExtendPlugin');
var tJ = s((e, t) => {
  t.addMethod(e.expect, 'extend', (r, n) => {
    Tn(BA(e, r, n));
  });
}, 'JestExtend');
function JA() {
  (Tn(tJ), Tn(eJ), Tn(ZB));
  const e = s((n, o) => {
    const { assertionCalls: i } = si(e);
    return (Zi({ assertionCalls: i + 1, soft: !1 }, e), Ur(n, o));
  }, 'expect');
  (Object.assign(e, Ur),
    (e.getState = () => si(e)),
    (e.setState = (n) => Zi(n, e)),
    (e.extend = (n) => Ur.extend(e, n)),
    (e.soft = (...n) => {
      const o = e(...n);
      return (e.setState({ soft: !0 }), o);
    }),
    e.extend(HB),
    (e.unreachable = (n) => {
      M.fail(`expected${n ? ` "${n}" ` : ' '}not to be reached`);
    }));
  function t(n) {
    const o = s(
      () =>
        new Error(
          `expected number of assertions to be ${n}, but got ${e.getState().assertionCalls}`,
        ),
      'errorGen',
    );
    ('captureStackTrace' in Error &&
      typeof Error.captureStackTrace == 'function' &&
      Error.captureStackTrace(o(), t),
      e.setState({ expectedAssertionsNumber: n, expectedAssertionsNumberErrorGen: o }));
  }
  s(t, 'assertions');
  function r() {
    const n = new Error('expected any number of assertion, but got none');
    ('captureStackTrace' in Error &&
      typeof Error.captureStackTrace == 'function' &&
      Error.captureStackTrace(n, r),
      e.setState({ isExpectingAssertions: !0, isExpectingAssertionsError: n }));
  }
  return (
    s(r, 'hasAssertions'),
    Zi(
      {
        assertionCalls: 0,
        isExpectingAssertions: !1,
        isExpectingAssertionsError: null,
        expectedAssertionsNumber: null,
        expectedAssertionsNumberErrorGen: null,
      },
      e,
    ),
    rr.addMethod(e, 'assertions', t),
    rr.addMethod(e, 'hasAssertions', r),
    e.extend(T_),
    e
  );
}
s(JA, 'createExpect');
var UA = JA();
Object.defineProperty(globalThis, fy, { value: UA, writable: !0, configurable: !0 });
function VA(e, t, r) {
  Object.defineProperty(e, t, r);
}
s(VA, 'f');
var ta = Symbol.for('tinyspy:spy'),
  rJ = s((e) => {
    ((e.called = !1),
      (e.callCount = 0),
      (e.calls = []),
      (e.results = []),
      (e.resolves = []),
      (e.next = []));
  }, 'P'),
  nJ = s((e) => (VA(e, ta, { value: { reset: s(() => rJ(e[ta]), 'reset') } }), e[ta]), 'K'),
  oJ = s((e) => e[ta] || nJ(e), 'T'),
  Ad = new Set();
function vy(e) {
  return (Ad.add(e), () => void Ad.delete(e));
}
s(vy, 'onMockCall');
var sJ = s((...e) => {
  const t = lA(...e);
  return Ey(t);
}, 'spyOn');
function Ty(e) {
  const t = e ? md(e) : md();
  return Ey(t);
}
s(Ty, 'fn');
function Ey(e) {
  const t = Rd(e),
    r = t.mockImplementation.bind(null);
  return ((t.mockImplementation = (n) => Rd(r(n))), t);
}
s(Ey, 'reactiveMock');
function Rd(e) {
  const t = oJ(e),
    r = t.impl;
  return (
    t.willCall(function (...n) {
      return (Ad.forEach((o) => o(e, n)), r?.apply(this, n));
    }),
    e
  );
}
s(Rd, 'listenWhenCalled');
function wy() {
  Mi.forEach((e) => e.mockClear());
}
s(wy, 'clearAllMocks');
function Sy() {
  Mi.forEach((e) => e.mockReset());
}
s(Sy, 'resetAllMocks');
function _y() {
  Mi.forEach((e) => e.mockRestore());
}
s(_y, 'restoreAllMocks');
function HA(e, t = {}) {
  return e;
}
s(HA, 'mocked');
var zA = {};
St(zA, {
  buildQueries: () => dr,
  configure: () => VR,
  createEvent: () => Fs,
  findAllByAltText: () => Dx,
  findAllByDisplayValue: () => Nx,
  findAllByLabelText: () => dx,
  findAllByPlaceholderText: () => Tx,
  findAllByRole: () => Qx,
  findAllByTestId: () => oP,
  findAllByText: () => Rx,
  findAllByTitle: () => Vx,
  findByAltText: () => Lx,
  findByDisplayValue: () => qx,
  findByLabelText: () => px,
  findByPlaceholderText: () => Ex,
  findByRole: () => Zx,
  findByTestId: () => sP,
  findByText: () => xx,
  findByTitle: () => Hx,
  fireEvent: () => Ro,
  getAllByAltText: () => $x,
  getAllByDisplayValue: () => Cx,
  getAllByLabelText: () => fx,
  getAllByPlaceholderText: () => bx,
  getAllByRole: () => Yx,
  getAllByTestId: () => rP,
  getAllByText: () => _x,
  getAllByTitle: () => Jx,
  getByAltText: () => kx,
  getByDisplayValue: () => Ix,
  getByLabelText: () => mx,
  getByPlaceholderText: () => vx,
  getByRole: () => Xx,
  getByTestId: () => nP,
  getByText: () => Ax,
  getByTitle: () => Ux,
  getConfig: () => Ee,
  getDefaultNormalizer: () => Ec,
  getElementError: () => ki,
  getMultipleElementsFoundError: () => Di,
  getNodeText: () => Jo,
  getQueriesForElement: () => za,
  getRoles: () => Vy,
  getSuggestedQuery: () => ai,
  isInaccessible: () => $i,
  logDOM: () => qd,
  logRoles: () => PJ,
  makeFindQuery: () => Cn,
  makeGetAllQuery: () => _c,
  makeSingleQuery: () => On,
  prettyDOM: () => Ao,
  prettyFormat: () => Ay,
  queries: () => Ha,
  queryAllByAltText: () => Mx,
  queryAllByAttribute: () => nn,
  queryAllByDisplayValue: () => Px,
  queryAllByLabelText: () => yx,
  queryAllByPlaceholderText: () => hx,
  queryAllByRole: () => Wx,
  queryAllByTestId: () => eP,
  queryAllByText: () => wx,
  queryAllByTitle: () => Fx,
  queryByAltText: () => jx,
  queryByAttribute: () => zy,
  queryByDisplayValue: () => Ox,
  queryByLabelText: () => cx,
  queryByPlaceholderText: () => gx,
  queryByRole: () => Kx,
  queryByTestId: () => tP,
  queryByText: () => Sx,
  queryByTitle: () => Bx,
  queryHelpers: () => OJ,
  screen: () => KJ,
  waitFor: () => Sc,
  waitForElementToBeRemoved: () => aP,
  within: () => za,
  wrapAllByQueryWithSuggestion: () => wt,
  wrapSingleQueryWithSuggestion: () => Hr,
});
var Ay = Ge(H$()),
  iJ = Object.prototype.toString;
function xd(e) {
  return typeof e == 'function' || iJ.call(e) === '[object Function]';
}
s(xd, 'isCallable');
function GA(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
s(GA, 'toInteger');
var aJ = Math.pow(2, 53) - 1;
function WA(e) {
  var t = GA(e);
  return Math.min(Math.max(t, 0), aJ);
}
s(WA, 'toLength');
function Dt(e, t) {
  var r = Array,
    n = Object(e);
  if (e == null)
    throw new TypeError('Array.from requires an array-like object - not null or undefined');
  if (typeof t < 'u' && !xd(t))
    throw new TypeError('Array.from: when provided, the second argument must be a function');
  for (var o = WA(n.length), i = xd(r) ? Object(new r(o)) : new Array(o), a = 0, c; a < o; )
    ((c = n[a]), t ? (i[a] = t(c, a)) : (i[a] = c), (a += 1));
  return ((i.length = o), i);
}
s(Dt, 'arrayFrom');
function So(e) {
  '@babel/helpers - typeof';
  return (
    (So =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    So(e)
  );
}
s(So, '_typeof');
function KA(e, t) {
  if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
s(KA, '_classCallCheck');
function Pd(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    ((n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      'value' in n && (n.writable = !0),
      Object.defineProperty(e, Ry(n.key), n));
  }
}
s(Pd, '_defineProperties');
function YA(e, t, r) {
  return (
    t && Pd(e.prototype, t),
    r && Pd(e, r),
    Object.defineProperty(e, 'prototype', { writable: !1 }),
    e
  );
}
s(YA, '_createClass');
function XA(e, t, r) {
  return (
    (t = Ry(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(XA, '_defineProperty');
function Ry(e) {
  var t = QA(e, 'string');
  return So(t) === 'symbol' ? t : String(t);
}
s(Ry, '_toPropertyKey');
function QA(e, t) {
  if (So(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (So(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
s(QA, '_toPrimitive');
var lJ = (function () {
    function e() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      (KA(this, e), XA(this, 'items', void 0), (this.items = t));
    }
    return (
      s(e, 'SetLike'),
      YA(e, [
        {
          key: 'add',
          value: s(function (r) {
            return (this.has(r) === !1 && this.items.push(r), this);
          }, 'add'),
        },
        {
          key: 'clear',
          value: s(function () {
            this.items = [];
          }, 'clear'),
        },
        {
          key: 'delete',
          value: s(function (r) {
            var n = this.items.length;
            return (
              (this.items = this.items.filter(function (o) {
                return o !== r;
              })),
              n !== this.items.length
            );
          }, '_delete'),
        },
        {
          key: 'forEach',
          value: s(function (r) {
            var n = this;
            this.items.forEach(function (o) {
              r(o, o, n);
            });
          }, 'forEach'),
        },
        {
          key: 'has',
          value: s(function (r) {
            return this.items.indexOf(r) !== -1;
          }, 'has'),
        },
        {
          key: 'size',
          get: s(function () {
            return this.items.length;
          }, 'get'),
        },
      ]),
      e
    );
  })(),
  cJ = typeof Set > 'u' ? Set : lJ;
function dt(e) {
  var t;
  return (t = e.localName) !== null && t !== void 0 ? t : e.tagName.toLowerCase();
}
s(dt, 'getLocalName');
var uJ = {
    article: 'article',
    aside: 'complementary',
    button: 'button',
    datalist: 'listbox',
    dd: 'definition',
    details: 'group',
    dialog: 'dialog',
    dt: 'term',
    fieldset: 'group',
    figure: 'figure',
    form: 'form',
    footer: 'contentinfo',
    h1: 'heading',
    h2: 'heading',
    h3: 'heading',
    h4: 'heading',
    h5: 'heading',
    h6: 'heading',
    header: 'banner',
    hr: 'separator',
    html: 'document',
    legend: 'legend',
    li: 'listitem',
    math: 'math',
    main: 'main',
    menu: 'list',
    nav: 'navigation',
    ol: 'list',
    optgroup: 'group',
    option: 'option',
    output: 'status',
    progress: 'progressbar',
    section: 'region',
    summary: 'button',
    table: 'table',
    tbody: 'rowgroup',
    textarea: 'textbox',
    tfoot: 'rowgroup',
    td: 'cell',
    th: 'columnheader',
    thead: 'rowgroup',
    tr: 'row',
    ul: 'list',
  },
  dJ = {
    caption: new Set(['aria-label', 'aria-labelledby']),
    code: new Set(['aria-label', 'aria-labelledby']),
    deletion: new Set(['aria-label', 'aria-labelledby']),
    emphasis: new Set(['aria-label', 'aria-labelledby']),
    generic: new Set(['aria-label', 'aria-labelledby', 'aria-roledescription']),
    insertion: new Set(['aria-label', 'aria-labelledby']),
    paragraph: new Set(['aria-label', 'aria-labelledby']),
    presentation: new Set(['aria-label', 'aria-labelledby']),
    strong: new Set(['aria-label', 'aria-labelledby']),
    subscript: new Set(['aria-label', 'aria-labelledby']),
    superscript: new Set(['aria-label', 'aria-labelledby']),
  };
function ZA(e, t) {
  return [
    'aria-atomic',
    'aria-busy',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-dropeffect',
    'aria-flowto',
    'aria-grabbed',
    'aria-hidden',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-live',
    'aria-owns',
    'aria-relevant',
    'aria-roledescription',
  ].some(function (r) {
    var n;
    return e.hasAttribute(r) && !((n = dJ[t]) !== null && n !== void 0 && n.has(r));
  });
}
s(ZA, 'hasGlobalAriaAttributes');
function xy(e, t) {
  return ZA(e, t);
}
s(xy, 'ignorePresentationalRole');
function eR(e) {
  var t = rR(e);
  if (t === null || t === 'presentation') {
    var r = tR(e);
    if (t !== 'presentation' || xy(e, r || '')) return r;
  }
  return t;
}
s(eR, 'getRole');
function tR(e) {
  var t = uJ[dt(e)];
  if (t !== void 0) return t;
  switch (dt(e)) {
    case 'a':
    case 'area':
    case 'link':
      if (e.hasAttribute('href')) return 'link';
      break;
    case 'img':
      return e.getAttribute('alt') === '' && !xy(e, 'img') ? 'presentation' : 'img';
    case 'input': {
      var r = e,
        n = r.type;
      switch (n) {
        case 'button':
        case 'image':
        case 'reset':
        case 'submit':
          return 'button';
        case 'checkbox':
        case 'radio':
          return n;
        case 'range':
          return 'slider';
        case 'email':
        case 'tel':
        case 'text':
        case 'url':
          return e.hasAttribute('list') ? 'combobox' : 'textbox';
        case 'search':
          return e.hasAttribute('list') ? 'combobox' : 'searchbox';
        case 'number':
          return 'spinbutton';
        default:
          return null;
      }
    }
    case 'select':
      return e.hasAttribute('multiple') || e.size > 1 ? 'listbox' : 'combobox';
  }
  return null;
}
s(tR, 'getImplicitRole');
function rR(e) {
  var t = e.getAttribute('role');
  if (t !== null) {
    var r = t.trim().split(' ')[0];
    if (r.length > 0) return r;
  }
  return null;
}
s(rR, 'getExplicitRole');
function $e(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
s($e, 'isElement');
function Py(e) {
  return $e(e) && dt(e) === 'caption';
}
s(Py, 'isHTMLTableCaptionElement');
function Ls(e) {
  return $e(e) && dt(e) === 'input';
}
s(Ls, 'isHTMLInputElement');
function nR(e) {
  return $e(e) && dt(e) === 'optgroup';
}
s(nR, 'isHTMLOptGroupElement');
function oR(e) {
  return $e(e) && dt(e) === 'select';
}
s(oR, 'isHTMLSelectElement');
function sR(e) {
  return $e(e) && dt(e) === 'table';
}
s(sR, 'isHTMLTableElement');
function iR(e) {
  return $e(e) && dt(e) === 'textarea';
}
s(iR, 'isHTMLTextAreaElement');
function aR(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument,
    r = t.defaultView;
  if (r === null) throw new TypeError('no window available');
  return r;
}
s(aR, 'safeWindow');
function lR(e) {
  return $e(e) && dt(e) === 'fieldset';
}
s(lR, 'isHTMLFieldSetElement');
function cR(e) {
  return $e(e) && dt(e) === 'legend';
}
s(cR, 'isHTMLLegendElement');
function uR(e) {
  return $e(e) && dt(e) === 'slot';
}
s(uR, 'isHTMLSlotElement');
function dR(e) {
  return $e(e) && e.ownerSVGElement !== void 0;
}
s(dR, 'isSVGElement');
function pR(e) {
  return $e(e) && dt(e) === 'svg';
}
s(pR, 'isSVGSVGElement');
function fR(e) {
  return dR(e) && dt(e) === 'title';
}
s(fR, 'isSVGTitleElement');
function ii(e, t) {
  if ($e(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(' '),
      n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r
      .map(function (o) {
        return n.getElementById(o);
      })
      .filter(function (o) {
        return o !== null;
      });
  }
  return [];
}
s(ii, 'queryIdRefs');
function or(e, t) {
  return $e(e) ? t.indexOf(eR(e)) !== -1 : !1;
}
s(or, 'hasAnyConcreteRoles');
function mR(e) {
  return e.trim().replace(/\s\s+/g, ' ');
}
s(mR, 'asFlatString');
function yR(e, t) {
  if (!$e(e)) return !1;
  if (e.hasAttribute('hidden') || e.getAttribute('aria-hidden') === 'true') return !0;
  var r = t(e);
  return r.getPropertyValue('display') === 'none' || r.getPropertyValue('visibility') === 'hidden';
}
s(yR, 'isHidden');
function hR(e) {
  return or(e, ['button', 'combobox', 'listbox', 'textbox']) || Oy(e, 'range');
}
s(hR, 'isControl');
function Oy(e, t) {
  if (!$e(e)) return !1;
  switch (t) {
    case 'range':
      return or(e, ['meter', 'progressbar', 'scrollbar', 'slider', 'spinbutton']);
    default:
      throw new TypeError(
        "No knowledge about abstract role '".concat(t, "'. This is likely a bug :("),
      );
  }
}
s(Oy, 'hasAbstractRole');
function Od(e, t) {
  var r = Dt(e.querySelectorAll(t));
  return (
    ii(e, 'aria-owns').forEach(function (n) {
      r.push.apply(r, Dt(n.querySelectorAll(t)));
    }),
    r
  );
}
s(Od, 'querySelectorAllSubtree');
function gR(e) {
  return oR(e) ? e.selectedOptions || Od(e, '[selected]') : Od(e, '[aria-selected="true"]');
}
s(gR, 'querySelectedOptions');
function bR(e) {
  return or(e, ['none', 'presentation']);
}
s(bR, 'isMarkedPresentational');
function vR(e) {
  return Py(e);
}
s(vR, 'isNativeHostLanguageTextAlternativeElement');
function TR(e) {
  return or(e, [
    'button',
    'cell',
    'checkbox',
    'columnheader',
    'gridcell',
    'heading',
    'label',
    'legend',
    'link',
    'menuitem',
    'menuitemcheckbox',
    'menuitemradio',
    'option',
    'radio',
    'row',
    'rowheader',
    'switch',
    'tab',
    'tooltip',
    'treeitem',
  ]);
}
s(TR, 'allowsNameFromContent');
function ER(e) {
  return !1;
}
s(ER, 'isDescendantOfNativeHostLanguageTextAlternativeElement');
function wR(e) {
  return Ls(e) || iR(e) ? e.value : e.textContent || '';
}
s(wR, 'getValueOfTextbox');
function Cd(e) {
  var t = e.getPropertyValue('content');
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : '';
}
s(Cd, 'getTextualContent');
function Cy(e) {
  var t = dt(e);
  return (
    t === 'button' ||
    (t === 'input' && e.getAttribute('type') !== 'hidden') ||
    t === 'meter' ||
    t === 'output' ||
    t === 'progress' ||
    t === 'select' ||
    t === 'textarea'
  );
}
s(Cy, 'isLabelableElement');
function Iy(e) {
  if (Cy(e)) return e;
  var t = null;
  return (
    e.childNodes.forEach(function (r) {
      if (t === null && $e(r)) {
        var n = Iy(r);
        n !== null && (t = n);
      }
    }),
    t
  );
}
s(Iy, 'findLabelableElement');
function SR(e) {
  if (e.control !== void 0) return e.control;
  var t = e.getAttribute('for');
  return t !== null ? e.ownerDocument.getElementById(t) : Iy(e);
}
s(SR, 'getControlOfLabel');
function _R(e) {
  var t = e.labels;
  if (t === null) return t;
  if (t !== void 0) return Dt(t);
  if (!Cy(e)) return null;
  var r = e.ownerDocument;
  return Dt(r.querySelectorAll('label')).filter(function (n) {
    return SR(n) === e;
  });
}
s(_R, 'getLabels');
function AR(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? Dt(e.childNodes) : t;
}
s(AR, 'getSlotContents');
function Ny(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = new cJ(),
    n = aR(e),
    o = t.compute,
    i = o === void 0 ? 'name' : o,
    a = t.computedStyleSupportsPseudoElements,
    c = a === void 0 ? t.getComputedStyle !== void 0 : a,
    d = t.getComputedStyle,
    u = d === void 0 ? n.getComputedStyle.bind(n) : d,
    p = t.hidden,
    f = p === void 0 ? !1 : p;
  function m(b, S) {
    var R = '';
    if ($e(b) && c) {
      var I = u(b, '::before'),
        q = Cd(I);
      R = ''.concat(q, ' ').concat(R);
    }
    var P = uR(b) ? AR(b) : Dt(b.childNodes).concat(ii(b, 'aria-owns'));
    if (
      (P.forEach(function (_) {
        var $ = E(_, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !1, recursion: !0 }),
          N = $e(_) ? u(_).getPropertyValue('display') : 'inline',
          V = N !== 'inline' ? ' ' : '';
        R += ''.concat(V).concat($).concat(V);
      }),
      $e(b) && c)
    ) {
      var A = u(b, '::after'),
        w = Cd(A);
      R = ''.concat(R, ' ').concat(w);
    }
    return R.trim();
  }
  s(m, 'computeMiscTextAlternative');
  function h(b, S) {
    var R = b.getAttributeNode(S);
    return R !== null && !r.has(R) && R.value.trim() !== '' ? (r.add(R), R.value) : null;
  }
  s(h, 'useAttribute');
  function g(b) {
    return $e(b) ? h(b, 'title') : null;
  }
  s(g, 'computeTooltipAttributeValue');
  function v(b) {
    if (!$e(b)) return null;
    if (lR(b)) {
      r.add(b);
      for (var S = Dt(b.childNodes), R = 0; R < S.length; R += 1) {
        var I = S[R];
        if (cR(I)) return E(I, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (sR(b)) {
      r.add(b);
      for (var q = Dt(b.childNodes), P = 0; P < q.length; P += 1) {
        var A = q[P];
        if (Py(A)) return E(A, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (pR(b)) {
      r.add(b);
      for (var w = Dt(b.childNodes), _ = 0; _ < w.length; _ += 1) {
        var $ = w[_];
        if (fR($)) return $.textContent;
      }
      return null;
    } else if (dt(b) === 'img' || dt(b) === 'area') {
      var N = h(b, 'alt');
      if (N !== null) return N;
    } else if (nR(b)) {
      var V = h(b, 'label');
      if (V !== null) return V;
    }
    if (Ls(b) && (b.type === 'button' || b.type === 'submit' || b.type === 'reset')) {
      var H = h(b, 'value');
      if (H !== null) return H;
      if (b.type === 'submit') return 'Submit';
      if (b.type === 'reset') return 'Reset';
    }
    var x = _R(b);
    if (x !== null && x.length !== 0)
      return (
        r.add(b),
        Dt(x)
          .map(function (K) {
            return E(K, { isEmbeddedInLabel: !0, isReferenced: !1, recursion: !0 });
          })
          .filter(function (K) {
            return K.length > 0;
          })
          .join(' ')
      );
    if (Ls(b) && b.type === 'image') {
      var D = h(b, 'alt');
      if (D !== null) return D;
      var F = h(b, 'title');
      return F !== null ? F : 'Submit Query';
    }
    if (or(b, ['button'])) {
      var k = m(b, { isEmbeddedInLabel: !1 });
      if (k !== '') return k;
    }
    return null;
  }
  s(v, 'computeElementTextAlternative');
  function E(b, S) {
    if (r.has(b)) return '';
    if (!f && yR(b, u) && !S.isReferenced) return (r.add(b), '');
    var R = $e(b) ? b.getAttributeNode('aria-labelledby') : null,
      I = R !== null && !r.has(R) ? ii(b, 'aria-labelledby') : [];
    if (i === 'name' && !S.isReferenced && I.length > 0)
      return (
        r.add(R),
        I.map(function (N) {
          return E(N, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !0, recursion: !1 });
        }).join(' ')
      );
    var q = S.recursion && hR(b) && i === 'name';
    if (!q) {
      var P = (($e(b) && b.getAttribute('aria-label')) || '').trim();
      if (P !== '' && i === 'name') return (r.add(b), P);
      if (!bR(b)) {
        var A = v(b);
        if (A !== null) return (r.add(b), A);
      }
    }
    if (or(b, ['menu'])) return (r.add(b), '');
    if (q || S.isEmbeddedInLabel || S.isReferenced) {
      if (or(b, ['combobox', 'listbox'])) {
        r.add(b);
        var w = gR(b);
        return w.length === 0
          ? Ls(b)
            ? b.value
            : ''
          : Dt(w)
              .map(function (N) {
                return E(N, {
                  isEmbeddedInLabel: S.isEmbeddedInLabel,
                  isReferenced: !1,
                  recursion: !0,
                });
              })
              .join(' ');
      }
      if (Oy(b, 'range'))
        return (
          r.add(b),
          b.hasAttribute('aria-valuetext')
            ? b.getAttribute('aria-valuetext')
            : b.hasAttribute('aria-valuenow')
              ? b.getAttribute('aria-valuenow')
              : b.getAttribute('value') || ''
        );
      if (or(b, ['textbox'])) return (r.add(b), wR(b));
    }
    if (TR(b) || ($e(b) && S.isReferenced) || vR(b) || ER()) {
      var _ = m(b, { isEmbeddedInLabel: S.isEmbeddedInLabel });
      if (_ !== '') return (r.add(b), _);
    }
    if (b.nodeType === b.TEXT_NODE) return (r.add(b), b.textContent || '');
    if (S.recursion) return (r.add(b), m(b, { isEmbeddedInLabel: S.isEmbeddedInLabel }));
    var $ = g(b);
    return $ !== null ? (r.add(b), $) : (r.add(b), '');
  }
  return (
    s(E, 'computeTextAlternative'),
    mR(E(e, { isEmbeddedInLabel: !1, isReferenced: i === 'description', recursion: !1 }))
  );
}
s(Ny, 'computeTextAlternative');
function _o(e) {
  '@babel/helpers - typeof';
  return (
    (_o =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    _o(e)
  );
}
s(_o, '_typeof');
function Id(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    (t &&
      (n = n.filter(function (o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })),
      r.push.apply(r, n));
  }
  return r;
}
s(Id, 'ownKeys');
function Nd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? Id(Object(r), !0).forEach(function (n) {
          RR(e, n, r[n]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : Id(Object(r)).forEach(function (n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
          });
  }
  return e;
}
s(Nd, '_objectSpread');
function RR(e, t, r) {
  return (
    (t = xR(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(RR, '_defineProperty');
function xR(e) {
  var t = PR(e, 'string');
  return _o(t) === 'symbol' ? t : String(t);
}
s(xR, '_toPropertyKey');
function PR(e, t) {
  if (_o(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (_o(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
s(PR, '_toPrimitive');
function qy(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = ii(e, 'aria-describedby')
      .map(function (o) {
        return Ny(o, Nd(Nd({}, t), {}, { compute: 'description' }));
      })
      .join(' ');
  if (r === '') {
    var n = e.getAttribute('title');
    r = n === null ? '' : n;
  }
  return r;
}
s(qy, 'computeAccessibleDescription');
function OR(e) {
  return or(e, [
    'caption',
    'code',
    'deletion',
    'emphasis',
    'generic',
    'insertion',
    'paragraph',
    'presentation',
    'strong',
    'subscript',
    'superscript',
  ]);
}
s(OR, 'prohibitsNaming');
function vc(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return OR(e) ? '' : Ny(e, t);
}
s(vc, 'computeAccessibleName');
var $t = Ge(Cp()),
  pJ = Ge(z$());
function My(e) {
  return e.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
s(My, 'escapeHTML');
var fJ = s((e, t, r, n, o, i, a) => {
    const c = n + r.indent,
      d = r.colors;
    return e
      .map((u) => {
        const p = t[u];
        let f = a(p, r, c, o, i);
        return (
          typeof p != 'string' &&
            (f.indexOf(`
`) !== -1 && (f = r.spacingOuter + c + f + r.spacingOuter + n),
            (f = '{' + f + '}')),
          r.spacingInner +
            n +
            d.prop.open +
            u +
            d.prop.close +
            '=' +
            d.value.open +
            f +
            d.value.close
        );
      })
      .join('');
  }, 'printProps'),
  mJ = 3,
  yJ = s(
    (e, t, r, n, o, i) =>
      e
        .map((a) => {
          const c = typeof a == 'string' ? CR(a, t) : i(a, t, r, n, o);
          return c === '' && typeof a == 'object' && a !== null && a.nodeType !== mJ
            ? ''
            : t.spacingOuter + r + c;
        })
        .join(''),
    'printChildren',
  ),
  CR = s((e, t) => {
    const r = t.colors.content;
    return r.open + My(e) + r.close;
  }, 'printText'),
  hJ = s((e, t) => {
    const r = t.colors.comment;
    return r.open + '<!--' + My(e) + '-->' + r.close;
  }, 'printComment'),
  gJ = s((e, t, r, n, o) => {
    const i = n.colors.tag;
    return (
      i.open +
      '<' +
      e +
      (t && i.close + t + n.spacingOuter + o + i.open) +
      (r
        ? '>' + i.close + r + n.spacingOuter + o + i.open + '</' + e
        : (t && !n.min ? '' : ' ') + '/') +
      '>' +
      i.close
    );
  }, 'printElement'),
  bJ = s((e, t) => {
    const r = t.colors.tag;
    return r.open + '<' + e + r.close + ' ' + r.open + ' />' + r.close;
  }, 'printElementAsLeaf'),
  vJ = 1,
  IR = 3,
  NR = 8,
  qR = 11,
  TJ = /^((HTML|SVG)\w*)?Element$/,
  MR = s((e) => {
    const { tagName: t } = e;
    return !!(
      (typeof t == 'string' && t.includes('-')) ||
      (typeof e.hasAttribute == 'function' && e.hasAttribute('is'))
    );
  }, 'isCustomElement'),
  EJ = s((e) => {
    const t = e.constructor.name,
      { nodeType: r } = e;
    return (
      (r === vJ && (TJ.test(t) || MR(e))) ||
      (r === IR && t === 'Text') ||
      (r === NR && t === 'Comment') ||
      (r === qR && t === 'DocumentFragment')
    );
  }, 'testNode');
function jR(e) {
  return e.nodeType === IR;
}
s(jR, 'nodeIsText');
function $R(e) {
  return e.nodeType === NR;
}
s($R, 'nodeIsComment');
function ra(e) {
  return e.nodeType === qR;
}
s(ra, 'nodeIsFragment');
function kR(e) {
  return {
    test: s((t) => {
      var r;
      return ((t == null || (r = t.constructor) == null ? void 0 : r.name) || MR(t)) && EJ(t);
    }, 'test'),
    serialize: s((t, r, n, o, i, a) => {
      if (jR(t)) return CR(t.data, r);
      if ($R(t)) return hJ(t.data, r);
      const c = ra(t) ? 'DocumentFragment' : t.tagName.toLowerCase();
      return ++o > r.maxDepth
        ? bJ(c, r)
        : gJ(
            c,
            fJ(
              ra(t)
                ? []
                : Array.from(t.attributes)
                    .map((d) => d.name)
                    .sort(),
              ra(t)
                ? {}
                : Array.from(t.attributes).reduce((d, u) => ((d[u.name] = u.value), d), {}),
              r,
              n + r.indent,
              o,
              i,
              a,
            ),
            yJ(
              Array.prototype.slice.call(t.childNodes || t.children).filter(e),
              r,
              n + r.indent,
              o,
              i,
              a,
            ),
            r,
            n,
          );
    }, 'serialize'),
  };
}
s(kR, 'createDOMElementFilter');
var DR = null,
  jy = null,
  $y = null;
try {
  const e = module && module.require;
  ((jy = e.call(module, 'fs').readFileSync),
    ($y = e.call(module, '@babel/code-frame').codeFrameColumns),
    (DR = e.call(module, 'picocolors')));
} catch {}
function LR(e) {
  const t = e.indexOf('(') + 1,
    r = e.indexOf(')'),
    n = e.slice(t, r),
    o = n.split(':'),
    [i, a, c] = [o[0], parseInt(o[1], 10), parseInt(o[2], 10)];
  let d = '';
  try {
    d = jy(i, 'utf-8');
  } catch {
    return '';
  }
  const u = $y(d, { start: { line: a, column: c } }, { highlightCode: !0, linesBelow: 0 });
  return (
    DR.dim(n) +
    `
` +
    u +
    `
`
  );
}
s(LR, 'getCodeFrame');
function FR() {
  if (!jy || !$y) return '';
  const t = new Error().stack
    .split(
      `
`,
    )
    .slice(1)
    .find((r) => !r.includes('node_modules/'));
  return LR(t);
}
s(FR, 'getUserCodeFrame');
var BR = 3;
function na() {
  return typeof jest < 'u' && jest !== null
    ? setTimeout._isMockFunction === !0 || Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
    : !1;
}
s(na, 'jestFakeTimersAreEnabled');
function Tc() {
  if (typeof window > 'u') throw new Error('Could not find default container');
  return window.document;
}
s(Tc, 'getDocument');
function ky(e) {
  if (e.defaultView) return e.defaultView;
  if (e.ownerDocument && e.ownerDocument.defaultView) return e.ownerDocument.defaultView;
  if (e.window) return e.window;
  throw e.ownerDocument && e.ownerDocument.defaultView === null
    ? new Error('It looks like the window object is not available for the provided node.')
    : e.then instanceof Function
      ? new Error(
          'It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?',
        )
      : Array.isArray(e)
        ? new Error(
            'It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?',
          )
        : typeof e.debug == 'function' && typeof e.logTestingPlaygroundURL == 'function'
          ? new Error(
              'It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?',
            )
          : new Error('The given node is not an Element, the node type is: ' + typeof e + '.');
}
s(ky, 'getWindowFromNode');
function ur(e) {
  if (!e || typeof e.querySelector != 'function' || typeof e.querySelectorAll != 'function')
    throw new TypeError(
      'Expected container to be an Element, a Document or a DocumentFragment but got ' + t(e) + '.',
    );
  function t(r) {
    return typeof r == 'object' ? (r === null ? 'null' : r.constructor.name) : typeof r;
  }
  s(t, 'getTypeName');
}
s(ur, 'checkContainerType');
var wJ = s(() => {
    if (typeof process > 'u') return !1;
    let e;
    try {
      var t;
      const r = (t = Tu) == null ? void 0 : t.COLORS;
      r && (e = JSON.parse(r));
    } catch {}
    return typeof e == 'boolean'
      ? e
      : process.versions !== void 0 && process.versions.node !== void 0;
  }, 'shouldHighlight'),
  { DOMCollection: SJ } = Ay.plugins,
  _J = 1,
  AJ = 8;
function JR(e) {
  return e.nodeType !== AJ && (e.nodeType !== _J || !e.matches(Ee().defaultIgnore));
}
s(JR, 'filterCommentsAndDefaultIgnoreTagsTags');
function Ao(e, t, r) {
  if (
    (r === void 0 && (r = {}),
    e || (e = Tc().body),
    typeof t != 'number' &&
      (t = (typeof process < 'u' && typeof Tu < 'u' && Tu.DEBUG_PRINT_LIMIT) || 7e3),
    t === 0)
  )
    return '';
  e.documentElement && (e = e.documentElement);
  let n = typeof e;
  if ((n === 'object' ? (n = e.constructor.name) : (e = {}), !('outerHTML' in e)))
    throw new TypeError('Expected an element or document but got ' + n);
  const { filterNode: o = JR, ...i } = r,
    a = Ay.format(e, { plugins: [kR(o), SJ], printFunctionName: !1, highlight: wJ(), ...i });
  return t !== void 0 && e.outerHTML.length > t ? a.slice(0, t) + '...' : a;
}
s(Ao, 'prettyDOM');
var qd = s(function () {
    const e = FR();
    console.log(
      e
        ? Ao(...arguments) +
            `

` +
            e
        : Ao(...arguments),
    );
  }, 'logDOM'),
  Sn = {
    testIdAttribute: 'data-testid',
    asyncUtilTimeout: 1e3,
    asyncWrapper: s((e) => e(), 'asyncWrapper'),
    unstable_advanceTimersWrapper: s((e) => e(), 'unstable_advanceTimersWrapper'),
    eventWrapper: s((e) => e(), 'eventWrapper'),
    defaultHidden: !1,
    defaultIgnore: 'script, style',
    showOriginalStackTrace: !1,
    throwSuggestions: !1,
    getElementError(e, t) {
      const r = Ao(t),
        n = new Error(
          [
            e,
            'Ignored nodes: comments, ' +
              Sn.defaultIgnore +
              `
` +
              r,
          ].filter(Boolean).join(`

`),
        );
      return ((n.name = 'TestingLibraryElementError'), n);
    },
    _disableExpensiveErrorDiagnostics: !1,
    computedStyleSupportsPseudoElements: !1,
  };
function UR(e) {
  try {
    return ((Sn._disableExpensiveErrorDiagnostics = !0), e());
  } finally {
    Sn._disableExpensiveErrorDiagnostics = !1;
  }
}
s(UR, 'runWithExpensiveErrorDiagnosticsDisabled');
function VR(e) {
  (typeof e == 'function' && (e = e(Sn)), (Sn = { ...Sn, ...e }));
}
s(VR, 'configure');
function Ee() {
  return Sn;
}
s(Ee, 'getConfig');
var RJ = ['button', 'meter', 'output', 'progress', 'select', 'textarea', 'input'];
function Dy(e) {
  return RJ.includes(e.nodeName.toLowerCase())
    ? ''
    : e.nodeType === BR
      ? e.textContent
      : Array.from(e.childNodes)
          .map((t) => Dy(t))
          .join('');
}
s(Dy, 'getTextContent');
function Va(e) {
  let t;
  return (e.tagName.toLowerCase() === 'label' ? (t = Dy(e)) : (t = e.value || e.textContent), t);
}
s(Va, 'getLabelContent');
function Ly(e) {
  if (e.labels !== void 0) {
    var t;
    return (t = e.labels) != null ? t : [];
  }
  if (!HR(e)) return [];
  const r = e.ownerDocument.querySelectorAll('label');
  return Array.from(r).filter((n) => n.control === e);
}
s(Ly, 'getRealLabels');
function HR(e) {
  return (
    /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) ||
    (e.tagName === 'INPUT' && e.getAttribute('type') !== 'hidden')
  );
}
s(HR, 'isLabelable');
function Fy(e, t, r) {
  let { selector: n = '*' } = r === void 0 ? {} : r;
  const o = t.getAttribute('aria-labelledby'),
    i = o ? o.split(' ') : [];
  return i.length
    ? i.map((a) => {
        const c = e.querySelector('[id="' + a + '"]');
        return c ? { content: Va(c), formControl: null } : { content: '', formControl: null };
      })
    : Array.from(Ly(t)).map((a) => {
        const c = Va(a),
          u = Array.from(
            a.querySelectorAll('button, input, meter, output, progress, select, textarea'),
          ).filter((p) => p.matches(n))[0];
        return { content: c, formControl: u };
      });
}
s(Fy, 'getLabels');
function By(e) {
  if (e == null)
    throw new Error(
      'It looks like ' +
        e +
        ' was passed instead of a matcher. Did you do something like getByText(' +
        e +
        ')?',
    );
}
s(By, 'assertNotNullOrUndefined');
function Un(e, t, r, n) {
  if (typeof e != 'string') return !1;
  By(r);
  const o = n(e);
  return typeof r == 'string' || typeof r == 'number'
    ? o.toLowerCase().includes(r.toString().toLowerCase())
    : typeof r == 'function'
      ? r(o, t)
      : Jy(r, o);
}
s(Un, 'fuzzyMatches');
function ir(e, t, r, n) {
  if (typeof e != 'string') return !1;
  By(r);
  const o = n(e);
  return r instanceof Function ? r(o, t) : r instanceof RegExp ? Jy(r, o) : o === String(r);
}
s(ir, 'matches');
function Ec(e) {
  let { trim: t = !0, collapseWhitespace: r = !0 } = e === void 0 ? {} : e;
  return (n) => {
    let o = n;
    return ((o = t ? o.trim() : o), (o = r ? o.replace(/\s+/g, ' ') : o), o);
  };
}
s(Ec, 'getDefaultNormalizer');
function rn(e) {
  let { trim: t, collapseWhitespace: r, normalizer: n } = e;
  if (!n) return Ec({ trim: t, collapseWhitespace: r });
  if (typeof t < 'u' || typeof r < 'u')
    throw new Error(
      'trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer',
    );
  return n;
}
s(rn, 'makeNormalizer');
function Jy(e, t) {
  const r = e.test(t);
  return (
    e.global &&
      e.lastIndex !== 0 &&
      (console.warn(
        'To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.',
      ),
      (e.lastIndex = 0)),
    r
  );
}
s(Jy, 'matchRegExp');
function Jo(e) {
  return e.matches('input[type=submit], input[type=button], input[type=reset]')
    ? e.value
    : Array.from(e.childNodes)
        .filter((t) => t.nodeType === BR && !!t.textContent)
        .map((t) => t.textContent)
        .join('');
}
s(Jo, 'getNodeText');
var xJ = zR($t.elementRoles);
function Uy(e) {
  return (
    e.hidden === !0 ||
    e.getAttribute('aria-hidden') === 'true' ||
    e.ownerDocument.defaultView.getComputedStyle(e).display === 'none'
  );
}
s(Uy, 'isSubtreeInaccessible');
function $i(e, t) {
  t === void 0 && (t = {});
  const { isSubtreeInaccessible: r = Uy } = t;
  if (e.ownerDocument.defaultView.getComputedStyle(e).visibility === 'hidden') return !0;
  let o = e;
  for (; o; ) {
    if (r(o)) return !0;
    o = o.parentElement;
  }
  return !1;
}
s($i, 'isInaccessible');
function wc(e) {
  for (const { match: t, roles: r } of xJ) if (t(e)) return [...r];
  return [];
}
s(wc, 'getImplicitAriaRoles');
function zR(e) {
  function t(a) {
    let { name: c, attributes: d } = a;
    return (
      '' +
      c +
      d
        .map((u) => {
          let { name: p, value: f, constraints: m = [] } = u;
          const h = m.indexOf('undefined') !== -1,
            g = m.indexOf('set') !== -1;
          return typeof f < 'u'
            ? '[' + p + '="' + f + '"]'
            : h
              ? ':not([' + p + '])'
              : g
                ? '[' + p + ']:not([' + p + '=""])'
                : '[' + p + ']';
        })
        .join('')
    );
  }
  s(t, 'makeElementSelector');
  function r(a) {
    let { attributes: c = [] } = a;
    return c.length;
  }
  s(r, 'getSelectorSpecificity');
  function n(a, c) {
    let { specificity: d } = a,
      { specificity: u } = c;
    return u - d;
  }
  s(n, 'bySelectorSpecificity');
  function o(a) {
    let { attributes: c = [] } = a;
    const d = c.findIndex((p) => p.value && p.name === 'type' && p.value === 'text');
    d >= 0 && (c = [...c.slice(0, d), ...c.slice(d + 1)]);
    const u = t({ ...a, attributes: c });
    return (p) => (d >= 0 && p.type !== 'text' ? !1 : p.matches(u));
  }
  s(o, 'match');
  let i = [];
  for (const [a, c] of e.entries())
    i = [...i, { match: o(a), roles: Array.from(c), specificity: r(a) }];
  return i.sort(n);
}
s(zR, 'buildElementRoleList');
function Vy(e, t) {
  let { hidden: r = !1 } = t === void 0 ? {} : t;
  function n(o) {
    return [o, ...Array.from(o.children).reduce((i, a) => [...i, ...n(a)], [])];
  }
  return (
    s(n, 'flattenDOM'),
    n(e)
      .filter((o) => (r === !1 ? $i(o) === !1 : !0))
      .reduce((o, i) => {
        let a = [];
        return (
          i.hasAttribute('role')
            ? (a = i.getAttribute('role').split(' ').slice(0, 1))
            : (a = wc(i)),
          a.reduce(
            (c, d) => (Array.isArray(c[d]) ? { ...c, [d]: [...c[d], i] } : { ...c, [d]: [i] }),
            o,
          )
        );
      }, {})
  );
}
s(Vy, 'getRoles');
function Hy(e, t) {
  let { hidden: r, includeDescription: n } = t;
  const o = Vy(e, { hidden: r });
  return Object.entries(o)
    .filter((i) => {
      let [a] = i;
      return a !== 'generic';
    })
    .map((i) => {
      let [a, c] = i;
      const d = '-'.repeat(50),
        u = c.map((p) => {
          const f =
              'Name "' +
              vc(p, {
                computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
              }) +
              `":
`,
            m = Ao(p.cloneNode(!1));
          if (n) {
            const h =
              'Description "' +
              qy(p, {
                computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
              }) +
              `":
`;
            return '' + f + h + m;
          }
          return '' + f + m;
        }).join(`

`);
      return (
        a +
        `:

` +
        u +
        `

` +
        d
      );
    }).join(`
`);
}
s(Hy, 'prettyRoles');
var PJ = s(function (e, t) {
  let { hidden: r = !1 } = t === void 0 ? {} : t;
  return console.log(Hy(e, { hidden: r }));
}, 'logRoles');
function GR(e) {
  return e.tagName === 'OPTION' ? e.selected : Uo(e, 'aria-selected');
}
s(GR, 'computeAriaSelected');
function WR(e) {
  return e.getAttribute('aria-busy') === 'true';
}
s(WR, 'computeAriaBusy');
function KR(e) {
  if (!('indeterminate' in e && e.indeterminate))
    return 'checked' in e ? e.checked : Uo(e, 'aria-checked');
}
s(KR, 'computeAriaChecked');
function YR(e) {
  return Uo(e, 'aria-pressed');
}
s(YR, 'computeAriaPressed');
function XR(e) {
  var t, r;
  return (t = (r = Uo(e, 'aria-current')) != null ? r : e.getAttribute('aria-current')) != null
    ? t
    : !1;
}
s(XR, 'computeAriaCurrent');
function QR(e) {
  return Uo(e, 'aria-expanded');
}
s(QR, 'computeAriaExpanded');
function Uo(e, t) {
  const r = e.getAttribute(t);
  if (r === 'true') return !0;
  if (r === 'false') return !1;
}
s(Uo, 'checkBooleanAttribute');
function ZR(e) {
  const t = { H1: 1, H2: 2, H3: 3, H4: 4, H5: 5, H6: 6 };
  return (e.getAttribute('aria-level') && Number(e.getAttribute('aria-level'))) || t[e.tagName];
}
s(ZR, 'computeHeadingLevel');
function ex(e) {
  const t = e.getAttribute('aria-valuenow');
  return t === null ? void 0 : +t;
}
s(ex, 'computeAriaValueNow');
function tx(e) {
  const t = e.getAttribute('aria-valuemax');
  return t === null ? void 0 : +t;
}
s(tx, 'computeAriaValueMax');
function rx(e) {
  const t = e.getAttribute('aria-valuemin');
  return t === null ? void 0 : +t;
}
s(rx, 'computeAriaValueMin');
function nx(e) {
  const t = e.getAttribute('aria-valuetext');
  return t === null ? void 0 : t;
}
s(nx, 'computeAriaValueText');
var cb = Ec();
function ox(e) {
  return e.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
}
s(ox, 'escapeRegExp');
function Md(e) {
  return new RegExp(ox(e.toLowerCase()), 'i');
}
s(Md, 'getRegExpMatcher');
function br(e, t, r, n) {
  let { variant: o, name: i } = n,
    a = '';
  const c = {},
    d = [['Role', 'TestId'].includes(e) ? r : Md(r)];
  (i && (c.name = Md(i)),
    e === 'Role' &&
      $i(t) &&
      ((c.hidden = !0),
      (a = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `)),
    Object.keys(c).length > 0 && d.push(c));
  const u = o + 'By' + e;
  return {
    queryName: e,
    queryMethod: u,
    queryArgs: d,
    variant: o,
    warning: a,
    toString() {
      a && console.warn(a);
      let [p, f] = d;
      return (
        (p = typeof p == 'string' ? "'" + p + "'" : p),
        (f = f
          ? ', { ' +
            Object.entries(f)
              .map((m) => {
                let [h, g] = m;
                return h + ': ' + g;
              })
              .join(', ') +
            ' }'
          : ''),
        u + '(' + p + f + ')'
      );
    },
  };
}
s(br, 'makeSuggestion');
function vr(e, t, r) {
  return r && (!t || t.toLowerCase() === e.toLowerCase());
}
s(vr, 'canSuggest');
function ai(e, t, r) {
  var n, o;
  if ((t === void 0 && (t = 'get'), e.matches(Ee().defaultIgnore))) return;
  const i = (n = e.getAttribute('role')) != null ? n : (o = wc(e)) == null ? void 0 : o[0];
  if (i !== 'generic' && vr('Role', r, i))
    return br('Role', e, i, {
      variant: t,
      name: vc(e, {
        computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
      }),
    });
  const a = Fy(document, e)
    .map((m) => m.content)
    .join(' ');
  if (vr('LabelText', r, a)) return br('LabelText', e, a, { variant: t });
  const c = e.getAttribute('placeholder');
  if (vr('PlaceholderText', r, c)) return br('PlaceholderText', e, c, { variant: t });
  const d = cb(Jo(e));
  if (vr('Text', r, d)) return br('Text', e, d, { variant: t });
  if (vr('DisplayValue', r, e.value)) return br('DisplayValue', e, cb(e.value), { variant: t });
  const u = e.getAttribute('alt');
  if (vr('AltText', r, u)) return br('AltText', e, u, { variant: t });
  const p = e.getAttribute('title');
  if (vr('Title', r, p)) return br('Title', e, p, { variant: t });
  const f = e.getAttribute(Ee().testIdAttribute);
  if (vr('TestId', r, f)) return br('TestId', e, f, { variant: t });
}
s(ai, 'getSuggestedQuery');
function Rs(e, t) {
  e.stack = t.stack.replace(t.message, e.message);
}
s(Rs, 'copyStackTrace');
function sx(e, t) {
  let {
    container: r = Tc(),
    timeout: n = Ee().asyncUtilTimeout,
    showOriginalStackTrace: o = Ee().showOriginalStackTrace,
    stackTraceError: i,
    interval: a = 50,
    onTimeout: c = s(
      (u) => (
        Object.defineProperty(u, 'message', { value: Ee().getElementError(u.message, r).message }),
        u
      ),
      'onTimeout',
    ),
    mutationObserverOptions: d = { subtree: !0, childList: !0, attributes: !0, characterData: !0 },
  } = t;
  if (typeof e != 'function') throw new TypeError('Received `callback` arg must be a function');
  return new Promise(async (u, p) => {
    let f,
      m,
      h,
      g = !1,
      v = 'idle';
    const E = setTimeout(q, n),
      b = na();
    if (b) {
      const { unstable_advanceTimersWrapper: P } = Ee();
      for (I(); !g; ) {
        if (!na()) {
          const A = new Error(
            "Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830",
          );
          (o || Rs(A, i), p(A));
          return;
        }
        if (
          (await P(async () => {
            jest.advanceTimersByTime(a);
          }),
          g)
        )
          break;
        I();
      }
    } else {
      try {
        ur(r);
      } catch (A) {
        p(A);
        return;
      }
      m = setInterval(R, a);
      const { MutationObserver: P } = ky(r);
      ((h = new P(R)), h.observe(r, d), I());
    }
    function S(P, A) {
      ((g = !0), clearTimeout(E), b || (clearInterval(m), h.disconnect()), P ? p(P) : u(A));
    }
    s(S, 'onDone');
    function R() {
      if (na()) {
        const P = new Error(
          "Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830",
        );
        return (o || Rs(P, i), p(P));
      } else return I();
    }
    s(R, 'checkRealTimersCallback');
    function I() {
      if (v !== 'pending')
        try {
          const P = UR(e);
          typeof P?.then == 'function'
            ? ((v = 'pending'),
              P.then(
                (A) => {
                  ((v = 'resolved'), S(null, A));
                },
                (A) => {
                  ((v = 'rejected'), (f = A));
                },
              ))
            : S(null, P);
        } catch (P) {
          f = P;
        }
    }
    s(I, 'checkCallback');
    function q() {
      let P;
      (f
        ? ((P = f), !o && P.name === 'TestingLibraryElementError' && Rs(P, i))
        : ((P = new Error('Timed out in waitFor.')), o || Rs(P, i)),
        S(c(P), null));
    }
    s(q, 'handleTimeout');
  });
}
s(sx, 'waitFor');
function Sc(e, t) {
  const r = new Error('STACK_TRACE_MESSAGE');
  return Ee().asyncWrapper(() => sx(e, { stackTraceError: r, ...t }));
}
s(Sc, 'waitForWrapper');
function ki(e, t) {
  return Ee().getElementError(e, t);
}
s(ki, 'getElementError');
function Di(e, t) {
  return ki(
    e +
      '\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).',
    t,
  );
}
s(Di, 'getMultipleElementsFoundError');
function nn(e, t, r, n) {
  let { exact: o = !0, collapseWhitespace: i, trim: a, normalizer: c } = n === void 0 ? {} : n;
  const d = o ? ir : Un,
    u = rn({ collapseWhitespace: i, trim: a, normalizer: c });
  return Array.from(t.querySelectorAll('[' + e + ']')).filter((p) => d(p.getAttribute(e), p, r, u));
}
s(nn, 'queryAllByAttribute');
function zy(e, t, r, n) {
  const o = nn(e, t, r, n);
  if (o.length > 1) throw Di('Found multiple elements by [' + e + '=' + r + ']', t);
  return o[0] || null;
}
s(zy, 'queryByAttribute');
function On(e, t) {
  return function (r) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      o[i - 1] = arguments[i];
    const a = e(r, ...o);
    if (a.length > 1) {
      const c = a.map((d) => ki(null, d).message).join(`

`);
      throw Di(
        t(r, ...o) +
          `

Here are the matching elements:

` +
          c,
        r,
      );
    }
    return a[0] || null;
  };
}
s(On, 'makeSingleQuery');
function Gy(e, t) {
  return Ee().getElementError(
    `A better query is available, try this:
` +
      e.toString() +
      `
`,
    t,
  );
}
s(Gy, 'getSuggestionError');
function _c(e, t) {
  return function (r) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      o[i - 1] = arguments[i];
    const a = e(r, ...o);
    if (!a.length) throw Ee().getElementError(t(r, ...o), r);
    return a;
  };
}
s(_c, 'makeGetAllQuery');
function Cn(e) {
  return (t, r, n, o) => Sc(() => e(t, r, n), { container: t, ...o });
}
s(Cn, 'makeFindQuery');
var Hr = s(
    (e, t, r) =>
      function (n) {
        for (var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), a = 1; a < o; a++)
          i[a - 1] = arguments[a];
        const c = e(n, ...i),
          [{ suggest: d = Ee().throwSuggestions } = {}] = i.slice(-1);
        if (c && d) {
          const u = ai(c, r);
          if (u && !t.endsWith(u.queryName)) throw Gy(u.toString(), n);
        }
        return c;
      },
    'wrapSingleQueryWithSuggestion',
  ),
  wt = s(
    (e, t, r) =>
      function (n) {
        for (var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), a = 1; a < o; a++)
          i[a - 1] = arguments[a];
        const c = e(n, ...i),
          [{ suggest: d = Ee().throwSuggestions } = {}] = i.slice(-1);
        if (c.length && d) {
          const u = [
            ...new Set(
              c.map((p) => {
                var f;
                return (f = ai(p, r)) == null ? void 0 : f.toString();
              }),
            ),
          ];
          if (u.length === 1 && !t.endsWith(ai(c[0], r).queryName)) throw Gy(u[0], n);
        }
        return c;
      },
    'wrapAllByQueryWithSuggestion',
  );
function dr(e, t, r) {
  const n = Hr(On(e, t), e.name, 'query'),
    o = _c(e, r),
    i = On(o, t),
    a = Hr(i, e.name, 'get'),
    c = wt(o, e.name.replace('query', 'get'), 'getAll'),
    d = Cn(wt(o, e.name, 'findAll')),
    u = Cn(Hr(i, e.name, 'find'));
  return [n, c, a, d, u];
}
s(dr, 'buildQueries');
var OJ = Object.freeze({
  __proto__: null,
  getElementError: ki,
  wrapAllByQueryWithSuggestion: wt,
  wrapSingleQueryWithSuggestion: Hr,
  getMultipleElementsFoundError: Di,
  queryAllByAttribute: nn,
  queryByAttribute: zy,
  makeSingleQuery: On,
  makeGetAllQuery: _c,
  makeFindQuery: Cn,
  buildQueries: dr,
});
function ix(e) {
  return Array.from(e.querySelectorAll('label,input'))
    .map((t) => ({ node: t, textToMatch: Va(t) }))
    .filter((t) => {
      let { textToMatch: r } = t;
      return r !== null;
    });
}
s(ix, 'queryAllLabels');
var CJ = s(function (e, t, r) {
    let { exact: n = !0, trim: o, collapseWhitespace: i, normalizer: a } = r === void 0 ? {} : r;
    const c = n ? ir : Un,
      d = rn({ collapseWhitespace: i, trim: o, normalizer: a });
    return ix(e)
      .filter((p) => {
        let { node: f, textToMatch: m } = p;
        return c(m, f, t, d);
      })
      .map((p) => {
        let { node: f } = p;
        return f;
      });
  }, 'queryAllLabelsByText'),
  li = s(function (e, t, r) {
    let {
      selector: n = '*',
      exact: o = !0,
      collapseWhitespace: i,
      trim: a,
      normalizer: c,
    } = r === void 0 ? {} : r;
    ur(e);
    const d = o ? ir : Un,
      u = rn({ collapseWhitespace: i, trim: a, normalizer: c }),
      p = Array.from(e.querySelectorAll('*'))
        .filter((f) => Ly(f).length || f.hasAttribute('aria-labelledby'))
        .reduce((f, m) => {
          const h = Fy(e, m, { selector: n });
          h.filter((v) => !!v.formControl).forEach((v) => {
            d(v.content, v.formControl, t, u) && v.formControl && f.push(v.formControl);
          });
          const g = h.filter((v) => !!v.content).map((v) => v.content);
          return (
            d(g.join(' '), m, t, u) && f.push(m),
            g.length > 1 &&
              g.forEach((v, E) => {
                d(v, m, t, u) && f.push(m);
                const b = [...g];
                (b.splice(E, 1), b.length > 1 && d(b.join(' '), m, t, u) && f.push(m));
              }),
            f
          );
        }, [])
        .concat(nn('aria-label', e, t, { exact: o, normalizer: u }));
    return Array.from(new Set(p)).filter((f) => f.matches(n));
  }, 'queryAllByLabelText'),
  In = s(function (e, t) {
    for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
      n[o - 2] = arguments[o];
    const i = li(e, t, ...n);
    if (!i.length) {
      const a = CJ(e, t, ...n);
      if (a.length) {
        const c = a.map((d) => ax(e, d)).filter((d) => !!d);
        throw c.length
          ? Ee().getElementError(
              c.map(
                (d) =>
                  'Found a label with the text of: ' +
                  t +
                  ', however the element associated with this label (<' +
                  d +
                  ' />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <' +
                  d +
                  ' />, you can use aria-label or aria-labelledby instead.',
              ).join(`

`),
              e,
            )
          : Ee().getElementError(
              'Found a label with the text of: ' +
                t +
                `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`,
              e,
            );
      } else throw Ee().getElementError('Unable to find a label with the text of: ' + t, e);
    }
    return i;
  }, 'getAllByLabelText');
function ax(e, t) {
  const r = t.getAttribute('for');
  if (!r) return null;
  const n = e.querySelector('[id="' + r + '"]');
  return n ? n.tagName.toLowerCase() : null;
}
s(ax, 'getTagNameOfElementAssociatedWithLabelViaFor');
var lx = s((e, t) => 'Found multiple elements with the text of: ' + t, 'getMultipleError$7'),
  cx = Hr(On(li, lx), li.name, 'query'),
  ux = On(In, lx),
  dx = Cn(wt(In, In.name, 'findAll')),
  px = Cn(Hr(ux, In.name, 'find')),
  fx = wt(In, In.name, 'getAll'),
  mx = Hr(ux, In.name, 'get'),
  yx = wt(li, li.name, 'queryAll'),
  jd = s(function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    return (ur(t[0]), nn('placeholder', ...t));
  }, 'queryAllByPlaceholderText'),
  IJ = s(
    (e, t) => 'Found multiple elements with the placeholder text of: ' + t,
    'getMultipleError$6',
  ),
  NJ = s(
    (e, t) => 'Unable to find an element with the placeholder text of: ' + t,
    'getMissingError$6',
  ),
  hx = wt(jd, jd.name, 'queryAll'),
  [gx, bx, vx, Tx, Ex] = dr(jd, IJ, NJ),
  $d = s(function (e, t, r) {
    let {
      selector: n = '*',
      exact: o = !0,
      collapseWhitespace: i,
      trim: a,
      ignore: c = Ee().defaultIgnore,
      normalizer: d,
    } = r === void 0 ? {} : r;
    ur(e);
    const u = o ? ir : Un,
      p = rn({ collapseWhitespace: i, trim: a, normalizer: d });
    let f = [];
    return (
      typeof e.matches == 'function' && e.matches(n) && (f = [e]),
      [...f, ...Array.from(e.querySelectorAll(n))]
        .filter((m) => !c || !m.matches(c))
        .filter((m) => u(Jo(m), m, t, p))
    );
  }, 'queryAllByText'),
  qJ = s((e, t) => 'Found multiple elements with the text: ' + t, 'getMultipleError$5'),
  MJ = s(function (e, t, r) {
    r === void 0 && (r = {});
    const { collapseWhitespace: n, trim: o, normalizer: i, selector: a } = r,
      d = rn({ collapseWhitespace: n, trim: o, normalizer: i })(t.toString()),
      u = d !== t.toString(),
      p = (a ?? '*') !== '*';
    return (
      'Unable to find an element with the text: ' +
      (u ? d + " (normalized from '" + t + "')" : t) +
      (p ? ", which matches selector '" + a + "'" : '') +
      '. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.'
    );
  }, 'getMissingError$5'),
  wx = wt($d, $d.name, 'queryAll'),
  [Sx, _x, Ax, Rx, xx] = dr($d, qJ, MJ),
  kd = s(function (e, t, r) {
    let { exact: n = !0, collapseWhitespace: o, trim: i, normalizer: a } = r === void 0 ? {} : r;
    ur(e);
    const c = n ? ir : Un,
      d = rn({ collapseWhitespace: o, trim: i, normalizer: a });
    return Array.from(e.querySelectorAll('input,textarea,select')).filter((u) =>
      u.tagName === 'SELECT'
        ? Array.from(u.options)
            .filter((f) => f.selected)
            .some((f) => c(Jo(f), f, t, d))
        : c(u.value, u, t, d),
    );
  }, 'queryAllByDisplayValue'),
  jJ = s(
    (e, t) => 'Found multiple elements with the display value: ' + t + '.',
    'getMultipleError$4',
  ),
  $J = s(
    (e, t) => 'Unable to find an element with the display value: ' + t + '.',
    'getMissingError$4',
  ),
  Px = wt(kd, kd.name, 'queryAll'),
  [Ox, Cx, Ix, Nx, qx] = dr(kd, jJ, $J),
  kJ = /^(img|input|area|.+-.+)$/i,
  Dd = s(function (e, t, r) {
    return (r === void 0 && (r = {}), ur(e), nn('alt', e, t, r).filter((n) => kJ.test(n.tagName)));
  }, 'queryAllByAltText'),
  DJ = s((e, t) => 'Found multiple elements with the alt text: ' + t, 'getMultipleError$3'),
  LJ = s((e, t) => 'Unable to find an element with the alt text: ' + t, 'getMissingError$3'),
  Mx = wt(Dd, Dd.name, 'queryAll'),
  [jx, $x, kx, Dx, Lx] = dr(Dd, DJ, LJ),
  FJ = s((e) => {
    var t;
    return (
      e.tagName.toLowerCase() === 'title' &&
      ((t = e.parentElement) == null ? void 0 : t.tagName.toLowerCase()) === 'svg'
    );
  }, 'isSvgTitle'),
  Ld = s(function (e, t, r) {
    let { exact: n = !0, collapseWhitespace: o, trim: i, normalizer: a } = r === void 0 ? {} : r;
    ur(e);
    const c = n ? ir : Un,
      d = rn({ collapseWhitespace: o, trim: i, normalizer: a });
    return Array.from(e.querySelectorAll('[title], svg > title')).filter(
      (u) => c(u.getAttribute('title'), u, t, d) || (FJ(u) && c(Jo(u), u, t, d)),
    );
  }, 'queryAllByTitle'),
  BJ = s((e, t) => 'Found multiple elements with the title: ' + t + '.', 'getMultipleError$2'),
  JJ = s((e, t) => 'Unable to find an element with the title: ' + t + '.', 'getMissingError$2'),
  Fx = wt(Ld, Ld.name, 'queryAll'),
  [Bx, Jx, Ux, Vx, Hx] = dr(Ld, BJ, JJ),
  Fd = s(function (e, t, r) {
    let {
      hidden: n = Ee().defaultHidden,
      name: o,
      description: i,
      queryFallbacks: a = !1,
      selected: c,
      busy: d,
      checked: u,
      pressed: p,
      current: f,
      level: m,
      expanded: h,
      value: { now: g, min: v, max: E, text: b } = {},
    } = r === void 0 ? {} : r;
    if ((ur(e), c !== void 0)) {
      var S;
      if (((S = $t.roles.get(t)) == null ? void 0 : S.props['aria-selected']) === void 0)
        throw new Error('"aria-selected" is not supported on role "' + t + '".');
    }
    if (d !== void 0) {
      var R;
      if (((R = $t.roles.get(t)) == null ? void 0 : R.props['aria-busy']) === void 0)
        throw new Error('"aria-busy" is not supported on role "' + t + '".');
    }
    if (u !== void 0) {
      var I;
      if (((I = $t.roles.get(t)) == null ? void 0 : I.props['aria-checked']) === void 0)
        throw new Error('"aria-checked" is not supported on role "' + t + '".');
    }
    if (p !== void 0) {
      var q;
      if (((q = $t.roles.get(t)) == null ? void 0 : q.props['aria-pressed']) === void 0)
        throw new Error('"aria-pressed" is not supported on role "' + t + '".');
    }
    if (f !== void 0) {
      var P;
      if (((P = $t.roles.get(t)) == null ? void 0 : P.props['aria-current']) === void 0)
        throw new Error('"aria-current" is not supported on role "' + t + '".');
    }
    if (m !== void 0 && t !== 'heading')
      throw new Error('Role "' + t + '" cannot have "level" property.');
    if (g !== void 0) {
      var A;
      if (((A = $t.roles.get(t)) == null ? void 0 : A.props['aria-valuenow']) === void 0)
        throw new Error('"aria-valuenow" is not supported on role "' + t + '".');
    }
    if (E !== void 0) {
      var w;
      if (((w = $t.roles.get(t)) == null ? void 0 : w.props['aria-valuemax']) === void 0)
        throw new Error('"aria-valuemax" is not supported on role "' + t + '".');
    }
    if (v !== void 0) {
      var _;
      if (((_ = $t.roles.get(t)) == null ? void 0 : _.props['aria-valuemin']) === void 0)
        throw new Error('"aria-valuemin" is not supported on role "' + t + '".');
    }
    if (b !== void 0) {
      var $;
      if ((($ = $t.roles.get(t)) == null ? void 0 : $.props['aria-valuetext']) === void 0)
        throw new Error('"aria-valuetext" is not supported on role "' + t + '".');
    }
    if (h !== void 0) {
      var N;
      if (((N = $t.roles.get(t)) == null ? void 0 : N.props['aria-expanded']) === void 0)
        throw new Error('"aria-expanded" is not supported on role "' + t + '".');
    }
    const V = new WeakMap();
    function H(x) {
      return (V.has(x) || V.set(x, Uy(x)), V.get(x));
    }
    return (
      s(H, 'cachedIsSubtreeInaccessible'),
      Array.from(e.querySelectorAll(zx(t)))
        .filter((x) => {
          if (x.hasAttribute('role')) {
            const k = x.getAttribute('role');
            if (a)
              return k
                .split(' ')
                .filter(Boolean)
                .some((X) => X === t);
            const [K] = k.split(' ');
            return K === t;
          }
          return wc(x).some((k) => k === t);
        })
        .filter((x) => {
          if (c !== void 0) return c === GR(x);
          if (d !== void 0) return d === WR(x);
          if (u !== void 0) return u === KR(x);
          if (p !== void 0) return p === YR(x);
          if (f !== void 0) return f === XR(x);
          if (h !== void 0) return h === QR(x);
          if (m !== void 0) return m === ZR(x);
          if (g !== void 0 || E !== void 0 || v !== void 0 || b !== void 0) {
            let F = !0;
            if (
              (g !== void 0 && F && (F = g === ex(x)),
              E !== void 0 && F && (F = E === tx(x)),
              v !== void 0 && F && (F = v === rx(x)),
              b !== void 0)
            ) {
              var D;
              F && (F = ir((D = nx(x)) != null ? D : null, x, b, (k) => k));
            }
            return F;
          }
          return !0;
        })
        .filter((x) =>
          o === void 0
            ? !0
            : ir(
                vc(x, {
                  computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
                }),
                x,
                o,
                (D) => D,
              ),
        )
        .filter((x) =>
          i === void 0
            ? !0
            : ir(
                qy(x, {
                  computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
                }),
                x,
                i,
                (D) => D,
              ),
        )
        .filter((x) => (n === !1 ? $i(x, { isSubtreeInaccessible: H }) === !1 : !0))
    );
  }, 'queryAllByRole');
function zx(e) {
  var t;
  const r = '*[role~="' + e + '"]',
    n = (t = $t.roleElements.get(e)) != null ? t : new Set(),
    o = new Set(
      Array.from(n).map((i) => {
        let { name: a } = i;
        return a;
      }),
    );
  return [r].concat(Array.from(o)).join(',');
}
s(zx, 'makeRoleSelector');
var Gx = s((e) => {
    let t = '';
    return (
      e === void 0
        ? (t = '')
        : typeof e == 'string'
          ? (t = ' and name "' + e + '"')
          : (t = ' and name `' + e + '`'),
      t
    );
  }, 'getNameHint'),
  UJ = s(function (e, t, r) {
    let { name: n } = r === void 0 ? {} : r;
    return 'Found multiple elements with the role "' + t + '"' + Gx(n);
  }, 'getMultipleError$1'),
  VJ = s(function (e, t, r) {
    let { hidden: n = Ee().defaultHidden, name: o, description: i } = r === void 0 ? {} : r;
    if (Ee()._disableExpensiveErrorDiagnostics) return 'Unable to find role="' + t + '"' + Gx(o);
    let a = '';
    Array.from(e.children).forEach((p) => {
      a += Hy(p, { hidden: n, includeDescription: i !== void 0 });
    });
    let c;
    a.length === 0
      ? n === !1
        ? (c =
            'There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole')
        : (c = 'There are no available roles.')
      : (c = (
          `
Here are the ` +
          (n === !1 ? 'accessible' : 'available') +
          ` roles:

  ` +
          a
            .replace(
              /\n/g,
              `
  `,
            )
            .replace(
              /\n\s\s\n/g,
              `

`,
            ) +
          `
`
        ).trim());
    let d = '';
    o === void 0
      ? (d = '')
      : typeof o == 'string'
        ? (d = ' and name "' + o + '"')
        : (d = ' and name `' + o + '`');
    let u = '';
    return (
      i === void 0
        ? (u = '')
        : typeof i == 'string'
          ? (u = ' and description "' + i + '"')
          : (u = ' and description `' + i + '`'),
      (
        `
Unable to find an ` +
        (n === !1 ? 'accessible ' : '') +
        'element with the role "' +
        t +
        '"' +
        d +
        u +
        `

` +
        c
      ).trim()
    );
  }, 'getMissingError$1'),
  Wx = wt(Fd, Fd.name, 'queryAll'),
  [Kx, Yx, Xx, Qx, Zx] = dr(Fd, UJ, VJ),
  Wy = s(() => Ee().testIdAttribute, 'getTestIdAttribute'),
  Bd = s(function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    return (ur(t[0]), nn(Wy(), ...t));
  }, 'queryAllByTestId'),
  HJ = s((e, t) => 'Found multiple elements by: [' + Wy() + '="' + t + '"]', 'getMultipleError'),
  zJ = s((e, t) => 'Unable to find an element by: [' + Wy() + '="' + t + '"]', 'getMissingError'),
  eP = wt(Bd, Bd.name, 'queryAll'),
  [tP, rP, nP, oP, sP] = dr(Bd, HJ, zJ),
  Ha = Object.freeze({
    __proto__: null,
    queryAllByLabelText: yx,
    queryByLabelText: cx,
    getAllByLabelText: fx,
    getByLabelText: mx,
    findAllByLabelText: dx,
    findByLabelText: px,
    queryByPlaceholderText: gx,
    queryAllByPlaceholderText: hx,
    getByPlaceholderText: vx,
    getAllByPlaceholderText: bx,
    findAllByPlaceholderText: Tx,
    findByPlaceholderText: Ex,
    queryByText: Sx,
    queryAllByText: wx,
    getByText: Ax,
    getAllByText: _x,
    findAllByText: Rx,
    findByText: xx,
    queryByDisplayValue: Ox,
    queryAllByDisplayValue: Px,
    getByDisplayValue: Ix,
    getAllByDisplayValue: Cx,
    findAllByDisplayValue: Nx,
    findByDisplayValue: qx,
    queryByAltText: jx,
    queryAllByAltText: Mx,
    getByAltText: kx,
    getAllByAltText: $x,
    findAllByAltText: Dx,
    findByAltText: Lx,
    queryByTitle: Bx,
    queryAllByTitle: Fx,
    getByTitle: Ux,
    getAllByTitle: Jx,
    findAllByTitle: Vx,
    findByTitle: Hx,
    queryByRole: Kx,
    queryAllByRole: Wx,
    getAllByRole: Yx,
    getByRole: Xx,
    findAllByRole: Qx,
    findByRole: Zx,
    queryByTestId: tP,
    queryAllByTestId: eP,
    getByTestId: nP,
    getAllByTestId: rP,
    findAllByTestId: oP,
    findByTestId: sP,
  });
function za(e, t, r) {
  return (
    t === void 0 && (t = Ha),
    r === void 0 && (r = {}),
    Object.keys(t).reduce((n, o) => {
      const i = t[o];
      return ((n[o] = i.bind(null, e)), n);
    }, r)
  );
}
s(za, 'getQueriesForElement');
var iP = s((e) => !e || (Array.isArray(e) && !e.length), 'isRemoved');
function Jd(e) {
  if (iP(e))
    throw new Error(
      'The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.',
    );
}
s(Jd, 'initialCheck');
async function aP(e, t) {
  const r = new Error('Timed out in waitForElementToBeRemoved.');
  if (typeof e != 'function') {
    Jd(e);
    const o = (Array.isArray(e) ? e : [e]).map((i) => {
      let a = i.parentElement;
      if (a === null) return () => null;
      for (; a.parentElement; ) a = a.parentElement;
      return () => (a.contains(i) ? i : null);
    });
    e = s(() => o.map((i) => i()).filter(Boolean), 'callback');
  }
  return (
    Jd(e()),
    Sc(() => {
      let n;
      try {
        n = e();
      } catch (o) {
        if (o.name === 'TestingLibraryElementError') return;
        throw o;
      }
      if (!iP(n)) throw r;
    }, t)
  );
}
s(aP, 'waitForElementToBeRemoved');
var ub = {
    copy: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    cut: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    paste: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionEnd: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionStart: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionUpdate: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    keyDown: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    keyPress: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    keyUp: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    focus: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
    blur: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
    focusIn: {
      EventType: 'FocusEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    focusOut: {
      EventType: 'FocusEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    change: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
    input: { EventType: 'InputEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
    invalid: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !0 } },
    submit: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
    reset: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
    click: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, button: 0, composed: !0 },
    },
    contextMenu: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dblClick: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    drag: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    dragEnd: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
    dragEnter: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dragExit: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    dragLeave: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    dragOver: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dragStart: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    drop: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    mouseDown: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseEnter: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
    },
    mouseLeave: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
    },
    mouseMove: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseOut: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseOver: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseUp: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    select: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
    touchCancel: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    touchEnd: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    touchMove: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    touchStart: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    resize: { EventType: 'UIEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    scroll: { EventType: 'UIEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    wheel: { EventType: 'WheelEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    abort: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    canPlay: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    canPlayThrough: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    durationChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    emptied: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    encrypted: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    ended: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadedData: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadedMetadata: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadStart: { EventType: 'ProgressEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    pause: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    play: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    playing: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    progress: { EventType: 'ProgressEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    rateChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    seeked: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    seeking: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    stalled: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    suspend: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    timeUpdate: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    volumeChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    waiting: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    load: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    error: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    animationStart: { EventType: 'AnimationEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    animationEnd: { EventType: 'AnimationEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    animationIteration: {
      EventType: 'AnimationEvent',
      defaultInit: { bubbles: !0, cancelable: !1 },
    },
    transitionCancel: {
      EventType: 'TransitionEvent',
      defaultInit: { bubbles: !0, cancelable: !1 },
    },
    transitionEnd: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
    transitionRun: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    transitionStart: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    pointerOver: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerEnter: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    pointerDown: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerMove: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerUp: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerCancel: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    pointerOut: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerLeave: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    gotPointerCapture: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    lostPointerCapture: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    popState: { EventType: 'PopStateEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    offline: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    online: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    pageHide: { EventType: 'PageTransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
    pageShow: { EventType: 'PageTransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
  },
  db = { doubleClick: 'dblClick' };
function Ro(e, t) {
  return Ee().eventWrapper(() => {
    if (!t) throw new Error('Unable to fire an event - please provide an event object.');
    if (!e)
      throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
    return e.dispatchEvent(t);
  });
}
s(Ro, 'fireEvent');
function Fs(e, t, r, n) {
  let { EventType: o = 'Event', defaultInit: i = {} } = n === void 0 ? {} : n;
  if (!t) throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
  const a = { ...i, ...r },
    { target: { value: c, files: d, ...u } = {} } = a;
  (c !== void 0 && lP(t, c),
    d !== void 0 &&
      Object.defineProperty(t, 'files', {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: d,
      }),
    Object.assign(t, u));
  const p = ky(t),
    f = p[o] || p.Event;
  let m;
  if (typeof f == 'function') m = new f(e, a);
  else {
    m = p.document.createEvent(o);
    const { bubbles: g, cancelable: v, detail: E, ...b } = a;
    (m.initEvent(e, g, v, E),
      Object.keys(b).forEach((S) => {
        m[S] = b[S];
      }));
  }
  return (
    ['dataTransfer', 'clipboardData'].forEach((g) => {
      const v = a[g];
      typeof v == 'object' &&
        (typeof p.DataTransfer == 'function'
          ? Object.defineProperty(m, g, {
              value: Object.getOwnPropertyNames(v).reduce(
                (E, b) => (Object.defineProperty(E, b, { value: v[b] }), E),
                new p.DataTransfer(),
              ),
            })
          : Object.defineProperty(m, g, { value: v }));
    }),
    m
  );
}
s(Fs, 'createEvent');
Object.keys(ub).forEach((e) => {
  const { EventType: t, defaultInit: r } = ub[e],
    n = e.toLowerCase();
  ((Fs[e] = (o, i) => Fs(n, o, i, { EventType: t, defaultInit: r })),
    (Ro[e] = (o, i) => Ro(o, Fs[e](o, i))));
});
function lP(e, t) {
  const { set: r } = Object.getOwnPropertyDescriptor(e, 'value') || {},
    n = Object.getPrototypeOf(e),
    { set: o } = Object.getOwnPropertyDescriptor(n, 'value') || {};
  if (o && r !== o) o.call(e, t);
  else if (r) r.call(e, t);
  else throw new Error('The given element does not have a value setter');
}
s(lP, 'setNativeValue');
Object.keys(db).forEach((e) => {
  const t = db[e];
  Ro[e] = function () {
    return Ro[t](...arguments);
  };
});
function cP(e) {
  return e.replace(
    /[ \t]*[\n][ \t]*/g,
    `
`,
  );
}
s(cP, 'unindent');
function uP(e) {
  return pJ.default.compressToEncodedURIComponent(cP(e));
}
s(uP, 'encode');
function dP(e) {
  return 'https://testing-playground.com/#markup=' + uP(e);
}
s(dP, 'getPlaygroundUrl');
var GJ = s((e, t, r) => (Array.isArray(e) ? e.forEach((n) => qd(n, t, r)) : qd(e, t, r)), 'debug'),
  WJ = s(function (e) {
    if ((e === void 0 && (e = Tc().body), !e || !('innerHTML' in e))) {
      console.log("The element you're providing isn't a valid DOM element.");
      return;
    }
    if (!e.innerHTML) {
      console.log("The provided element doesn't have any children.");
      return;
    }
    const t = dP(e.innerHTML);
    return (
      console.log(
        `Open this URL in your browser

` + t,
      ),
      t
    );
  }, 'logTestingPlaygroundURL'),
  pb = { debug: GJ, logTestingPlaygroundURL: WJ },
  KJ =
    typeof document < 'u' && document.body
      ? za(document.body, Ha, pb)
      : Object.keys(Ha).reduce(
          (e, t) => (
            (e[t] = () => {
              throw new TypeError(
                'For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error',
              );
            }),
            e
          ),
          pb,
        );
function he(e, t, r) {
  return (e.namespaceURI && e.namespaceURI !== 'http://www.w3.org/1999/xhtml') ||
    ((t = Array.isArray(t) ? t : [t]), !t.includes(e.tagName.toLowerCase()))
    ? !1
    : r
      ? Object.entries(r).every(([n, o]) => e[n] === o)
      : !0;
}
s(he, 'isElementType');
function qt(e) {
  var t;
  if (pP(e) && e.defaultView) return e.defaultView;
  if (!((t = e.ownerDocument) === null || t === void 0) && t.defaultView)
    return e.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${fP(e)}`);
}
s(qt, 'getWindow');
function pP(e) {
  return e.nodeType === 9;
}
s(pP, 'isDocument');
function fP(e) {
  return typeof e == 'function' ? `function ${e.name}` : e === null ? 'null' : String(e);
}
s(fP, 'describe');
function Ky(e, t) {
  return new Promise((r, n) => {
    const o = new t();
    ((o.onerror = n),
      (o.onabort = n),
      (o.onload = () => {
        r(String(o.result));
      }),
      o.readAsText(e));
  });
}
s(Ky, 'readBlobText');
function Ac(e, t) {
  const r = {
    ...t,
    length: t.length,
    item: s((n) => r[n], 'item'),
    [Symbol.iterator]: s(function* () {
      for (let o = 0; o < r.length; o++) yield r[o];
    }, 'nextFile'),
  };
  return (
    (r.constructor = e.FileList),
    e.FileList && Object.setPrototypeOf(r, e.FileList.prototype),
    Object.freeze(r),
    r
  );
}
s(Ac, 'createFileList');
function Ar(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(Ar, '_define_property');
var mP = class {
  getAsFile() {
    return this.file;
  }
  getAsString(t) {
    typeof this.data == 'string' && t(this.data);
  }
  webkitGetAsEntry() {
    throw new Error('not implemented');
  }
  constructor(t, r) {
    (Ar(this, 'kind', void 0),
      Ar(this, 'type', void 0),
      Ar(this, 'file', null),
      Ar(this, 'data', void 0),
      typeof t == 'string'
        ? ((this.kind = 'string'), (this.type = String(r)), (this.data = t))
        : ((this.kind = 'file'), (this.type = t.type), (this.file = t)));
  }
};
s(mP, 'DataTransferItemStub');
var yP = mP,
  hP = class extends Array {
    add(...t) {
      const r = new yP(t[0], t[1]);
      return (this.push(r), r);
    }
    clear() {
      this.splice(0, this.length);
    }
    remove(t) {
      this.splice(t, 1);
    }
  };
s(hP, 'DataTransferItemListStub');
var YJ = hP;
function xs(e, t) {
  const [r, n] = e.split('/'),
    o = !n || n === '*';
  return (i) => (t ? i.type === (o ? r : e) : o ? i.type.startsWith(`${r}/`) : i.type === r);
}
s(xs, 'getTypeMatcher');
function gP(e) {
  var t;
  return new ((t = class {
    getData(r) {
      var n;
      const o =
        (n = this.items.find(xs(r, !0))) !== null && n !== void 0 ? n : this.items.find(xs(r, !1));
      let i = '';
      return (
        o?.getAsString((a) => {
          i = a;
        }),
        i
      );
    }
    setData(r, n) {
      const o = this.items.findIndex(xs(r, !0)),
        i = new yP(n, r);
      o >= 0 ? this.items.splice(o, 1, i) : this.items.push(i);
    }
    clearData(r) {
      if (r) {
        const n = this.items.findIndex(xs(r, !0));
        n >= 0 && this.items.remove(n);
      } else this.items.clear();
    }
    get types() {
      const r = [];
      return (
        this.files.length && r.push('Files'),
        this.items.forEach((n) => r.push(n.type)),
        Object.freeze(r),
        r
      );
    }
    setDragImage() {}
    constructor() {
      (Ar(this, 'dropEffect', 'none'),
        Ar(this, 'effectAllowed', 'uninitialized'),
        Ar(this, 'items', new YJ()),
        Ar(this, 'files', Ac(e, [])));
    }
  }),
  s(t, 'DataTransferStub'),
  t)();
}
s(gP, 'createDataTransferStub');
function Rc(e, t = []) {
  const r = typeof e.DataTransfer > 'u' ? gP(e) : new e.DataTransfer();
  return (Object.defineProperty(r, 'files', { get: s(() => Ac(e, t), 'get') }), r);
}
s(Rc, 'createDataTransfer');
async function bP(e, t) {
  return t.kind === 'file'
    ? t.getAsFile()
    : new e.Blob([await new Promise((r) => t.getAsString(r))], { type: t.type });
}
s(bP, 'getBlobFromDataTransferItem');
function Yy(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(Yy, '_define_property');
function Xy(e, ...t) {
  var r;
  const n = Object.fromEntries(
    t.map((o) => [typeof o == 'string' ? 'text/plain' : o.type, Promise.resolve(o)]),
  );
  return typeof e.ClipboardItem < 'u'
    ? new e.ClipboardItem(n)
    : new ((r = class {
        get types() {
          return Array.from(Object.keys(this.data));
        }
        async getType(o) {
          const i = await this.data[o];
          if (!i) throw new Error(`${o} is not one of the available MIME types on this item.`);
          return i instanceof e.Blob ? i : new e.Blob([i], { type: o });
        }
        constructor(o) {
          (Yy(this, 'data', void 0), (this.data = o));
        }
      }),
      s(r, 'ClipboardItem'),
      r)(n);
}
s(Xy, 'createClipboardItem');
var xo = Symbol('Manage ClipboardSub');
function Ud(e, t) {
  var r;
  return Object.assign(
    new ((r = class extends e.EventTarget {
      async read() {
        return Array.from(this.items);
      }
      async readText() {
        let n = '';
        for (const o of this.items) {
          const i = o.types.includes('text/plain')
            ? 'text/plain'
            : o.types.find((a) => a.startsWith('text/'));
          i && (n += await o.getType(i).then((a) => Ky(a, e.FileReader)));
        }
        return n;
      }
      async write(n) {
        this.items = n;
      }
      async writeText(n) {
        this.items = [Xy(e, n)];
      }
      constructor(...n) {
        (super(...n), Yy(this, 'items', []));
      }
    }),
    s(r, 'Clipboard'),
    r)(),
    { [xo]: t },
  );
}
s(Ud, 'createClipboardStub');
function xc(e) {
  return !!e?.[xo];
}
s(xc, 'isClipboardStub');
function vP(e) {
  if (xc(e.navigator.clipboard)) return e.navigator.clipboard[xo];
  const t = Object.getOwnPropertyDescriptor(e.navigator, 'clipboard');
  let r;
  const n = {
    resetClipboardStub: s(() => {
      r = Ud(e, n);
    }, 'resetClipboardStub'),
    detachClipboardStub: s(() => {
      t
        ? Object.defineProperty(e.navigator, 'clipboard', t)
        : Object.defineProperty(e.navigator, 'clipboard', { value: void 0, configurable: !0 });
    }, 'detachClipboardStub'),
  };
  return (
    (r = Ud(e, n)),
    Object.defineProperty(e.navigator, 'clipboard', { get: s(() => r, 'get'), configurable: !0 }),
    r[xo]
  );
}
s(vP, 'attachClipboardStubToView');
function TP(e) {
  xc(e.navigator.clipboard) && e.navigator.clipboard[xo].resetClipboardStub();
}
s(TP, 'resetClipboardStubOnView');
function EP(e) {
  xc(e.navigator.clipboard) && e.navigator.clipboard[xo].detachClipboardStub();
}
s(EP, 'detachClipboardStubFromView');
async function wP(e) {
  const t = e.defaultView,
    r = t?.navigator.clipboard,
    n = r && (await r.read());
  if (!n) throw new Error('The Clipboard API is unavailable.');
  const o = Rc(t);
  for (const i of n)
    for (const a of i.types) o.setData(a, await i.getType(a).then((c) => Ky(c, t.FileReader)));
  return o;
}
s(wP, 'readDataTransferFromClipboard');
async function Qy(e, t) {
  const r = qt(e),
    n = r.navigator.clipboard,
    o = [];
  for (let a = 0; a < t.items.length; a++) {
    const c = t.items[a],
      d = await bP(r, c);
    o.push(Xy(r, d));
  }
  if (
    !(
      n &&
      (await n.write(o).then(
        () => !0,
        () => !1,
      ))
    )
  )
    throw new Error('The Clipboard API is unavailable.');
}
s(Qy, 'writeDataTransferToClipboard');
var Ga = globalThis;
typeof Ga.afterEach == 'function' &&
  Ga.afterEach(() => {
    typeof globalThis.window < 'u' && TP(globalThis.window);
  });
typeof Ga.afterAll == 'function' &&
  Ga.afterAll(() => {
    typeof globalThis.window < 'u' && EP(globalThis.window);
  });
var SP = [
  'input:not([type=hidden]):not([disabled])',
  'button:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  '[contenteditable=""]',
  '[contenteditable="true"]',
  'a[href]',
  '[tabindex]:not([disabled])',
].join(', ');
function Pc(e) {
  return e.matches(SP);
}
s(Pc, 'isFocusable');
function _P(e) {
  return new e.constructor(e.type, e);
}
s(_P, 'cloneEvent');
function lr(e) {
  for (let r = e; r; r = r.parentElement)
    if (he(r, ['button', 'input', 'select', 'textarea', 'optgroup', 'option'])) {
      if (r.hasAttribute('disabled')) return !0;
    } else if (he(r, 'fieldset')) {
      var t;
      if (
        r.hasAttribute('disabled') &&
        !(!((t = r.querySelector(':scope > legend')) === null || t === void 0) && t.contains(e))
      )
        return !0;
    } else if (
      r.tagName.includes('-') &&
      r.constructor.formAssociated &&
      r.hasAttribute('disabled')
    )
      return !0;
  return !1;
}
s(lr, 'isDisabled');
function Vo(e) {
  const t = e.activeElement;
  return t?.shadowRoot
    ? Vo(t.shadowRoot)
    : lr(t)
      ? e.ownerDocument
        ? e.ownerDocument.body
        : e.body
      : t;
}
s(Vo, 'getActiveElement');
function oa(e) {
  var t;
  return (t = Vo(e)) !== null && t !== void 0 ? t : e.body;
}
s(oa, 'getActiveElementOrBody');
function AP(e, t) {
  let r = e;
  do {
    if (t(r)) return r;
    r = r.parentElement;
  } while (r && r !== e.ownerDocument.body);
}
s(AP, 'findClosest');
function Xr(e) {
  return (
    e.hasAttribute('contenteditable') &&
    (e.getAttribute('contenteditable') == 'true' || e.getAttribute('contenteditable') == '')
  );
}
s(Xr, 'isContentEditable');
function Po(e) {
  const t = RP(e);
  return t && (t.closest('[contenteditable=""]') || t.closest('[contenteditable="true"]'));
}
s(Po, 'getContentEditable');
function RP(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
s(RP, 'getElement');
var xP = (function (e) {
  return (
    (e.button = 'button'),
    (e.color = 'color'),
    (e.file = 'file'),
    (e.image = 'image'),
    (e.reset = 'reset'),
    (e.submit = 'submit'),
    (e.checkbox = 'checkbox'),
    (e.radio = 'radio'),
    e
  );
})(xP || {});
function Zy(e) {
  return he(e, 'button') || (he(e, 'input') && e.type in xP);
}
s(Zy, 'isClickableInput');
function Nn(e) {
  return (eh(e) && !e.readOnly) || Xr(e);
}
s(Nn, 'isEditable');
var PP = (function (e) {
  return (
    (e.text = 'text'),
    (e.date = 'date'),
    (e['datetime-local'] = 'datetime-local'),
    (e.email = 'email'),
    (e.month = 'month'),
    (e.number = 'number'),
    (e.password = 'password'),
    (e.search = 'search'),
    (e.tel = 'tel'),
    (e.time = 'time'),
    (e.url = 'url'),
    (e.week = 'week'),
    e
  );
})(PP || {});
function eh(e) {
  return he(e, 'textarea') || (he(e, 'input') && e.type in PP);
}
s(eh, 'isEditableInputOrTextArea');
function Yt(e) {
  return th(e) && eh(e);
}
s(Yt, 'hasOwnSelection');
function OP(e) {
  return th(e) && Zy(e);
}
s(OP, 'hasNoSelection');
function th(e) {
  return e.nodeType === 1;
}
s(th, 'isElement');
function CP(e) {
  const t = e.ownerDocument.getSelection();
  if (t?.focusNode && Yt(e)) {
    const n = Po(t.focusNode);
    if (n) {
      if (!t.isCollapsed) {
        var r;
        const o =
          ((r = n.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === 3
            ? n.firstChild
            : n;
        t.setBaseAndExtent(o, 0, o, 0);
      }
    } else t.setBaseAndExtent(e, 0, e, 0);
  }
}
s(CP, 'updateSelectionOnFocus');
function qn(e, t) {
  return Ee().eventWrapper(e);
}
s(qn, 'wrapEvent');
function Cr(e) {
  const t = AP(e, Pc),
    r = Vo(e.ownerDocument);
  (t ?? e.ownerDocument.body) !== r &&
    (qn(t ? () => t.focus() : () => r?.blur()), CP(t ?? e.ownerDocument.body));
}
s(Cr, 'focusElement');
function IP(e) {
  !Pc(e) || !(Vo(e.ownerDocument) === e) || qn(() => e.blur());
}
s(IP, 'blurElement');
var Qr = {};
Qr.click = (e, t, r) => {
  const n = t.closest('button,input,label,select,textarea'),
    o = n && he(n, 'label') && n.control;
  if (o && o !== t)
    return () => {
      Pc(o) && (Cr(o), r.dispatchEvent(o, _P(e)));
    };
  if (he(t, 'input', { type: 'file' }))
    return () => {
      (IP(t), t.dispatchEvent(new (qt(t).Event)('fileDialog')), Cr(t));
    };
};
var Oo = Symbol('Displayed value in UI'),
  Rr = Symbol('Displayed selection in UI'),
  Wa = Symbol('Initial value to compare on blur');
function NP(e) {
  return typeof e == 'object' && Oo in e;
}
s(NP, 'isUIValue');
function qP(e) {
  return !!e && typeof e == 'object' && Rr in e;
}
s(qP, 'isUISelectionStart');
function MP(e, t) {
  (e[Wa] === void 0 && (e[Wa] = e.value),
    (e[Oo] = t),
    (e.value = Object.assign(new String(t), { [Oo]: !0 })));
}
s(MP, 'setUIValue');
function Xt(e) {
  return e[Oo] === void 0 ? e.value : String(e[Oo]);
}
s(Xt, 'getUIValue');
function Oc(e) {
  e[Oo] = void 0;
}
s(Oc, 'setUIValueClean');
function rh(e) {
  e[Wa] = void 0;
}
s(rh, 'clearInitialValue');
function jP(e) {
  return e[Wa];
}
s(jP, 'getInitialValue');
function $P(e, t) {
  e[Rr] = t;
}
s($P, 'setUISelectionRaw');
function Vn(e, { focusOffset: t, anchorOffset: r = t }, n = 'replace') {
  const o = Xt(e).length,
    i = s((f) => Math.max(0, Math.min(o, f)), 'sanitizeOffset'),
    a = n === 'replace' || e[Rr] === void 0 ? i(r) : e[Rr].anchorOffset,
    c = i(t),
    d = Math.min(a, c),
    u = Math.max(a, c);
  if (
    ((e[Rr] = { anchorOffset: a, focusOffset: c }), e.selectionStart === d && e.selectionEnd === u)
  )
    return;
  const p = Object.assign(new Number(d), { [Rr]: !0 });
  try {
    e.setSelectionRange(p, u);
  } catch {}
}
s(Vn, 'setUISelection');
function Co(e) {
  var t, r, n;
  const o =
    (n = e[Rr]) !== null && n !== void 0
      ? n
      : {
          anchorOffset: (t = e.selectionStart) !== null && t !== void 0 ? t : 0,
          focusOffset: (r = e.selectionEnd) !== null && r !== void 0 ? r : 0,
        };
  return {
    ...o,
    startOffset: Math.min(o.anchorOffset, o.focusOffset),
    endOffset: Math.max(o.anchorOffset, o.focusOffset),
  };
}
s(Co, 'getUISelection');
function kP(e) {
  return !!e[Rr];
}
s(kP, 'hasUISelection');
function Bs(e) {
  e[Rr] = void 0;
}
s(Bs, 'setUISelectionClean');
var Ka = globalThis.parseInt;
function DP(e) {
  const t = e.replace(/\D/g, '');
  if (t.length < 2) return e;
  const r = Ka(t[0], 10),
    n = Ka(t[1], 10);
  if (r >= 3 || (r === 2 && n >= 4)) {
    let o;
    return (r >= 3 ? (o = 1) : (o = 2), Vd(t, o));
  }
  return e.length === 2 ? e : Vd(t, 2);
}
s(DP, 'buildTimeValue');
function Vd(e, t) {
  const r = e.slice(0, t),
    n = Math.min(Ka(r, 10), 23),
    o = e.slice(t),
    i = Ka(o, 10),
    a = Math.min(i, 59);
  return `${n.toString().padStart(2, '0')}:${a.toString().padStart(2, '0')}`;
}
s(Vd, 'build');
function nh(e, t) {
  const r = e.cloneNode();
  return ((r.value = t), r.value === t);
}
s(nh, 'isValidDateOrTimeValue');
var LP = (function (e) {
  return (
    (e.email = 'email'),
    (e.password = 'password'),
    (e.search = 'search'),
    (e.telephone = 'telephone'),
    (e.text = 'text'),
    (e.url = 'url'),
    e
  );
})(LP || {});
function FP(e) {
  var t;
  const r = (t = e.getAttribute('maxlength')) !== null && t !== void 0 ? t : '';
  return /^\d+$/.test(r) && Number(r) >= 0 ? Number(r) : void 0;
}
s(FP, 'getMaxLength');
function BP(e) {
  return he(e, 'textarea') || (he(e, 'input') && e.type in LP);
}
s(BP, 'supportsMaxLength');
function oh(e, t, r, n) {
  if (Js(e) && t + r >= 0 && t + r <= e.nodeValue.length) return { node: e, offset: t + r };
  const o = Hd(e, t, r);
  if (o) {
    if (Js(o))
      return {
        node: o,
        offset: r > 0 ? Math.min(1, o.nodeValue.length) : Math.max(o.nodeValue.length - 1, 0),
      };
    if (he(o, 'br')) {
      const i = Hd(o, void 0, r);
      return i
        ? Js(i)
          ? { node: i, offset: r > 0 ? 0 : i.nodeValue.length }
          : r < 0 && he(i, 'br')
            ? { node: o.parentNode, offset: Ps(o) }
            : { node: i.parentNode, offset: Ps(i) + (r > 0 ? 0 : 1) }
        : r < 0 && n === 'deleteContentBackward'
          ? { node: o.parentNode, offset: Ps(o) }
          : void 0;
    } else return { node: o.parentNode, offset: Ps(o) + (r > 0 ? 1 : 0) };
  }
}
s(oh, 'getNextCursorPosition');
function Hd(e, t, r) {
  const n = Number(t) + (r < 0 ? -1 : 0);
  return (
    t !== void 0 && Cc(e) && n >= 0 && n < e.children.length && (e = e.children[n]),
    UP(e, r === 1 ? 'next' : 'previous', JP)
  );
}
s(Hd, 'getNextCharacterContentNode');
function JP(e) {
  if (Js(e)) return !0;
  if (Cc(e)) {
    if (he(e, ['input', 'textarea'])) return e.type !== 'hidden';
    if (he(e, 'br')) return !0;
  }
  return !1;
}
s(JP, 'isTreatedAsCharacterContent');
function Ps(e) {
  let t = 0;
  for (; e.previousSibling; ) (t++, (e = e.previousSibling));
  return t;
}
s(Ps, 'getOffset');
function Cc(e) {
  return e.nodeType === 1;
}
s(Cc, 'isElement');
function Js(e) {
  return e.nodeType === 3;
}
s(Js, 'isTextNode');
function UP(e, t, r) {
  for (;;) {
    var n;
    const o = e[`${t}Sibling`];
    if (o) {
      if (((e = VP(o, t === 'next' ? 'first' : 'last')), r(e))) return e;
    } else if (
      e.parentNode &&
      (!Cc(e.parentNode) ||
        (!Xr(e.parentNode) &&
          e.parentNode !== ((n = e.ownerDocument) === null || n === void 0 ? void 0 : n.body)))
    )
      e = e.parentNode;
    else break;
  }
}
s(UP, 'walkNodes');
function VP(e, t) {
  for (; e.hasChildNodes(); ) e = e[`${t}Child`];
  return e;
}
s(VP, 'getDescendant');
var ci = Symbol('Track programmatic changes for React workaround');
function HP(e) {
  return (
    Object.getOwnPropertyNames(e).some((t) => t.startsWith('__react')) && qt(e).REACT_VERSION === 17
  );
}
s(HP, 'isReact17Element');
function zP(e) {
  HP(e) && (e[ci] = { previousValue: String(e.value), tracked: [] });
}
s(zP, 'startTrackValue');
function GP(e, t) {
  var r, n;
  ((n = e[ci]) === null || n === void 0 || (r = n.tracked) === null || r === void 0 || r.push(t),
    e[ci] || (Oc(e), Vn(e, { focusOffset: t.length })));
}
s(GP, 'trackOrSetValue');
function WP(e, t) {
  var r;
  const n = e[ci];
  if (((e[ci] = void 0), !(!(n == null || (r = n.tracked) === null || r === void 0) && r.length)))
    return;
  const o = n.tracked.length === 2 && n.tracked[0] === n.previousValue && n.tracked[1] === e.value;
  (o || Oc(e), kP(e) && Vn(e, { focusOffset: o ? t : e.value.length }));
}
s(WP, 'commitValueAfterInput');
function sh(e) {
  const t = KP(e);
  if (t && Yt(t)) return { type: 'input', selection: Co(t) };
  const r = t?.ownerDocument.getSelection();
  return {
    type: Po(e) && r?.anchorNode && Po(r.anchorNode) ? 'contenteditable' : 'default',
    selection: r,
  };
}
s(sh, 'getTargetTypeAndSelection');
function KP(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
s(KP, 'getElement');
function YP(e) {
  const t = sh(e);
  if (t.type === 'input') return t.selection;
  if (t.type === 'contenteditable') {
    var r;
    return (r = t.selection) === null || r === void 0 ? void 0 : r.getRangeAt(0);
  }
}
s(YP, 'getInputRange');
function Zr({ focusNode: e, focusOffset: t, anchorNode: r = e, anchorOffset: n = t }) {
  var o, i;
  if (sh(e).type === 'input') return Vn(e, { anchorOffset: n, focusOffset: t });
  (i = r.ownerDocument) === null ||
    i === void 0 ||
    (o = i.getSelection()) === null ||
    o === void 0 ||
    o.setBaseAndExtent(r, n, e, t);
}
s(Zr, 'setSelection');
function ih(e) {
  return he(e, 'input') && ['date', 'time'].includes(e.type);
}
s(ih, 'isDateOrTime');
function Mn(e, t, r, n = 'insertText') {
  const o = YP(t);
  o &&
    ((!ih(t) && !e.dispatchUIEvent(t, 'beforeinput', { inputType: n, data: r })) ||
      ('startContainer' in o ? XP(e, t, o, r, n) : QP(e, t, o, r, n)));
}
s(Mn, 'input');
function XP(e, t, r, n, o) {
  let i = !1;
  if (!r.collapsed) ((i = !0), r.deleteContents());
  else if (['deleteContentBackward', 'deleteContentForward'].includes(o)) {
    const a = oh(r.startContainer, r.startOffset, o === 'deleteContentBackward' ? -1 : 1, o);
    if (a) {
      i = !0;
      const c = r.cloneRange();
      (c.comparePoint(a.node, a.offset) < 0
        ? c.setStart(a.node, a.offset)
        : c.setEnd(a.node, a.offset),
        c.deleteContents());
    }
  }
  if (n)
    if (r.endContainer.nodeType === 3) {
      const a = r.endOffset;
      (r.endContainer.insertData(a, n),
        r.setStart(r.endContainer, a + n.length),
        r.setEnd(r.endContainer, a + n.length));
    } else {
      const a = t.ownerDocument.createTextNode(n);
      (r.insertNode(a), r.setStart(a, n.length), r.setEnd(a, n.length));
    }
  (i || n) && e.dispatchUIEvent(t, 'input', { inputType: o });
}
s(XP, 'editContenteditable');
function QP(e, t, r, n, o) {
  let i = n;
  if (BP(t)) {
    const u = FP(t);
    if (u !== void 0 && n.length > 0) {
      const p = u - t.value.length;
      if (p > 0) i = n.substring(0, p);
      else return;
    }
  }
  const { newValue: a, newOffset: c, oldValue: d } = ZP(i, t, r, o);
  (a === d && c === r.startOffset && c === r.endOffset) ||
    (he(t, 'input', { type: 'number' }) && !eO(a)) ||
    (MP(t, a),
    Zr({ focusNode: t, anchorOffset: c, focusOffset: c }),
    ih(t)
      ? nh(t, a) && (zd(e, t, c, {}), e.dispatchUIEvent(t, 'change'), rh(t))
      : zd(e, t, c, { data: n, inputType: o }));
}
s(QP, 'editInputElement');
function ZP(e, t, { startOffset: r, endOffset: n }, o) {
  const i = Xt(t),
    a = Math.max(0, r === n && o === 'deleteContentBackward' ? r - 1 : r),
    c = i.substring(0, a),
    d = Math.min(i.length, r === n && o === 'deleteContentForward' ? r + 1 : n),
    u = i.substring(d, i.length);
  let p = `${c}${e}${u}`,
    f = a + e.length;
  if (he(t, 'input', { type: 'time' })) {
    const m = DP(p);
    m !== '' && nh(t, m) && ((p = m), (f = m.length));
  }
  return { oldValue: i, newValue: p, newOffset: f };
}
s(ZP, 'calculateNewValue');
function zd(e, t, r, n) {
  (e.dispatchUIEvent(t, 'input', n), WP(t, r));
}
s(zd, 'commitInput');
function eO(e) {
  var t, r;
  const n = e.split('e', 2);
  return !(
    /[^\d.\-e]/.test(e) ||
    Number((t = e.match(/-/g)) === null || t === void 0 ? void 0 : t.length) > 2 ||
    Number((r = e.match(/\./g)) === null || r === void 0 ? void 0 : r.length) > 1 ||
    (n[1] && !/^-?\d*$/.test(n[1]))
  );
}
s(eO, 'isValidNumberInput');
Qr.cut = (e, t, r) => () => {
  Nn(t) && Mn(r, t, '', 'deleteByCut');
};
function tO(e) {
  return e ? (Xr(e) ? e.textContent : Xt(e)) : null;
}
s(tO, 'getValueOrTextContent');
function rO(e) {
  const t = qt(e);
  for (let r = e; r?.ownerDocument; r = r.parentElement) {
    const { display: n, visibility: o } = t.getComputedStyle(r);
    if (n === 'none' || o === 'hidden') return !1;
  }
  return !0;
}
s(rO, 'isVisible');
function nO(e, t) {
  const r = e.ownerDocument,
    n = r.querySelectorAll(SP),
    o = Array.from(n).filter((d) => d === e || !(Number(d.getAttribute('tabindex')) < 0 || lr(d)));
  Number(e.getAttribute('tabindex')) >= 0 &&
    o.sort((d, u) => {
      const p = Number(d.getAttribute('tabindex')),
        f = Number(u.getAttribute('tabindex'));
      return p === f ? 0 : p === 0 ? 1 : f === 0 ? -1 : p - f;
    });
  const i = {};
  let a = [r.body];
  const c = he(e, 'input', { type: 'radio' }) ? e.name : void 0;
  o.forEach((d) => {
    const u = d;
    if (he(u, 'input', { type: 'radio' }) && u.name) {
      if (u === e) {
        a.push(u);
        return;
      } else if (u.name === c) return;
      if (u.checked) {
        ((a = a.filter((p) => !he(p, 'input', { type: 'radio', name: u.name }))),
          a.push(u),
          (i[u.name] = u));
        return;
      }
      if (typeof i[u.name] < 'u') return;
    }
    a.push(u);
  });
  for (let d = a.findIndex((u) => u === e); ; )
    if (
      ((d += t ? -1 : 1),
      d === a.length ? (d = 0) : d === -1 && (d = a.length - 1),
      a[d] === e || a[d] === r.body || rO(a[d]))
    )
      return a[d];
}
s(nO, 'getTabDestination');
function Gd(e, t) {
  if (Yt(e)) {
    const r = Co(e);
    Zr({
      focusNode: e,
      focusOffset:
        r.startOffset === r.endOffset ? r.focusOffset + t : t < 0 ? r.startOffset : r.endOffset,
    });
  } else {
    const r = e.ownerDocument.getSelection();
    if (!r?.focusNode) return;
    if (r.isCollapsed) {
      const n = oh(r.focusNode, r.focusOffset, t);
      n && Zr({ focusNode: n.node, focusOffset: n.offset });
    } else r[t < 0 ? 'collapseToStart' : 'collapseToEnd']();
  }
}
s(Gd, 'moveSelection');
function ah(e) {
  if (Yt(e)) return Zr({ focusNode: e, anchorOffset: 0, focusOffset: Xt(e).length });
  var t;
  const r = (t = Po(e)) !== null && t !== void 0 ? t : e.ownerDocument.body;
  Zr({ focusNode: r, anchorOffset: 0, focusOffset: r.childNodes.length });
}
s(ah, 'selectAll');
function oO(e) {
  if (Yt(e)) return Co(e).startOffset === 0 && Co(e).endOffset === Xt(e).length;
  var t;
  const r = (t = Po(e)) !== null && t !== void 0 ? t : e.ownerDocument.body,
    n = e.ownerDocument.getSelection();
  return (
    n?.anchorNode === r &&
    n.focusNode === r &&
    n.anchorOffset === 0 &&
    n.focusOffset === r.childNodes.length
  );
}
s(oO, 'isAllSelected');
function to(e, t, r) {
  var n;
  if (Yt(e)) return Zr({ focusNode: e, anchorOffset: t, focusOffset: r });
  if (Xr(e) && ((n = e.firstChild) === null || n === void 0 ? void 0 : n.nodeType) === 3)
    return Zr({ focusNode: e.firstChild, anchorOffset: t, focusOffset: r });
  throw new Error('Not implemented. The result of this interaction is unreliable.');
}
s(to, 'setSelectionRange');
function Os(e, t, r) {
  const n = qt(t),
    o = Array.from(
      t.ownerDocument.querySelectorAll(
        t.name
          ? `input[type="radio"][name="${n.CSS.escape(t.name)}"]`
          : 'input[type="radio"][name=""], input[type="radio"]:not([name])',
      ),
    );
  for (let i = o.findIndex((a) => a === t) + r; ; i += r) {
    if ((o[i] || (i = r > 0 ? 0 : o.length - 1), o[i] === t)) return;
    if (!lr(o[i])) {
      (Cr(o[i]), e.dispatchUIEvent(o[i], 'click'));
      return;
    }
  }
}
s(Os, 'walkRadio');
Qr.keydown = (e, t, r) => {
  var n, o;
  return (o = (n = fb[e.key]) === null || n === void 0 ? void 0 : n.call(fb, e, t, r)) !== null &&
    o !== void 0
    ? o
    : XJ(e, t, r);
};
var fb = {
    ArrowDown: s((e, t, r) => {
      if (he(t, 'input', { type: 'radio' })) return () => Os(r, t, 1);
    }, 'ArrowDown'),
    ArrowLeft: s(
      (e, t, r) => (he(t, 'input', { type: 'radio' }) ? () => Os(r, t, -1) : () => Gd(t, -1)),
      'ArrowLeft',
    ),
    ArrowRight: s(
      (e, t, r) => (he(t, 'input', { type: 'radio' }) ? () => Os(r, t, 1) : () => Gd(t, 1)),
      'ArrowRight',
    ),
    ArrowUp: s((e, t, r) => {
      if (he(t, 'input', { type: 'radio' })) return () => Os(r, t, -1);
    }, 'ArrowUp'),
    Backspace: s((e, t, r) => {
      if (Nn(t))
        return () => {
          Mn(r, t, '', 'deleteContentBackward');
        };
    }, 'Backspace'),
    Delete: s((e, t, r) => {
      if (Nn(t))
        return () => {
          Mn(r, t, '', 'deleteContentForward');
        };
    }, 'Delete'),
    End: s((e, t) => {
      if (he(t, ['input', 'textarea']) || Xr(t))
        return () => {
          var r, n;
          const o =
            (n = (r = tO(t)) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0
              ? n
              : 0;
          to(t, o, o);
        };
    }, 'End'),
    Home: s((e, t) => {
      if (he(t, ['input', 'textarea']) || Xr(t))
        return () => {
          to(t, 0, 0);
        };
    }, 'Home'),
    PageDown: s((e, t) => {
      if (he(t, ['input']))
        return () => {
          const r = Xt(t).length;
          to(t, r, r);
        };
    }, 'PageDown'),
    PageUp: s((e, t) => {
      if (he(t, ['input']))
        return () => {
          to(t, 0, 0);
        };
    }, 'PageUp'),
    Tab: s(
      (e, t, r) => () => {
        const n = nO(t, r.system.keyboard.modifiers.Shift);
        (Cr(n), Yt(n) && Vn(n, { anchorOffset: 0, focusOffset: n.value.length }));
      },
      'Tab',
    ),
  },
  XJ = s((e, t, r) => {
    if (e.code === 'KeyA' && r.system.keyboard.modifiers.Control) return () => ah(t);
  }, 'combinationBehavior');
Qr.keypress = (e, t, r) => {
  if (e.key === 'Enter') {
    if (he(t, 'button') || (he(t, 'input') && QJ.includes(t.type)) || (he(t, 'a') && t.href))
      return () => {
        r.dispatchUIEvent(t, 'click');
      };
    if (he(t, 'input')) {
      const n = t.form,
        o = n?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return o
        ? () => r.dispatchUIEvent(o, 'click')
        : n && ZJ.includes(t.type) && n.querySelectorAll('input').length === 1
          ? () => r.dispatchUIEvent(n, 'submit')
          : void 0;
    }
  }
  if (Nn(t)) {
    const n =
        e.key === 'Enter'
          ? Xr(t) && !r.system.keyboard.modifiers.Shift
            ? 'insertParagraph'
            : 'insertLineBreak'
          : 'insertText',
      o =
        e.key === 'Enter'
          ? `
`
          : e.key;
    return () => Mn(r, t, o, n);
  }
};
var QJ = ['button', 'color', 'file', 'image', 'reset', 'submit'],
  ZJ = ['email', 'month', 'password', 'search', 'tel', 'text', 'url', 'week'];
Qr.keyup = (e, t, r) => {
  var n;
  return (n = mb[e.key]) === null || n === void 0 ? void 0 : n.call(mb, e, t, r);
};
var mb = {
  ' ': s((e, t, r) => {
    if (Zy(t)) return () => r.dispatchUIEvent(t, 'click');
  }, ' '),
};
Qr.paste = (e, t, r) => {
  if (Nn(t))
    return () => {
      var n;
      const o = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.getData('text');
      o && Mn(r, t, o, 'insertFromPaste');
    };
};
var sO = {
  auxclick: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  beforeinput: {
    EventType: 'InputEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  blur: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
  click: { EventType: 'PointerEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  contextmenu: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  copy: { EventType: 'ClipboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  change: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
  cut: { EventType: 'ClipboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  dblclick: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  focus: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
  focusin: { EventType: 'FocusEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  focusout: { EventType: 'FocusEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  keydown: {
    EventType: 'KeyboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  keypress: {
    EventType: 'KeyboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  keyup: { EventType: 'KeyboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  paste: {
    EventType: 'ClipboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  input: { EventType: 'InputEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  mousedown: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseenter: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
  },
  mouseleave: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
  },
  mousemove: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseout: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  mouseover: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseup: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  pointerover: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerenter: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
  pointerdown: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointermove: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerup: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointercancel: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
  },
  pointerout: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerleave: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
  submit: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
};
function lh(e) {
  return sO[e].EventType;
}
s(lh, 'getEventClass');
var eU = ['MouseEvent', 'PointerEvent'];
function iO(e) {
  return eU.includes(lh(e));
}
s(iO, 'isMouseEvent');
function aO(e) {
  return lh(e) === 'KeyboardEvent';
}
s(aO, 'isKeyboardEvent');
var tU = {
  ClipboardEvent: [cO],
  Event: [],
  FocusEvent: [Kn, uO],
  InputEvent: [Kn, dO],
  MouseEvent: [Kn, sa, Wd],
  PointerEvent: [Kn, sa, Wd, fO],
  KeyboardEvent: [Kn, sa, pO],
};
function ch(e, t, r) {
  const n = qt(t),
    { EventType: o, defaultInit: i } = sO[e],
    a = new (lO(n)[o])(e, i);
  return (tU[o].forEach((c) => c(a, r ?? {})), a);
}
s(ch, 'createEvent');
function lO(e) {
  var t, r, n, o, i, a, c, d, u, p, f, m, h, g, v, E;
  const b = (E = e.Event) !== null && E !== void 0 ? E : ((t = class {}), s(t, 'Event'), t);
  var S;
  const R =
    (S = e.AnimationEvent) !== null && S !== void 0
      ? S
      : ((r = class extends b {}), s(r, 'AnimationEvent'), r);
  var I;
  const q =
    (I = e.ClipboardEvent) !== null && I !== void 0
      ? I
      : ((n = class extends b {}), s(n, 'ClipboardEvent'), n);
  var P;
  const A =
    (P = e.PopStateEvent) !== null && P !== void 0
      ? P
      : ((o = class extends b {}), s(o, 'PopStateEvent'), o);
  var w;
  const _ =
    (w = e.ProgressEvent) !== null && w !== void 0
      ? w
      : ((i = class extends b {}), s(i, 'ProgressEvent'), i);
  var $;
  const N =
    ($ = e.TransitionEvent) !== null && $ !== void 0
      ? $
      : ((a = class extends b {}), s(a, 'TransitionEvent'), a);
  var V;
  const H =
    (V = e.UIEvent) !== null && V !== void 0 ? V : ((c = class extends b {}), s(c, 'UIEvent'), c);
  var x;
  const D =
    (x = e.CompositionEvent) !== null && x !== void 0
      ? x
      : ((d = class extends H {}), s(d, 'CompositionEvent'), d);
  var F;
  const k =
    (F = e.FocusEvent) !== null && F !== void 0
      ? F
      : ((u = class extends H {}), s(u, 'FocusEvent'), u);
  var K;
  const X =
    (K = e.InputEvent) !== null && K !== void 0
      ? K
      : ((p = class extends H {}), s(p, 'InputEvent'), p);
  var se;
  const ie =
    (se = e.KeyboardEvent) !== null && se !== void 0
      ? se
      : ((f = class extends H {}), s(f, 'KeyboardEvent'), f);
  var W;
  const ae =
    (W = e.MouseEvent) !== null && W !== void 0
      ? W
      : ((m = class extends H {}), s(m, 'MouseEvent'), m);
  var be;
  const ue =
    (be = e.DragEvent) !== null && be !== void 0
      ? be
      : ((h = class extends ae {}), s(h, 'DragEvent'), h);
  var ee;
  const xe =
    (ee = e.PointerEvent) !== null && ee !== void 0
      ? ee
      : ((g = class extends ae {}), s(g, 'PointerEvent'), g);
  var Pe;
  const He =
    (Pe = e.TouchEvent) !== null && Pe !== void 0
      ? Pe
      : ((v = class extends H {}), s(v, 'TouchEvent'), v);
  return {
    Event: b,
    AnimationEvent: R,
    ClipboardEvent: q,
    PopStateEvent: A,
    ProgressEvent: _,
    TransitionEvent: N,
    UIEvent: H,
    CompositionEvent: D,
    FocusEvent: k,
    InputEvent: X,
    KeyboardEvent: ie,
    MouseEvent: ae,
    DragEvent: ue,
    PointerEvent: xe,
    TouchEvent: He,
  };
}
s(lO, 'getEventConstructors');
function Mr(e, t) {
  for (const [r, n] of Object.entries(t))
    Object.defineProperty(e, r, { get: s(() => n ?? null, 'get') });
}
s(Mr, 'assignProps');
function De(e) {
  return Number(e ?? 0);
}
s(De, 'sanitizeNumber');
function cO(e, { clipboardData: t }) {
  Mr(e, { clipboardData: t });
}
s(cO, 'initClipboardEvent');
function uO(e, { relatedTarget: t }) {
  Mr(e, { relatedTarget: t });
}
s(uO, 'initFocusEvent');
function dO(e, { data: t, inputType: r, isComposing: n }) {
  Mr(e, { data: t, isComposing: !!n, inputType: String(r) });
}
s(dO, 'initInputEvent');
function Kn(e, { view: t, detail: r }) {
  Mr(e, { view: t, detail: De(r ?? 0) });
}
s(Kn, 'initUIEvent');
function sa(
  e,
  {
    altKey: t,
    ctrlKey: r,
    metaKey: n,
    shiftKey: o,
    modifierAltGraph: i,
    modifierCapsLock: a,
    modifierFn: c,
    modifierFnLock: d,
    modifierNumLock: u,
    modifierScrollLock: p,
    modifierSymbol: f,
    modifierSymbolLock: m,
  },
) {
  Mr(e, {
    altKey: !!t,
    ctrlKey: !!r,
    metaKey: !!n,
    shiftKey: !!o,
    getModifierState(h) {
      return !!{
        Alt: t,
        AltGraph: i,
        CapsLock: a,
        Control: r,
        Fn: c,
        FnLock: d,
        Meta: n,
        NumLock: u,
        ScrollLock: p,
        Shift: o,
        Symbol: f,
        SymbolLock: m,
      }[h];
    },
  });
}
s(sa, 'initUIEventModifiers');
function pO(e, { key: t, code: r, location: n, repeat: o, isComposing: i, charCode: a }) {
  Mr(e, {
    key: String(t),
    code: String(r),
    location: De(n),
    repeat: !!o,
    isComposing: !!i,
    charCode: a,
  });
}
s(pO, 'initKeyboardEvent');
function Wd(
  e,
  {
    x: t,
    y: r,
    screenX: n,
    screenY: o,
    clientX: i = t,
    clientY: a = r,
    button: c,
    buttons: d,
    relatedTarget: u,
    offsetX: p,
    offsetY: f,
    pageX: m,
    pageY: h,
  },
) {
  Mr(e, {
    screenX: De(n),
    screenY: De(o),
    clientX: De(i),
    x: De(i),
    clientY: De(a),
    y: De(a),
    button: De(c),
    buttons: De(d),
    relatedTarget: u,
    offsetX: De(p),
    offsetY: De(f),
    pageX: De(m),
    pageY: De(h),
  });
}
s(Wd, 'initMouseEvent');
function fO(
  e,
  {
    pointerId: t,
    width: r,
    height: n,
    pressure: o,
    tangentialPressure: i,
    tiltX: a,
    tiltY: c,
    twist: d,
    pointerType: u,
    isPrimary: p,
  },
) {
  Mr(e, {
    pointerId: De(t),
    width: De(r ?? 1),
    height: De(n ?? 1),
    pressure: De(o),
    tangentialPressure: De(i),
    tiltX: De(a),
    tiltY: De(c),
    twist: De(d),
    pointerType: String(u),
    isPrimary: !!p,
  });
}
s(fO, 'initPointerEvent');
function mO(e, t, r, n = !1) {
  (iO(t) || aO(t)) && (r = { ...r, ...this.system.getUIEventModifiers() });
  const o = ch(t, e, r);
  return uh.call(this, e, o, n);
}
s(mO, 'dispatchUIEvent');
function uh(e, t, r = !1) {
  var n;
  const o = t.type,
    i = r ? () => {} : (n = Qr[o]) === null || n === void 0 ? void 0 : n.call(Qr, t, e, this);
  if (i) {
    t.preventDefault();
    let a = !1;
    return (
      Object.defineProperty(t, 'defaultPrevented', { get: s(() => a, 'get') }),
      Object.defineProperty(t, 'preventDefault', {
        value: s(() => {
          a = t.cancelable;
        }, 'value'),
      }),
      qn(() => e.dispatchEvent(t)),
      a || i(),
      !a
    );
  }
  return qn(() => e.dispatchEvent(t));
}
s(uh, 'dispatchEvent');
function Lr(e, t, r) {
  const n = ch(t, e, r);
  qn(() => e.dispatchEvent(n));
}
s(Lr, 'dispatchDOMEvent');
var yb = Symbol('patched focus/blur methods');
function dh(e) {
  if (e.prototype[yb]) return;
  const { focus: t, blur: r } = e.prototype;
  Object.defineProperties(e.prototype, {
    focus: { configurable: !0, get: s(() => o, 'get') },
    blur: { configurable: !0, get: s(() => i, 'get') },
    [yb]: { configurable: !0, get: s(() => ({ focus: t, blur: r }), 'get') },
  });
  let n;
  function o(a) {
    if (this.ownerDocument.visibilityState !== 'hidden') return t.call(this, a);
    const c = Kd(this.ownerDocument);
    if (c === this) return;
    const d = Symbol('focus call');
    ((n = d),
      c &&
        (r.call(c),
        Lr(c, 'blur', { relatedTarget: this }),
        Lr(c, 'focusout', { relatedTarget: n === d ? this : null })),
      n === d && (t.call(this, a), Lr(this, 'focus', { relatedTarget: c })),
      n === d && Lr(this, 'focusin', { relatedTarget: c }));
  }
  s(o, 'patchedFocus');
  function i() {
    if (this.ownerDocument.visibilityState !== 'hidden') return r.call(this);
    const a = Kd(this.ownerDocument);
    if (a !== this) return;
    ((n = Symbol('blur call')),
      r.call(this),
      Lr(a, 'blur', { relatedTarget: null }),
      Lr(a, 'focusout', { relatedTarget: null }));
  }
  s(i, 'patchedBlur');
}
s(dh, 'patchFocus');
function Kd(e) {
  const t = Vo(e);
  return t?.tagName === 'BODY' ? null : t;
}
s(Kd, 'getActiveTarget');
var du = Symbol('Interceptor for programmatical calls');
function gn(e, t, r) {
  const n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    o = Object.getOwnPropertyDescriptor(e, t),
    i = n?.set ? 'set' : 'value';
  if (typeof n?.[i] != 'function' || n[i][du])
    throw new Error(`Element ${e.tagName} does not implement "${String(t)}".`);
  function a(...c) {
    const { applyNative: d = !1, realArgs: u, then: p } = r.call(this, ...c),
      f = ((!d && o) || n)[i];
    (i === 'set' ? f.call(this, u) : f.call(this, ...u), p?.());
  }
  (s(a, 'intercept'), (a[du] = du), Object.defineProperty(e, t, { ...(o ?? n), [i]: a }));
}
s(gn, 'prepareInterceptor');
function yO(e) {
  gn(
    e,
    'value',
    s(function (r) {
      const n = NP(r);
      return (
        n && zP(this),
        { applyNative: !!n, realArgs: hO(this, r), then: n ? void 0 : () => GP(this, String(r)) }
      );
    }, 'interceptorImpl'),
  );
}
s(yO, 'prepareValueInterceptor');
function hO(e, t) {
  return he(e, 'input', { type: 'number' }) && String(t) !== '' && !Number.isNaN(Number(t))
    ? String(Number(t))
    : String(t);
}
s(hO, 'sanitizeValue');
function gO(e) {
  (gn(
    e,
    'setSelectionRange',
    s(function (r, ...n) {
      const o = qP(r);
      return {
        applyNative: !!o,
        realArgs: [Number(r), ...n],
        then: s(() => (o ? void 0 : Bs(e)), 'then'),
      };
    }, 'interceptorImpl'),
  ),
    gn(
      e,
      'selectionStart',
      s(function (r) {
        return { realArgs: r, then: s(() => Bs(e), 'then') };
      }, 'interceptorImpl'),
    ),
    gn(
      e,
      'selectionEnd',
      s(function (r) {
        return { realArgs: r, then: s(() => Bs(e), 'then') };
      }, 'interceptorImpl'),
    ),
    gn(
      e,
      'select',
      s(function () {
        return {
          realArgs: [],
          then: s(() => $P(e, { anchorOffset: 0, focusOffset: Xt(e).length }), 'then'),
        };
      }, 'interceptorImpl'),
    ));
}
s(gO, 'prepareSelectionInterceptor');
function bO(e) {
  gn(
    e,
    'setRangeText',
    s(function (...r) {
      return {
        realArgs: r,
        then: s(() => {
          (Oc(e), Bs(e));
        }, 'then'),
      };
    }, 'interceptorImpl'),
  );
}
s(bO, 'prepareRangeTextInterceptor');
var co = Symbol('Node prepared with document state workarounds');
function ph(e) {
  e[co] ||
    (e.addEventListener(
      'focus',
      (t) => {
        const r = t.target;
        Yd(r);
      },
      { capture: !0, passive: !0 },
    ),
    e.activeElement && Yd(e.activeElement),
    e.addEventListener(
      'blur',
      (t) => {
        const r = t.target,
          n = jP(r);
        n !== void 0 && (r.value !== n && Lr(r, 'change'), rh(r));
      },
      { capture: !0, passive: !0 },
    ),
    (e[co] = co));
}
s(ph, 'prepareDocument');
function Yd(e) {
  e[co] || (he(e, ['input', 'textarea']) && (yO(e), gO(e), bO(e)), (e[co] = co));
}
s(Yd, 'prepareElement');
function vO(e) {
  return TO(e) ? e : e.ownerDocument;
}
s(vO, 'getDocumentFromNode');
function TO(e) {
  return e.nodeType === 9;
}
s(TO, 'isDocument');
var Ot = (function (e) {
  return ((e[(e.Trigger = 2)] = 'Trigger'), (e[(e.Call = 1)] = 'Call'), e);
})({});
function ro(e, t) {
  e.levelRefs[t] = {};
}
s(ro, 'setLevelRef');
function Cs(e, t) {
  return e.levelRefs[t];
}
s(Cs, 'getLevelRef');
function jn(e) {
  const t = e.delay;
  if (typeof t == 'number')
    return Promise.all([
      new Promise((r) => globalThis.setTimeout(() => r(), t)),
      e.advanceTimers(t),
    ]);
}
s(jn, 'wait');
var ia = (function (e) {
  return (
    (e[(e.EachTrigger = 4)] = 'EachTrigger'),
    (e[(e.EachApiCall = 2)] = 'EachApiCall'),
    (e[(e.EachTarget = 1)] = 'EachTarget'),
    (e[(e.Never = 0)] = 'Never'),
    e
  );
})({});
function $r(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s($r, '_define_property');
var Qt = (function (e) {
    return (
      (e[(e.STANDARD = 0)] = 'STANDARD'),
      (e[(e.LEFT = 1)] = 'LEFT'),
      (e[(e.RIGHT = 2)] = 'RIGHT'),
      (e[(e.NUMPAD = 3)] = 'NUMPAD'),
      e
    );
  })({}),
  rU = ['Alt', 'AltGraph', 'Control', 'Fn', 'Meta', 'Shift', 'Symbol'];
function Xd(e) {
  return rU.includes(e);
}
s(Xd, 'isModifierKey');
var nU = ['CapsLock', 'FnLock', 'NumLock', 'ScrollLock', 'SymbolLock'];
function Qd(e) {
  return nU.includes(e);
}
s(Qd, 'isModifierLock');
var EO = class {
  isKeyPressed(t) {
    return this.pressed.has(String(t.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((t) => t.keyDef);
  }
  async keydown(t, r) {
    const n = String(r.key),
      o = String(r.code),
      i = oa(t.config.document);
    (this.setKeydownTarget(i), this.pressed.add(o, r), Xd(n) && (this.modifiers[n] = !0));
    const a = t.dispatchUIEvent(i, 'keydown', { key: n, code: o });
    (Qd(n) && !this.modifiers[n] && ((this.modifiers[n] = !0), (this.modifierLockStart[n] = !0)),
      a && this.pressed.setUnprevented(o),
      a &&
        this.hasKeyPress(n) &&
        t.dispatchUIEvent(oa(t.config.document), 'keypress', {
          key: n,
          code: o,
          charCode: r.key === 'Enter' ? 13 : String(r.key).charCodeAt(0),
        }));
  }
  async keyup(t, r) {
    const n = String(r.key),
      o = String(r.code),
      i = this.pressed.isUnprevented(o);
    (this.pressed.delete(o),
      Xd(n) && !this.pressed.values().find((a) => a.keyDef.key === n) && (this.modifiers[n] = !1),
      t.dispatchUIEvent(oa(t.config.document), 'keyup', { key: n, code: o }, !i),
      Qd(n) &&
        this.modifiers[n] &&
        (this.modifierLockStart[n] ? (this.modifierLockStart[n] = !1) : (this.modifiers[n] = !1)));
  }
  setKeydownTarget(t) {
    (t !== this.lastKeydownTarget && (this.carryChar = ''), (this.lastKeydownTarget = t));
  }
  hasKeyPress(t) {
    return (t.length === 1 || t === 'Enter') && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(t) {
    ($r(this, 'system', void 0),
      $r(this, 'modifiers', {
        Alt: !1,
        AltGraph: !1,
        CapsLock: !1,
        Control: !1,
        Fn: !1,
        FnLock: !1,
        Meta: !1,
        NumLock: !1,
        ScrollLock: !1,
        Shift: !1,
        Symbol: !1,
        SymbolLock: !1,
      }),
      $r(
        this,
        'pressed',
        new (class {
          add(r, n) {
            var o, i, a;
            ((a = (o = this.registry)[(i = r)]) !== null && a !== void 0) ||
              (o[i] = { keyDef: n, unpreventedDefault: !1 });
          }
          has(r) {
            return !!this.registry[r];
          }
          setUnprevented(r) {
            const n = this.registry[r];
            n && (n.unpreventedDefault = !0);
          }
          isUnprevented(r) {
            var n;
            return !!(!((n = this.registry[r]) === null || n === void 0) && n.unpreventedDefault);
          }
          delete(r) {
            delete this.registry[r];
          }
          values() {
            return Object.values(this.registry);
          }
          constructor() {
            $r(this, 'registry', {});
          }
        })(),
      ),
      $r(this, 'carryChar', ''),
      $r(this, 'lastKeydownTarget', void 0),
      $r(this, 'modifierLockStart', {}),
      (this.system = t));
  }
};
s(EO, 'KeyboardHost');
var oU = EO,
  sU = [
    ...'0123456789'.split('').map((e) => ({ code: `Digit${e}`, key: e })),
    ...')!@#$%^&*('.split('').map((e, t) => ({ code: `Digit${t}`, key: e, shiftKey: !0 })),
    ...'abcdefghijklmnopqrstuvwxyz'
      .split('')
      .map((e) => ({ code: `Key${e.toUpperCase()}`, key: e })),
    ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      .split('')
      .map((e) => ({ code: `Key${e}`, key: e, shiftKey: !0 })),
    { code: 'BracketLeft', key: '[' },
    { code: 'BracketLeft', key: '{', shiftKey: !0 },
    { code: 'BracketRight', key: ']' },
    { code: 'BracketRight', key: '}', shiftKey: !0 },
    { code: 'Space', key: ' ' },
    { code: 'AltLeft', key: 'Alt', location: Qt.LEFT },
    { code: 'AltRight', key: 'Alt', location: Qt.RIGHT },
    { code: 'ShiftLeft', key: 'Shift', location: Qt.LEFT },
    { code: 'ShiftRight', key: 'Shift', location: Qt.RIGHT },
    { code: 'ControlLeft', key: 'Control', location: Qt.LEFT },
    { code: 'ControlRight', key: 'Control', location: Qt.RIGHT },
    { code: 'MetaLeft', key: 'Meta', location: Qt.LEFT },
    { code: 'MetaRight', key: 'Meta', location: Qt.RIGHT },
    { code: 'OSLeft', key: 'OS', location: Qt.LEFT },
    { code: 'OSRight', key: 'OS', location: Qt.RIGHT },
    { code: 'ContextMenu', key: 'ContextMenu' },
    { code: 'Tab', key: 'Tab' },
    { code: 'CapsLock', key: 'CapsLock' },
    { code: 'Backspace', key: 'Backspace' },
    { code: 'Enter', key: 'Enter' },
    { code: 'Escape', key: 'Escape' },
    { code: 'ArrowUp', key: 'ArrowUp' },
    { code: 'ArrowDown', key: 'ArrowDown' },
    { code: 'ArrowLeft', key: 'ArrowLeft' },
    { code: 'ArrowRight', key: 'ArrowRight' },
    { code: 'Home', key: 'Home' },
    { code: 'End', key: 'End' },
    { code: 'Delete', key: 'Delete' },
    { code: 'PageUp', key: 'PageUp' },
    { code: 'PageDown', key: 'PageDown' },
    { code: 'Fn', key: 'Fn' },
    { code: 'Symbol', key: 'Symbol' },
    { code: 'AltRight', key: 'AltGraph' },
  ],
  iU = [
    { name: 'MouseLeft', pointerType: 'mouse', button: 'primary' },
    { name: 'MouseRight', pointerType: 'mouse', button: 'secondary' },
    { name: 'MouseMiddle', pointerType: 'mouse', button: 'auxiliary' },
    { name: 'TouchA', pointerType: 'touch' },
    { name: 'TouchB', pointerType: 'touch' },
    { name: 'TouchC', pointerType: 'touch' },
  ];
function wO(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(wO, '_define_property');
var SO = class {
  getButtons() {
    let t = 0;
    for (const r of Object.keys(this.pressed)) t |= 2 ** Number(r);
    return t;
  }
  down(t) {
    const r = Ya(t.button);
    if (r in this.pressed) {
      this.pressed[r].push(t);
      return;
    }
    return ((this.pressed[r] = [t]), r);
  }
  up(t) {
    const r = Ya(t.button);
    if (
      r in this.pressed &&
      ((this.pressed[r] = this.pressed[r].filter((n) => n.name !== t.name)),
      this.pressed[r].length === 0)
    )
      return (delete this.pressed[r], r);
  }
  constructor() {
    wO(this, 'pressed', {});
  }
};
s(SO, 'Buttons');
var _O = SO,
  hb = { primary: 0, secondary: 1, auxiliary: 2, back: 3, X1: 3, forward: 4, X2: 4 };
function Ya(e = 0) {
  return e in hb ? hb[e] : Number(e);
}
s(Ya, 'getMouseButtonId');
var gb = { 1: 2, 2: 1 };
function Xa(e) {
  return ((e = Ya(e)), e in gb ? gb[e] : e);
}
s(Xa, 'getMouseEventButton');
function AO(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(AO, '_define_property');
var RO = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(t) {
    return this.pressedKeys.has(t.name);
  }
  addPressed(t) {
    return this.pressedKeys.add(t.name);
  }
  removePressed(t) {
    return this.pressedKeys.delete(t.name);
  }
  constructor() {
    AO(this, 'pressedKeys', new Set());
  }
};
s(RO, 'Device');
var aU = RO;
function uo(e, t) {
  const r = [];
  for (let i = e; i; i = i.parentElement) r.push(i);
  const n = [];
  for (let i = t; i; i = i.parentElement) n.push(i);
  let o = 0;
  for (; !(o >= r.length || o >= n.length || r[r.length - 1 - o] !== n[n.length - 1 - o]); o++);
  return [r.slice(0, r.length - o), n.slice(0, n.length - o), n.slice(n.length - o)];
}
s(uo, 'getTreeDiff');
function Qa({ target: e, node: t, offset: r }) {
  return Yt(e)
    ? { node: e, offset: r ?? Xt(e).length }
    : t
      ? { node: t, offset: r ?? (t.nodeType === 3 ? t.nodeValue.length : t.childNodes.length) }
      : fh(e, r);
}
s(Qa, 'resolveCaretPosition');
function fh(e, t, r = !0) {
  let n = t === void 0 ? e.childNodes.length - 1 : 0;
  const o = t === void 0 ? -1 : 1;
  for (
    ;
    t === void 0 ? n >= (r ? Math.max(e.childNodes.length - 1, 0) : 0) : n <= e.childNodes.length;

  ) {
    if (t && n === e.childNodes.length) throw new Error('The given offset is out of bounds.');
    const i = e.childNodes.item(n),
      a = String(i.textContent);
    if (a.length)
      if (t !== void 0 && a.length < t) t -= a.length;
      else {
        if (i.nodeType === 1) return fh(i, t, !1);
        if (i.nodeType === 3) return { node: i, offset: t ?? i.nodeValue.length };
      }
    n += o;
  }
  return { node: e, offset: e.childNodes.length };
}
s(fh, 'findNodeAtTextOffset');
function xO({ document: e, target: t, clickCount: r, node: n, offset: o }) {
  if (OP(t)) return;
  const i = Yt(t),
    a = String(i ? Xt(t) : t.textContent),
    [c, d] = n ? [o, o] : PO(a, o, r);
  if (i)
    return (
      Vn(t, { anchorOffset: c ?? a.length, focusOffset: d ?? a.length }),
      { node: t, start: c ?? 0, end: d ?? a.length }
    );
  {
    const { node: u, offset: p } = Qa({ target: t, node: n, offset: c }),
      { node: f, offset: m } = Qa({ target: t, node: n, offset: d }),
      h = t.ownerDocument.createRange();
    try {
      (h.setStart(u, p), h.setEnd(f, m));
    } catch {
      throw new Error('The given offset is out of bounds.');
    }
    const g = e.getSelection();
    return (g?.removeAllRanges(), g?.addRange(h.cloneRange()), h);
  }
}
s(xO, 'setSelectionPerMouseDown');
function PO(e, t, r) {
  if (r % 3 === 1 || e.length === 0) return [t, t];
  const n = t ?? e.length;
  return r % 3 === 2
    ? [
        n - e.substr(0, t).match(/(\w+|\s+|\W)?$/)[0].length,
        t === void 0 ? t : t + e.substr(t).match(/^(\w+|\s+|\W)?/)[0].length,
      ]
    : [
        n - e.substr(0, t).match(/[^\r\n]*$/)[0].length,
        t === void 0 ? t : t + e.substr(t).match(/^[^\r\n]*/)[0].length,
      ];
}
s(PO, 'getTextRange');
function OO(e, { document: t, target: r, node: n, offset: o }) {
  const i = Qa({ target: r, node: n, offset: o });
  if ('node' in e) {
    if (i.node === e.node) {
      const a = i.offset < e.start ? e.end : e.start,
        c = i.offset > e.end || i.offset < e.start ? i.offset : e.end;
      Vn(e.node, { anchorOffset: a, focusOffset: c });
    }
  } else {
    const a = e.cloneRange(),
      c = a.comparePoint(i.node, i.offset);
    c < 0 ? a.setStart(i.node, i.offset) : c > 0 && a.setEnd(i.node, i.offset);
    const d = t.getSelection();
    (d?.removeAllRanges(), d?.addRange(a.cloneRange()));
  }
}
s(OO, 'modifySelectionPerMouseMove');
function mh(e, t) {
  var r, n, o, i, a, c, d, u, p, f, m, h, g, v, E, b, S, R, I, q, P, A, w, _;
  return (
    e.target !== t.target ||
    ((r = e.coords) === null || r === void 0 ? void 0 : r.x) !==
      ((n = t.coords) === null || n === void 0 ? void 0 : n.x) ||
    ((o = e.coords) === null || o === void 0 ? void 0 : o.y) !==
      ((i = t.coords) === null || i === void 0 ? void 0 : i.y) ||
    ((a = e.coords) === null || a === void 0 ? void 0 : a.clientX) !==
      ((c = t.coords) === null || c === void 0 ? void 0 : c.clientX) ||
    ((d = e.coords) === null || d === void 0 ? void 0 : d.clientY) !==
      ((u = t.coords) === null || u === void 0 ? void 0 : u.clientY) ||
    ((p = e.coords) === null || p === void 0 ? void 0 : p.offsetX) !==
      ((f = t.coords) === null || f === void 0 ? void 0 : f.offsetX) ||
    ((m = e.coords) === null || m === void 0 ? void 0 : m.offsetY) !==
      ((h = t.coords) === null || h === void 0 ? void 0 : h.offsetY) ||
    ((g = e.coords) === null || g === void 0 ? void 0 : g.pageX) !==
      ((v = t.coords) === null || v === void 0 ? void 0 : v.pageX) ||
    ((E = e.coords) === null || E === void 0 ? void 0 : E.pageY) !==
      ((b = t.coords) === null || b === void 0 ? void 0 : b.pageY) ||
    ((S = e.coords) === null || S === void 0 ? void 0 : S.screenX) !==
      ((R = t.coords) === null || R === void 0 ? void 0 : R.screenX) ||
    ((I = e.coords) === null || I === void 0 ? void 0 : I.screenY) !==
      ((q = t.coords) === null || q === void 0 ? void 0 : q.screenY) ||
    ((P = e.caret) === null || P === void 0 ? void 0 : P.node) !==
      ((A = t.caret) === null || A === void 0 ? void 0 : A.node) ||
    ((w = e.caret) === null || w === void 0 ? void 0 : w.offset) !==
      ((_ = t.caret) === null || _ === void 0 ? void 0 : _.offset)
  );
}
s(mh, 'isDifferentPointerPosition');
function kr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(kr, '_define_property');
var CO = class {
  move(t, r, n) {
    const o = this.position,
      i = this.getTarget(t);
    if (((this.position = r), !mh(o, r))) return;
    const a = this.getTarget(t),
      c = this.getEventInit('mousemove'),
      [d, u] = uo(i, a);
    return {
      leave: s(() => {
        i !== a &&
          (t.dispatchUIEvent(i, 'mouseout', c),
          d.forEach((p) => t.dispatchUIEvent(p, 'mouseleave', c)));
      }, 'leave'),
      enter: s(() => {
        i !== a &&
          (t.dispatchUIEvent(a, 'mouseover', c),
          u.forEach((p) => t.dispatchUIEvent(p, 'mouseenter', c)));
      }, 'enter'),
      move: s(() => {
        n || (t.dispatchUIEvent(a, 'mousemove', c), this.modifySelecting(t));
      }, 'move'),
    };
  }
  down(t, r, n) {
    const o = this.buttons.down(r);
    if (o === void 0) return;
    const i = this.getTarget(t);
    this.buttonDownTarget[o] = i;
    const a = this.getEventInit('mousedown', r.button),
      c = lr(i);
    (!n && (c || t.dispatchUIEvent(i, 'mousedown', a)) && (this.startSelecting(t, a.detail), Cr(i)),
      !c &&
        Xa(r.button) === 2 &&
        t.dispatchUIEvent(i, 'contextmenu', this.getEventInit('contextmenu', r.button)));
  }
  up(t, r, n) {
    const o = this.buttons.up(r);
    if (o === void 0) return;
    const i = this.getTarget(t);
    if (!lr(i)) {
      if (!n) {
        const c = this.getEventInit('mouseup', r.button);
        (t.dispatchUIEvent(i, 'mouseup', c), this.endSelecting());
      }
      const a = uo(this.buttonDownTarget[o], i)[2][0];
      if (a) {
        const c = this.getEventInit('click', r.button);
        c.detail &&
          (t.dispatchUIEvent(a, c.button === 0 ? 'click' : 'auxclick', c),
          c.button === 0 &&
            c.detail === 2 &&
            t.dispatchUIEvent(a, 'dblclick', {
              ...this.getEventInit('dblclick', r.button),
              detail: c.detail,
            }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(t, r) {
    const n = { ...this.position.coords };
    return (
      (n.button = Xa(r)),
      (n.buttons = this.buttons.getButtons()),
      t === 'mousedown'
        ? (n.detail = this.clickCount.getOnDown(n.button))
        : t === 'mouseup'
          ? (n.detail = this.clickCount.getOnUp(n.button))
          : (t === 'click' || t === 'auxclick') &&
            (n.detail = this.clickCount.incOnClick(n.button)),
      n
    );
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  startSelecting(t, r) {
    var n, o;
    this.selecting = xO({
      document: t.config.document,
      target: this.getTarget(t),
      node: (n = this.position.caret) === null || n === void 0 ? void 0 : n.node,
      offset: (o = this.position.caret) === null || o === void 0 ? void 0 : o.offset,
      clickCount: r,
    });
  }
  modifySelecting(t) {
    var r, n;
    this.selecting &&
      OO(this.selecting, {
        document: t.config.document,
        target: this.getTarget(t),
        node: (r = this.position.caret) === null || r === void 0 ? void 0 : r.node,
        offset: (n = this.position.caret) === null || n === void 0 ? void 0 : n.offset,
      });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    (kr(this, 'position', {}),
      kr(this, 'buttons', new _O()),
      kr(this, 'selecting', void 0),
      kr(this, 'buttonDownTarget', {}),
      kr(
        this,
        'clickCount',
        new (class {
          incOnClick(t) {
            const r = this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
            return (
              (this.count = this.count[t] === void 0 ? {} : { [t]: Number(this.count[t]) + 1 }),
              r
            );
          }
          getOnDown(t) {
            var r;
            this.down = { [t]: (r = this.count[t]) !== null && r !== void 0 ? r : 0 };
            var n;
            return (
              (this.count = { [t]: (n = this.count[t]) !== null && n !== void 0 ? n : 0 }),
              Number(this.count[t]) + 1
            );
          }
          getOnUp(t) {
            return this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
          }
          reset() {
            this.count = {};
          }
          constructor() {
            (kr(this, 'down', {}), kr(this, 'count', {}));
          }
        })(),
      ));
  }
};
s(CO, 'Mouse');
var lU = CO;
function ui(e, t) {
  var r;
  return ((r = yh(e, t)) === null || r === void 0 ? void 0 : r.pointerEvents) !== 'none';
}
s(ui, 'hasPointerEvents');
function IO(e) {
  const t = qt(e);
  for (let r = e, n = []; r?.ownerDocument; r = r.parentElement) {
    n.push(r);
    const o = t.getComputedStyle(r).pointerEvents;
    if (o && !['inherit', 'unset'].includes(o)) return { pointerEvents: o, tree: n };
  }
}
s(IO, 'closestPointerEventsDeclaration');
var bb = Symbol('Last check for pointer-events');
function yh(e, t) {
  const r = t[bb];
  if (
    !(
      e.config.pointerEventsCheck !== ia.Never &&
      (!r ||
        (Zd(e.config.pointerEventsCheck, ia.EachApiCall) && r[Ot.Call] !== Cs(e, Ot.Call)) ||
        (Zd(e.config.pointerEventsCheck, ia.EachTrigger) && r[Ot.Trigger] !== Cs(e, Ot.Trigger)))
    )
  )
    return r?.result;
  const o = IO(t);
  return ((t[bb] = { [Ot.Call]: Cs(e, Ot.Call), [Ot.Trigger]: Cs(e, Ot.Trigger), result: o }), o);
}
s(yh, 'checkPointerEvents');
function no(e, t) {
  const r = yh(e, t);
  if (r?.pointerEvents === 'none')
    throw new Error(
      [
        `Unable to perform pointer interaction as the element ${r.tree.length > 1 ? 'inherits' : 'has'} \`pointer-events: none\`:`,
        '',
        NO(r.tree),
      ].join(`
`),
    );
}
s(no, 'assertPointerEvents');
function NO(e) {
  return e
    .reverse()
    .map((t, r) =>
      [
        ''.padEnd(r),
        t.tagName,
        t.id && `#${t.id}`,
        t.hasAttribute('data-testid') && `(testId=${t.getAttribute('data-testid')})`,
        qO(t),
        e.length > 1 && r === 0 && '  <-- This element declared `pointer-events: none`',
        e.length > 1 && r === e.length - 1 && '  <-- Asserted pointer events here',
      ]
        .filter(Boolean)
        .join(''),
    ).join(`
`);
}
s(NO, 'printTree');
function qO(e) {
  var t;
  let r;
  if (e.hasAttribute('aria-label')) r = e.getAttribute('aria-label');
  else if (e.hasAttribute('aria-labelledby')) {
    var n, o;
    r =
      (o = e.ownerDocument.getElementById(e.getAttribute('aria-labelledby'))) === null ||
      o === void 0 ||
      (n = o.textContent) === null ||
      n === void 0
        ? void 0
        : n.trim();
  } else if (
    he(e, ['button', 'input', 'meter', 'output', 'progress', 'select', 'textarea']) &&
    !((t = e.labels) === null || t === void 0) &&
    t.length
  )
    r = Array.from(e.labels)
      .map((a) => {
        var c;
        return (c = a.textContent) === null || c === void 0 ? void 0 : c.trim();
      })
      .join('|');
  else if (he(e, 'button')) {
    var i;
    r = (i = e.textContent) === null || i === void 0 ? void 0 : i.trim();
  }
  return (
    (r = r?.replace(/\n/g, '  ')),
    Number(r?.length) > 30 && (r = `${r?.substring(0, 29)}`),
    r ? `(label=${r})` : ''
  );
}
s(qO, 'getLabelDescr');
function Zd(e, t) {
  return (e & t) > 0;
}
s(Zd, 'hasBitFlag');
function tr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(tr, '_define_property');
var MO = class {
  init(t) {
    const r = this.getTarget(t),
      [, n] = uo(null, r),
      o = this.getEventInit();
    return (
      no(t, r),
      t.dispatchUIEvent(r, 'pointerover', o),
      n.forEach((i) => t.dispatchUIEvent(i, 'pointerenter', o)),
      this
    );
  }
  move(t, r) {
    const n = this.position,
      o = this.getTarget(t);
    if (((this.position = r), !mh(n, r))) return;
    const i = this.getTarget(t),
      a = this.getEventInit(-1),
      [c, d] = uo(o, i);
    return {
      leave: s(() => {
        ui(t, o) &&
          o !== i &&
          (t.dispatchUIEvent(o, 'pointerout', a),
          c.forEach((u) => t.dispatchUIEvent(u, 'pointerleave', a)));
      }, 'leave'),
      enter: s(() => {
        (no(t, i),
          o !== i &&
            (t.dispatchUIEvent(i, 'pointerover', a),
            d.forEach((u) => t.dispatchUIEvent(u, 'pointerenter', a))));
      }, 'enter'),
      move: s(() => {
        t.dispatchUIEvent(i, 'pointermove', a);
      }, 'move'),
    };
  }
  down(t, r = 0) {
    if (this.isDown) return;
    const n = this.getTarget(t);
    (no(t, n),
      (this.isDown = !0),
      (this.isPrevented = !t.dispatchUIEvent(n, 'pointerdown', this.getEventInit(r))));
  }
  up(t, r = 0) {
    if (!this.isDown) return;
    const n = this.getTarget(t);
    (no(t, n),
      (this.isPrevented = !1),
      (this.isDown = !1),
      t.dispatchUIEvent(n, 'pointerup', this.getEventInit(r)));
  }
  release(t) {
    const r = this.getTarget(t),
      [n] = uo(r, null),
      o = this.getEventInit();
    (ui(t, r) &&
      (t.dispatchUIEvent(r, 'pointerout', o),
      n.forEach((i) => t.dispatchUIEvent(i, 'pointerleave', o))),
      (this.isCancelled = !0));
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  getEventInit(t) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: Xa(t),
      buttons: this.buttons.getButtons(),
    };
  }
  constructor({ pointerId: t, pointerType: r, isPrimary: n }, o) {
    (tr(this, 'pointerId', void 0),
      tr(this, 'pointerType', void 0),
      tr(this, 'isPrimary', void 0),
      tr(this, 'buttons', void 0),
      tr(this, 'isMultitouch', !1),
      tr(this, 'isCancelled', !1),
      tr(this, 'isDown', !1),
      tr(this, 'isPrevented', !1),
      tr(this, 'position', {}),
      (this.pointerId = t),
      (this.pointerType = r),
      (this.isPrimary = n),
      (this.isMultitouch = !n),
      (this.buttons = o));
  }
};
s(MO, 'Pointer');
var cU = MO;
function Tr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(Tr, '_define_property');
var jO = class {
  isKeyPressed(t) {
    return this.devices.get(t.pointerType).isPressed(t);
  }
  async press(t, r, n) {
    (this.devices.get(r.pointerType).addPressed(r), this.buttons.down(r));
    const o = this.getPointerName(r),
      i =
        r.pointerType === 'touch'
          ? this.pointers.new(o, r.pointerType, this.buttons)
          : this.pointers.get(o);
    ((i.position = n),
      i.pointerType !== 'touch' && (this.mouse.position = n),
      i.pointerType === 'touch' && i.init(t),
      i.down(t, r.button),
      i.pointerType !== 'touch' && this.mouse.down(t, r, i.isPrevented));
  }
  async move(t, r, n) {
    const o = this.pointers.get(r),
      i = o.move(t, n),
      a = o.pointerType === 'touch' ? void 0 : this.mouse.move(t, n, o.isPrevented);
    (i?.leave(), a?.leave(), i?.enter(), a?.enter(), i?.move(), a?.move());
  }
  async release(t, r, n) {
    const o = this.devices.get(r.pointerType);
    (o.removePressed(r), this.buttons.up(r));
    const i = this.pointers.get(this.getPointerName(r)),
      a = i.isPrevented;
    if (
      ((i.position = n),
      i.pointerType !== 'touch' && (this.mouse.position = n),
      o.countPressed === 0 && i.up(t, r.button),
      i.pointerType === 'touch' && i.release(t),
      i.pointerType === 'touch' && !i.isMultitouch)
    ) {
      const c = this.mouse.move(t, n, a);
      (c?.leave(), c?.enter(), c?.move(), this.mouse.down(t, r, a));
    }
    if (!i.isMultitouch) {
      const c = this.mouse.move(t, n, a);
      (c?.leave(), c?.enter(), c?.move(), this.mouse.up(t, r, a));
    }
  }
  getPointerName(t) {
    return t.pointerType === 'touch' ? t.name : t.pointerType;
  }
  getPreviousPosition(t) {
    return this.pointers.has(t) ? this.pointers.get(t).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(t) {
    var r;
    return (r = this.mouse.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  setMousePosition(t) {
    ((this.mouse.position = t), (this.pointers.get('mouse').position = t));
  }
  constructor(t) {
    (Tr(this, 'system', void 0),
      Tr(this, 'mouse', void 0),
      Tr(this, 'buttons', void 0),
      Tr(
        this,
        'devices',
        new (class {
          get(r) {
            var n, o, i;
            return (i = (n = this.registry)[(o = r)]) !== null && i !== void 0
              ? i
              : (n[o] = new aU());
          }
          constructor() {
            Tr(this, 'registry', {});
          }
        })(),
      ),
      Tr(
        this,
        'pointers',
        new (class {
          new(r, n, o) {
            const i =
              n !== 'touch' ||
              !Object.values(this.registry).some(
                (a) => a.pointerType === 'touch' && !a.isCancelled,
              );
            return (
              i ||
                Object.values(this.registry).forEach((a) => {
                  a.pointerType === n && !a.isCancelled && (a.isMultitouch = !0);
                }),
              (this.registry[r] = new cU(
                { pointerId: this.nextId++, pointerType: n, isPrimary: i },
                o,
              )),
              this.registry[r]
            );
          }
          get(r) {
            if (!this.has(r))
              throw new Error(`Trying to access pointer "${r}" which does not exist.`);
            return this.registry[r];
          }
          has(r) {
            return r in this.registry;
          }
          constructor() {
            (Tr(this, 'registry', {}), Tr(this, 'nextId', 1));
          }
        })(),
      ),
      (this.system = t),
      (this.buttons = new _O()),
      (this.mouse = new lU()),
      this.pointers.new('mouse', 'mouse', this.buttons));
  }
};
s(jO, 'PointerHost');
var uU = jO;
function ep(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(ep, '_define_property');
var $O = class {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock,
    };
  }
  constructor() {
    (ep(this, 'keyboard', new oU(this)), ep(this, 'pointer', new uU(this)));
  }
};
s($O, 'System');
var kO = $O;
async function DO(e) {
  const t = [];
  return (
    this.config.skipHover || t.push({ target: e }),
    t.push({ keys: '[MouseLeft]', target: e }),
    this.pointer(t)
  );
}
s(DO, 'click');
async function LO(e) {
  return this.pointer([{ target: e }, '[MouseLeft][MouseLeft]']);
}
s(LO, 'dblClick');
async function FO(e) {
  return this.pointer([{ target: e }, '[MouseLeft][MouseLeft][MouseLeft]']);
}
s(FO, 'tripleClick');
async function BO(e) {
  return this.pointer({ target: e });
}
s(BO, 'hover');
async function JO(e) {
  return (
    no(this, this.system.pointer.getMouseTarget(this)),
    this.pointer({ target: e.ownerDocument.body })
  );
}
s(JO, 'unhover');
async function UO({ shift: e } = {}) {
  return this.keyboard(
    e === !0 ? '{Shift>}{Tab}{/Shift}' : e === !1 ? '[/ShiftLeft][/ShiftRight]{Tab}' : '{Tab}',
  );
}
s(UO, 'tab');
var hh = (function (e) {
  return ((e['{'] = '}'), (e['['] = ']'), e);
})(hh || {});
function gh(e, t) {
  let r = 0;
  const n = e[r] in hh ? e[r] : '';
  r += n.length;
  const i = new RegExp(`^\\${n}{2}`).test(e) ? '' : n;
  return { type: i, ...(i === '' ? VO(e, r, t) : HO(e, r, i, t)) };
}
s(gh, 'readNextDescriptor');
function VO(e, t, r) {
  const n = e[t];
  return (
    bh(n, e, t, r),
    (t += n.length),
    { consumedLength: t, descriptor: n, releasePrevious: !1, releaseSelf: !0, repeat: 1 }
  );
}
s(VO, 'readPrintableChar');
function HO(e, t, r, n) {
  var o, i;
  const a = e[t] === '/' ? '/' : '';
  t += a.length;
  const c = r === '{' && e[t] === '\\';
  t += Number(c);
  const d = c
    ? e[t]
    : (o = e.slice(t).match(r === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || o === void 0
      ? void 0
      : o[0];
  (bh(d, e, t, n), (t += d.length));
  var u;
  const p =
    (u = (i = e.slice(t).match(/^>\d+/)) === null || i === void 0 ? void 0 : i[0]) !== null &&
    u !== void 0
      ? u
      : '';
  t += p.length;
  const f = e[t] === '/' || (!p && e[t] === '>') ? e[t] : '';
  t += f.length;
  const m = hh[r],
    h = e[t] === m ? m : '';
  if (!h)
    throw new Error(
      vh(
        [!p && 'repeat modifier', !f && 'release modifier', `"${m}"`].filter(Boolean).join(' or '),
        e[t],
        e,
        n,
      ),
    );
  return (
    (t += h.length),
    {
      consumedLength: t,
      descriptor: d,
      releasePrevious: !!a,
      repeat: p ? Math.max(Number(p.substr(1)), 1) : 1,
      releaseSelf: zO(f, p),
    }
  );
}
s(HO, 'readTag');
function bh(e, t, r, n) {
  if (!e) throw new Error(vh('key descriptor', t[r], t, n));
}
s(bh, 'assertDescriptor');
function zO(e, t) {
  if (e) return e === '/';
  if (t) return !1;
}
s(zO, 'hasReleaseSelf');
function vh(e, t, r, n) {
  return `Expected ${e} but found "${t ?? ''}" in "${r}"
    See ${n === 'pointer' ? 'https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen' : 'https://testing-library.com/docs/user-event/keyboard'}
    for more information about how userEvent parses your input.`;
}
s(vh, 'getErrorMessage');
function GO(e, t) {
  const r = [];
  do {
    const {
      type: o,
      descriptor: i,
      consumedLength: a,
      releasePrevious: c,
      releaseSelf: d = !0,
      repeat: u,
    } = gh(t, 'keyboard');
    var n;
    const p =
      (n = e.find((f) => {
        if (o === '[') {
          var m;
          return (
            ((m = f.code) === null || m === void 0 ? void 0 : m.toLowerCase()) === i.toLowerCase()
          );
        } else if (o === '{') {
          var h;
          return (
            ((h = f.key) === null || h === void 0 ? void 0 : h.toLowerCase()) === i.toLowerCase()
          );
        }
        return f.key === i;
      })) !== null && n !== void 0
        ? n
        : { key: 'Unknown', code: 'Unknown', [o === '[' ? 'code' : 'key']: i };
    (r.push({ keyDef: p, releasePrevious: c, releaseSelf: d, repeat: u }), (t = t.slice(a)));
  } while (t);
  return r;
}
s(GO, 'parseKeyDef');
async function WO(e) {
  const t = GO(this.config.keyboardMap, e);
  for (let r = 0; r < t.length; r++) (await jn(this.config), await KO(this, t[r]));
}
s(WO, 'keyboard');
async function KO(e, { keyDef: t, releasePrevious: r, releaseSelf: n, repeat: o }) {
  const { system: i } = e;
  if ((i.keyboard.isKeyPressed(t) && (await i.keyboard.keyup(e, t)), !r)) {
    for (let a = 1; a <= o; a++) (await i.keyboard.keydown(e, t), a < o && (await jn(e.config)));
    n && (await i.keyboard.keyup(e, t));
  }
}
s(KO, 'keyboardAction');
async function YO(e) {
  for (const t of e.system.keyboard.getPressedKeys()) await e.system.keyboard.keyup(e, t);
}
s(YO, 'releaseAllKeys');
function Th(e) {
  const t = Yt(e)
      ? { 'text/plain': XO(e) }
      : { 'text/plain': String(e.ownerDocument.getSelection()) },
    r = Rc(qt(e));
  for (const n in t) t[n] && r.setData(n, t[n]);
  return r;
}
s(Th, 'copySelection');
function XO(e) {
  const t = Co(e);
  return Xt(e).substring(t.startOffset, t.endOffset);
}
s(XO, 'readSelectedValueFromInput');
async function QO() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : e.body,
    n = Th(r);
  if (n.items.length !== 0)
    return (
      this.dispatchUIEvent(r, 'copy', { clipboardData: n }) &&
        this.config.writeToClipboard &&
        (await Qy(e, n)),
      n
    );
}
s(QO, 'copy');
async function ZO() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : e.body,
    n = Th(r);
  if (n.items.length !== 0)
    return (
      this.dispatchUIEvent(r, 'cut', { clipboardData: n }) &&
        this.config.writeToClipboard &&
        (await Qy(r.ownerDocument, n)),
      n
    );
}
s(ZO, 'cut');
async function eC(e) {
  const t = this.config.document;
  var r;
  const n = (r = t.activeElement) !== null && r !== void 0 ? r : t.body;
  var o;
  const i =
    (o = typeof e == 'string' ? tC(t, e) : e) !== null && o !== void 0
      ? o
      : await wP(t).catch(() => {
          throw new Error(
            '`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.',
          );
        });
  this.dispatchUIEvent(n, 'paste', { clipboardData: i });
}
s(eC, 'paste');
function tC(e, t) {
  const r = Rc(qt(e));
  return (r.setData('text', t), r);
}
s(tC, 'getClipboardDataFromString');
function tp(e, t) {
  const r = [];
  do {
    const {
        descriptor: n,
        consumedLength: o,
        releasePrevious: i,
        releaseSelf: a = !0,
      } = gh(t, 'pointer'),
      c = e.find((d) => d.name === n);
    (c && r.push({ keyDef: c, releasePrevious: i, releaseSelf: a }), (t = t.slice(o)));
  } while (t);
  return r;
}
s(tp, 'parseKeyDef');
async function rC(e) {
  const { pointerMap: t } = this.config,
    r = [];
  (Array.isArray(e) ? e : [e]).forEach((n) => {
    typeof n == 'string'
      ? r.push(...tp(t, n))
      : 'keys' in n
        ? r.push(...tp(t, n.keys).map((o) => ({ ...n, ...o })))
        : r.push(n);
  });
  for (let n = 0; n < r.length; n++) (await jn(this.config), await nC(this, r[n]));
  this.system.pointer.resetClickCount();
}
s(rC, 'pointer');
async function nC(e, t) {
  var r, n;
  const o =
      'pointerName' in t && t.pointerName
        ? t.pointerName
        : 'keyDef' in t
          ? e.system.pointer.getPointerName(t.keyDef)
          : 'mouse',
    i = e.system.pointer.getPreviousPosition(o);
  var a, c, d, u;
  const p = {
    target: (a = t.target) !== null && a !== void 0 ? a : oC(e, i),
    coords: (c = t.coords) !== null && c !== void 0 ? c : i?.coords,
    caret: {
      node:
        (d = t.node) !== null && d !== void 0
          ? d
          : rp(t) || i == null || (r = i.caret) === null || r === void 0
            ? void 0
            : r.node,
      offset:
        (u = t.offset) !== null && u !== void 0
          ? u
          : rp(t) || i == null || (n = i.caret) === null || n === void 0
            ? void 0
            : n.offset,
    },
  };
  'keyDef' in t
    ? (e.system.pointer.isKeyPressed(t.keyDef) &&
        (ro(e, Ot.Trigger), await e.system.pointer.release(e, t.keyDef, p)),
      t.releasePrevious ||
        (ro(e, Ot.Trigger),
        await e.system.pointer.press(e, t.keyDef, p),
        t.releaseSelf && (ro(e, Ot.Trigger), await e.system.pointer.release(e, t.keyDef, p))))
    : (ro(e, Ot.Trigger), await e.system.pointer.move(e, o, p));
}
s(nC, 'pointerAction');
function rp(e) {
  var t, r;
  return !!((r = (t = e.target) !== null && t !== void 0 ? t : e.node) !== null && r !== void 0
    ? r
    : e.offset !== void 0);
}
s(rp, 'hasCaretPosition');
function oC(e, t) {
  if (!t) throw new Error('This pointer has no previous position. Provide a target property!');
  var r;
  return (r = t.target) !== null && r !== void 0 ? r : e.config.document.body;
}
s(oC, 'getPrevTarget');
async function sC(e) {
  if (!Nn(e) || lr(e)) throw new Error('clear()` is only supported on editable elements.');
  if ((Cr(e), e.ownerDocument.activeElement !== e))
    throw new Error('The element to be cleared could not be focused.');
  if ((ah(e), !oO(e))) throw new Error('The element content to be cleared could not be selected.');
  Mn(this, e, '', 'deleteContentBackward');
}
s(sC, 'clear');
async function iC(e, t) {
  return Eh.call(this, !0, e, t);
}
s(iC, 'selectOptions');
async function aC(e, t) {
  return Eh.call(this, !1, e, t);
}
s(aC, 'deselectOptions');
async function Eh(e, t, r) {
  if (!e && !t.multiple)
    throw Ee().getElementError(
      'Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.',
      t,
    );
  const n = Array.isArray(r) ? r : [r],
    o = Array.from(t.querySelectorAll('option, [role="option"]')),
    i = n
      .map((c) => {
        if (typeof c != 'string' && o.includes(c)) return c;
        {
          const d = o.find((u) => u.value === c || u.innerHTML === c);
          if (d) return d;
          throw Ee().getElementError(`Value "${String(c)}" not found in options`, t);
        }
      })
      .filter((c) => !lr(c));
  if (lr(t) || !i.length) return;
  const a = s((c) => {
    ((c.selected = e),
      this.dispatchUIEvent(t, 'input', { bubbles: !0, cancelable: !1, composed: !0 }),
      this.dispatchUIEvent(t, 'change'));
  }, 'selectOption');
  if (he(t, 'select'))
    if (t.multiple)
      for (const c of i) {
        const d = this.config.pointerEventsCheck === 0 ? !0 : ui(this, c);
        (d &&
          (this.dispatchUIEvent(c, 'pointerover'),
          this.dispatchUIEvent(t, 'pointerenter'),
          this.dispatchUIEvent(c, 'mouseover'),
          this.dispatchUIEvent(t, 'mouseenter'),
          this.dispatchUIEvent(c, 'pointermove'),
          this.dispatchUIEvent(c, 'mousemove'),
          this.dispatchUIEvent(c, 'pointerdown'),
          this.dispatchUIEvent(c, 'mousedown')),
          Cr(t),
          d && (this.dispatchUIEvent(c, 'pointerup'), this.dispatchUIEvent(c, 'mouseup')),
          a(c),
          d && this.dispatchUIEvent(c, 'click'),
          await jn(this.config));
      }
    else if (i.length === 1) {
      const c = this.config.pointerEventsCheck === 0 ? !0 : ui(this, t);
      (c ? await this.click(t) : Cr(t),
        a(i[0]),
        c &&
          (this.dispatchUIEvent(t, 'pointerover'),
          this.dispatchUIEvent(t, 'pointerenter'),
          this.dispatchUIEvent(t, 'mouseover'),
          this.dispatchUIEvent(t, 'mouseenter'),
          this.dispatchUIEvent(t, 'pointerup'),
          this.dispatchUIEvent(t, 'mouseup'),
          this.dispatchUIEvent(t, 'click')),
        await jn(this.config));
    } else throw Ee().getElementError('Cannot select multiple options on a non-multiple select', t);
  else if (t.getAttribute('role') === 'listbox')
    for (const c of i) (await this.click(c), await this.unhover(c));
  else
    throw Ee().getElementError(
      'Cannot select options on elements that are neither select nor listbox elements',
      t,
    );
}
s(Eh, 'selectOptionsBase');
async function lC(
  e,
  t,
  {
    skipClick: r = this.config.skipClick,
    skipAutoClose: n = this.config.skipAutoClose,
    initialSelectionStart: o,
    initialSelectionEnd: i,
  } = {},
) {
  e.disabled ||
    (r || (await this.click(e)),
    o !== void 0 && to(e, o, i ?? o),
    await this.keyboard(t),
    n || (await YO(this)));
}
s(lC, 'type');
var vb = Symbol('files and value properties are mocked');
function aa(e, t, r) {
  r ? Object.defineProperty(e, t, r) : delete e[t];
}
s(aa, 'restoreProperty');
function cC(e, t) {
  var r;
  (r = e[vb]) === null || r === void 0 || r.restore();
  const n = Object.getOwnPropertyDescriptor(e, 'type'),
    o = Object.getOwnPropertyDescriptor(e, 'value'),
    i = Object.getOwnPropertyDescriptor(e, 'files');
  function a() {
    (aa(e, 'type', n), aa(e, 'value', o), aa(e, 'files', i));
  }
  (s(a, 'restore'),
    (e[vb] = { restore: a }),
    Object.defineProperties(e, {
      files: { configurable: !0, get: s(() => t, 'get') },
      value: {
        configurable: !0,
        get: s(() => (t.length ? `C:\\fakepath\\${t[0].name}` : ''), 'get'),
        set(c) {
          if (c === '') a();
          else {
            var d;
            o == null || (d = o.set) === null || d === void 0 || d.call(e, c);
          }
        },
      },
      type: {
        configurable: !0,
        get: s(() => 'file', 'get'),
        set(c) {
          c !== 'file' && (a(), (e.type = c));
        },
      },
    }));
}
s(cC, 'setFiles');
async function uC(e, t) {
  const r = he(e, 'label') ? e.control : e;
  if (!r || !he(r, 'input', { type: 'file' }))
    throw new TypeError(
      `The ${r === e ? 'given' : 'associated'} ${r?.tagName} element does not accept file uploads`,
    );
  if (lr(e)) return;
  const n = (Array.isArray(t) ? t : [t])
      .filter((i) => !this.config.applyAccept || dC(i, r.accept))
      .slice(0, r.multiple ? void 0 : 1),
    o = s(() => {
      var i;
      (n.length === ((i = r.files) === null || i === void 0 ? void 0 : i.length) &&
        n.every((a, c) => {
          var d;
          return a === ((d = r.files) === null || d === void 0 ? void 0 : d.item(c));
        })) ||
        (cC(r, Ac(qt(e), n)), this.dispatchUIEvent(r, 'input'), this.dispatchUIEvent(r, 'change'));
    }, 'fileDialog');
  (r.addEventListener('fileDialog', o),
    await this.click(e),
    r.removeEventListener('fileDialog', o));
}
s(uC, 'upload');
function Is(e) {
  return e.toLowerCase().replace(/(\.|\/)jpg\b/g, '$1jpeg');
}
s(Is, 'normalize');
function dC(e, t) {
  if (!t) return !0;
  const r = ['audio/*', 'image/*', 'video/*'];
  return Is(t)
    .trim()
    .split(/\s*,\s*/)
    .some((n) =>
      n.startsWith('.')
        ? Is(e.name).endsWith(n)
        : r.includes(n)
          ? Is(e.type).startsWith(n.replace('*', ''))
          : Is(e.type) === n,
    );
}
s(dC, 'isAcceptableFile');
var Tb = {
  click: DO,
  dblClick: LO,
  tripleClick: FO,
  hover: BO,
  unhover: JO,
  tab: UO,
  keyboard: WO,
  copy: QO,
  cut: ZO,
  paste: eC,
  pointer: rC,
  clear: sC,
  deselectOptions: aC,
  selectOptions: iC,
  type: lC,
  upload: uC,
};
function pC(e) {
  return Ee().asyncWrapper(e);
}
s(pC, 'wrapAsync');
var fC = {
    applyAccept: !0,
    autoModify: !0,
    delay: 0,
    document: globalThis.document,
    keyboardMap: sU,
    pointerMap: iU,
    pointerEventsCheck: ia.EachApiCall,
    skipAutoClose: !1,
    skipClick: !1,
    skipHover: !1,
    writeToClipboard: !1,
    advanceTimers: s(() => Promise.resolve(), 'advanceTimers'),
  },
  dU = { ...fC, writeToClipboard: !0 };
function wh(e = {}, t = dU, r) {
  const n = gC(e, r, t);
  return { ...t, ...e, document: n };
}
s(wh, 'createConfig');
function mC(e = {}) {
  const t = wh(e);
  (ph(t.document), dh(qt(t.document).HTMLElement));
  var r;
  const n = (r = t.document.defaultView) !== null && r !== void 0 ? r : globalThis.window;
  return (vP(n), Ic(t).api);
}
s(mC, 'setupMain');
function pt({ keyboardState: e, pointerState: t, ...r } = {}, n) {
  const o = wh(r, fC, n);
  (ph(o.document), dh(qt(o.document).HTMLElement));
  var i;
  const a = (i = t ?? e) !== null && i !== void 0 ? i : new kO();
  return { api: Ic(o, a).api, system: a };
}
s(pt, 'setupDirect');
function yC(e) {
  return Ic({ ...this.config, ...e }, this.system).api;
}
s(yC, 'setupSub');
function hC(e, t) {
  function r(...n) {
    return (ro(e, Ot.Call), pC(() => t.apply(e, n).then(async (o) => (await jn(e.config), o))));
  }
  return (s(r, 'method'), Object.defineProperty(r, 'name', { get: s(() => t.name, 'get') }), r);
}
s(hC, 'wrapAndBindImpl');
function Ic(e, t = new kO()) {
  const r = {};
  return (
    Object.assign(r, {
      config: e,
      dispatchEvent: uh.bind(r),
      dispatchUIEvent: mO.bind(r),
      system: t,
      levelRefs: {},
      ...Tb,
    }),
    {
      instance: r,
      api: {
        ...Object.fromEntries(Object.entries(Tb).map(([n, o]) => [n, hC(r, o)])),
        setup: yC.bind(r),
      },
    }
  );
}
s(Ic, 'createInstance');
function gC(e, t, r) {
  var n, o;
  return (o = (n = e.document) !== null && n !== void 0 ? n : t && vO(t)) !== null && o !== void 0
    ? o
    : r.document;
}
s(gC, 'getDocument');
var bC = {};
St(bC, {
  clear: () => vC,
  click: () => TC,
  copy: () => EC,
  cut: () => wC,
  dblClick: () => SC,
  deselectOptions: () => _C,
  hover: () => AC,
  keyboard: () => RC,
  paste: () => PC,
  pointer: () => xC,
  selectOptions: () => OC,
  tab: () => MC,
  tripleClick: () => CC,
  type: () => IC,
  unhover: () => NC,
  upload: () => qC,
});
function vC(e) {
  return pt().api.clear(e);
}
s(vC, 'clear');
function TC(e, t = {}) {
  return pt(t, e).api.click(e);
}
s(TC, 'click');
function EC(e = {}) {
  return pt(e).api.copy();
}
s(EC, 'copy');
function wC(e = {}) {
  return pt(e).api.cut();
}
s(wC, 'cut');
function SC(e, t = {}) {
  return pt(t).api.dblClick(e);
}
s(SC, 'dblClick');
function _C(e, t, r = {}) {
  return pt(r).api.deselectOptions(e, t);
}
s(_C, 'deselectOptions');
function AC(e, t = {}) {
  return pt(t).api.hover(e);
}
s(AC, 'hover');
async function RC(e, t = {}) {
  const { api: r, system: n } = pt(t);
  return r.keyboard(e).then(() => n);
}
s(RC, 'keyboard');
async function xC(e, t = {}) {
  const { api: r, system: n } = pt(t);
  return r.pointer(e).then(() => n);
}
s(xC, 'pointer');
function PC(e, t) {
  return pt(t).api.paste(e);
}
s(PC, 'paste');
function OC(e, t, r = {}) {
  return pt(r).api.selectOptions(e, t);
}
s(OC, 'selectOptions');
function CC(e, t = {}) {
  return pt(t).api.tripleClick(e);
}
s(CC, 'tripleClick');
function IC(e, t, r = {}) {
  return pt(r, e).api.type(e, t, r);
}
s(IC, 'type');
function NC(e, t = {}) {
  const { api: r, system: n } = pt(t);
  return (n.pointer.setMousePosition({ target: e }), r.unhover(e));
}
s(NC, 'unhover');
function qC(e, t, r = {}) {
  return pt(r).api.upload(e, t);
}
s(qC, 'upload');
function MC(e = {}) {
  return pt().api.tab(e);
}
s(MC, 'tab');
var jC = { ...bC, setup: mC },
  np = jo(
    { ...zA },
    {
      getKeys: s((e) => Object.keys(e).filter((t) => t !== 'eventWrapper'), 'getKeys'),
      intercept: s(
        (e, t) => t[0] === 'fireEvent' || e.startsWith('find') || e.startsWith('waitFor'),
        'intercept',
      ),
    },
  );
np.screen = new Proxy(np.screen, {
  get(e, t, r) {
    return (
      typeof window < 'u' &&
        globalThis.location?.href?.includes('viewMode=docs') &&
        Ve.warn(ve`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `),
      Reflect.get(e, t, r)
    );
  },
});
var {
    buildQueries: pU,
    configure: fU,
    createEvent: mU,
    fireEvent: yU,
    findAllByAltText: hU,
    findAllByDisplayValue: gU,
    findAllByLabelText: bU,
    findAllByPlaceholderText: vU,
    findAllByRole: TU,
    findAllByTestId: EU,
    findAllByText: wU,
    findAllByTitle: SU,
    findByAltText: _U,
    findByDisplayValue: AU,
    findByLabelText: RU,
    findByPlaceholderText: xU,
    findByRole: PU,
    findByTestId: OU,
    findByText: CU,
    findByTitle: IU,
    getAllByAltText: NU,
    getAllByDisplayValue: qU,
    getAllByLabelText: MU,
    getAllByPlaceholderText: jU,
    getAllByRole: $U,
    getAllByTestId: kU,
    getAllByText: DU,
    getAllByTitle: LU,
    getByAltText: FU,
    getByDisplayValue: BU,
    getByLabelText: JU,
    getByPlaceholderText: UU,
    getByRole: VU,
    getByTestId: HU,
    getByText: zU,
    getByTitle: GU,
    getConfig: WU,
    getDefaultNormalizer: KU,
    getElementError: YU,
    getNodeText: XU,
    getQueriesForElement: QU,
    getRoles: ZU,
    getSuggestedQuery: eV,
    isInaccessible: tV,
    logDOM: rV,
    logRoles: nV,
    prettyDOM: oV,
    queries: sV,
    queryAllByAltText: iV,
    queryAllByAttribute: aV,
    queryAllByDisplayValue: lV,
    queryAllByLabelText: cV,
    queryAllByPlaceholderText: uV,
    queryAllByRole: dV,
    queryAllByTestId: pV,
    queryAllByText: fV,
    queryAllByTitle: mV,
    queryByAltText: yV,
    queryByAttribute: hV,
    queryByDisplayValue: gV,
    queryByLabelText: bV,
    queryByPlaceholderText: vV,
    queryByRole: TV,
    queryByTestId: EV,
    queryByText: wV,
    queryByTitle: SV,
    queryHelpers: _V,
    screen: AV,
    waitFor: RV,
    waitForElementToBeRemoved: xV,
    within: $C,
    prettyFormat: PV,
  } = np,
  kC = jC,
  { userEvent: OV } = jo(
    { userEvent: jC },
    {
      intercept: !0,
      getKeys: s((e) => Object.keys(e).filter((t) => t !== 'eventWrapper'), 'getKeys'),
    },
  ),
  { expect: CV } = jo(
    { expect: UA },
    {
      getKeys: s((e, t) => {
        if ('constructor' in e && e.constructor === j) {
          const r = ['assert', '__methods', '__flags', '_obj'],
            n = Object.keys(Object.getPrototypeOf(e)).filter((o) => !r.includes(o));
          return t > 2 ? n : [...n, 'not'];
        }
        return 'any' in e ? Object.keys(e).filter((r) => r !== 'any') : Object.keys(e);
      }, 'getKeys'),
      mutate: !0,
      intercept: s((e) => e !== 'expect', 'intercept'),
    },
  ),
  IV = { mock: s(() => {}, 'mock') },
  Eb = !1,
  NV = s((e) => {
    const { parameters: t } = e;
    t?.actions?.disable ||
      Eb ||
      (vy((r, n) => {
        const o = r.getMockName();
        o !== 'spy' &&
          o !== 'vi.fn()' &&
          (!/^next\/.*::/.test(o) ||
            [
              'next/router::useRouter()',
              'next/navigation::useRouter()',
              'next/navigation::redirect',
              'next/cache::',
              'next/headers::cookies().set',
              'next/headers::cookies().delete',
              'next/headers::headers().set',
              'next/headers::headers().delete',
            ].some((i) => o.startsWith(i))) &&
          Ho(o)(n);
      }),
      (Eb = !0));
  }, 'logActionsWhenMockCalled'),
  qV = [NV],
  wb = s(() => ({ ...ww, ..._w }), 'default'),
  Za = 'backgrounds',
  MV = { light: { name: 'light', value: '#F8F8F8' }, dark: { name: 'dark', value: '#333' } },
  { document: Gt } = globalThis,
  jV = s(
    () =>
      globalThis?.matchMedia
        ? !!globalThis.matchMedia('(prefers-reduced-motion: reduce)')?.matches
        : !1,
    'isReduceMotionEnabled',
  ),
  Sb = s((e) => {
    (Array.isArray(e) ? e : [e]).forEach($V);
  }, 'clearStyles'),
  $V = s((e) => {
    if (!Gt) return;
    const t = Gt.getElementById(e);
    t && t.parentElement && t.parentElement.removeChild(t);
  }, 'clearStyle'),
  kV = s((e, t) => {
    if (!Gt) return;
    const r = Gt.getElementById(e);
    if (r) r.innerHTML !== t && (r.innerHTML = t);
    else {
      const n = Gt.createElement('style');
      (n.setAttribute('id', e), (n.innerHTML = t), Gt.head.appendChild(n));
    }
  }, 'addGridStyle'),
  DV = s((e, t, r) => {
    if (!Gt) return;
    const n = Gt.getElementById(e);
    if (n) n.innerHTML !== t && (n.innerHTML = t);
    else {
      const o = Gt.createElement('style');
      (o.setAttribute('id', e), (o.innerHTML = t));
      const i = `addon-backgrounds-grid${r ? `-docs-${r}` : ''}`,
        a = Gt.getElementById(i);
      a ? a.parentElement?.insertBefore(o, a) : Gt.head.appendChild(o);
    }
  }, 'addBackgroundStyle'),
  LV = { cellSize: 100, cellAmount: 10, opacity: 0.8 },
  _b = 'addon-backgrounds',
  Ab = 'addon-backgrounds-grid',
  FV = jV() ? '' : 'transition: background-color 0.3s;',
  BV = s((e, t) => {
    const { globals: r = {}, parameters: n = {}, viewMode: o, id: i } = t,
      { options: a = MV, disable: c, grid: d = LV } = n[Za] || {},
      u = r[Za] || {},
      p = typeof u == 'string' ? u : u?.value,
      f = p ? a[p] : void 0,
      m = typeof f == 'string' ? f : f?.value || 'transparent',
      h = typeof u == 'string' ? !1 : u.grid || !1,
      g = !!f && !c,
      v = o === 'docs' ? `#anchor--${i} .docs-story` : '.sb-show-main',
      E = o === 'docs' ? `#anchor--${i} .docs-story` : '.sb-show-main',
      b = n.layout === void 0 || n.layout === 'padded',
      S = o === 'docs' ? 20 : b ? 16 : 0,
      { cellAmount: R, cellSize: I, opacity: q, offsetX: P = S, offsetY: A = S } = d,
      w = o === 'docs' ? `${_b}-docs-${i}` : `${_b}-color`,
      _ = o === 'docs' ? i : null;
    Kr(() => {
      const N = `
    ${v} {
      background: ${m} !important;
      ${FV}
      }`;
      if (!g) {
        Sb(w);
        return;
      }
      DV(w, N, _);
    }, [v, w, _, g, m]);
    const $ = o === 'docs' ? `${Ab}-docs-${i}` : `${Ab}`;
    return (
      Kr(() => {
        if (!h) {
          Sb($);
          return;
        }
        const N = [
            `${I * R}px ${I * R}px`,
            `${I * R}px ${I * R}px`,
            `${I}px ${I}px`,
            `${I}px ${I}px`,
          ].join(', '),
          V = `
        ${E} {
          background-size: ${N} !important;
          background-position: ${P}px ${A}px, ${P}px ${A}px, ${P}px ${A}px, ${P}px ${A}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${q}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${q}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${q / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${q / 2}) 1px, transparent 1px) !important;
        }
      `;
        kV($, V);
      }, [R, I, E, $, h, P, A, q]),
      e()
    );
  }, 'withBackgroundAndGrid'),
  JV = globalThis.FEATURES?.backgrounds ? [BV] : [],
  UV = { [Za]: { grid: { cellSize: 20, opacity: 0.5, cellAmount: 5 }, disable: !1 } },
  VV = { [Za]: { value: void 0, grid: !1 } },
  Rb = s(() => ({ decorators: JV, parameters: UV, initialGlobals: VV }), 'default'),
  { step: HV } = jo({ step: s(async (e, t, r) => t(r), 'step') }, { intercept: !0 }),
  xb = s(() => ({ parameters: { throwPlayFunctionExceptions: !1 }, runStep: HV }), 'default'),
  Nc = 'storybook/highlight',
  zV = `${Nc}/add`,
  GV = `${Nc}/remove`,
  WV = `${Nc}/reset`,
  KV = `${Nc}/scroll-into-view`,
  Pb = 2147483647,
  Fr = 28,
  Ob = {
    chevronLeft: [
      'M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z',
    ],
    chevronRight: [
      'M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z',
    ],
    info: [
      'M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z',
      'M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z',
    ],
    shareAlt: [
      'M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z',
      'M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z',
    ],
  },
  YV = 'svg,path,rect,circle,line,polyline,polygon,ellipse,text'.split(','),
  et = s((e, t = {}, r) => {
    const n = YV.includes(e)
      ? document.createElementNS('http://www.w3.org/2000/svg', e)
      : document.createElement(e);
    return (
      Object.entries(t).forEach(([o, i]) => {
        /[A-Z]/.test(o)
          ? (o === 'onClick' &&
              (n.addEventListener('click', i),
              n.addEventListener('keydown', (a) => {
                (a.key === 'Enter' || a.key === ' ') && (a.preventDefault(), i());
              })),
            o === 'onMouseEnter' && n.addEventListener('mouseenter', i),
            o === 'onMouseLeave' && n.addEventListener('mouseleave', i))
          : n.setAttribute(o, i);
      }),
      r?.forEach((o) => {
        if (!(o == null || o === !1))
          try {
            n.appendChild(o);
          } catch {
            n.appendChild(document.createTextNode(String(o)));
          }
      }),
      n
    );
  }, 'createElement'),
  Ji = s(
    (e) =>
      Ob[e] &&
      et(
        'svg',
        { width: '14', height: '14', viewBox: '0 0 14 14', xmlns: 'http://www.w3.org/2000/svg' },
        Ob[e].map((t) =>
          et('path', {
            fill: 'currentColor',
            'fill-rule': 'evenodd',
            'clip-rule': 'evenodd',
            d: t,
          }),
        ),
      ),
    'createIcon',
  ),
  XV = s((e) => {
    if ('elements' in e) {
      const { elements: n, color: o, style: i } = e;
      return {
        id: void 0,
        priority: 0,
        selectors: n,
        styles: {
          outline: `2px ${i} ${o}`,
          outlineOffset: '2px',
          boxShadow: '0 0 0 6px rgba(255,255,255,0.6)',
        },
        menu: void 0,
      };
    }
    const { menu: t, ...r } = e;
    return {
      id: void 0,
      priority: 0,
      styles: { outline: '2px dashed #029cfd' },
      ...r,
      menu: Array.isArray(t) ? (t.every(Array.isArray) ? t : [t]) : void 0,
    };
  }, 'normalizeOptions'),
  QV = s((e) => e instanceof Function, 'isFunction'),
  ws = new Map(),
  dn = new Map(),
  Ui = new Map(),
  gr = s((e) => {
    const t = Symbol();
    return (
      dn.set(t, []),
      ws.set(t, e),
      {
        get: s(() => ws.get(t), 'get'),
        set: s((a) => {
          const c = ws.get(t),
            d = QV(a) ? a(c) : a;
          d !== c &&
            (ws.set(t, d),
            dn.get(t)?.forEach((u) => {
              (Ui.get(u)?.(), Ui.set(u, u(d)));
            }));
        }, 'set'),
        subscribe: s(
          (a) => (
            dn.get(t)?.push(a),
            () => {
              const c = dn.get(t);
              c &&
                dn.set(
                  t,
                  c.filter((d) => d !== a),
                );
            }
          ),
          'subscribe',
        ),
        teardown: s(() => {
          (dn.get(t)?.forEach((a) => {
            (Ui.get(a)?.(), Ui.delete(a));
          }),
            dn.delete(t),
            ws.delete(t));
        }, 'teardown'),
      }
    );
  }, 'useStore'),
  Cb = s((e) => {
    const t = document.getElementById('storybook-root'),
      r = new Map();
    for (const n of e) {
      const { priority: o = 0 } = n;
      for (const i of n.selectors) {
        const a = [
          ...document.querySelectorAll(
            `:is(${i}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`,
          ),
          ...(t?.querySelectorAll(i) || []),
        ];
        for (const c of a) {
          const d = r.get(c);
          (!d || d.priority <= o) &&
            r.set(c, {
              ...n,
              priority: o,
              selectors: Array.from(new Set((d?.selectors || []).concat(i))),
            });
        }
      }
    }
    return r;
  }, 'mapElements'),
  ZV = s(
    (e) =>
      Array.from(e.entries())
        .map(([t, { selectors: r, styles: n, hoverStyles: o, focusStyles: i, menu: a }]) => {
          const { top: c, left: d, width: u, height: p } = t.getBoundingClientRect(),
            { position: f } = getComputedStyle(t);
          return {
            element: t,
            selectors: r,
            styles: n,
            hoverStyles: o,
            focusStyles: i,
            menu: a,
            top: f === 'fixed' ? c : c + window.scrollY,
            left: f === 'fixed' ? d : d + window.scrollX,
            width: u,
            height: p,
          };
        })
        .sort((t, r) => r.width * r.height - t.width * t.height),
    'mapBoxes',
  ),
  Ib = s((e, t) => {
    const r = e.getBoundingClientRect(),
      { x: n, y: o } = t;
    return (
      r?.top &&
      r?.left &&
      n >= r.left &&
      n <= r.left + r.width &&
      o >= r.top &&
      o <= r.top + r.height
    );
  }, 'isOverMenu'),
  Nb = s((e, t, r) => {
    if (!t || !r) return !1;
    let { left: n, top: o, width: i, height: a } = e;
    (a < Fr && ((o = o - Math.round((Fr - a) / 2)), (a = Fr)),
      i < Fr && ((n = n - Math.round((Fr - i) / 2)), (i = Fr)),
      t.style.position === 'fixed' && ((n += window.scrollX), (o += window.scrollY)));
    const { x: c, y: d } = r;
    return c >= n && c <= n + i && d >= o && d <= o + a;
  }, 'isTargeted'),
  eH = s((e, t, r = {}) => {
    const { x: n, y: o } = t,
      { margin: i = 5, topOffset: a = 0, centered: c = !1 } = r,
      { scrollX: d, scrollY: u, innerHeight: p, innerWidth: f } = window,
      m = Math.min(e.style.position === 'fixed' ? o - u : o, p - e.clientHeight - i - a + u),
      h = c ? e.clientWidth / 2 : 0,
      g =
        e.style.position === 'fixed'
          ? Math.max(Math.min(n - d, f - h - i), h + i)
          : Math.max(Math.min(n, f - h - i + d), h + i + d);
    Object.assign(e.style, {
      ...(g !== n && { left: `${g}px` }),
      ...(m !== o && { top: `${m}px` }),
    });
  }, 'keepInViewport'),
  qb = s((e) => {
    window.HTMLElement.prototype.hasOwnProperty('showPopover') && e.showPopover();
  }, 'showPopover'),
  tH = s((e) => {
    window.HTMLElement.prototype.hasOwnProperty('showPopover') && e.hidePopover();
  }, 'hidePopover'),
  rH = s(
    (e) => ({
      top: e.top,
      left: e.left,
      width: e.width,
      height: e.height,
      selectors: e.selectors,
      element: {
        attributes: Object.fromEntries(
          Array.from(e.element.attributes).map((t) => [t.name, t.value]),
        ),
        localName: e.element.localName,
        tagName: e.element.tagName,
        outerHTML: e.element.outerHTML,
      },
    }),
    'getEventDetails',
  ),
  Me = 'storybook-highlights-menu',
  Mb = 'storybook-highlights-root',
  nH = 'storybook-root',
  oH = s((e) => {
    if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED) return;
    globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
    const { document: t } = globalThis,
      r = gr([]),
      n = gr(new Map()),
      o = gr([]),
      i = gr(),
      a = gr(),
      c = gr([]),
      d = gr([]),
      u = gr(),
      p = gr();
    let f = t.getElementById(Mb);
    (r.subscribe(() => {
      f || ((f = et('div', { id: Mb })), t.body.appendChild(f));
    }),
      r.subscribe((A) => {
        const w = t.getElementById(nH);
        if (!w) return;
        n.set(Cb(A));
        const _ = new MutationObserver(() => n.set(Cb(A)));
        return (
          _.observe(w, { subtree: !0, childList: !0 }),
          () => {
            _.disconnect();
          }
        );
      }),
      n.subscribe((A) => {
        const w = s(() => requestAnimationFrame(() => o.set(ZV(A))), 'updateBoxes'),
          _ = new ResizeObserver(w);
        (_.observe(t.body), Array.from(A.keys()).forEach((N) => _.observe(N)));
        const $ = Array.from(t.body.querySelectorAll('*')).filter((N) => {
          const { overflow: V, overflowX: H, overflowY: x } = window.getComputedStyle(N);
          return ['auto', 'scroll'].some((D) => [V, H, x].includes(D));
        });
        return (
          $.forEach((N) => N.addEventListener('scroll', w)),
          () => {
            (_.disconnect(), $.forEach((N) => N.removeEventListener('scroll', w)));
          }
        );
      }),
      n.subscribe((A) => {
        const w = Array.from(A.keys()).filter(({ style: $ }) => $.position === 'sticky'),
          _ = s(
            () =>
              requestAnimationFrame(() => {
                o.set(($) =>
                  $.map((N) => {
                    if (w.includes(N.element)) {
                      const { top: V, left: H } = N.element.getBoundingClientRect();
                      return { ...N, top: V + window.scrollY, left: H + window.scrollX };
                    }
                    return N;
                  }),
                );
              }),
            'updateBoxes',
          );
        return (t.addEventListener('scroll', _), () => t.removeEventListener('scroll', _));
      }),
      n.subscribe((A) => {
        c.set((w) => w.filter(({ element: _ }) => A.has(_)));
      }),
      c.subscribe((A) => {
        A.length
          ? (p.set((w) => (A.some((_) => _.element === w?.element) ? w : void 0)),
            u.set((w) => (A.some((_) => _.element === w?.element) ? w : void 0)))
          : (p.set(void 0), u.set(void 0), i.set(void 0));
      }));
    const m = new Map(new Map());
    r.subscribe((A) => {
      (A.forEach(({ keyframes: w }) => {
        if (w) {
          let _ = m.get(w);
          (_ ||
            ((_ = t.createElement('style')),
            _.setAttribute('data-highlight', 'keyframes'),
            m.set(w, _),
            t.head.appendChild(_)),
            (_.innerHTML = w));
        }
      }),
        m.forEach((w, _) => {
          A.some(($) => $.keyframes === _) || (w.remove(), m.delete(_));
        }));
    });
    const h = new Map(new Map());
    (o.subscribe((A) => {
      (A.forEach((w) => {
        let _ = h.get(w.element);
        if (f && !_) {
          const $ = {
            popover: 'manual',
            'data-highlight-dimensions': `w${w.width.toFixed(0)}h${w.height.toFixed(0)}`,
            'data-highlight-coordinates': `x${w.left.toFixed(0)}y${w.top.toFixed(0)}`,
          };
          ((_ = f.appendChild(et('div', $, [et('div')]))), h.set(w.element, _));
        }
      }),
        h.forEach((w, _) => {
          A.some(({ element: $ }) => $ === _) || (w.remove(), h.delete(_));
        }));
    }),
      o.subscribe((A) => {
        const w = A.filter(($) => $.menu);
        if (!w.length) return;
        const _ = s(($) => {
          requestAnimationFrame(() => {
            const N = t.getElementById(Me),
              V = { x: $.pageX, y: $.pageY };
            if (N && !Ib(N, V)) {
              const H = w.filter((x) => {
                const D = h.get(x.element);
                return Nb(x, D, V);
              });
              (i.set(H.length ? V : void 0), c.set(H));
            }
          });
        }, 'onClick');
        return (t.addEventListener('click', _), () => t.removeEventListener('click', _));
      }));
    const g = s(() => {
      const A = t.getElementById(Me),
        w = a.get();
      !w ||
        (A && Ib(A, w)) ||
        d.set((_) => {
          const $ = o.get().filter((x) => {
              const D = h.get(x.element);
              return Nb(x, D, w);
            }),
            N = _.filter((x) => $.includes(x)),
            V = $.filter((x) => !_.includes(x)),
            H = _.length - N.length;
          return V.length || H ? [...N, ...V] : _;
        });
    }, 'updateHovered');
    (a.subscribe(g), o.subscribe(g));
    const v = s(() => {
      const A = p.get(),
        w = A ? [A] : c.get(),
        _ = w.length === 1 ? w[0] : u.get(),
        $ = i.get() !== void 0;
      o.get().forEach((N) => {
        const V = h.get(N.element);
        if (V) {
          const H = _ === N,
            x = $ ? (_ ? H : w.includes(N)) : d.get()?.includes(N);
          (Object.assign(V.style, {
            animation: 'none',
            background: 'transparent',
            border: 'none',
            boxSizing: 'border-box',
            outline: 'none',
            outlineOffset: '0px',
            ...N.styles,
            ...(x ? N.hoverStyles : {}),
            ...(H ? N.focusStyles : {}),
            position: getComputedStyle(N.element).position === 'fixed' ? 'fixed' : 'absolute',
            zIndex: Pb - 10,
            top: `${N.top}px`,
            left: `${N.left}px`,
            width: `${N.width}px`,
            height: `${N.height}px`,
            margin: 0,
            padding: 0,
            cursor: N.menu && x ? 'pointer' : 'default',
            pointerEvents: N.menu ? 'auto' : 'none',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            overflow: 'visible',
          }),
            Object.assign(V.children[0].style, {
              width: '100%',
              height: '100%',
              minHeight: `${Fr}px`,
              minWidth: `${Fr}px`,
              boxSizing: 'content-box',
              padding: V.style.outlineWidth || '0px',
            }),
            qb(V));
        }
      });
    }, 'updateBoxStyles');
    (o.subscribe(v), c.subscribe(v), d.subscribe(v), u.subscribe(v), p.subscribe(v));
    const E = s(() => {
      if (!f) return;
      let A = t.getElementById(Me);
      if (A) A.innerHTML = '';
      else {
        const N = { id: Me, popover: 'manual' };
        ((A = f.appendChild(et('div', N))),
          f.appendChild(
            et('style', {}, [
              `
            #${Me} {
              position: absolute;
              z-index: ${Pb};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${Me} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${Me} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${Me} li {
              padding: 0 4px;
              margin: 0;
            }
            #${Me} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${Me} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${Me} button:focus-visible {
              outline-color: #029CFD;
            }
            #${Me} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${Me} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${Me} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${Me} li > button:hover svg, #${Me} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${Me} .element-list li svg {
              display: none;
            }
            #${Me} li.selectable svg, #${Me} li.selected svg {
              display: block;
            }
            #${Me} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Me} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Me} .menu-items, #${Me} .menu-items li {
              padding: 0;
            }
            #${Me} .menu-item {
              display: flex;
            }
            #${Me} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `,
            ]),
          ));
      }
      const w = p.get(),
        _ = w ? [w] : c.get();
      if (
        (_.length &&
          ((A.style.position =
            getComputedStyle(_[0].element).position === 'fixed' ? 'fixed' : 'absolute'),
          A.appendChild(
            et(
              'ul',
              { class: 'element-list' },
              _.map((N) => {
                const V =
                    _.length > 1 &&
                    !!N.menu?.some((D) =>
                      D.some(
                        (F) => !F.selectors || F.selectors.some((k) => N.selectors.includes(k)),
                      ),
                    ),
                  H = V
                    ? {
                        class: 'selectable',
                        onClick: s(() => p.set(N), 'onClick'),
                        onMouseEnter: s(() => u.set(N), 'onMouseEnter'),
                        onMouseLeave: s(() => u.set(void 0), 'onMouseLeave'),
                      }
                    : w
                      ? { class: 'selected', onClick: s(() => p.set(void 0), 'onClick') }
                      : {},
                  x = V || w;
                return et('li', H, [
                  et(x ? 'button' : 'div', x ? { type: 'button' } : {}, [
                    w ? Ji('chevronLeft') : null,
                    et('code', {}, [N.element.outerHTML]),
                    V ? Ji('chevronRight') : null,
                  ]),
                ]);
              }),
            ),
          )),
        p.get() || c.get().length === 1)
      ) {
        const N = p.get() || c.get()[0],
          V = N.menu?.filter((H) =>
            H.some((x) => !x.selectors || x.selectors.some((D) => N.selectors.includes(D))),
          );
        V?.length &&
          A.appendChild(
            et(
              'ul',
              { class: 'menu-list' },
              V.map((H) =>
                et('li', {}, [
                  et(
                    'ul',
                    { class: 'menu-items' },
                    H.map(
                      ({
                        id: x,
                        title: D,
                        description: F,
                        iconLeft: k,
                        iconRight: K,
                        clickEvent: X,
                      }) => {
                        const se = X && (() => e.emit(X, x, rH(N)));
                        return et('li', {}, [
                          et(
                            se ? 'button' : 'div',
                            se
                              ? { class: 'menu-item', type: 'button', onClick: se }
                              : { class: 'menu-item' },
                            [
                              k ? Ji(k) : null,
                              et('div', { class: 'menu-item-content' }, [
                                et(F ? 'strong' : 'span', {}, [D]),
                                F && et('span', {}, [F]),
                              ]),
                              K ? Ji(K) : null,
                            ],
                          ),
                        ]);
                      },
                    ),
                  ),
                ]),
              ),
            ),
          );
      }
      const $ = i.get();
      $
        ? (Object.assign(A.style, {
            display: 'block',
            left: `${A.style.position === 'fixed' ? $.x - window.scrollX : $.x}px`,
            top: `${A.style.position === 'fixed' ? $.y - window.scrollY : $.y}px`,
          }),
          qb(A),
          requestAnimationFrame(() => eH(A, $, { topOffset: 15, centered: !0 })))
        : (tH(A), Object.assign(A.style, { display: 'none' }));
    }, 'renderMenu');
    (c.subscribe(E), p.subscribe(E));
    const b = s((A) => {
        const w = XV(A);
        r.set((_) => {
          const $ = w.id ? _.filter((N) => N.id !== w.id) : _;
          return w.selectors?.length ? [...$, w] : $;
        });
      }, 'addHighlight'),
      S = s((A) => {
        A && r.set((w) => w.filter((_) => _.id !== A));
      }, 'removeHighlight'),
      R = s(() => {
        (r.set([]),
          n.set(new Map()),
          o.set([]),
          i.set(void 0),
          a.set(void 0),
          c.set([]),
          d.set([]),
          u.set(void 0),
          p.set(void 0));
      }, 'resetState');
    let I;
    const q = s((A, w) => {
        const _ = 'scrollIntoView-highlight';
        (clearTimeout(I), S(_));
        const $ = t.querySelector(A);
        if (!$) {
          console.warn(`Cannot scroll into view: ${A} not found`);
          return;
        }
        $.scrollIntoView({ behavior: 'smooth', block: 'center', ...w });
        const N = `kf-${Math.random().toString(36).substring(2, 15)}`;
        (r.set((V) => [
          ...V,
          {
            id: _,
            priority: 1e3,
            selectors: [A],
            styles: {
              outline: '2px solid #1EA7FD',
              outlineOffset: '-1px',
              animation: `${N} 3s linear forwards`,
            },
            keyframes: `@keyframes ${N} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`,
          },
        ]),
          (I = setTimeout(() => S(_), 3500)));
      }, 'scrollIntoView'),
      P = s((A) => {
        requestAnimationFrame(() => a.set({ x: A.pageX, y: A.pageY }));
      }, 'onMouseMove');
    (t.body.addEventListener('mousemove', P),
      e.on(zV, b),
      e.on(GV, S),
      e.on(WV, R),
      e.on(KV, q),
      e.on(xn, ({ newPhase: A }) => {
        A === 'loading' && R();
      }));
  }, 'useHighlights');
globalThis?.FEATURES?.highlight && Ft?.ready && Ft.ready().then(oH);
var jb = s(() => ({}), 'default'),
  sH = 'measureEnabled';
function Sh() {
  const e = te.document.documentElement,
    t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
s(Sh, 'getDocumentWidthAndHeight');
function DC() {
  const e = te.document.createElement('canvas');
  e.id = 'storybook-addon-measure';
  const t = e.getContext('2d');
  sr(t != null);
  const { width: r, height: n } = Sh();
  return (
    el(e, t, { width: r, height: n }),
    (e.style.position = 'absolute'),
    (e.style.left = '0'),
    (e.style.top = '0'),
    (e.style.zIndex = '2147483647'),
    (e.style.pointerEvents = 'none'),
    te.document.body.appendChild(e),
    { canvas: e, context: t, width: r, height: n }
  );
}
s(DC, 'createCanvas');
function el(e, t, { width: r, height: n }) {
  ((e.style.width = `${r}px`), (e.style.height = `${n}px`));
  const o = te.window.devicePixelRatio;
  ((e.width = Math.floor(r * o)), (e.height = Math.floor(n * o)), t.scale(o, o));
}
s(el, 'setCanvasWidthAndHeight');
var tt = {};
function LC() {
  tt.canvas || (tt = DC());
}
s(LC, 'init');
function _h() {
  tt.context && tt.context.clearRect(0, 0, tt.width ?? 0, tt.height ?? 0);
}
s(_h, 'clear');
function FC(e) {
  (_h(), e(tt.context));
}
s(FC, 'draw');
function BC() {
  (sr(tt.canvas), sr(tt.context), el(tt.canvas, tt.context, { width: 0, height: 0 }));
  const { width: e, height: t } = Sh();
  (el(tt.canvas, tt.context, { width: e, height: t }), (tt.width = e), (tt.height = t));
}
s(BC, 'rescale');
function JC() {
  tt.canvas && (_h(), tt.canvas.parentNode?.removeChild(tt.canvas), (tt = {}));
}
s(JC, 'destroy');
var Gn = {
    margin: '#f6b26b',
    border: '#ffe599',
    padding: '#93c47d',
    content: '#6fa8dc',
    text: '#232020',
  },
  xr = 6;
function op(e, { x: t, y: r, w: n, h: o, r: i }) {
  ((t = t - n / 2),
    (r = r - o / 2),
    n < 2 * i && (i = n / 2),
    o < 2 * i && (i = o / 2),
    e.beginPath(),
    e.moveTo(t + i, r),
    e.arcTo(t + n, r, t + n, r + o, i),
    e.arcTo(t + n, r + o, t, r + o, i),
    e.arcTo(t, r + o, t, r, i),
    e.arcTo(t, r, t + n, r, i),
    e.closePath());
}
s(op, 'roundedRect');
function UC(e, { padding: t, border: r, width: n, height: o, top: i, left: a }) {
  const c = n - r.left - r.right - t.left - t.right,
    d = o - t.top - t.bottom - r.top - r.bottom;
  let u = a + r.left + t.left,
    p = i + r.top + t.top;
  return (
    e === 'top'
      ? (u += c / 2)
      : e === 'right'
        ? ((u += c), (p += d / 2))
        : e === 'bottom'
          ? ((u += c / 2), (p += d))
          : e === 'left'
            ? (p += d / 2)
            : e === 'center' && ((u += c / 2), (p += d / 2)),
    { x: u, y: p }
  );
}
s(UC, 'positionCoordinate');
function VC(e, t, { margin: r, border: n, padding: o }, i, a) {
  let c = s((m) => 0, 'shift'),
    d = 0,
    u = 0;
  const p = a ? 1 : 0.5,
    f = a ? i * 2 : 0;
  return (
    e === 'padding'
      ? (c = s((m) => o[m] * p + f, 'shift'))
      : e === 'border'
        ? (c = s((m) => o[m] + n[m] * p + f, 'shift'))
        : e === 'margin' && (c = s((m) => o[m] + n[m] + r[m] * p + f, 'shift')),
    t === 'top'
      ? (u = -c('top'))
      : t === 'right'
        ? (d = c('right'))
        : t === 'bottom'
          ? (u = c('bottom'))
          : t === 'left' && (d = -c('left')),
    { offsetX: d, offsetY: u }
  );
}
s(VC, 'offset');
function HC(e, t) {
  return (
    Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2
  );
}
s(HC, 'collide');
function zC(e, t, r) {
  return (
    e === 'top'
      ? (t.y = r.y - r.h - xr)
      : e === 'right'
        ? (t.x = r.x + r.w / 2 + xr + t.w / 2)
        : e === 'bottom'
          ? (t.y = r.y + r.h + xr)
          : e === 'left' && (t.x = r.x - r.w / 2 - xr - t.w / 2),
    { x: t.x, y: t.y }
  );
}
s(zC, 'overlapAdjustment');
function Ah(e, t, { x: r, y: n, w: o, h: i }, a) {
  return (
    op(e, { x: r, y: n, w: o, h: i, r: 3 }),
    (e.fillStyle = `${Gn[t]}dd`),
    e.fill(),
    (e.strokeStyle = Gn[t]),
    e.stroke(),
    (e.fillStyle = Gn.text),
    e.fillText(a, r, n),
    op(e, { x: r, y: n, w: o, h: i, r: 3 }),
    (e.fillStyle = `${Gn[t]}dd`),
    e.fill(),
    (e.strokeStyle = Gn[t]),
    e.stroke(),
    (e.fillStyle = Gn.text),
    e.fillText(a, r, n),
    { x: r, y: n, w: o, h: i }
  );
}
s(Ah, 'textWithRect');
function Rh(e, t) {
  ((e.font = '600 12px monospace'), (e.textBaseline = 'middle'), (e.textAlign = 'center'));
  const r = e.measureText(t),
    n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent,
    o = r.width + xr * 2,
    i = n + xr * 2;
  return { w: o, h: i };
}
s(Rh, 'configureText');
function GC(e, t, { type: r, position: n = 'center', text: o }, i, a = !1) {
  let { x: c, y: d } = UC(n, t);
  const { offsetX: u, offsetY: p } = VC(r, n, t, xr + 1, a);
  ((c += u), (d += p));
  const { w: f, h: m } = Rh(e, o);
  if (i && HC({ x: c, y: d, w: f, h: m }, i)) {
    const h = zC(n, { x: c, y: d, w: f }, i);
    ((c = h.x), (d = h.y));
  }
  return Ah(e, r, { x: c, y: d, w: f, h: m }, o);
}
s(GC, 'drawLabel');
function WC(e, { w: t, h: r }) {
  const n = t * 0.5 + xr,
    o = r * 0.5 + xr;
  return { offsetX: (e.x === 'left' ? -1 : 1) * n, offsetY: (e.y === 'top' ? -1 : 1) * o };
}
s(WC, 'floatingOffset');
function KC(e, t, { type: r, text: n }) {
  const { floatingAlignment: o, extremities: i } = t;
  let a = i[o.x],
    c = i[o.y];
  const { w: d, h: u } = Rh(e, n),
    { offsetX: p, offsetY: f } = WC(o, { w: d, h: u });
  return ((a += p), (c += f), Ah(e, r, { x: a, y: c, w: d, h: u }, n));
}
s(KC, 'drawFloatingLabel');
function Yn(e, t, r, n) {
  const o = [];
  r.forEach((i, a) => {
    const c = n && i.position === 'center' ? KC(e, t, i) : GC(e, t, i, o[a - 1], n);
    o[a] = c;
  });
}
s(Yn, 'drawStack');
function YC(e, t, r, n) {
  const o = r.reduce(
    (i, a) => (
      Object.prototype.hasOwnProperty.call(i, a.position) || (i[a.position] = []),
      i[a.position]?.push(a),
      i
    ),
    {},
  );
  (o.top && Yn(e, t, o.top, n),
    o.right && Yn(e, t, o.right, n),
    o.bottom && Yn(e, t, o.bottom, n),
    o.left && Yn(e, t, o.left, n),
    o.center && Yn(e, t, o.center, n));
}
s(YC, 'labelStacks');
var qc = { margin: '#f6b26ba8', border: '#ffe599a8', padding: '#93c47d8c', content: '#6fa8dca8' },
  $b = 30;
function Rt(e) {
  return parseInt(e.replace('px', ''), 10);
}
s(Rt, 'pxToNumber');
function bn(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
s(bn, 'round');
function Mc(e) {
  return e.filter((t) => t.text !== 0 && t.text !== '0');
}
s(Mc, 'filterZeroValues');
function XC(e) {
  const t = {
      top: te.window.scrollY,
      bottom: te.window.scrollY + te.window.innerHeight,
      left: te.window.scrollX,
      right: te.window.scrollX + te.window.innerWidth,
    },
    r = {
      top: Math.abs(t.top - e.top),
      bottom: Math.abs(t.bottom - e.bottom),
      left: Math.abs(t.left - e.left),
      right: Math.abs(t.right - e.right),
    };
  return { x: r.left > r.right ? 'left' : 'right', y: r.top > r.bottom ? 'top' : 'bottom' };
}
s(XC, 'floatingAlignment');
function QC(e) {
  const t = te.getComputedStyle(e);
  let { top: r, left: n, right: o, bottom: i, width: a, height: c } = e.getBoundingClientRect();
  const {
    marginTop: d,
    marginBottom: u,
    marginLeft: p,
    marginRight: f,
    paddingTop: m,
    paddingBottom: h,
    paddingLeft: g,
    paddingRight: v,
    borderBottomWidth: E,
    borderTopWidth: b,
    borderLeftWidth: S,
    borderRightWidth: R,
  } = t;
  ((r = r + te.window.scrollY),
    (n = n + te.window.scrollX),
    (i = i + te.window.scrollY),
    (o = o + te.window.scrollX));
  const I = { top: Rt(d), bottom: Rt(u), left: Rt(p), right: Rt(f) },
    q = { top: Rt(m), bottom: Rt(h), left: Rt(g), right: Rt(v) },
    P = { top: Rt(b), bottom: Rt(E), left: Rt(S), right: Rt(R) },
    A = { top: r - I.top, bottom: i + I.bottom, left: n - I.left, right: o + I.right };
  return {
    margin: I,
    padding: q,
    border: P,
    top: r,
    left: n,
    bottom: i,
    right: o,
    width: a,
    height: c,
    extremities: A,
    floatingAlignment: XC(A),
  };
}
s(QC, 'measureElement');
function ZC(e, { margin: t, width: r, height: n, top: o, left: i, bottom: a, right: c }) {
  const d = n + t.bottom + t.top;
  ((e.fillStyle = qc.margin),
    e.fillRect(i, o - t.top, r, t.top),
    e.fillRect(c, o - t.top, t.right, d),
    e.fillRect(i, a, r, t.bottom),
    e.fillRect(i - t.left, o - t.top, t.left, d));
  const u = [
    { type: 'margin', text: bn(t.top), position: 'top' },
    { type: 'margin', text: bn(t.right), position: 'right' },
    { type: 'margin', text: bn(t.bottom), position: 'bottom' },
    { type: 'margin', text: bn(t.left), position: 'left' },
  ];
  return Mc(u);
}
s(ZC, 'drawMargin');
function eI(
  e,
  { padding: t, border: r, width: n, height: o, top: i, left: a, bottom: c, right: d },
) {
  const u = n - r.left - r.right,
    p = o - t.top - t.bottom - r.top - r.bottom;
  ((e.fillStyle = qc.padding),
    e.fillRect(a + r.left, i + r.top, u, t.top),
    e.fillRect(d - t.right - r.right, i + t.top + r.top, t.right, p),
    e.fillRect(a + r.left, c - t.bottom - r.bottom, u, t.bottom),
    e.fillRect(a + r.left, i + t.top + r.top, t.left, p));
  const f = [
    { type: 'padding', text: t.top, position: 'top' },
    { type: 'padding', text: t.right, position: 'right' },
    { type: 'padding', text: t.bottom, position: 'bottom' },
    { type: 'padding', text: t.left, position: 'left' },
  ];
  return Mc(f);
}
s(eI, 'drawPadding');
function tI(e, { border: t, width: r, height: n, top: o, left: i, bottom: a, right: c }) {
  const d = n - t.top - t.bottom;
  ((e.fillStyle = qc.border),
    e.fillRect(i, o, r, t.top),
    e.fillRect(i, a - t.bottom, r, t.bottom),
    e.fillRect(i, o + t.top, t.left, d),
    e.fillRect(c - t.right, o + t.top, t.right, d));
  const u = [
    { type: 'border', text: t.top, position: 'top' },
    { type: 'border', text: t.right, position: 'right' },
    { type: 'border', text: t.bottom, position: 'bottom' },
    { type: 'border', text: t.left, position: 'left' },
  ];
  return Mc(u);
}
s(tI, 'drawBorder');
function rI(e, { padding: t, border: r, width: n, height: o, top: i, left: a }) {
  const c = n - r.left - r.right - t.left - t.right,
    d = o - t.top - t.bottom - r.top - r.bottom;
  return (
    (e.fillStyle = qc.content),
    e.fillRect(a + r.left + t.left, i + r.top + t.top, c, d),
    [{ type: 'content', position: 'center', text: `${bn(c)} x ${bn(d)}` }]
  );
}
s(rI, 'drawContent');
function nI(e) {
  return (t) => {
    if (e && t) {
      const r = QC(e),
        n = ZC(t, r),
        o = eI(t, r),
        i = tI(t, r),
        a = rI(t, r),
        c = r.width <= $b * 3 || r.height <= $b;
      YC(t, r, [...a, ...o, ...i, ...n], c);
    }
  };
}
s(nI, 'drawBoxModel');
function oI(e) {
  FC(nI(e));
}
s(oI, 'drawSelectedElement');
var iH = s((e, t) => {
    const r = te.document.elementFromPoint(e, t),
      n = s((i) => {
        if (i && i.shadowRoot) {
          const a = i.shadowRoot.elementFromPoint(e, t);
          return i.isEqualNode(a) ? i : a.shadowRoot ? n(a) : a;
        }
        return i;
      }, 'crawlShadows');
    return n(r) || r;
  }, 'deepElementFromPoint'),
  kb,
  Vi = { x: 0, y: 0 };
function sp(e, t) {
  ((kb = iH(e, t)), oI(kb));
}
s(sp, 'findAndDrawElement');
var aH = s((e, t) => {
    const { measureEnabled: r } = t.globals || {};
    return (
      Kr(() => {
        if (typeof globalThis.document > 'u') return;
        const n = s((o) => {
          window.requestAnimationFrame(() => {
            (o.stopPropagation(), (Vi.x = o.clientX), (Vi.y = o.clientY));
          });
        }, 'onPointerMove');
        return (
          globalThis.document.addEventListener('pointermove', n),
          () => {
            globalThis.document.removeEventListener('pointermove', n);
          }
        );
      }, []),
      Kr(() => {
        const n = s((i) => {
            window.requestAnimationFrame(() => {
              (i.stopPropagation(), sp(i.clientX, i.clientY));
            });
          }, 'onPointerOver'),
          o = s(() => {
            window.requestAnimationFrame(() => {
              BC();
            });
          }, 'onResize');
        return (
          t.viewMode === 'story' &&
            r &&
            (globalThis.document.addEventListener('pointerover', n),
            LC(),
            globalThis.window.addEventListener('resize', o),
            sp(Vi.x, Vi.y)),
          () => {
            (globalThis.window.removeEventListener('resize', o), JC());
          }
        );
      }, [r, t.viewMode]),
      e()
    );
  }, 'withMeasure'),
  lH = globalThis.FEATURES?.measure ? [aH] : [],
  cH = { [sH]: !1 },
  Db = s(() => ({ decorators: lH, initialGlobals: cH }), 'default'),
  sI = 'outline',
  Lb = s((e) => {
    (Array.isArray(e) ? e : [e]).forEach(uH);
  }, 'clearStyles'),
  uH = s((e) => {
    const t = typeof e == 'string' ? e : e.join(''),
      r = te.document.getElementById(t);
    r && r.parentElement && r.parentElement.removeChild(r);
  }, 'clearStyle'),
  dH = s((e, t) => {
    const r = te.document.getElementById(e);
    if (r) r.innerHTML !== t && (r.innerHTML = t);
    else {
      const n = te.document.createElement('style');
      (n.setAttribute('id', e), (n.innerHTML = t), te.document.head.appendChild(n));
    }
  }, 'addOutlineStyles');
function iI(e) {
  return ve`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
s(iI, 'outlineCSS');
var pH = s((e, t) => {
    const r = t.globals || {},
      n = [!0, 'true'].includes(r[sI]),
      o = t.viewMode === 'docs',
      i = af(() => iI(o ? '[data-story-block="true"]' : '.sb-show-main'), [t]);
    return (
      Kr(() => {
        const a = o ? `addon-outline-docs-${t.id}` : 'addon-outline';
        return (
          n ? dH(a, i) : Lb(a),
          () => {
            Lb(a);
          }
        );
      }, [n, i, t]),
      e()
    );
  }, 'withOutline'),
  fH = globalThis.FEATURES?.outline ? [pH] : [],
  mH = { [sI]: !1 },
  Fb = s(() => ({ decorators: fH, initialGlobals: mH }), 'default'),
  yH = s(({ parameters: e }) => {
    e?.test?.mockReset === !0
      ? Sy()
      : e?.test?.clearMocks === !0
        ? wy()
        : e?.test?.restoreMocks !== !1 && _y();
  }, 'resetAllMocksLoader'),
  ip = s((e, t = 0, r) => {
    if (t > 5 || e == null) return e;
    if (wn(e)) return (r && e.mockName(r), e);
    if (
      typeof e == 'function' &&
      'isAction' in e &&
      e.isAction &&
      !('implicit' in e && e.implicit)
    ) {
      const n = Ty(e);
      return (r && n.mockName(r), n);
    }
    if (Array.isArray(e)) {
      t++;
      for (let n = 0; n < e.length; n++)
        Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = ip(e[n], t));
      return e;
    }
    if (typeof e == 'object' && e.constructor === Object) {
      t++;
      for (const [n, o] of Object.entries(e))
        Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = ip(o, t, n));
      return e;
    }
    return e;
  }, 'traverseArgs'),
  hH = s(({ initialArgs: e }) => {
    ip(e);
  }, 'nameSpiesAndWrapActionsInSpies'),
  Bb = !1,
  gH = s(async (e) => {
    globalThis.HTMLElement &&
      e.canvasElement instanceof globalThis.HTMLElement &&
      (e.canvas = $C(e.canvasElement));
    const t = globalThis.window?.navigator?.clipboard;
    if (
      t &&
      ((e.userEvent = jo(
        { userEvent: kC.setup() },
        {
          intercept: !0,
          getKeys: s((r) => Object.keys(r).filter((n) => n !== 'eventWrapper'), 'getKeys'),
        },
      ).userEvent),
      Object.defineProperty(globalThis.window.navigator, 'clipboard', {
        get: s(() => t, 'get'),
        configurable: !0,
      }),
      !Bb)
    ) {
      const r = HTMLElement.prototype.focus;
      let n = HTMLElement.prototype.focus;
      const o = new Set();
      (Object.defineProperties(HTMLElement.prototype, {
        focus: {
          configurable: !0,
          set: s((i) => {
            n = i;
          }, 'set'),
          get() {
            return o.has(this) ? r : (o.add(this), setTimeout(() => o.delete(this), 0), n);
          },
        },
      }),
        (Bb = !0));
    }
  }, 'enhanceContext'),
  Jb = s(() => ({ loaders: [yH, hH, gH] }), 'default'),
  bH = 'viewport',
  vH = { [bH]: { value: void 0, isRotated: !1 } },
  Ub = s(() => ({ initialGlobals: vH }), 'default');
function xh() {
  return [
    (Db.default ?? Db)(),
    (Rb.default ?? Rb)(),
    (jb.default ?? jb)(),
    (Fb.default ?? Fb)(),
    (Ub.default ?? Ub)(),
    (wb.default ?? wb)(),
    (xb.default ?? xb)(),
    (Jb.default ?? Jb)(),
  ];
}
s(xh, 'getCoreAnnotations');
function TH(e) {
  return e;
}
s(TH, 'definePreviewAddon');
function aI(e) {
  return e != null && typeof e == 'object' && '_tag' in e && e?._tag === 'Meta';
}
s(aI, 'isMeta');
function jc(e) {
  return e != null && typeof e == 'object' && '_tag' in e && e?._tag === 'Story';
}
s(jc, 'isStory');
function lI(e) {
  return '__children' in e ? e.__children : [];
}
s(lI, 'getStoryChildren');
var cI = s(
    (e) =>
      e
        .toLowerCase()
        .replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '-')
        .replace(/-+/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, ''),
    'sanitize',
  ),
  ap = s((e, t) => {
    const r = cI(e);
    if (r === '') throw new Error(`Invalid ${t} '${e}', must include alphanumeric characters`);
    return r;
  }, 'sanitizeSafe'),
  EH = s((e, t) => `${ap(e, 'kind')}${t ? `--${ap(t, 'name')}` : ''}`, 'toId'),
  wH = s((e, t) => `${e}:${ap(t, 'test')}`, 'toTestId'),
  SH = s((e) => bw(e), 'storyNameFromExport');
function lp(e, t) {
  return Array.isArray(t) ? t.includes(e) : e.match(t);
}
s(lp, 'matches');
function tl(e, { includeStories: t, excludeStories: r }) {
  return e !== '__esModule' && (!t || lp(e, t)) && (!r || !lp(e, r));
}
s(tl, 'isExportStory');
var _H = s((...e) => {
  const t = e.reduce((r, n) => (n.startsWith('!') ? r.delete(n.slice(1)) : r.add(n), r), new Set());
  return Array.from(t);
}, 'combineTags');
function cp(e) {
  return Object.getOwnPropertySymbols(e).filter((t) =>
    Object.prototype.propertyIsEnumerable.call(e, t),
  );
}
s(cp, 'getSymbols');
function up(e) {
  return e == null
    ? e === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(e);
}
s(up, 'getTag');
var AH = '[object RegExp]',
  RH = '[object String]',
  xH = '[object Number]',
  PH = '[object Boolean]',
  Vb = '[object Arguments]',
  OH = '[object Symbol]',
  CH = '[object Date]',
  IH = '[object Map]',
  NH = '[object Set]',
  qH = '[object Array]',
  MH = '[object Function]',
  jH = '[object ArrayBuffer]',
  pu = '[object Object]',
  $H = '[object Error]',
  kH = '[object DataView]',
  DH = '[object Uint8Array]',
  LH = '[object Uint8ClampedArray]',
  FH = '[object Uint16Array]',
  BH = '[object Uint32Array]',
  JH = '[object BigUint64Array]',
  UH = '[object Int8Array]',
  VH = '[object Int16Array]',
  HH = '[object Int32Array]',
  zH = '[object BigInt64Array]',
  GH = '[object Float32Array]',
  WH = '[object Float64Array]';
function Kt(e) {
  if (!e || typeof e != 'object') return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null
    ? Object.prototype.toString.call(e) === '[object Object]'
    : !1;
}
s(Kt, 'isPlainObject');
function Io(e, t) {
  const r = {},
    n = Object.keys(e);
  for (let o = 0; o < n.length; o++) {
    const i = n[o],
      a = e[i];
    r[i] = t(a, i, e);
  }
  return r;
}
s(Io, 'mapValues');
function uI(e, t) {
  const r = {},
    n = Object.keys(e);
  for (let o = 0; o < n.length; o++) {
    const i = n[o],
      a = e[i];
    t(a, i) && (r[i] = a);
  }
  return r;
}
s(uI, 'pickBy');
var fu = Ge(Rv(), 1);
function dI(e, t) {
  return e === t || (Number.isNaN(e) && Number.isNaN(t));
}
s(dI, 'eq');
function pI(e, t, r) {
  return oo(e, t, void 0, void 0, void 0, void 0, r);
}
s(pI, 'isEqualWith');
function oo(e, t, r, n, o, i, a) {
  const c = a(e, t, r, n, o, i);
  if (c !== void 0) return c;
  if (typeof e == typeof t)
    switch (typeof e) {
      case 'bigint':
      case 'string':
      case 'boolean':
      case 'symbol':
      case 'undefined':
        return e === t;
      case 'number':
        return e === t || Object.is(e, t);
      case 'function':
        return e === t;
      case 'object':
        return po(e, t, i, a);
    }
  return po(e, t, i, a);
}
s(oo, 'isEqualWithImpl');
function po(e, t, r, n) {
  if (Object.is(e, t)) return !0;
  let o = up(e),
    i = up(t);
  if ((o === Vb && (o = pu), i === Vb && (i = pu), o !== i)) return !1;
  switch (o) {
    case RH:
      return e.toString() === t.toString();
    case xH: {
      const d = e.valueOf(),
        u = t.valueOf();
      return dI(d, u);
    }
    case PH:
    case CH:
    case OH:
      return Object.is(e.valueOf(), t.valueOf());
    case AH:
      return e.source === t.source && e.flags === t.flags;
    case MH:
      return e === t;
  }
  r = r ?? new Map();
  const a = r.get(e),
    c = r.get(t);
  if (a != null && c != null) return a === t;
  (r.set(e, t), r.set(t, e));
  try {
    switch (o) {
      case IH: {
        if (e.size !== t.size) return !1;
        for (const [d, u] of e.entries())
          if (!t.has(d) || !oo(u, t.get(d), d, e, t, r, n)) return !1;
        return !0;
      }
      case NH: {
        if (e.size !== t.size) return !1;
        const d = Array.from(e.values()),
          u = Array.from(t.values());
        for (let p = 0; p < d.length; p++) {
          const f = d[p],
            m = u.findIndex((h) => oo(f, h, void 0, e, t, r, n));
          if (m === -1) return !1;
          u.splice(m, 1);
        }
        return !0;
      }
      case qH:
      case DH:
      case LH:
      case FH:
      case BH:
      case JH:
      case UH:
      case VH:
      case HH:
      case zH:
      case GH:
      case WH: {
        if (
          (typeof Buffer < 'u' && Buffer.isBuffer(e) !== Buffer.isBuffer(t)) ||
          e.length !== t.length
        )
          return !1;
        for (let d = 0; d < e.length; d++) if (!oo(e[d], t[d], d, e, t, r, n)) return !1;
        return !0;
      }
      case jH:
        return e.byteLength !== t.byteLength ? !1 : po(new Uint8Array(e), new Uint8Array(t), r, n);
      case kH:
        return e.byteLength !== t.byteLength || e.byteOffset !== t.byteOffset
          ? !1
          : po(new Uint8Array(e), new Uint8Array(t), r, n);
      case $H:
        return e.name === t.name && e.message === t.message;
      case pu: {
        if (!(po(e.constructor, t.constructor, r, n) || (Kt(e) && Kt(t)))) return !1;
        const u = [...Object.keys(e), ...cp(e)],
          p = [...Object.keys(t), ...cp(t)];
        if (u.length !== p.length) return !1;
        for (let f = 0; f < u.length; f++) {
          const m = u[f],
            h = e[m];
          if (!Object.hasOwn(t, m)) return !1;
          const g = t[m];
          if (!oo(h, g, m, e, t, r, n)) return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    (r.delete(e), r.delete(t));
  }
}
s(po, 'areObjectsEqual');
function fI() {}
s(fI, 'noop');
function mI(e, t) {
  return pI(e, t, fI);
}
s(mI, 'isEqual');
var fn = Symbol('incompatible'),
  dp = s((e, t) => {
    const r = t.type;
    if (e == null || !r || t.mapping) return e;
    switch (r.name) {
      case 'string':
        return String(e);
      case 'enum':
        return e;
      case 'number':
        return Number(e);
      case 'boolean':
        return String(e) === 'true';
      case 'array':
        return !r.value || !Array.isArray(e)
          ? fn
          : e.reduce((n, o, i) => {
              const a = dp(o, { type: r.value });
              return (a !== fn && (n[i] = a), n);
            }, new Array(e.length));
      case 'object':
        return typeof e == 'string' || typeof e == 'number'
          ? e
          : !r.value || typeof e != 'object'
            ? fn
            : Object.entries(e).reduce((n, [o, i]) => {
                const a = dp(i, { type: r.value[o] });
                return a === fn ? n : Object.assign(n, { [o]: a });
              }, {});
      case 'other': {
        const n = typeof e == 'string' || typeof e == 'number' || typeof e == 'boolean';
        return r.value === 'ReactNode' && n ? e : fn;
      }
      default:
        return fn;
    }
  }, 'map'),
  KH = s(
    (e, t) =>
      Object.entries(e).reduce((r, [n, o]) => {
        if (!t[n]) return r;
        const i = dp(o, t[n]);
        return i === fn ? r : Object.assign(r, { [n]: i });
      }, {}),
    'mapArgsToTypes',
  ),
  rl = s(
    (e, t) =>
      Array.isArray(e) && Array.isArray(t)
        ? t.reduce((r, n, o) => ((r[o] = rl(e[o], t[o])), r), [...e]).filter((r) => r !== void 0)
        : !Kt(e) || !Kt(t)
          ? t
          : Object.keys({ ...e, ...t }).reduce((r, n) => {
              if (n in t) {
                const o = rl(e[n], t[n]);
                o !== void 0 && (r[n] = o);
              } else r[n] = e[n];
              return r;
            }, {}),
    'combineArgs',
  ),
  YH = s(
    (e, t) =>
      Object.entries(t).reduce((r, [n, { options: o }]) => {
        function i() {
          return (n in e && (r[n] = e[n]), r);
        }
        if ((s(i, 'allowArg'), !o)) return i();
        if (!Array.isArray(o))
          return (
            Ve.error(ve`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `),
            i()
          );
        if (o.some((f) => f && ['object', 'function'].includes(typeof f)))
          return (
            Ve.error(ve`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `),
            i()
          );
        const a = Array.isArray(e[n]),
          c = a && e[n].findIndex((f) => !o.includes(f)),
          d = a && c === -1;
        if (e[n] === void 0 || o.includes(e[n]) || d) return i();
        const u = a ? `${n}[${c}]` : n,
          p = o.map((f) => (typeof f == 'string' ? `'${f}'` : String(f))).join(', ');
        return (Ve.warn(`Received illegal value for '${u}'. Supported options: ${p}`), r);
      }, {}),
    'validateOptions',
  ),
  Us = Symbol('Deeply equal'),
  nl = s((e, t) => {
    if (typeof e != typeof t) return t;
    if (mI(e, t)) return Us;
    if (Array.isArray(e) && Array.isArray(t)) {
      const r = t.reduce((n, o, i) => {
        const a = nl(e[i], o);
        return (a !== Us && (n[i] = a), n);
      }, new Array(t.length));
      return t.length >= e.length ? r : r.concat(new Array(e.length - t.length).fill(void 0));
    }
    return Kt(e) && Kt(t)
      ? Object.keys({ ...e, ...t }).reduce((r, n) => {
          const o = nl(e?.[n], t?.[n]);
          return o === Us ? r : Object.assign(r, { [n]: o });
        }, {})
      : t;
  }, 'deepDiff'),
  yI = 'UNTARGETED';
function hI({ args: e, argTypes: t }) {
  const r = {};
  return (
    Object.entries(e).forEach(([n, o]) => {
      const { target: i = yI } = t[n] || {};
      ((r[i] = r[i] || {}), (r[i][n] = o));
    }),
    r
  );
}
s(hI, 'groupArgsByTarget');
function gI(e) {
  return (Object.keys(e).forEach((t) => e[t] === void 0 && delete e[t]), e);
}
s(gI, 'deleteUndefined');
var bI = class {
  constructor() {
    ((this.initialArgsByStoryId = {}), (this.argsByStoryId = {}));
  }
  get(t) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    return this.argsByStoryId[t];
  }
  setInitial(t) {
    if (!this.initialArgsByStoryId[t.id])
      ((this.initialArgsByStoryId[t.id] = t.initialArgs),
        (this.argsByStoryId[t.id] = t.initialArgs));
    else if (this.initialArgsByStoryId[t.id] !== t.initialArgs) {
      const r = nl(this.initialArgsByStoryId[t.id], this.argsByStoryId[t.id]);
      ((this.initialArgsByStoryId[t.id] = t.initialArgs),
        (this.argsByStoryId[t.id] = t.initialArgs),
        r !== Us && this.updateFromDelta(t, r));
    }
  }
  updateFromDelta(t, r) {
    const n = YH(r, t.argTypes);
    this.argsByStoryId[t.id] = rl(this.argsByStoryId[t.id], n);
  }
  updateFromPersisted(t, r) {
    const n = KH(r, t.argTypes);
    return this.updateFromDelta(t, n);
  }
  update(t, r) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    this.argsByStoryId[t] = gI({ ...this.argsByStoryId[t], ...r });
  }
};
s(bI, 'ArgsStore');
var XH = bI,
  vI = s(
    (e = {}) =>
      Object.entries(e).reduce(
        (t, [r, { defaultValue: n }]) => (typeof n < 'u' && (t[r] = n), t),
        {},
      ),
    'getValuesFromArgTypes',
  ),
  TI = class {
    constructor({ globals: t = {}, globalTypes: r = {} }) {
      this.set({ globals: t, globalTypes: r });
    }
    set({ globals: t = {}, globalTypes: r = {} }) {
      const n = this.initialGlobals && nl(this.initialGlobals, this.globals);
      this.allowedGlobalNames = new Set([...Object.keys(t), ...Object.keys(r)]);
      const o = vI(r);
      ((this.initialGlobals = { ...o, ...t }),
        (this.globals = this.initialGlobals),
        n && n !== Us && this.updateFromPersisted(n));
    }
    filterAllowedGlobals(t) {
      return Object.entries(t).reduce(
        (r, [n, o]) => (
          this.allowedGlobalNames.has(n)
            ? (r[n] = o)
            : ke.warn(
                `Attempted to set a global (${n}) that is not defined in initial globals or globalTypes`,
              ),
          r
        ),
        {},
      );
    }
    updateFromPersisted(t) {
      const r = this.filterAllowedGlobals(t);
      this.globals = { ...this.globals, ...r };
    }
    get() {
      return this.globals;
    }
    update(t) {
      this.globals = { ...this.globals, ...this.filterAllowedGlobals(t) };
      for (const r in t) t[r] === void 0 && (this.globals[r] = this.initialGlobals[r]);
    }
  };
s(TI, 'GlobalsStore');
var QH = TI,
  ZH = Ge(Rv(), 1),
  e3 = (0, ZH.default)(1)((e) =>
    Object.values(e).reduce((t, r) => ((t[r.importPath] = t[r.importPath] || r), t), {}),
  ),
  EI = class {
    constructor({ entries: t } = { v: 5, entries: {} }) {
      this.entries = t;
    }
    entryFromSpecifier(t) {
      const r = Object.values(this.entries);
      if (t === '*') return r[0];
      if (typeof t == 'string')
        return this.entries[t] ? this.entries[t] : r.find((i) => i.id.startsWith(t));
      const { name: n, title: o } = t;
      return r.find((i) => i.name === n && i.title === o);
    }
    storyIdToEntry(t) {
      const r = this.entries[t];
      if (!r) throw new _E({ storyId: t });
      return r;
    }
    importPathToEntry(t) {
      return e3(this.entries)[t];
    }
  };
s(EI, 'StoryIndexStore');
var t3 = EI,
  r3 = s((e) => (typeof e == 'string' ? { name: e } : e), 'normalizeType'),
  n3 = s((e) => (typeof e == 'string' ? { type: e } : e), 'normalizeControl'),
  o3 = s((e, t) => {
    const { type: r, control: n, ...o } = e,
      i = { name: t, ...o };
    return (
      r && (i.type = r3(r)),
      n ? (i.control = n3(n)) : n === !1 && (i.control = { disable: !0 }),
      i
    );
  }, 'normalizeInputType'),
  ol = s((e) => Io(e, o3), 'normalizeInputTypes'),
  Ne = s((e) => (Array.isArray(e) ? e : e ? [e] : []), 'normalizeArrays'),
  s3 = ve`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function fo(e, t, r) {
  const n = t,
    o = typeof t == 'function' ? t : null,
    { story: i } = n;
  i && (ke.debug('deprecated story', i), Jp(s3));
  const a = SH(e),
    c = (typeof n != 'function' && n.name) || n.storyName || i?.name || a,
    d = [...Ne(n.decorators), ...Ne(i?.decorators)],
    u = { ...i?.parameters, ...n.parameters },
    p = { ...i?.args, ...n.args },
    f = { ...i?.argTypes, ...n.argTypes },
    m = [...Ne(n.loaders), ...Ne(i?.loaders)],
    h = [...Ne(n.beforeEach), ...Ne(i?.beforeEach)],
    g = [...Ne(n.afterEach), ...Ne(i?.afterEach)],
    { render: v, play: E, tags: b = [], globals: S = {} } = n,
    R = u.__id || EH(r.id, a);
  return {
    moduleExport: t,
    id: R,
    name: c,
    tags: b,
    decorators: d,
    parameters: u,
    args: p,
    argTypes: ol(f),
    loaders: m,
    beforeEach: h,
    afterEach: g,
    globals: S,
    ...(v && { render: v }),
    ...(o && { userStoryFn: o }),
    ...(E && { play: E }),
  };
}
s(fo, 'normalizeStory');
function sl(e, t = e.title, r) {
  const { id: n, argTypes: o } = e;
  return {
    id: cI(n || t),
    ...e,
    title: t,
    ...(o && { argTypes: ol(o) }),
    parameters: { fileName: r, ...e.parameters },
  };
}
s(sl, 'normalizeComponentAnnotations');
var i3 = s((e) => {
    const { globals: t, globalTypes: r } = e;
    (t || r) &&
      ke.error(
        'Global args/argTypes can only be set globally',
        JSON.stringify({ globals: t, globalTypes: r }),
      );
  }, 'checkGlobals'),
  a3 = s((e) => {
    const { options: t } = e;
    t?.storySort && ke.error('The storySort option parameter can only be set globally');
  }, 'checkStorySort'),
  Hi = s((e) => {
    e && (i3(e), a3(e));
  }, 'checkDisallowedParameters');
function wI(e, t, r) {
  const { default: n, __namedExportsOrder: o, ...i } = e,
    a = Object.values(i)[0];
  if (jc(a)) {
    const u = sl(a.meta.input, r, t);
    Hi(u.parameters);
    const p = { meta: u, stories: {}, moduleExports: e };
    return (
      Object.keys(i).forEach((f) => {
        if (tl(f, u)) {
          const m = i[f],
            h = fo(f, m.input, u);
          (Hi(h.parameters),
            (p.stories[h.id] = h),
            lI(m).forEach((g) => {
              var b;
              const v = g.input.name,
                E = wH(h.id, v);
              ((b = g.input).parameters ?? (b.parameters = {}),
                (g.input.parameters.__id = E),
                (p.stories[E] = fo(v, g.input, u)));
            }));
        }
      }),
      (p.projectAnnotations = a.meta.preview.composed),
      p
    );
  }
  const c = sl(n, r, t);
  Hi(c.parameters);
  const d = { meta: c, stories: {}, moduleExports: e };
  return (
    Object.keys(i).forEach((u) => {
      if (tl(u, c)) {
        const p = fo(u, i[u], c);
        (Hi(p.parameters), (d.stories[p.id] = p));
      }
    }),
    d
  );
}
s(wI, 'processCSFFile');
function Ph(e, t, r) {
  const n = r(e);
  return (o) => t(n, o);
}
s(Ph, 'decorateStory');
function Oh({
  componentId: e,
  title: t,
  kind: r,
  id: n,
  name: o,
  story: i,
  parameters: a,
  initialArgs: c,
  argTypes: d,
  ...u
} = {}) {
  return u;
}
s(Oh, 'sanitizeStoryContextUpdate');
function Ch(e, t) {
  const r = {},
    n = s(
      (i) => (a) => {
        if (!r.value) throw new Error('Decorated function called without init');
        return ((r.value = { ...r.value, ...Oh(a) }), i(r.value));
      },
      'bindWithContext',
    ),
    o = t.reduce((i, a) => Ph(i, a, n), e);
  return (i) => ((r.value = i), o(i));
}
s(Ch, 'defaultDecorateStory');
var $n = s((...e) => {
  const t = {},
    r = e.filter(Boolean),
    n = r.reduce(
      (o, i) => (
        Object.entries(i).forEach(([a, c]) => {
          const d = o[a];
          Array.isArray(c) || typeof d > 'u'
            ? (o[a] = c)
            : Kt(c) && Kt(d)
              ? (t[a] = !0)
              : typeof c < 'u' && (o[a] = c);
        }),
        o
      ),
      {},
    );
  return (
    Object.keys(t).forEach((o) => {
      const i = r
        .filter(Boolean)
        .map((a) => a[o])
        .filter((a) => typeof a < 'u');
      i.every((a) => Kt(a)) ? (n[o] = $n(...i)) : (n[o] = i[i.length - 1]);
    }),
    n
  );
}, 'combineParameters');
function $c(e, t, r) {
  const { moduleExport: n, id: o, name: i } = e || {},
    a = Nh(e, t, r),
    c = s(async (P) => {
      const A = {};
      for (const w of [Ne(r.loaders), Ne(t.loaders), Ne(e.loaders)]) {
        if (P.abortSignal.aborted) return A;
        const _ = await Promise.all(w.map(($) => $(P)));
        Object.assign(A, ..._);
      }
      return A;
    }, 'applyLoaders'),
    d = s(async (P) => {
      const A = new Array();
      for (const w of [...Ne(r.beforeEach), ...Ne(t.beforeEach), ...Ne(e.beforeEach)]) {
        if (P.abortSignal.aborted) return A;
        const _ = await w(P);
        _ && A.push(_);
      }
      return A;
    }, 'applyBeforeEach'),
    u = s(async (P) => {
      const A = [...Ne(r.afterEach), ...Ne(t.afterEach), ...Ne(e.afterEach)].reverse();
      for (const w of A) {
        if (P.abortSignal.aborted) return;
        await w(P);
      }
    }, 'applyAfterEach'),
    p = s((P) => P.originalStoryFn(P.args, P), 'undecoratedStoryFn'),
    { applyDecorators: f = Ch, runStep: m } = r,
    h = [...Ne(e?.decorators), ...Ne(t?.decorators), ...Ne(r?.decorators)],
    g = e?.userStoryFn || e?.render || t.render || r.render,
    v = lw(f)(p, h),
    E = s((P) => v(P), 'unboundStoryFn'),
    b = e?.play ?? t?.play,
    S = Tw(b);
  if (!g && !S) throw new zE({ id: o });
  const R = s((P) => async () => (await P.renderToCanvas(), P.canvas), 'defaultMount'),
    I = e.mount ?? t.mount ?? r.mount ?? R,
    q = r.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a,
    moduleExport: n,
    id: o,
    name: i,
    story: i,
    originalStoryFn: g,
    undecoratedStoryFn: p,
    unboundStoryFn: E,
    applyLoaders: c,
    applyBeforeEach: d,
    applyAfterEach: u,
    playFunction: b,
    runStep: m,
    mount: I,
    testingLibraryRender: q,
    renderToCanvas: r.renderToCanvas,
    usesMount: S,
  };
}
s($c, 'prepareStory');
function Ih(e, t, r) {
  return { ...Nh(void 0, e, t), moduleExport: r };
}
s(Ih, 'prepareMeta');
function Nh(e, t, r) {
  const n = ['dev', 'test'],
    o = te.DOCS_OPTIONS?.autodocs === !0 ? ['autodocs'] : [],
    i = e?.tags?.includes('test-fn') ? ['!autodocs'] : [],
    a = _H(...n, ...o, ...(r.tags ?? []), ...(t.tags ?? []), ...i, ...(e?.tags ?? [])),
    c = $n(r.parameters, t.parameters, e?.parameters),
    { argTypesEnhancers: d = [], argsEnhancers: u = [] } = r,
    p = $n(r.argTypes, t.argTypes, e?.argTypes);
  if (e) {
    const S = e?.userStoryFn || e?.render || t.render || r.render;
    c.__isArgsStory = S && S.length > 0;
  }
  const f = { ...r.args, ...t.args, ...e?.args },
    m = { ...t.globals, ...e?.globals },
    h = {
      componentId: t.id,
      title: t.title,
      kind: t.title,
      id: e?.id || t.id,
      name: e?.name || '__meta',
      story: e?.name || '__meta',
      component: t.component,
      subcomponents: t.subcomponents,
      tags: a,
      parameters: c,
      initialArgs: f,
      argTypes: p,
      storyGlobals: m,
    };
  h.argTypes = d.reduce((S, R) => R({ ...h, argTypes: S }), h.argTypes);
  const g = { ...f };
  h.initialArgs = [...u].reduce((S, R) => ({ ...S, ...R({ ...h, initialArgs: S }) }), g);
  const { name: v, story: E, ...b } = h;
  return b;
}
s(Nh, 'preparePartialAnnotations');
function qh(e) {
  const { args: t } = e;
  let r = { ...e, allArgs: void 0, argsByTarget: void 0 };
  if (te.FEATURES?.argTypeTargetsV7) {
    const i = hI(e);
    r = { ...e, allArgs: e.args, argsByTarget: i, args: i[yI] || {} };
  }
  const n = Object.entries(r.args).reduce((i, [a, c]) => {
      if (!r.argTypes[a]?.mapping) return ((i[a] = c), i);
      const d = s((u) => {
        const p = r.argTypes[a].mapping;
        return p && u in p ? p[u] : u;
      }, 'mappingFn');
      return ((i[a] = Array.isArray(c) ? c.map(d) : d(c)), i);
    }, {}),
    o = Object.entries(n).reduce((i, [a, c]) => {
      const d = r.argTypes[a] || {};
      return (hL(d, n, r.globals) && (i[a] = c), i);
    }, {});
  return { ...r, unmappedArgs: t, args: o };
}
s(qh, 'prepareContext');
var pp = s((e, t, r) => {
    const n = typeof e;
    switch (n) {
      case 'boolean':
      case 'string':
      case 'number':
      case 'function':
      case 'symbol':
        return { name: n };
    }
    return e
      ? r.has(e)
        ? (ke.warn(ve`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `),
          { name: 'other', value: 'cyclic object' })
        : (r.add(e),
          Array.isArray(e)
            ? {
                name: 'array',
                value: e.length > 0 ? pp(e[0], t, new Set(r)) : { name: 'other', value: 'unknown' },
              }
            : { name: 'object', value: Io(e, (i) => pp(i, t, new Set(r))) })
      : { name: 'object', value: {} };
  }, 'inferType'),
  SI = s((e) => {
    const { id: t, argTypes: r = {}, initialArgs: n = {} } = e,
      o = Io(n, (a, c) => ({ name: c, type: pp(a, `${t}.${c}`, new Set()) })),
      i = Io(r, (a, c) => ({ name: c }));
    return $n(o, i, r);
  }, 'inferArgTypes');
SI.secondPass = !0;
var Hb = s((e, t) => (Array.isArray(t) ? t.includes(e) : e.match(t)), 'matches'),
  _I = s(
    (e, t, r) =>
      !t && !r
        ? e
        : e &&
          uI(e, (n, o) => {
            const i = n.name || o.toString();
            return !!(!t || Hb(i, t)) && (!r || !Hb(i, r));
          }),
    'filterArgTypes',
  ),
  l3 = s((e, t, r) => {
    const { type: n, options: o } = e;
    if (n) {
      if (r.color && r.color.test(t)) {
        const i = n.name;
        if (i === 'string') return { control: { type: 'color' } };
        i !== 'enum' &&
          ke.warn(
            `Addon controls: Control of type color only supports string, received "${i}" instead`,
          );
      }
      if (r.date && r.date.test(t)) return { control: { type: 'date' } };
      switch (n.name) {
        case 'array':
          return { control: { type: 'object' } };
        case 'boolean':
          return { control: { type: 'boolean' } };
        case 'string':
          return { control: { type: 'text' } };
        case 'number':
          return { control: { type: 'number' } };
        case 'enum': {
          const { value: i } = n;
          return { control: { type: i?.length <= 5 ? 'radio' : 'select' }, options: i };
        }
        case 'function':
        case 'symbol':
          return null;
        default:
          return { control: { type: o ? 'select' : 'object' } };
      }
    }
  }, 'inferControl'),
  Mh = s((e) => {
    const {
      argTypes: t,
      parameters: {
        __isArgsStory: r,
        controls: { include: n = null, exclude: o = null, matchers: i = {} } = {},
      },
    } = e;
    if (!r) return t;
    const a = _I(t, n, o),
      c = Io(a, (d, u) => d?.type && l3(d, u.toString(), i));
    return $n(c, a);
  }, 'inferControls');
Mh.secondPass = !0;
function di({
  argTypes: e,
  globalTypes: t,
  argTypesEnhancers: r,
  decorators: n,
  loaders: o,
  beforeEach: i,
  afterEach: a,
  initialGlobals: c,
  ...d
}) {
  return {
    ...(e && { argTypes: ol(e) }),
    ...(t && { globalTypes: ol(t) }),
    decorators: Ne(n),
    loaders: Ne(o),
    beforeEach: Ne(i),
    afterEach: Ne(a),
    argTypesEnhancers: [...(r || []), SI, Mh],
    initialGlobals: c,
    ...d,
  };
}
s(di, 'normalizeProjectAnnotations');
var c3 = s(
  (e) => async () => {
    const t = [];
    for (const r of e) {
      const n = await r();
      n && t.unshift(n);
    }
    return async () => {
      for (const r of t) await r();
    };
  },
  'composeBeforeAllHooks',
);
function jh(e) {
  return async (t, r, n) => {
    await e.reduceRight(
      (i, a) => async () => a(t, i, n),
      async () => r(n),
    )();
  };
}
s(jh, 'composeStepRunners');
function No(e, t) {
  return e.map((r) => r.default?.[t] ?? r[t]).filter(Boolean);
}
s(No, 'getField');
function Er(e, t, r = {}) {
  return No(e, t).reduce((n, o) => {
    const i = Ne(o);
    return r.reverseFileOrder ? [...i, ...n] : [...n, ...i];
  }, []);
}
s(Er, 'getArrayField');
function Ns(e, t) {
  return Object.assign({}, ...No(e, t));
}
s(Ns, 'getObjectField');
function Xn(e, t) {
  return No(e, t).pop();
}
s(Xn, 'getSingletonField');
function kn(e) {
  const t = Er(e, 'argTypesEnhancers'),
    r = No(e, 'runStep'),
    n = Er(e, 'beforeAll');
  return {
    parameters: $n(...No(e, 'parameters')),
    decorators: Er(e, 'decorators', {
      reverseFileOrder: !(te.FEATURES?.legacyDecoratorFileOrder ?? !1),
    }),
    args: Ns(e, 'args'),
    argsEnhancers: Er(e, 'argsEnhancers'),
    argTypes: Ns(e, 'argTypes'),
    argTypesEnhancers: [...t.filter((o) => !o.secondPass), ...t.filter((o) => o.secondPass)],
    initialGlobals: Ns(e, 'initialGlobals'),
    globalTypes: Ns(e, 'globalTypes'),
    loaders: Er(e, 'loaders'),
    beforeAll: c3(n),
    beforeEach: Er(e, 'beforeEach'),
    afterEach: Er(e, 'afterEach'),
    render: Xn(e, 'render'),
    renderToCanvas: Xn(e, 'renderToCanvas'),
    applyDecorators: Xn(e, 'applyDecorators'),
    runStep: jh(r),
    tags: Er(e, 'tags'),
    mount: Xn(e, 'mount'),
    testingLibraryRender: Xn(e, 'testingLibraryRender'),
  };
}
s(kn, 'composeConfigs');
var u3 = 5e3;
function $h() {
  try {
    return (
      !!globalThis.__vitest_browser__ ||
      !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return !1;
  }
}
s($h, 'isTestEnvironment');
function kc(e = !0) {
  if (!('document' in globalThis && 'createElement' in globalThis.document)) return () => {};
  const t = document.createElement('style');
  ((t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`),
    document.head.appendChild(t));
  const r = document.createElement('style');
  return (
    (r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? 'reverse' : 'normal'} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`),
    document.head.appendChild(r),
    document.body.clientHeight,
    document.head.removeChild(t),
    () => {
      r.parentNode?.removeChild(r);
    }
  );
}
s(kc, 'pauseAnimations');
async function Dc(e) {
  if (
    !(
      'document' in globalThis &&
      'getAnimations' in globalThis.document &&
      'querySelectorAll' in globalThis.document
    )
  )
    return;
  let t = !1;
  await Promise.race([
    new Promise((r) => {
      setTimeout(() => {
        const n = [globalThis.document, ...kh(globalThis.document)],
          o = s(async () => {
            if (t || e?.aborted) return;
            const i = n
              .flatMap((a) => a?.getAnimations?.() || [])
              .filter((a) => a.playState === 'running' && !AI(a));
            i.length > 0 && (await Promise.all(i.map((a) => a.finished)), await o());
          }, 'checkAnimationsFinished');
        o().then(r);
      }, 100);
    }),
    new Promise((r) =>
      setTimeout(() => {
        ((t = !0), r(void 0));
      }, u3),
    ),
  ]);
}
s(Dc, 'waitForAnimations');
function kh(e) {
  return [e, ...e.querySelectorAll('*')].reduce(
    (t, r) => ('shadowRoot' in r && r.shadowRoot && t.push(r.shadowRoot, ...kh(r.shadowRoot)), t),
    [],
  );
}
s(kh, 'getShadowRoots');
function AI(e) {
  if (e instanceof CSSAnimation && e.effect instanceof KeyframeEffect && e.effect.target) {
    const t = getComputedStyle(e.effect.target, e.effect.pseudoElement),
      r = t.animationName?.split(', ').indexOf(e.animationName);
    return t.animationIterationCount.split(', ')[r] === 'infinite';
  }
  return !1;
}
s(AI, 'isInfiniteAnimation');
var RI = class {
  constructor() {
    this.reports = [];
  }
  async addReport(t) {
    this.reports.push(t);
  }
};
s(RI, 'ReporterAPI');
var Dh = RI;
function Lh(e, t, r) {
  return jc(e)
    ? { story: e.input, meta: e.meta.input, preview: e.meta.preview.composed }
    : { story: e, meta: aI(t) ? t.input : t, preview: r };
}
s(Lh, 'getCsfFactoryAnnotations');
function xI(e) {
  globalThis.defaultProjectAnnotations = e;
}
s(xI, 'setDefaultProjectAnnotations');
var d3 = 'ComposedStory',
  p3 = 'Unnamed Story';
function PI(e) {
  return e ? kn([e]) : {};
}
s(PI, 'extractAnnotation');
function OI(e) {
  const t = Array.isArray(e) ? e : [e];
  return (
    (globalThis.globalProjectAnnotations = kn([
      ...xh(),
      globalThis.defaultProjectAnnotations ?? {},
      kn(t.map(PI)),
    ])),
    globalThis.globalProjectAnnotations ?? {}
  );
}
s(OI, 'setProjectAnnotations');
var Br = [];
function Fh(e, t, r, n, o) {
  if (e === void 0) throw new Error('Expected a story but received undefined.');
  t.title = t.title ?? d3;
  const i = sl(t),
    a = o || e.storyName || e.story?.name || e.name || p3,
    c = fo(a, e, i),
    d = di(kn([n ?? globalThis.globalProjectAnnotations ?? {}, r ?? {}])),
    u = $c(c, i, d),
    f = { ...vI(d.globalTypes), ...d.initialGlobals, ...u.storyGlobals },
    m = new Dh(),
    h = s(() => {
      const R = qh({
        hooks: new nf(),
        globals: f,
        args: { ...u.initialArgs },
        viewMode: 'story',
        reporting: m,
        loaded: {},
        abortSignal: new AbortController().signal,
        step: s((I, q) => u.runStep(I, q, R), 'step'),
        canvasElement: null,
        canvas: {},
        userEvent: {},
        globalTypes: d.globalTypes,
        ...u,
        context: null,
        mount: null,
      });
      return (
        (R.parameters.__isPortableStory = !0),
        (R.context = R),
        u.renderToCanvas &&
          (R.renderToCanvas = async () => {
            const I = await u.renderToCanvas?.(
              {
                componentId: u.componentId,
                title: u.title,
                id: u.id,
                name: u.name,
                tags: u.tags,
                showMain: s(() => {}, 'showMain'),
                showError: s((q) => {
                  throw new Error(`${q.title}
${q.description}`);
                }, 'showError'),
                showException: s((q) => {
                  throw q;
                }, 'showException'),
                forceRemount: !0,
                storyContext: R,
                storyFn: s(() => u.unboundStoryFn(R), 'storyFn'),
                unboundStoryFn: u.unboundStoryFn,
              },
              R.canvasElement,
            );
            I && Br.push(I);
          }),
        (R.mount = u.mount(R)),
        R
      );
    }, 'initializeContext');
  let g;
  const v = s(async (R) => {
      const I = h();
      return (
        I.canvasElement ?? (I.canvasElement = globalThis?.document?.body),
        g && (I.loaded = g.loaded),
        Object.assign(I, R),
        u.playFunction(I)
      );
    }, 'play'),
    E = s((R) => {
      const I = h();
      return (Object.assign(I, R), NI(u, I));
    }, 'run'),
    b = u.playFunction ? v : void 0;
  return Object.assign(
    s(function (I) {
      const q = h();
      return (
        g && (q.loaded = g.loaded),
        (q.args = { ...q.initialArgs, ...I }),
        u.unboundStoryFn(q)
      );
    }, 'storyFn'),
    {
      id: u.id,
      storyName: a,
      load: s(async () => {
        for (const I of [...Br].reverse()) await I();
        Br.length = 0;
        const R = h();
        ((R.loaded = await u.applyLoaders(R)),
          Br.push(...(await u.applyBeforeEach(R)).filter(Boolean)),
          (g = R));
      }, 'load'),
      globals: f,
      args: u.initialArgs,
      parameters: u.parameters,
      argTypes: u.argTypes,
      play: b,
      run: E,
      reporting: m,
      tags: u.tags,
    },
  );
}
s(Fh, 'composeStory');
var f3 = s((e, t, r, n) => Fh(e, t, r, {}, n), 'defaultComposeStory');
function CI(e, t, r = f3) {
  const { default: n, __esModule: o, __namedExportsOrder: i, ...a } = e;
  let c = n;
  return Object.entries(a).reduce((u, [p, f]) => {
    const { story: m, meta: h } = Lh(f);
    return (!c && h && (c = h), tl(p, c) ? Object.assign(u, { [p]: r(m, c, t, p) }) : u);
  }, {});
}
s(CI, 'composeStories');
function II(e) {
  return e.extend({
    mount: s(async ({ mount: t, page: r }, n) => {
      await n(async (o, ...i) => {
        if (!('__pw_type' in o) || ('__pw_type' in o && o.__pw_type !== 'jsx'))
          throw new Error(ve`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        const { props: a, ...c } = o;
        await r.evaluate(async (u) => {
          const p = await globalThis.__pwUnwrapObject?.(u);
          return ('__pw_type' in p ? p.type : p)?.load?.();
        }, c);
        const d = await t(o, ...i);
        return (
          await r.evaluate(async (u) => {
            const p = await globalThis.__pwUnwrapObject?.(u),
              f = '__pw_type' in p ? p.type : p,
              m = document.querySelector('#root');
            return f?.play?.({ canvasElement: m });
          }, c),
          d
        );
      });
    }, 'mount'),
  });
}
s(II, 'createPlaywrightTest');
async function NI(e, t) {
  for (const i of [...Br].reverse()) await i();
  if (((Br.length = 0), !t.canvasElement)) {
    const i = document.createElement('div');
    (globalThis?.document?.body?.appendChild(i),
      (t.canvasElement = i),
      Br.push(() => {
        globalThis?.document?.body?.contains(i) && globalThis?.document?.body?.removeChild(i);
      }));
  }
  if (((t.loaded = await e.applyLoaders(t)), t.abortSignal.aborted)) return;
  Br.push(...(await e.applyBeforeEach(t)).filter(Boolean));
  const r = e.playFunction,
    n = e.usesMount;
  if ((n || (await t.mount()), t.abortSignal.aborted)) return;
  r &&
    (n ||
      (t.mount = async () => {
        throw new tf({ playFunction: r.toString() });
      }),
    await r(t));
  let o;
  ($h() ? (o = kc()) : await Dc(t.abortSignal), await e.applyAfterEach(t), await o?.());
}
s(NI, 'runStory');
var zb = 1e3,
  m3 = 1e4,
  qI = class {
    constructor(t, r, n) {
      ((this.importFn = r),
        (this.storyIndex = new t3(t)),
        (this.projectAnnotations = di(kn([...xh(), n]))));
      const { initialGlobals: o, globalTypes: i } = this.projectAnnotations;
      ((this.args = new XH()),
        (this.userGlobals = new QH({ globals: o, globalTypes: i })),
        (this.hooks = {}),
        (this.cleanupCallbacks = {}),
        (this.processCSFFileWithCache = (0, fu.default)(zb)(wI)),
        (this.prepareMetaWithCache = (0, fu.default)(zb)(Ih)),
        (this.prepareStoryWithCache = (0, fu.default)(m3)($c)));
    }
    setProjectAnnotations(t) {
      this.projectAnnotations = di(t);
      const { initialGlobals: r, globalTypes: n } = t;
      this.userGlobals.set({ globals: r, globalTypes: n });
    }
    async onStoriesChanged({ importFn: t, storyIndex: r }) {
      (t && (this.importFn = t),
        r && (this.storyIndex.entries = r.entries),
        this.cachedCSFFiles && (await this.cacheAllCSFFiles()));
    }
    async storyIdToEntry(t) {
      return this.storyIndex.storyIdToEntry(t);
    }
    async loadCSFFileByStoryId(t) {
      const { importPath: r, title: n } = this.storyIndex.storyIdToEntry(t),
        o = await this.importFn(r);
      return this.processCSFFileWithCache(o, r, n);
    }
    async loadAllCSFFiles() {
      const t = {};
      return (
        Object.entries(this.storyIndex.entries).forEach(([n, { importPath: o }]) => {
          t[o] = n;
        }),
        (
          await Promise.all(
            Object.entries(t).map(async ([n, o]) => ({
              importPath: n,
              csfFile: await this.loadCSFFileByStoryId(o),
            })),
          )
        ).reduce((n, { importPath: o, csfFile: i }) => ((n[o] = i), n), {})
      );
    }
    async cacheAllCSFFiles() {
      this.cachedCSFFiles = await this.loadAllCSFFiles();
    }
    preparedMetaFromCSFFile({ csfFile: t }) {
      const r = t.meta;
      return this.prepareMetaWithCache(r, this.projectAnnotations, t.moduleExports.default);
    }
    async loadStory({ storyId: t }) {
      const r = await this.loadCSFFileByStoryId(t);
      return this.storyFromCSFFile({ storyId: t, csfFile: r });
    }
    storyFromCSFFile({ storyId: t, csfFile: r }) {
      const n = r.stories[t];
      if (!n) throw new BE({ storyId: t });
      const o = r.meta,
        i = this.prepareStoryWithCache(n, o, r.projectAnnotations ?? this.projectAnnotations);
      return (this.args.setInitial(i), (this.hooks[i.id] = this.hooks[i.id] || new nf()), i);
    }
    componentStoriesFromCSFFile({ csfFile: t }) {
      return Object.keys(this.storyIndex.entries)
        .filter((r) => !!t.stories[r])
        .map((r) => this.storyFromCSFFile({ storyId: r, csfFile: t }));
    }
    async loadEntry(t) {
      const r = await this.storyIdToEntry(t),
        n = r.type === 'docs' ? r.storiesImports : [],
        [o, ...i] = await Promise.all([
          this.importFn(r.importPath),
          ...n.map((a) => {
            const c = this.storyIndex.importPathToEntry(a);
            return this.loadCSFFileByStoryId(c.id);
          }),
        ]);
      return { entryExports: o, csfFiles: i };
    }
    getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
      const n = this.userGlobals.get(),
        { initialGlobals: o } = this.userGlobals,
        i = new Dh();
      return qh({
        ...t,
        args: r ? t.initialArgs : this.args.get(t.id),
        initialGlobals: o,
        globalTypes: this.projectAnnotations.globalTypes,
        userGlobals: n,
        reporting: i,
        globals: { ...n, ...t.storyGlobals },
        hooks: this.hooks[t.id],
      });
    }
    addCleanupCallbacks(t, ...r) {
      this.cleanupCallbacks[t.id] = (this.cleanupCallbacks[t.id] || []).concat(r);
    }
    async cleanupStory(t) {
      this.hooks[t.id].clean();
      const r = this.cleanupCallbacks[t.id];
      if (r) for (const n of [...r].reverse()) await n();
      delete this.cleanupCallbacks[t.id];
    }
    extract(t = { includeDocsOnly: !1 }) {
      const { cachedCSFFiles: r } = this;
      if ((console.log('extract: extracting stories', r), !r)) throw new PE();
      const n = Object.entries(this.storyIndex.entries).reduce((o, [i, a]) => {
        if (a.type === 'docs') return o;
        const c = r[a.importPath],
          d = this.storyFromCSFFile({ storyId: i, csfFile: c });
        return (
          (!t.includeDocsOnly && d.parameters.docsOnly) ||
            (o[i] = Object.entries(d).reduce(
              (u, [p, f]) =>
                p === 'story' && a.subtype === 'test'
                  ? { ...u, story: a.parentName }
                  : p === 'moduleExport' || typeof f == 'function'
                    ? u
                    : Array.isArray(f)
                      ? Object.assign(u, { [p]: f.slice().sort() })
                      : Object.assign(u, { [p]: f }),
              {
                args: d.initialArgs,
                globals: {
                  ...this.userGlobals.initialGlobals,
                  ...this.userGlobals.globals,
                  ...d.storyGlobals,
                },
                storyId: a.parent ? a.parent : i,
              },
            )),
          o
        );
      }, {});
      return (console.log('extract: stories', n), n);
    }
  };
s(qI, 'StoryStore');
var MI = qI;
function jI(e) {
  return e.startsWith('\\\\?\\') ? e : e.replace(/\\/g, '/');
}
s(jI, 'slash');
var y3 = s((e) => {
  if (e.length === 0) return e;
  const t = e[e.length - 1],
    r = t?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, '');
  if (e.length === 1) return [r];
  const n = e[e.length - 2];
  return r && n && r.toLowerCase() === n.toLowerCase()
    ? [...e.slice(0, -2), r]
    : r && (/^(story|stories)([.][^.]+)$/i.test(t) || /^index$/i.test(r))
      ? e.slice(0, -1)
      : [...e.slice(0, -1), r];
}, 'sanitize');
function fp(e) {
  return e
    .flatMap((t) => t.split('/'))
    .filter(Boolean)
    .join('/');
}
s(fp, 'pathJoin');
var $I = s((e, t, r) => {
    const { directory: n, importPathMatcher: o, titlePrefix: i = '' } = t || {};
    typeof e == 'number' &&
      Ve.warn(ve`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
    const a = jI(String(e));
    if (o.exec(a)) {
      if (!r) {
        const c = a.replace(n, '');
        let d = fp([i, c]).split('/');
        return ((d = y3(d)), d.join('/'));
      }
      return i ? fp([i, r]) : r;
    }
  }, 'userOrAutoTitleFromSpecifier'),
  h3 = s((e, t, r) => {
    for (let n = 0; n < t.length; n += 1) {
      const o = $I(e, t[n], r);
      if (o) return o;
    }
    return r || void 0;
  }, 'userOrAutoTitle'),
  Gb = /\s*\/\s*/,
  g3 = s(
    (e = {}) =>
      (t, r) => {
        if (t.title === r.title && !e.includeNames) return 0;
        const n = e.method || 'configure';
        let o = e.order || [];
        const i = t.title.trim().split(Gb),
          a = r.title.trim().split(Gb);
        e.includeNames && (i.push(t.name), a.push(r.name));
        let c = 0;
        for (; i[c] || a[c]; ) {
          if (!i[c]) return -1;
          if (!a[c]) return 1;
          const d = i[c],
            u = a[c];
          if (d !== u) {
            let f = o.indexOf(d),
              m = o.indexOf(u);
            const h = o.indexOf('*');
            return f !== -1 || m !== -1
              ? (f === -1 && (h !== -1 ? (f = h) : (f = o.length)),
                m === -1 && (h !== -1 ? (m = h) : (m = o.length)),
                f - m)
              : n === 'configure'
                ? 0
                : d.localeCompare(u, e.locales ? e.locales : void 0, {
                    numeric: !0,
                    sensitivity: 'accent',
                  });
          }
          let p = o.indexOf(d);
          (p === -1 && (p = o.indexOf('*')),
            (o = p !== -1 && Array.isArray(o[p + 1]) ? o[p + 1] : []),
            (c += 1));
        }
        return 0;
      },
    'storySort',
  ),
  b3 = s((e, t, r) => {
    if (t) {
      let n;
      (typeof t == 'function' ? (n = t) : (n = g3(t)), e.sort(n));
    } else e.sort((n, o) => r.indexOf(n.importPath) - r.indexOf(o.importPath));
    return e;
  }, 'sortStoriesCommon'),
  v3 = s((e, t, r) => {
    try {
      return b3(e, t, r);
    } catch (n) {
      throw new Error(ve`
    Error sorting stories with sort parameter ${t}:

    > ${n.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
    }
  }, 'sortStoriesV7'),
  Lc = new Error('prepareAborted'),
  { AbortController: Wb } = globalThis;
function mp(e) {
  try {
    const { name: t = 'Error', message: r = String(e), stack: n } = e;
    return { name: t, message: r, stack: n };
  } catch {
    return { name: 'Error', message: String(e) };
  }
}
s(mp, 'serializeError');
var kI = class {
  constructor(t, r, n, o, i, a, c = { autoplay: !0, forceInitialArgs: !1 }, d) {
    ((this.channel = t),
      (this.store = r),
      (this.renderToScreen = n),
      (this.callbacks = o),
      (this.id = i),
      (this.viewMode = a),
      (this.renderOptions = c),
      (this.type = 'story'),
      (this.notYetRendered = !0),
      (this.rerenderEnqueued = !1),
      (this.disableKeyListeners = !1),
      (this.teardownRender = s(() => {}, 'teardownRender')),
      (this.torndown = !1),
      (this.abortController = new Wb()),
      (this.renderId = Date.now()),
      d && ((this.story = d), (this.phase = 'preparing')));
  }
  async runPhase(t, r, n) {
    ((this.phase = r),
      this.channel.emit(xn, { newPhase: this.phase, renderId: this.renderId, storyId: this.id }),
      n && (await n(), this.checkIfAborted(t)));
  }
  checkIfAborted(t) {
    return (
      t.aborted &&
        !['finished', 'aborted', 'errored'].includes(this.phase) &&
        ((this.phase = 'aborted'),
        this.channel.emit(xn, { newPhase: this.phase, renderId: this.renderId, storyId: this.id })),
      t.aborted
    );
  }
  async prepare() {
    if (
      (await this.runPhase(this.abortController.signal, 'preparing', async () => {
        this.story = await this.store.loadStory({ storyId: this.id });
      }),
      this.abortController.signal.aborted)
    )
      throw (await this.store.cleanupStory(this.story), Lc);
  }
  isEqual(t) {
    return !!(this.id === t.id && this.story && this.story === t.story);
  }
  isPreparing() {
    return ['preparing'].includes(this.phase);
  }
  isPending() {
    return ['loading', 'beforeEach', 'rendering', 'playing', 'afterEach'].includes(this.phase);
  }
  async renderToElement(t) {
    return ((this.canvasElement = t), this.render({ initial: !0, forceRemount: !0 }));
  }
  storyContext() {
    if (!this.story) throw new Error('Cannot call storyContext before preparing');
    const { forceInitialArgs: t } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: t });
  }
  async render({ initial: t = !1, forceRemount: r = !1 } = {}) {
    const { canvasElement: n } = this;
    if (!this.story) throw new Error('cannot render when not prepared');
    const o = this.story;
    if (!n) throw new Error('cannot render when canvasElement is unset');
    const {
      id: i,
      componentId: a,
      title: c,
      name: d,
      tags: u,
      applyLoaders: p,
      applyBeforeEach: f,
      applyAfterEach: m,
      unboundStoryFn: h,
      playFunction: g,
      runStep: v,
    } = o;
    r && !t && (this.cancelRender(), (this.abortController = new Wb()));
    const E = this.abortController.signal;
    let b = !1;
    const S = o.usesMount;
    try {
      const R = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: E,
        canvasElement: n,
        loaded: {},
        step: s((H, x) => v(H, x, R), 'step'),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: s(async () => {
          const H = await this.renderToScreen(I, n);
          ((this.teardownRender = H || (() => {})), (b = !0));
        }, 'renderToCanvas'),
        mount: s(async (...H) => {
          this.callbacks.showStoryDuringRender?.();
          let x = null;
          return (
            await this.runPhase(E, 'rendering', async () => {
              x = await o.mount(R)(...H);
            }),
            S && (await this.runPhase(E, 'playing')),
            x
          );
        }, 'mount'),
      };
      R.context = R;
      const I = {
        componentId: a,
        title: c,
        kind: c,
        id: i,
        name: d,
        story: d,
        tags: u,
        ...this.callbacks,
        showError: s((H) => ((this.phase = 'errored'), this.callbacks.showError(H)), 'showError'),
        showException: s(
          (H) => ((this.phase = 'errored'), this.callbacks.showException(H)),
          'showException',
        ),
        forceRemount: r || this.notYetRendered,
        storyContext: R,
        storyFn: s(() => h(R), 'storyFn'),
        unboundStoryFn: h,
      };
      if (
        (await this.runPhase(E, 'loading', async () => {
          R.loaded = await p(R);
        }),
        E.aborted)
      )
        return;
      const q = await f(R);
      if (
        (this.store.addCleanupCallbacks(o, ...q),
        this.checkIfAborted(E) ||
          (!b && !S && (await R.mount()), (this.notYetRendered = !1), E.aborted))
      )
        return;
      const P = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0,
        A = new Set(),
        w = s((H) => {
          H.error && A.add(H.error);
        }, 'onError'),
        _ = s((H) => {
          H.reason && A.add(H.reason);
        }, 'onUnhandledRejection');
      if (this.renderOptions.autoplay && r && g && this.phase !== 'errored') {
        (window?.addEventListener?.('error', w),
          window?.addEventListener?.('unhandledrejection', _),
          (this.disableKeyListeners = !0));
        try {
          if (
            (S
              ? await g(R)
              : ((R.mount = async () => {
                  throw new tf({ playFunction: g.toString() });
                }),
                await this.runPhase(E, 'playing', async () => g(R))),
            !b)
          )
            throw new WE();
          (this.checkIfAborted(E),
            !P && A.size > 0
              ? await this.runPhase(E, 'errored')
              : await this.runPhase(E, 'played'));
        } catch (H) {
          if (
            (this.callbacks.showStoryDuringRender?.(),
            await this.runPhase(E, 'errored', async () => {
              this.channel.emit(kv, mp(H));
            }),
            this.story.parameters.throwPlayFunctionExceptions !== !1)
          )
            throw H;
          console.error(H);
        }
        if (
          (!P && A.size > 0 && this.channel.emit(Dv, Array.from(A).map(mp)),
          (this.disableKeyListeners = !1),
          window?.removeEventListener?.('unhandledrejection', _),
          window?.removeEventListener?.('error', w),
          E.aborted)
        )
          return;
      }
      (await this.runPhase(E, 'completing', async () => {
        $h() ? this.store.addCleanupCallbacks(o, kc()) : await Dc(E);
      }),
        await this.runPhase(E, 'completed', async () => {
          this.channel.emit(ma, i);
        }),
        this.phase !== 'errored' &&
          (await this.runPhase(E, 'afterEach', async () => {
            await m(R);
          })));
      const $ = !P && A.size > 0,
        N = R.reporting.reports.some((H) => H.status === 'failed'),
        V = $ || N;
      await this.runPhase(E, 'finished', async () =>
        this.channel.emit(Su, {
          storyId: i,
          status: V ? 'error' : 'success',
          reporters: R.reporting.reports,
        }),
      );
    } catch (R) {
      ((this.phase = 'errored'),
        this.callbacks.showException(R),
        await this.runPhase(E, 'finished', async () =>
          this.channel.emit(Su, { storyId: i, status: 'error', reporters: [] }),
        ));
    }
    this.rerenderEnqueued && ((this.rerenderEnqueued = !1), this.render());
  }
  async rerender() {
    if (this.isPending() && this.phase !== 'playing') this.rerenderEnqueued = !0;
    else return this.render();
  }
  async remount() {
    return (await this.teardown(), this.render({ forceRemount: !0 }));
  }
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === 'playing' &&
      (this.abortController.abort(), this.runPhase(this.abortController.signal, 'aborted'));
  }
  async teardown() {
    ((this.torndown = !0),
      this.cancelRender(),
      this.story && (await this.store.cleanupStory(this.story)));
    for (let t = 0; t < 3; t += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((r) => setTimeout(r, 0));
    }
    (window?.location?.reload?.(), await new Promise(() => {}));
  }
};
s(kI, 'StoryRender');
var yp = kI,
  { fetch: T3 } = te,
  E3 = './index.json',
  DI = class {
    constructor(t, r, n = Ft.getChannel(), o = !0) {
      ((this.importFn = t),
        (this.getProjectAnnotations = r),
        (this.channel = n),
        (this.storyRenders = []),
        (this.storeInitializationPromise = new Promise((i, a) => {
          ((this.resolveStoreInitializationPromise = i),
            (this.rejectStoreInitializationPromise = a));
        })),
        o && this.initialize());
    }
    get storyStore() {
      return new Proxy(
        {},
        {
          get: s((t, r) => {
            if (this.storyStoreValue)
              return (
                Jp('Accessing the Story Store is deprecated and will be removed in 9.0'),
                this.storyStoreValue[r]
              );
            throw new UE();
          }, 'get'),
        },
      );
    }
    async initialize() {
      this.setupListeners();
      try {
        const t = await this.getProjectAnnotationsOrRenderError();
        (await this.runBeforeAllHook(t), await this.initializeWithProjectAnnotations(t));
        const r = globalThis?.navigator?.userAgent;
        await this.channel.emit(Fv, { userAgent: r });
      } catch (t) {
        this.rejectStoreInitializationPromise(t);
      }
    }
    ready() {
      return this.storeInitializationPromise;
    }
    setupListeners() {
      (this.channel.on(zv, this.onStoryIndexChanged.bind(this)),
        this.channel.on(Fp, this.onUpdateGlobals.bind(this)),
        this.channel.on(Bp, this.onUpdateArgs.bind(this)),
        this.channel.on(eT, this.onRequestArgTypesInfo.bind(this)),
        this.channel.on(Dp, this.onResetArgs.bind(this)),
        this.channel.on(kp, this.onForceReRender.bind(this)),
        this.channel.on(fa, this.onForceRemount.bind(this)),
        this.channel.on(Xv, this.onStoryHotUpdated.bind(this)));
    }
    async getProjectAnnotationsOrRenderError() {
      try {
        const t = await this.getProjectAnnotations();
        if (((this.renderToCanvas = t.renderToCanvas), !this.renderToCanvas)) throw new CE();
        return t;
      } catch (t) {
        throw (this.renderPreviewEntryError('Error reading preview.js:', t), t);
      }
    }
    async initializeWithProjectAnnotations(t) {
      this.projectAnnotationsBeforeInitialization = t;
      try {
        const r = await this.getStoryIndexFromServer();
        return this.initializeWithStoryIndex(r);
      } catch (r) {
        throw (this.renderPreviewEntryError('Error loading story index:', r), r);
      }
    }
    async runBeforeAllHook(t) {
      try {
        (await this.beforeAllCleanup?.(), (this.beforeAllCleanup = await t.beforeAll?.()));
      } catch (r) {
        throw (this.renderPreviewEntryError('Error in beforeAll hook:', r), r);
      }
    }
    async getStoryIndexFromServer() {
      const t = await T3(E3);
      if (t.status === 200) return t.json();
      throw new qE({ text: await t.text() });
    }
    initializeWithStoryIndex(t) {
      if (!this.projectAnnotationsBeforeInitialization)
        throw new Error('Cannot call initializeWithStoryIndex until project annotations resolve');
      ((this.storyStoreValue = new MI(
        t,
        this.importFn,
        this.projectAnnotationsBeforeInitialization,
      )),
        delete this.projectAnnotationsBeforeInitialization,
        this.setInitialGlobals(),
        this.resolveStoreInitializationPromise());
    }
    async setInitialGlobals() {
      this.emitGlobals();
    }
    emitGlobals() {
      if (!this.storyStoreValue) throw new Pt({ methodName: 'emitGlobals' });
      const t = {
        globals: this.storyStoreValue.userGlobals.get() || {},
        globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {},
      };
      this.channel.emit(Jv, t);
    }
    async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
      (delete this.previewEntryError, (this.getProjectAnnotations = t));
      const r = await this.getProjectAnnotationsOrRenderError();
      if ((await this.runBeforeAllHook(r), !this.storyStoreValue)) {
        await this.initializeWithProjectAnnotations(r);
        return;
      }
      (this.storyStoreValue.setProjectAnnotations(r), this.emitGlobals());
    }
    async onStoryIndexChanged() {
      if (
        (delete this.previewEntryError,
        !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      )
        try {
          const t = await this.getStoryIndexFromServer();
          if (this.projectAnnotationsBeforeInitialization) {
            this.initializeWithStoryIndex(t);
            return;
          }
          await this.onStoriesChanged({ storyIndex: t });
        } catch (t) {
          throw (this.renderPreviewEntryError('Error loading story index:', t), t);
        }
    }
    async onStoriesChanged({ importFn: t, storyIndex: r }) {
      if (!this.storyStoreValue) throw new Pt({ methodName: 'onStoriesChanged' });
      await this.storyStoreValue.onStoriesChanged({ importFn: t, storyIndex: r });
    }
    async onUpdateGlobals({ globals: t, currentStory: r }) {
      if ((this.storyStoreValue || (await this.storeInitializationPromise), !this.storyStoreValue))
        throw new Pt({ methodName: 'onUpdateGlobals' });
      if ((this.storyStoreValue.userGlobals.update(t), r)) {
        const {
          initialGlobals: n,
          storyGlobals: o,
          userGlobals: i,
          globals: a,
        } = this.storyStoreValue.getStoryContext(r);
        this.channel.emit(Hs, { initialGlobals: n, userGlobals: i, storyGlobals: o, globals: a });
      } else {
        const { initialGlobals: n, globals: o } = this.storyStoreValue.userGlobals;
        this.channel.emit(Hs, { initialGlobals: n, userGlobals: o, storyGlobals: {}, globals: o });
      }
      await Promise.all(this.storyRenders.map((n) => n.rerender()));
    }
    async onUpdateArgs({ storyId: t, updatedArgs: r }) {
      if (!this.storyStoreValue) throw new Pt({ methodName: 'onUpdateArgs' });
      (this.storyStoreValue.args.update(t, r),
        await Promise.all(
          this.storyRenders
            .filter((n) => n.id === t && !n.renderOptions.forceInitialArgs)
            .map((n) => (n.story && n.story.usesMount ? n.remount() : n.rerender())),
        ),
        this.channel.emit(Uv, { storyId: t, args: this.storyStoreValue.args.get(t) }));
    }
    async onRequestArgTypesInfo({ id: t, payload: r }) {
      try {
        await this.storeInitializationPromise;
        const n = await this.storyStoreValue?.loadStory(r);
        this.channel.emit(_u, {
          id: t,
          success: !0,
          payload: { argTypes: n?.argTypes || {} },
          error: null,
        });
      } catch (n) {
        this.channel.emit(_u, { id: t, success: !1, error: n?.message });
      }
    }
    async onResetArgs({ storyId: t, argNames: r }) {
      if (!this.storyStoreValue) throw new Pt({ methodName: 'onResetArgs' });
      const o =
          this.storyRenders.find((c) => c.id === t)?.story ||
          (await this.storyStoreValue.loadStory({ storyId: t })),
        a = (
          r || [
            ...new Set([
              ...Object.keys(o.initialArgs),
              ...Object.keys(this.storyStoreValue.args.get(t)),
            ]),
          ]
        ).reduce((c, d) => ((c[d] = o.initialArgs[d]), c), {});
      await this.onUpdateArgs({ storyId: t, updatedArgs: a });
    }
    async onForceReRender() {
      await Promise.all(this.storyRenders.map((t) => t.rerender()));
    }
    async onForceRemount({ storyId: t }) {
      await Promise.all(this.storyRenders.filter((r) => r.id === t).map((r) => r.remount()));
    }
    async onStoryHotUpdated() {
      await Promise.all(this.storyRenders.map((t) => t.cancelPlayFunction()));
    }
    renderStoryToElement(t, r, n, o) {
      if (!this.renderToCanvas || !this.storyStoreValue)
        throw new Pt({ methodName: 'renderStoryToElement' });
      const i = new yp(
        this.channel,
        this.storyStoreValue,
        this.renderToCanvas,
        n,
        t.id,
        'docs',
        o,
        t,
      );
      return (
        i.renderToElement(r),
        this.storyRenders.push(i),
        async () => {
          await this.teardownRender(i);
        }
      );
    }
    async teardownRender(t, { viewModeChanged: r } = {}) {
      ((this.storyRenders = this.storyRenders.filter((n) => n !== t)),
        await t?.teardown?.({ viewModeChanged: r }));
    }
    async loadStory({ storyId: t }) {
      if (!this.storyStoreValue) throw new Pt({ methodName: 'loadStory' });
      return this.storyStoreValue.loadStory({ storyId: t });
    }
    getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
      if (!this.storyStoreValue) throw new Pt({ methodName: 'getStoryContext' });
      return this.storyStoreValue.getStoryContext(t, { forceInitialArgs: r });
    }
    async extract(t) {
      if (!this.storyStoreValue) throw new Pt({ methodName: 'extract' });
      if (this.previewEntryError) throw this.previewEntryError;
      return (await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(t));
    }
    renderPreviewEntryError(t, r) {
      ((this.previewEntryError = r), ke.error(t), ke.error(r), this.channel.emit(jv, r));
    }
  };
s(DI, 'Preview');
var LI = DI,
  FI = class {
    constructor(t, r, n, o) {
      ((this.channel = t),
        (this.store = r),
        (this.renderStoryToElement = n),
        (this.storyIdByName = s((i) => {
          const a = this.nameToStoryId.get(i);
          if (a) return a;
          throw new Error(`No story found with that name: ${i}`);
        }, 'storyIdByName')),
        (this.componentStories = s(() => this.componentStoriesValue, 'componentStories')),
        (this.componentStoriesFromCSFFile = s(
          (i) => this.store.componentStoriesFromCSFFile({ csfFile: i }),
          'componentStoriesFromCSFFile',
        )),
        (this.storyById = s((i) => {
          if (!i) {
            if (!this.primaryStory)
              throw new Error(
                'No primary story defined for docs entry. Did you forget to use `<Meta>`?',
              );
            return this.primaryStory;
          }
          const a = this.storyIdToCSFFile.get(i);
          if (!a) throw new Error(`Called \`storyById\` for story that was never loaded: ${i}`);
          return this.store.storyFromCSFFile({ storyId: i, csfFile: a });
        }, 'storyById')),
        (this.getStoryContext = s(
          (i) => ({ ...this.store.getStoryContext(i), loaded: {}, viewMode: 'docs' }),
          'getStoryContext',
        )),
        (this.loadStory = s((i) => this.store.loadStory({ storyId: i }), 'loadStory')),
        (this.componentStoriesValue = []),
        (this.storyIdToCSFFile = new Map()),
        (this.exportToStory = new Map()),
        (this.exportsToCSFFile = new Map()),
        (this.nameToStoryId = new Map()),
        (this.attachedCSFFiles = new Set()),
        o.forEach((i, a) => {
          this.referenceCSFFile(i);
        }));
    }
    referenceCSFFile(t) {
      (this.exportsToCSFFile.set(t.moduleExports, t),
        this.exportsToCSFFile.set(t.moduleExports.default, t),
        this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
          const o = t.stories[n.id];
          (this.storyIdToCSFFile.set(o.id, t), this.exportToStory.set(o.moduleExport, n));
        }));
    }
    attachCSFFile(t) {
      if (!this.exportsToCSFFile.has(t.moduleExports))
        throw new Error('Cannot attach a CSF file that has not been referenced');
      if (this.attachedCSFFiles.has(t)) return;
      (this.attachedCSFFiles.add(t),
        this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
          (this.nameToStoryId.set(n.name, n.id),
            this.componentStoriesValue.push(n),
            this.primaryStory || (this.primaryStory = n));
        }));
    }
    referenceMeta(t, r) {
      const n = this.resolveModuleExport(t);
      if (n.type !== 'meta')
        throw new Error(
          '<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?',
        );
      r && this.attachCSFFile(n.csfFile);
    }
    get projectAnnotations() {
      const { projectAnnotations: t } = this.store;
      if (!t)
        throw new Error(
          "Can't get projectAnnotations from DocsContext before they are initialized",
        );
      return t;
    }
    resolveAttachedModuleExportType(t) {
      if (t === 'story') {
        if (!this.primaryStory)
          throw new Error(
            'No primary story attached to this docs file, did you forget to use <Meta of={} />?',
          );
        return { type: 'story', story: this.primaryStory };
      }
      if (this.attachedCSFFiles.size === 0)
        throw new Error(
          'No CSF file attached to this docs file, did you forget to use <Meta of={} />?',
        );
      const r = Array.from(this.attachedCSFFiles)[0];
      if (t === 'meta') return { type: 'meta', csfFile: r };
      const { component: n } = r.meta;
      if (!n)
        throw new Error(
          'Attached CSF file does not defined a component, did you forget to export one?',
        );
      return { type: 'component', component: n };
    }
    resolveModuleExport(t) {
      const r = this.exportsToCSFFile.get(t);
      if (r) return { type: 'meta', csfFile: r };
      const n = this.exportToStory.get(jc(t) ? t.input : t);
      return n ? { type: 'story', story: n } : { type: 'component', component: t };
    }
    resolveOf(t, r = []) {
      let n;
      if (['component', 'meta', 'story'].includes(t)) {
        const o = t;
        n = this.resolveAttachedModuleExportType(o);
      } else n = this.resolveModuleExport(t);
      if (r.length && !r.includes(n.type)) {
        const o = n.type === 'component' ? 'component or unknown' : n.type;
        throw new Error(ve`Invalid value passed to the 'of' prop. The value was resolved to a '${o}' type but the only types for this block are: ${r.join(', ')}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
      }
      switch (n.type) {
        case 'component':
          return { ...n, projectAnnotations: this.projectAnnotations };
        case 'meta':
          return { ...n, preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: n.csfFile }) };
        case 'story':
        default:
          return n;
      }
    }
  };
s(FI, 'DocsContext');
var Bh = FI,
  BI = class {
    constructor(t, r, n, o) {
      ((this.channel = t),
        (this.store = r),
        (this.entry = n),
        (this.callbacks = o),
        (this.type = 'docs'),
        (this.subtype = 'csf'),
        (this.torndown = !1),
        (this.disableKeyListeners = !1),
        (this.preparing = !1),
        (this.id = n.id),
        (this.renderId = Date.now()));
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
      if (this.torndown) throw Lc;
      const { importPath: n, title: o } = this.entry,
        i = this.store.processCSFFileWithCache(t, n, o),
        a = Object.keys(i.stories)[0];
      ((this.story = this.store.storyFromCSFFile({ storyId: a, csfFile: i })),
        (this.csfFiles = [i, ...r]),
        (this.preparing = !1));
    }
    isEqual(t) {
      return !!(this.id === t.id && this.story && this.story === t.story);
    }
    docsContext(t) {
      if (!this.csfFiles) throw new Error('Cannot render docs before preparing');
      const r = new Bh(this.channel, this.store, t, this.csfFiles);
      return (this.csfFiles.forEach((n) => r.attachCSFFile(n)), r);
    }
    async renderToElement(t, r) {
      if (!this.story || !this.csfFiles) throw new Error('Cannot render docs before preparing');
      const n = this.docsContext(r),
        { docs: o } = this.story.parameters || {};
      if (!o)
        throw new Error(
          'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed',
        );
      const i = await o.renderer(),
        { render: a } = i,
        c = s(async () => {
          try {
            (await a(n, o, t), this.channel.emit($p, this.id));
          } catch (d) {
            this.callbacks.showException(d);
          }
        }, 'renderDocs');
      return (
        (this.rerender = async () => c()),
        (this.teardownRender = async ({ viewModeChanged: d }) => {
          !d || !t || i.unmount(t);
        }),
        c()
      );
    }
    async teardown({ viewModeChanged: t } = {}) {
      (this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0));
    }
  };
s(BI, 'CsfDocsRender');
var Kb = BI,
  JI = class {
    constructor(t, r, n, o) {
      ((this.channel = t),
        (this.store = r),
        (this.entry = n),
        (this.callbacks = o),
        (this.type = 'docs'),
        (this.subtype = 'mdx'),
        (this.torndown = !1),
        (this.disableKeyListeners = !1),
        (this.preparing = !1),
        (this.id = n.id),
        (this.renderId = Date.now()));
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
      if (this.torndown) throw Lc;
      ((this.csfFiles = r), (this.exports = t), (this.preparing = !1));
    }
    isEqual(t) {
      return !!(this.id === t.id && this.exports && this.exports === t.exports);
    }
    docsContext(t) {
      if (!this.csfFiles) throw new Error('Cannot render docs before preparing');
      return new Bh(this.channel, this.store, t, this.csfFiles);
    }
    async renderToElement(t, r) {
      if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
        throw new Error('Cannot render docs before preparing');
      const n = this.docsContext(r),
        { docs: o } = this.store.projectAnnotations.parameters ?? {};
      if (!o)
        throw new Error(
          'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed',
        );
      const i = { ...o, page: this.exports.default },
        a = await o.renderer(),
        { render: c } = a,
        d = s(async () => {
          try {
            (await c(n, i, t), this.channel.emit($p, this.id));
          } catch (u) {
            this.callbacks.showException(u);
          }
        }, 'renderDocs');
      return (
        (this.rerender = async () => d()),
        (this.teardownRender = async ({ viewModeChanged: u } = {}) => {
          !u || !t || (a.unmount(t), (this.torndown = !0));
        }),
        d()
      );
    }
    async teardown({ viewModeChanged: t } = {}) {
      (this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0));
    }
  };
s(JI, 'MdxDocsRender');
var Yb = JI,
  w3 = globalThis;
function UI(e) {
  const t = (e.composedPath && e.composedPath()[0]) || e.target;
  return /input|textarea/i.test(t.tagName) || t.getAttribute('contenteditable') !== null;
}
s(UI, 'focusInInput');
var VI = 'attached-mdx',
  S3 = 'unattached-mdx';
function HI({ tags: e }) {
  return e?.includes(S3) || e?.includes(VI);
}
s(HI, 'isMdxEntry');
function la(e) {
  return e.type === 'story';
}
s(la, 'isStoryRender');
function zI(e) {
  return e.type === 'docs';
}
s(zI, 'isDocsRender');
function GI(e) {
  return zI(e) && e.subtype === 'csf';
}
s(GI, 'isCsfDocsRender');
var WI = class extends LI {
  constructor(t, r, n, o) {
    (super(t, r, void 0, !1),
      (this.importFn = t),
      (this.getProjectAnnotations = r),
      (this.selectionStore = n),
      (this.view = o),
      this.initialize());
  }
  setupListeners() {
    (super.setupListeners(),
      (w3.onkeydown = this.onKeydown.bind(this)),
      this.channel.on(Lp, this.onSetCurrentStory.bind(this)),
      this.channel.on(Qv, this.onUpdateQueryParams.bind(this)),
      this.channel.on(Lv, this.onPreloadStories.bind(this)));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue) throw new Pt({ methodName: 'setInitialGlobals' });
    const { globals: t } = this.selectionStore.selectionSpecifier || {};
    (t && this.storyStoreValue.userGlobals.updateFromPersisted(t), this.emitGlobals());
  }
  async initializeWithStoryIndex(t) {
    return (await super.initializeWithStoryIndex(t), this.selectSpecifiedStory());
  }
  async selectSpecifiedStory() {
    if (!this.storyStoreValue) throw new Pt({ methodName: 'selectSpecifiedStory' });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    const { storySpecifier: t, args: r } = this.selectionStore.selectionSpecifier,
      n = this.storyStoreValue.storyIndex.entryFromSpecifier(t);
    if (!n) {
      t === '*'
        ? this.renderStoryLoadingException(t, new kE())
        : this.renderStoryLoadingException(t, new LE({ storySpecifier: t.toString() }));
      return;
    }
    const { id: o, type: i } = n;
    (this.selectionStore.setSelection({ storyId: o, viewMode: i }),
      this.channel.emit(Wv, this.selectionStore.selection),
      this.channel.emit(Eu, this.selectionStore.selection),
      await this.renderSelection({ persistedArgs: r }));
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
    (await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: t }),
      this.selectionStore.selection && this.renderSelection());
  }
  async onStoriesChanged({ importFn: t, storyIndex: r }) {
    (await super.onStoriesChanged({ importFn: t, storyIndex: r }),
      this.selectionStore.selection
        ? await this.renderSelection()
        : await this.selectSpecifiedStory());
  }
  onKeydown(t) {
    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !UI(t)) {
      const { altKey: r, ctrlKey: n, metaKey: o, shiftKey: i, key: a, code: c, keyCode: d } = t;
      this.channel.emit(Bv, {
        event: { altKey: r, ctrlKey: n, metaKey: o, shiftKey: i, key: a, code: c, keyCode: d },
      });
    }
  }
  async onSetCurrentStory(t) {
    (this.selectionStore.setSelection({ viewMode: 'story', ...t }),
      await this.storeInitializationPromise,
      this.channel.emit(Eu, this.selectionStore.selection),
      this.renderSelection());
  }
  onUpdateQueryParams(t) {
    this.selectionStore.setQueryParams(t);
  }
  async onUpdateGlobals({ globals: t }) {
    const r = (this.currentRender instanceof yp && this.currentRender.story) || void 0;
    (super.onUpdateGlobals({ globals: t, currentStory: r }),
      (this.currentRender instanceof Yb || this.currentRender instanceof Kb) &&
        (await this.currentRender.rerender?.()));
  }
  async onUpdateArgs({ storyId: t, updatedArgs: r }) {
    super.onUpdateArgs({ storyId: t, updatedArgs: r });
  }
  async onPreloadStories({ ids: t }) {
    (await this.storeInitializationPromise,
      this.storyStoreValue &&
        (await Promise.allSettled(t.map((r) => this.storyStoreValue?.loadEntry(r)))));
  }
  async renderSelection({ persistedArgs: t } = {}) {
    const { renderToCanvas: r } = this;
    if (!this.storyStoreValue || !r) throw new Pt({ methodName: 'renderSelection' });
    const { selection: n } = this.selectionStore;
    if (!n) throw new Error('Cannot call renderSelection as no selection was made');
    const { storyId: o } = n;
    let i;
    try {
      i = await this.storyStoreValue.storyIdToEntry(o);
    } catch (m) {
      (this.currentRender && (await this.teardownRender(this.currentRender)),
        this.renderStoryLoadingException(o, m));
      return;
    }
    const a = this.currentSelection?.storyId !== o,
      c = this.currentRender?.type !== i.type;
    (i.type === 'story'
      ? this.view.showPreparingStory({ immediate: c })
      : this.view.showPreparingDocs({ immediate: c }),
      this.currentRender?.isPreparing() && (await this.teardownRender(this.currentRender)));
    let d;
    i.type === 'story'
      ? (d = new yp(this.channel, this.storyStoreValue, r, this.mainStoryCallbacks(o), o, 'story'))
      : HI(i)
        ? (d = new Yb(this.channel, this.storyStoreValue, i, this.mainStoryCallbacks(o)))
        : (d = new Kb(this.channel, this.storyStoreValue, i, this.mainStoryCallbacks(o)));
    const u = this.currentSelection;
    this.currentSelection = n;
    const p = this.currentRender;
    this.currentRender = d;
    try {
      await d.prepare();
    } catch (m) {
      (p && (await this.teardownRender(p)), m !== Lc && this.renderStoryLoadingException(o, m));
      return;
    }
    const f = !a && p && !d.isEqual(p);
    if (
      (t && la(d) && (sr(!!d.story), this.storyStoreValue.args.updateFromPersisted(d.story, t)),
      p && !p.torndown && !a && !f && !c)
    ) {
      ((this.currentRender = p), this.channel.emit(Yv, o), this.view.showMain());
      return;
    }
    if (
      (p && (await this.teardownRender(p, { viewModeChanged: c })),
      u && (a || c) && this.channel.emit(Vv, o),
      la(d))
    ) {
      sr(!!d.story);
      const {
        parameters: m,
        initialArgs: h,
        argTypes: g,
        unmappedArgs: v,
        initialGlobals: E,
        userGlobals: b,
        storyGlobals: S,
        globals: R,
      } = this.storyStoreValue.getStoryContext(d.story);
      (this.channel.emit(Gv, { id: o, parameters: m, initialArgs: h, argTypes: g, args: v }),
        this.channel.emit(Hs, { userGlobals: b, storyGlobals: S, globals: R, initialGlobals: E }));
    } else {
      let { parameters: m } = this.storyStoreValue.projectAnnotations;
      const { initialGlobals: h, globals: g } = this.storyStoreValue.userGlobals;
      if (
        (this.channel.emit(Hs, { globals: g, initialGlobals: h, storyGlobals: {}, userGlobals: g }),
        GI(d) || d.entry.tags?.includes(VI))
      ) {
        if (!d.csfFiles) throw new jE({ storyId: o });
        ({ parameters: m } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: d.csfFiles[0],
        }));
      }
      this.channel.emit($v, { id: o, parameters: m });
    }
    la(d)
      ? (sr(!!d.story),
        this.storyRenders.push(d),
        this.currentRender.renderToElement(this.view.prepareForStory(d.story)))
      : this.currentRender.renderToElement(
          this.view.prepareForDocs(),
          this.renderStoryToElement.bind(this),
        );
  }
  async teardownRender(t, { viewModeChanged: r = !1 } = {}) {
    ((this.storyRenders = this.storyRenders.filter((n) => n !== t)),
      await t?.teardown?.({ viewModeChanged: r }));
  }
  mainStoryCallbacks(t) {
    return {
      showStoryDuringRender: s(() => this.view.showStoryDuringRender(), 'showStoryDuringRender'),
      showMain: s(() => this.view.showMain(), 'showMain'),
      showError: s((r) => this.renderError(t, r), 'showError'),
      showException: s((r) => this.renderException(t, r), 'showException'),
    };
  }
  renderPreviewEntryError(t, r) {
    (super.renderPreviewEntryError(t, r), this.view.showErrorDisplay(r));
  }
  renderMissingStory() {
    (this.view.showNoPreview(), this.channel.emit(wu));
  }
  renderStoryLoadingException(t, r) {
    (ke.error(r), this.view.showErrorDisplay(r), this.channel.emit(wu, t));
  }
  renderException(t, r) {
    const { name: n = 'Error', message: o = String(r), stack: i } = r,
      a = this.currentRender?.renderId;
    (this.channel.emit(Kv, { name: n, message: o, stack: i }),
      this.channel.emit(xn, { newPhase: 'errored', renderId: a, storyId: t }),
      this.view.showErrorDisplay(r),
      ke.error(`Error rendering story '${t}':`),
      ke.error(r));
  }
  renderError(t, { title: r, description: n }) {
    const o = this.currentRender?.renderId;
    (this.channel.emit(Hv, { title: r, description: n }),
      this.channel.emit(xn, { newPhase: 'errored', renderId: o, storyId: t }),
      this.view.showErrorDisplay({ message: r, stack: n }),
      ke.error(`Error rendering story ${r}: ${n}`));
  }
};
s(WI, 'PreviewWithSelection');
var KI = WI,
  hp = Ge(qp(), 1),
  _3 = Ge(qp(), 1),
  Xb = /^[a-zA-Z0-9 _-]*$/,
  YI = /^-?[0-9]+(\.[0-9]+)?$/,
  A3 = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i,
  XI =
    /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i,
  gp = s(
    (e = '', t) =>
      e === null || e === '' || !Xb.test(e)
        ? !1
        : t == null || t instanceof Date || typeof t == 'number' || typeof t == 'boolean'
          ? !0
          : typeof t == 'string'
            ? Xb.test(t) || YI.test(t) || A3.test(t) || XI.test(t)
            : Array.isArray(t)
              ? t.every((r) => gp(e, r))
              : Kt(t)
                ? Object.entries(t).every(([r, n]) => gp(r, n))
                : !1,
    'validateArgs',
  ),
  R3 = {
    delimiter: ';',
    nesting: !0,
    arrayRepeat: !0,
    arrayRepeatSyntax: 'bracket',
    nestingSyntax: 'js',
    valueDeserializer(e) {
      if (e.startsWith('!')) {
        if (e === '!undefined') return;
        if (e === '!null') return null;
        if (e === '!true') return !0;
        if (e === '!false') return !1;
        if (e.startsWith('!date(') && e.endsWith(')'))
          return new Date(e.replaceAll(' ', '+').slice(6, -1));
        if (e.startsWith('!hex(') && e.endsWith(')')) return `#${e.slice(5, -1)}`;
        const t = e.slice(1).match(XI);
        if (t)
          return e.startsWith('!rgba') || e.startsWith('!RGBA')
            ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})`
            : e.startsWith('!hsla') || e.startsWith('!HSLA')
              ? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})`
              : e.startsWith('!rgb') || e.startsWith('!RGB')
                ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})`
                : `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`;
      }
      return YI.test(e) ? Number(e) : e;
    },
  },
  Qb = s((e) => {
    const t = e.split(';').map((r) => r.replace('=', '~').replace(':', '='));
    return Object.entries((0, _3.parse)(t.join(';'), R3)).reduce(
      (r, [n, o]) =>
        gp(n, o)
          ? Object.assign(r, { [n]: o })
          : (Ve.warn(ve`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `),
            r),
      {},
    );
  }, 'parseArgsParam'),
  { history: QI, document: zr } = te;
function ZI(e) {
  const t = (e || '').match(/^\/story\/(.+)/);
  if (!t) throw new Error(`Invalid path '${e}',  must start with '/story/'`);
  return t[1];
}
s(ZI, 'pathToId');
var eN = s(({ selection: e, extraParams: t }) => {
    const r = zr?.location.search.slice(1),
      { path: n, selectedKind: o, selectedStory: i, ...a } = (0, hp.parse)(r);
    return `?${(0, hp.stringify)({ ...a, ...t, ...(e && { id: e.storyId, viewMode: e.viewMode }) })}`;
  }, 'getQueryString'),
  x3 = s((e) => {
    if (!e) return;
    const t = eN({ selection: e }),
      { hash: r = '' } = zr.location;
    ((zr.title = e.storyId), QI.replaceState({}, '', `${zr.location.pathname}${t}${r}`));
  }, 'setPath'),
  P3 = s((e) => e != null && typeof e == 'object' && Array.isArray(e) === !1, 'isObject'),
  Vs = s((e) => {
    if (e !== void 0) {
      if (typeof e == 'string') return e;
      if (Array.isArray(e)) return Vs(e[0]);
      if (P3(e)) return Vs(Object.values(e).filter(Boolean));
    }
  }, 'getFirstString'),
  O3 = s(() => {
    if (typeof zr < 'u') {
      const e = zr.location.search.slice(1),
        t = (0, hp.parse)(e),
        r = typeof t.args == 'string' ? Qb(t.args) : void 0,
        n = typeof t.globals == 'string' ? Qb(t.globals) : void 0;
      let o = Vs(t.viewMode);
      (typeof o != 'string' || !o.match(/docs|story/)) && (o = 'story');
      const i = Vs(t.path),
        a = i ? ZI(i) : Vs(t.id);
      if (a) return { storySpecifier: a, args: r, globals: n, viewMode: o };
    }
    return null;
  }, 'getSelectionSpecifierFromPath'),
  tN = class {
    constructor() {
      this.selectionSpecifier = O3();
    }
    setSelection(t) {
      ((this.selection = t), x3(this.selection));
    }
    setQueryParams(t) {
      const r = eN({ extraParams: t }),
        { hash: n = '' } = zr.location;
      QI.replaceState({}, '', `${zr.location.pathname}${r}${n}`);
    }
  };
s(tN, 'UrlStore');
var rN = tN,
  C3 = Ge(ek(), 1),
  I3 = Ge(qp(), 1),
  { document: gt } = te,
  Zb = 100,
  nN = ((e) => (
    (e.MAIN = 'MAIN'),
    (e.NOPREVIEW = 'NOPREVIEW'),
    (e.PREPARING_STORY = 'PREPARING_STORY'),
    (e.PREPARING_DOCS = 'PREPARING_DOCS'),
    (e.ERROR = 'ERROR'),
    e
  ))(nN || {}),
  mu = {
    PREPARING_STORY: 'sb-show-preparing-story',
    PREPARING_DOCS: 'sb-show-preparing-docs',
    MAIN: 'sb-show-main',
    NOPREVIEW: 'sb-show-nopreview',
    ERROR: 'sb-show-errordisplay',
  },
  yu = { centered: 'sb-main-centered', fullscreen: 'sb-main-fullscreen', padded: 'sb-main-padded' },
  ev = new C3.default({ escapeXML: !0 }),
  oN = class {
    constructor() {
      if (((this.testing = !1), typeof gt < 'u')) {
        const { __SPECIAL_TEST_PARAMETER__: t } = (0, I3.parse)(gt.location.search.slice(1));
        switch (t) {
          case 'preparing-story': {
            (this.showPreparingStory(), (this.testing = !0));
            break;
          }
          case 'preparing-docs': {
            (this.showPreparingDocs(), (this.testing = !0));
            break;
          }
        }
      }
    }
    prepareForStory(t) {
      return (
        this.showStory(),
        this.applyLayout(t.parameters.layout),
        (gt.documentElement.scrollTop = 0),
        (gt.documentElement.scrollLeft = 0),
        this.storyRoot()
      );
    }
    storyRoot() {
      return gt.getElementById('storybook-root');
    }
    prepareForDocs() {
      return (
        this.showMain(),
        this.showDocs(),
        this.applyLayout('fullscreen'),
        (gt.documentElement.scrollTop = 0),
        (gt.documentElement.scrollLeft = 0),
        this.docsRoot()
      );
    }
    docsRoot() {
      return gt.getElementById('storybook-docs');
    }
    applyLayout(t = 'padded') {
      if (t === 'none') {
        (gt.body.classList.remove(this.currentLayoutClass), (this.currentLayoutClass = null));
        return;
      }
      this.checkIfLayoutExists(t);
      const r = yu[t];
      (gt.body.classList.remove(this.currentLayoutClass),
        gt.body.classList.add(r),
        (this.currentLayoutClass = r));
    }
    checkIfLayoutExists(t) {
      yu[t] ||
        ke.warn(ve`
          The desired layout: ${t} is not a valid option.
          The possible options are: ${Object.keys(yu).join(', ')}, none.
        `);
    }
    showMode(t) {
      (clearTimeout(this.preparingTimeout),
        Object.keys(nN).forEach((r) => {
          r === t ? gt.body.classList.add(mu[r]) : gt.body.classList.remove(mu[r]);
        }));
    }
    showErrorDisplay({ message: t = '', stack: r = '' }) {
      let n = t,
        o = r;
      const i = t.split(`
`);
      (i.length > 1 &&
        (([n] = i),
        (o = i
          .slice(1)
          .join(
            `
`,
          )
          .replace(/^\n/, ''))),
        (gt.getElementById('error-message').innerHTML = ev.toHtml(n)),
        (gt.getElementById('error-stack').innerHTML = ev.toHtml(o)),
        this.showMode('ERROR'));
    }
    showNoPreview() {
      this.testing ||
        (this.showMode('NOPREVIEW'),
        this.storyRoot()?.setAttribute('hidden', 'true'),
        this.docsRoot()?.setAttribute('hidden', 'true'));
    }
    showPreparingStory({ immediate: t = !1 } = {}) {
      (clearTimeout(this.preparingTimeout),
        t
          ? this.showMode('PREPARING_STORY')
          : (this.preparingTimeout = setTimeout(() => this.showMode('PREPARING_STORY'), Zb)));
    }
    showPreparingDocs({ immediate: t = !1 } = {}) {
      (clearTimeout(this.preparingTimeout),
        t
          ? this.showMode('PREPARING_DOCS')
          : (this.preparingTimeout = setTimeout(() => this.showMode('PREPARING_DOCS'), Zb)));
    }
    showMain() {
      this.showMode('MAIN');
    }
    showDocs() {
      (this.storyRoot().setAttribute('hidden', 'true'), this.docsRoot().removeAttribute('hidden'));
    }
    showStory() {
      (this.docsRoot().setAttribute('hidden', 'true'), this.storyRoot().removeAttribute('hidden'));
    }
    showStoryDuringRender() {
      gt.body.classList.add(mu.MAIN);
    }
  };
s(oN, 'WebView');
var sN = oN,
  iN = class extends KI {
    constructor(t, r) {
      (super(t, r, new rN(), new sN()),
        (this.importFn = t),
        (this.getProjectAnnotations = r),
        (te.__STORYBOOK_PREVIEW__ = this));
    }
  };
s(iN, 'PreviewWeb');
var N3 = iN,
  { document: _n } = te,
  q3 = [
    'application/javascript',
    'application/ecmascript',
    'application/x-ecmascript',
    'application/x-javascript',
    'text/ecmascript',
    'text/javascript',
    'text/javascript1.0',
    'text/javascript1.1',
    'text/javascript1.2',
    'text/javascript1.3',
    'text/javascript1.4',
    'text/javascript1.5',
    'text/jscript',
    'text/livescript',
    'text/x-ecmascript',
    'text/x-javascript',
    'module',
  ],
  M3 = 'script',
  tv = 'scripts-root';
function il() {
  const e = _n.createEvent('Event');
  (e.initEvent('DOMContentLoaded', !0, !0), _n.dispatchEvent(e));
}
s(il, 'simulateDOMContentLoaded');
function aN(e, t, r) {
  const n = _n.createElement('script');
  ((n.type = e.type === 'module' ? 'module' : 'text/javascript'),
    e.src ? ((n.onload = t), (n.onerror = t), (n.src = e.src)) : (n.textContent = e.innerText),
    r ? r.appendChild(n) : _n.head.appendChild(n),
    e.parentNode.removeChild(e),
    e.src || t());
}
s(aN, 'insertScript');
function Jh(e, t, r = 0) {
  e[r](() => {
    (r++, r === e.length ? t() : Jh(e, t, r));
  });
}
s(Jh, 'insertScriptsSequentially');
function lN(e) {
  let t = _n.getElementById(tv);
  t ? (t.innerHTML = '') : ((t = _n.createElement('div')), (t.id = tv), _n.body.appendChild(t));
  const r = Array.from(e.querySelectorAll(M3));
  if (r.length) {
    const n = [];
    (r.forEach((o) => {
      const i = o.getAttribute('type');
      (!i || q3.includes(i)) && n.push((a) => aN(o, a, t));
    }),
      n.length && Jh(n, il, void 0));
  } else il();
}
s(lN, 'simulatePageLoad');
var hu;
(function (e) {
  ((e.start = '/**'), (e.nostart = '/***'), (e.delim = '*'), (e.end = '*/'));
})((hu = hu || (hu = {})));
function cN(e) {
  return (
    e.start +
    e.delimiter +
    e.postDelimiter +
    e.tag +
    e.postTag +
    e.type +
    e.postType +
    e.name +
    e.postName +
    e.description +
    e.end +
    e.lineEnd
  );
}
s(cN, 'join');
function j3() {
  return (e) =>
    e.source.map(({ tokens: t }) => cN(t)).join(`
`);
}
s(j3, 'getStringifier');
var $3 = Ge(tk(), 1),
  Hn = (0, $3.stringifyRules)(),
  k3 = Hn.JsdocTypeObject;
Hn.JsdocTypeAny = () => 'any';
Hn.JsdocTypeObject = (e, t) => `(${k3(e, t)})`;
Hn.JsdocTypeOptional = (e, t) => t(e.element);
Hn.JsdocTypeNullable = (e, t) => t(e.element);
Hn.JsdocTypeNotNullable = (e, t) => t(e.element);
Hn.JsdocTypeUnion = (e, t) => e.elements.map(t).join('|');
var D3 = 'storybook/docs',
  L3 = `${D3}/snippet-rendered`;
async function uN(e, t) {
  const r = t.parameters?.docs?.source?.transform,
    { id: n, unmappedArgs: o } = t,
    i = r && e ? r?.(e, t) : e,
    a = i ? await i : void 0;
  Ft.getChannel().emit(L3, { id: n, source: a, args: o });
}
s(uN, 'emitTransformCode');
var pi = { depth: 10, clearOnStoryChange: !0, limit: 50 },
  F3 = s((e = {}) => {
    Object.assign(pi, e);
  }, 'configureActions'),
  dN = s((e, t) => {
    const r = Object.getPrototypeOf(e);
    return !r || t(r) ? r : dN(r, t);
  }, 'findProto'),
  B3 = s(
    (e) =>
      !!(
        typeof e == 'object' &&
        e &&
        dN(e, (t) => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) &&
        typeof e.persist == 'function'
      ),
    'isReactSyntheticEvent',
  ),
  J3 = s((e) => {
    if (B3(e)) {
      const t = Object.create(e.constructor.prototype, Object.getOwnPropertyDescriptors(e));
      t.persist();
      const r = Object.getOwnPropertyDescriptor(t, 'view'),
        n = r?.value;
      return (
        typeof n == 'object' &&
          n?.constructor.name === 'Window' &&
          Object.defineProperty(t, 'view', { ...r, value: Object.create(n.constructor.prototype) }),
        t
      );
    }
    return e;
  }, 'serializeArg');
function Ho(e, t = {}) {
  const r = { ...pi, ...t },
    n = s(function (...i) {
      if (t.implicit) {
        const h = (
          '__STORYBOOK_PREVIEW__' in te ? te.__STORYBOOK_PREVIEW__ : void 0
        )?.storyRenders.find((g) => g.phase === 'playing' || g.phase === 'rendering');
        if (h) {
          const g = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8,
            v = new RE({ phase: h.phase, name: e, deprecated: g });
          if (g) console.warn(v);
          else throw v;
        }
      }
      const a = Ft.getChannel(),
        c = Date.now().toString(36) + Math.random().toString(36).substring(2),
        d = 5,
        u = i.map(J3),
        p = i.length > 1 ? u : u[0],
        f = {
          id: c,
          count: 0,
          data: { name: e, args: p },
          options: { ...r, maxDepth: d + (r.depth || 3) },
        };
      a.emit(ow, f);
    }, 'actionHandler');
  return ((n.isAction = !0), (n.implicit = t.implicit), n);
}
s(Ho, 'action');
var U3 = s((...e) => {
    let t = pi,
      r = e;
    (r.length === 1 && Array.isArray(r[0]) && ([r] = r),
      r.length !== 1 && typeof r[r.length - 1] != 'string' && (t = { ...pi, ...r.pop() }));
    let n = r[0];
    (r.length !== 1 || typeof n == 'string') &&
      ((n = {}),
      r.forEach((i) => {
        n[i] = i;
      }));
    const o = {};
    return (
      Object.keys(n).forEach((i) => {
        o[i] = Ho(n[i], t);
      }),
      o
    );
  }, 'actions'),
  V3 = {
    '@storybook/global': tT,
    'storybook/test': Aw,
    'storybook/actions': nw,
    'storybook/preview-api': Pu,
    'storybook/internal/channels': nT,
    'storybook/internal/client-logger': sT,
    'storybook/internal/core-events': Mp,
    'storybook/internal/types': tw,
    'storybook/internal/preview-errors': vE,
    'storybook/internal/preview-api': Pu,
  };
async function pN() {
  const e = new URL(window.location.href);
  if (e.searchParams.get('navigator') !== 'true' || globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__)
    return;
  globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__ = !0;
  const t = await (await fetch('/index.json')).json(),
    r = e.searchParams.get('id');
  if (!r) {
    const n = Object.values(t.entries)[0];
    n &&
      (e.searchParams.set('id', n.id),
      e.searchParams.set('viewMode', n.type),
      (window.location.href = e.toString()));
    return;
  }
  H3(t, r);
}
s(pN, 'maybeSetupPreviewNavigator');
var H3 = s(async (e, t) => {
    const r = { entries: {} };
    for (const c of Object.values(e.entries)) {
      const d = c.title.split('/');
      let u = r;
      for (const p of d)
        (u.entries || (u.entries = {}),
          u.entries[p]
            ? t === c.id && (u.entries[p].isActive = !0)
            : (u.entries[p] = { title: p, isActive: t === c.id, entries: {} }),
          (u = u.entries[p]));
      (u.entries || (u.entries = {}),
        (u.entries[c.name] = {
          id: c.id,
          name: c.name,
          href: `?id=${c.id}&viewMode=${c.type}&navigator=true`,
          isActive: t === c.id,
        }));
    }
    const n = s((c) => {
        if ('entries' in c && 'title' in c) {
          const u = c;
          return `
      <li class="sb-navigator-branch">
        <details${u.isActive ? ' open' : ''}>
          <summary class="sb-navigator-title">
            ${u.title}
          </summary>
          <ul class="sb-navigator-entries" aria-label="${u.title}">
            ${Object.values(u.entries).map(n).join('')}
          </ul>
        </details>
      </li>
      `;
        }
        const d = c;
        return `
      <li class="sb-navigator-story-item">
        <a href="${d.href}" 
           class="sb-navigator-story-link${d.isActive ? ' active' : ''}" 
           aria-current="${d.isActive ? 'location' : 'false'}">${d.name}</a>
      </li>
    `;
      }, 'createHtmlForNode'),
      o = Object.values(r.entries).map(n).join(''),
      i = document.createElement('nav');
    ((i.id = 'sb-navigator-container'),
      i.setAttribute('role', 'navigation'),
      i.setAttribute('aria-label', 'Story navigation'),
      (i.innerHTML = `
    <ul class="sb-navigator-list">${o}</ul>
  `),
      document.body.insertBefore(i, document.body.firstChild));
    const a = document.createElement('style');
    ((a.id = 'sb-navigator-style'),
      (a.textContent = `
    body {
      display: grid !important;
      grid-template-columns: 300px 1fr;
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      margin: 0;

      --text-color: rgb(46, 52, 56);
      --bg-color: rgb(246, 249, 252);

      @media (prefers-color-scheme: dark) {
        --text-color: rgb(201, 205, 207);
        --bg-color: rgb(34, 36, 37);
      }
    }
    #storybook-root, #storybook-docs {
      overflow-y: auto;
      max-height: 100vh;
      max-width: 100%;
    }
    #sb-navigator-container, #sb-navigator-container * {
      box-sizing: border-box;
    }
    #sb-navigator-container {
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid #eee;
        padding: 1rem;
        font-size: 14px;
        color: var(--text-color);
        background-color: var(--bg-color);
        align-self: start;
        z-index: 1000;
    }
    .sb-main-padded #sb-navigator-container {
      margin: -1rem 1rem -1rem -1rem;
    }
    .sb-navigator-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    .sb-navigator-branch {
      list-style-type: none;
    }
    .sb-navigator-item {
      margin-bottom: 15px;
    }
    .sb-navigator-title {
      color: var(--text-color);
      text-decoration: none;
      padding-block: 5px;
      cursor: pointer;
    }
    .sb-navigator-entries {
      padding-left: 15px;
    }
    .sb-navigator-story-item {
      margin-bottom: 8px;
      margin-left: 8px;
    }
    .sb-navigator-story-link {
      color: var(--text-color);
    }
    .sb-navigator-story-link.active {
      font-weight: bold;
      color: rgb(2, 156, 253);
    }
  `),
      document.head.appendChild(a),
      i
        .querySelector('.sb-navigator-story-link.active')
        ?.closest('details')
        ?.scrollIntoView({ block: 'center' }));
  }, 'setupPreviewNavigator'),
  z3 = Ge(rk(), 1),
  gu;
function fN() {
  return (gu || (gu = new z3.default(te.navigator?.userAgent).getBrowserInfo()), gu);
}
s(fN, 'getBrowserInfo');
function mN(e) {
  return ((e.browserInfo = fN()), e);
}
s(mN, 'prepareForTelemetry');
function yN(e) {
  const t = e.error || e;
  t.fromStorybook && te.sendTelemetryError(t);
}
s(yN, 'errorListener');
function hN({ reason: e }) {
  e.fromStorybook && te.sendTelemetryError(e);
}
s(hN, 'unhandledRejectionListener');
function Uh() {
  (Ok.forEach((e) => {
    te[rT[e]] = V3[e];
  }),
    (te.sendTelemetryError = (e) => {
      te.__STORYBOOK_ADDONS_CHANNEL__.emit(Zv, mN(e));
    }),
    te.addEventListener('error', yN),
    te.addEventListener('unhandledrejection', hN),
    pN());
}
s(Uh, 'setup');
Uh();
const { createBrowserChannel: G3 } = __STORYBOOK_MODULE_CHANNELS__,
  { addons: W3 } = __STORYBOOK_MODULE_PREVIEW_API__,
  Vh = G3({ page: 'preview' });
W3.setChannel(Vh);
window.__STORYBOOK_ADDONS_CHANNEL__ = Vh;
window.CONFIG_TYPE === 'DEVELOPMENT' && (window.__STORYBOOK_SERVER_CHANNEL__ = Vh);
var K3 = Object.create,
  Hh = Object.defineProperty,
  Y3 = Object.getOwnPropertyDescriptor,
  gN = Object.getOwnPropertyNames,
  X3 = Object.getPrototypeOf,
  Q3 = Object.prototype.hasOwnProperty,
  O = (e, t) => Hh(e, 'name', { value: t, configurable: !0 }),
  Z3 = (e, t) =>
    function () {
      return (t || (0, e[gN(e)[0]])((t = { exports: {} }).exports, t), t.exports);
    },
  ez = (e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let o of gN(t))
        !Q3.call(e, o) &&
          o !== r &&
          Hh(e, o, { get: () => t[o], enumerable: !(n = Y3(t, o)) || n.enumerable });
    return e;
  },
  tz = (e, t, r) => (
    (r = e != null ? K3(X3(e)) : {}),
    ez(Hh(r, 'default', { value: e, enumerable: !0 }), e)
  );
function ca(e) {
  if (!e || typeof e != 'object') return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null
    ? Object.prototype.toString.call(e) === '[object Object]'
    : !1;
}
O(ca, 'isPlainObject');
function rz(e) {
  return e == null || (typeof e != 'object' && typeof e != 'function');
}
O(rz, 'isPrimitive');
function nz(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
O(nz, 'isTypedArray');
function oz(e) {
  return Object.getOwnPropertySymbols(e).filter((t) =>
    Object.prototype.propertyIsEnumerable.call(e, t),
  );
}
O(oz, 'getSymbols');
function sz(e) {
  return e == null
    ? e === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(e);
}
O(sz, 'getTag');
var iz = Z3({
  '../node_modules/jsdoc-type-pratt-parser/dist/index.js'(e, t) {
    (function (r, n) {
      typeof e == 'object' && typeof t < 'u'
        ? n(e)
        : typeof define == 'function' && define.amd
          ? define(['exports'], n)
          : ((r = typeof globalThis < 'u' ? globalThis : r || self), n((r.jtpp = {})));
    })(e, function (r) {
      function n(l) {
        return l.text !== void 0 && l.text !== ''
          ? `'${l.type}' with value '${l.text}'`
          : `'${l.type}'`;
      }
      O(n, 'tokenToString');
      const o = class bN extends Error {
        constructor(y) {
          (super(`No parslet found for token: ${n(y)}`),
            (this.token = y),
            Object.setPrototypeOf(this, bN.prototype));
        }
        getToken() {
          return this.token;
        }
      };
      O(o, 'NoParsletFoundError');
      let i = o;
      const a = class vN extends Error {
        constructor(y) {
          (super(`The parsing ended early. The next token was: ${n(y)}`),
            (this.token = y),
            Object.setPrototypeOf(this, vN.prototype));
        }
        getToken() {
          return this.token;
        }
      };
      O(a, 'EarlyEndOfParseError');
      let c = a;
      const d = class TN extends Error {
        constructor(y, T) {
          let C = `Unexpected type: '${y.type}'.`;
          (T !== void 0 && (C += ` Message: ${T}`),
            super(C),
            Object.setPrototypeOf(this, TN.prototype));
        }
      };
      O(d, 'UnexpectedTypeError');
      let u = d;
      function p(l) {
        return (y) => (y.startsWith(l) ? { type: l, text: l } : null);
      }
      O(p, 'makePunctuationRule');
      function f(l) {
        let y = 0,
          T;
        const C = l[0];
        let L = !1;
        if (C !== "'" && C !== '"') return null;
        for (; y < l.length; ) {
          if ((y++, (T = l[y]), !L && T === C)) {
            y++;
            break;
          }
          L = !L && T === '\\';
        }
        if (T !== C) throw new Error('Unterminated String');
        return l.slice(0, y);
      }
      O(f, 'getQuoted');
      const m = new RegExp(
          '[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
          'u',
        ),
        h = new RegExp(
          '[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
          'u',
        );
      function g(l) {
        let y = l[0];
        if (!m.test(y)) return null;
        let T = 1;
        do {
          if (((y = l[T]), !h.test(y))) break;
          T++;
        } while (T < l.length);
        return l.slice(0, T);
      }
      O(g, 'getIdentifier');
      const v = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function E(l) {
        var y, T;
        return (T = (y = v.exec(l)) === null || y === void 0 ? void 0 : y[0]) !== null &&
          T !== void 0
          ? T
          : null;
      }
      O(E, 'getNumber');
      const b = O((l) => {
        const y = g(l);
        return y == null ? null : { type: 'Identifier', text: y };
      }, 'identifierRule');
      function S(l) {
        return (y) => {
          if (!y.startsWith(l)) return null;
          const T = y[l.length];
          return T !== void 0 && h.test(T) ? null : { type: l, text: l };
        };
      }
      O(S, 'makeKeyWordRule');
      const R = O((l) => {
          const y = f(l);
          return y == null ? null : { type: 'StringValue', text: y };
        }, 'stringValueRule'),
        I = O((l) => (l.length > 0 ? null : { type: 'EOF', text: '' }), 'eofRule'),
        q = O((l) => {
          const y = E(l);
          return y === null ? null : { type: 'Number', text: y };
        }, 'numberRule'),
        P = [
          I,
          p('=>'),
          p('('),
          p(')'),
          p('{'),
          p('}'),
          p('['),
          p(']'),
          p('|'),
          p('&'),
          p('<'),
          p('>'),
          p(','),
          p(';'),
          p('*'),
          p('?'),
          p('!'),
          p('='),
          p(':'),
          p('...'),
          p('.'),
          p('#'),
          p('~'),
          p('/'),
          p('@'),
          S('undefined'),
          S('null'),
          S('function'),
          S('this'),
          S('new'),
          S('module'),
          S('event'),
          S('extends'),
          S('external'),
          S('infer'),
          S('typeof'),
          S('keyof'),
          S('readonly'),
          S('import'),
          S('is'),
          S('in'),
          S('asserts'),
          q,
          b,
          R,
        ],
        A = /^\s*\n\s*/,
        w = class ua {
          static create(y) {
            const T = this.read(y);
            y = T.text;
            const C = this.read(y);
            return ((y = C.text), new ua(y, void 0, T.token, C.token));
          }
          constructor(y, T, C, L) {
            ((this.text = ''),
              (this.text = y),
              (this.previous = T),
              (this.current = C),
              (this.next = L));
          }
          static read(y, T = !1) {
            ((T = T || A.test(y)), (y = y.trim()));
            for (const C of P) {
              const L = C(y);
              if (L !== null) {
                const G = Object.assign(Object.assign({}, L), { startOfLine: T });
                return ((y = y.slice(G.text.length)), { text: y, token: G });
              }
            }
            throw new Error('Unexpected Token ' + y);
          }
          advance() {
            const y = ua.read(this.text);
            return new ua(y.text, this.current, this.next, y.token);
          }
        };
      O(w, 'Lexer');
      let _ = w;
      function $(l) {
        if (l === void 0) throw new Error('Unexpected undefined');
        if (
          l.type === 'JsdocTypeKeyValue' ||
          l.type === 'JsdocTypeParameterList' ||
          l.type === 'JsdocTypeProperty' ||
          l.type === 'JsdocTypeReadonlyProperty' ||
          l.type === 'JsdocTypeObjectField' ||
          l.type === 'JsdocTypeJsdocObjectField' ||
          l.type === 'JsdocTypeIndexSignature' ||
          l.type === 'JsdocTypeMappedType' ||
          l.type === 'JsdocTypeTypeParameter'
        )
          throw new u(l);
        return l;
      }
      O($, 'assertRootResult');
      function N(l) {
        return l.type === 'JsdocTypeKeyValue' ? H(l) : $(l);
      }
      O(N, 'assertPlainKeyValueOrRootResult');
      function V(l) {
        return l.type === 'JsdocTypeName' ? l : H(l);
      }
      O(V, 'assertPlainKeyValueOrNameResult');
      function H(l) {
        if (l.type !== 'JsdocTypeKeyValue') throw new u(l);
        return l;
      }
      O(H, 'assertPlainKeyValueResult');
      function x(l) {
        var y;
        if (l.type === 'JsdocTypeVariadic') {
          if (((y = l.element) === null || y === void 0 ? void 0 : y.type) === 'JsdocTypeName')
            return l;
          throw new u(l);
        }
        if (l.type !== 'JsdocTypeNumber' && l.type !== 'JsdocTypeName') throw new u(l);
        return l;
      }
      O(x, 'assertNumberOrVariadicNameResult');
      function D(l) {
        if (
          l.type === 'JsdocTypeTuple' ||
          (l.type === 'JsdocTypeGeneric' && l.meta.brackets === 'square')
        )
          return l;
        throw new u(l);
      }
      O(D, 'assertArrayOrTupleResult');
      function F(l) {
        return l.type === 'JsdocTypeIndexSignature' || l.type === 'JsdocTypeMappedType';
      }
      O(F, 'isSquaredProperty');
      var k;
      (function (l) {
        ((l[(l.ALL = 0)] = 'ALL'),
          (l[(l.PARAMETER_LIST = 1)] = 'PARAMETER_LIST'),
          (l[(l.OBJECT = 2)] = 'OBJECT'),
          (l[(l.KEY_VALUE = 3)] = 'KEY_VALUE'),
          (l[(l.INDEX_BRACKETS = 4)] = 'INDEX_BRACKETS'),
          (l[(l.UNION = 5)] = 'UNION'),
          (l[(l.INTERSECTION = 6)] = 'INTERSECTION'),
          (l[(l.PREFIX = 7)] = 'PREFIX'),
          (l[(l.INFIX = 8)] = 'INFIX'),
          (l[(l.TUPLE = 9)] = 'TUPLE'),
          (l[(l.SYMBOL = 10)] = 'SYMBOL'),
          (l[(l.OPTIONAL = 11)] = 'OPTIONAL'),
          (l[(l.NULLABLE = 12)] = 'NULLABLE'),
          (l[(l.KEY_OF_TYPE_OF = 13)] = 'KEY_OF_TYPE_OF'),
          (l[(l.FUNCTION = 14)] = 'FUNCTION'),
          (l[(l.ARROW = 15)] = 'ARROW'),
          (l[(l.ARRAY_BRACKETS = 16)] = 'ARRAY_BRACKETS'),
          (l[(l.GENERIC = 17)] = 'GENERIC'),
          (l[(l.NAME_PATH = 18)] = 'NAME_PATH'),
          (l[(l.PARENTHESIS = 19)] = 'PARENTHESIS'),
          (l[(l.SPECIAL_TYPES = 20)] = 'SPECIAL_TYPES'));
      })(k || (k = {}));
      const K = class {
        constructor(y, T, C) {
          ((this.grammar = y),
            typeof T == 'string' ? (this._lexer = _.create(T)) : (this._lexer = T),
            (this.baseParser = C));
        }
        get lexer() {
          return this._lexer;
        }
        parse() {
          const y = this.parseType(k.ALL);
          if (this.lexer.current.type !== 'EOF') throw new c(this.lexer.current);
          return y;
        }
        parseType(y) {
          return $(this.parseIntermediateType(y));
        }
        parseIntermediateType(y) {
          const T = this.tryParslets(null, y);
          if (T === null) throw new i(this.lexer.current);
          return this.parseInfixIntermediateType(T, y);
        }
        parseInfixIntermediateType(y, T) {
          let C = this.tryParslets(y, T);
          for (; C !== null; ) ((y = C), (C = this.tryParslets(y, T)));
          return y;
        }
        tryParslets(y, T) {
          for (const C of this.grammar) {
            const L = C(this, T, y);
            if (L !== null) return L;
          }
          return null;
        }
        consume(y) {
          return (
            Array.isArray(y) || (y = [y]),
            y.includes(this.lexer.current.type) ? ((this._lexer = this.lexer.advance()), !0) : !1
          );
        }
        acceptLexerState(y) {
          this._lexer = y.lexer;
        }
      };
      O(K, 'Parser');
      let X = K;
      function se(l) {
        return l === '}' || l === 'EOF' || l === '|' || l === ',' || l === ')' || l === '>';
      }
      O(se, 'isQuestionMarkUnknownType');
      const ie = O((l, y, T) => {
        const C = l.lexer.current.type,
          L = l.lexer.next.type;
        return (T == null && C === '?' && !se(L)) || (T != null && C === '?')
          ? (l.consume('?'),
            T == null
              ? {
                  type: 'JsdocTypeNullable',
                  element: l.parseType(k.NULLABLE),
                  meta: { position: 'prefix' },
                }
              : { type: 'JsdocTypeNullable', element: $(T), meta: { position: 'suffix' } })
          : null;
      }, 'nullableParslet');
      function W(l) {
        const y = O((T, C, L) => {
          const G = T.lexer.current.type,
            Z = T.lexer.next.type;
          if (L === null) {
            if ('parsePrefix' in l && l.accept(G, Z)) return l.parsePrefix(T);
          } else if ('parseInfix' in l && l.precedence > C && l.accept(G, Z))
            return l.parseInfix(T, L);
          return null;
        }, 'parslet');
        return (Object.defineProperty(y, 'name', { value: l.name }), y);
      }
      O(W, 'composeParslet');
      const ae = W({
          name: 'optionalParslet',
          accept: O((l) => l === '=', 'accept'),
          precedence: k.OPTIONAL,
          parsePrefix: O(
            (l) => (
              l.consume('='),
              {
                type: 'JsdocTypeOptional',
                element: l.parseType(k.OPTIONAL),
                meta: { position: 'prefix' },
              }
            ),
            'parsePrefix',
          ),
          parseInfix: O(
            (l, y) => (
              l.consume('='),
              { type: 'JsdocTypeOptional', element: $(y), meta: { position: 'suffix' } }
            ),
            'parseInfix',
          ),
        }),
        be = W({
          name: 'numberParslet',
          accept: O((l) => l === 'Number', 'accept'),
          parsePrefix: O((l) => {
            const y = parseFloat(l.lexer.current.text);
            return (l.consume('Number'), { type: 'JsdocTypeNumber', value: y });
          }, 'parsePrefix'),
        }),
        ue = W({
          name: 'parenthesisParslet',
          accept: O((l) => l === '(', 'accept'),
          parsePrefix: O((l) => {
            if ((l.consume('('), l.consume(')')))
              return { type: 'JsdocTypeParameterList', elements: [] };
            const y = l.parseIntermediateType(k.ALL);
            if (!l.consume(')')) throw new Error('Unterminated parenthesis');
            return y.type === 'JsdocTypeParameterList'
              ? y
              : y.type === 'JsdocTypeKeyValue'
                ? { type: 'JsdocTypeParameterList', elements: [y] }
                : { type: 'JsdocTypeParenthesis', element: $(y) };
          }, 'parsePrefix'),
        }),
        ee = W({
          name: 'specialTypesParslet',
          accept: O(
            (l, y) => (l === '?' && se(y)) || l === 'null' || l === 'undefined' || l === '*',
            'accept',
          ),
          parsePrefix: O((l) => {
            if (l.consume('null')) return { type: 'JsdocTypeNull' };
            if (l.consume('undefined')) return { type: 'JsdocTypeUndefined' };
            if (l.consume('*')) return { type: 'JsdocTypeAny' };
            if (l.consume('?')) return { type: 'JsdocTypeUnknown' };
            throw new Error('Unacceptable token: ' + l.lexer.current.text);
          }, 'parsePrefix'),
        }),
        xe = W({
          name: 'notNullableParslet',
          accept: O((l) => l === '!', 'accept'),
          precedence: k.NULLABLE,
          parsePrefix: O(
            (l) => (
              l.consume('!'),
              {
                type: 'JsdocTypeNotNullable',
                element: l.parseType(k.NULLABLE),
                meta: { position: 'prefix' },
              }
            ),
            'parsePrefix',
          ),
          parseInfix: O(
            (l, y) => (
              l.consume('!'),
              { type: 'JsdocTypeNotNullable', element: $(y), meta: { position: 'suffix' } }
            ),
            'parseInfix',
          ),
        });
      function Pe({ allowTrailingComma: l }) {
        return W({
          name: 'parameterListParslet',
          accept: O((y) => y === ',', 'accept'),
          precedence: k.PARAMETER_LIST,
          parseInfix: O((y, T) => {
            const C = [N(T)];
            y.consume(',');
            do
              try {
                const L = y.parseIntermediateType(k.PARAMETER_LIST);
                C.push(N(L));
              } catch (L) {
                if (L instanceof i) break;
                throw L;
              }
            while (y.consume(','));
            if (C.length > 0 && C.slice(0, -1).some((L) => L.type === 'JsdocTypeVariadic'))
              throw new Error('Only the last parameter may be a rest parameter');
            return { type: 'JsdocTypeParameterList', elements: C };
          }, 'parseInfix'),
        });
      }
      O(Pe, 'createParameterListParslet');
      const He = W({
          name: 'genericParslet',
          accept: O((l, y) => l === '<' || (l === '.' && y === '<'), 'accept'),
          precedence: k.GENERIC,
          parseInfix: O((l, y) => {
            const T = l.consume('.');
            l.consume('<');
            const C = [];
            let L = !1;
            if (l.consume('infer')) {
              L = !0;
              const G = l.parseIntermediateType(k.SYMBOL);
              if (G.type !== 'JsdocTypeName')
                throw new u(G, 'A typescript asserts always has to have a name on the left side.');
              C.push(G);
            } else
              do C.push(l.parseType(k.PARAMETER_LIST));
              while (l.consume(','));
            if (!l.consume('>')) throw new Error('Unterminated generic parameter list');
            return Object.assign(
              Object.assign(
                { type: 'JsdocTypeGeneric', left: $(y), elements: C },
                L ? { infer: !0 } : {},
              ),
              { meta: { brackets: 'angle', dot: T } },
            );
          }, 'parseInfix'),
        }),
        Ke = W({
          name: 'unionParslet',
          accept: O((l) => l === '|', 'accept'),
          precedence: k.UNION,
          parseInfix: O((l, y) => {
            l.consume('|');
            const T = [];
            do T.push(l.parseType(k.UNION));
            while (l.consume('|'));
            return { type: 'JsdocTypeUnion', elements: [$(y), ...T] };
          }, 'parseInfix'),
        }),
        J = [ie, ae, be, ue, ee, xe, Pe({ allowTrailingComma: !0 }), He, Ke, ae];
      function Q({ allowSquareBracketsOnAnyType: l, allowJsdocNamePaths: y, pathGrammar: T }) {
        return O(function (L, G, Z) {
          if (Z == null || G >= k.NAME_PATH) return null;
          const ce = L.lexer.current.type,
            _e = L.lexer.next.type;
          if (
            !(
              (ce === '.' && _e !== '<') ||
              (ce === '[' && (l || Z.type === 'JsdocTypeName')) ||
              (y && (ce === '~' || ce === '#'))
            )
          )
            return null;
          let qe,
            yr = !1;
          L.consume('.')
            ? (qe = 'property')
            : L.consume('[')
              ? ((qe = 'property-brackets'), (yr = !0))
              : L.consume('~')
                ? (qe = 'inner')
                : (L.consume('#'), (qe = 'instance'));
          const hs = T !== null ? new X(T, L.lexer, L) : L,
            Qe = hs.parseIntermediateType(k.NAME_PATH);
          L.acceptLexerState(hs);
          let Vt;
          switch (Qe.type) {
            case 'JsdocTypeName':
              Vt = { type: 'JsdocTypeProperty', value: Qe.value, meta: { quote: void 0 } };
              break;
            case 'JsdocTypeNumber':
              Vt = {
                type: 'JsdocTypeProperty',
                value: Qe.value.toString(10),
                meta: { quote: void 0 },
              };
              break;
            case 'JsdocTypeStringValue':
              Vt = { type: 'JsdocTypeProperty', value: Qe.value, meta: { quote: Qe.meta.quote } };
              break;
            case 'JsdocTypeSpecialNamePath':
              if (Qe.specialType === 'event') Vt = Qe;
              else
                throw new u(
                  Qe,
                  "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'",
                );
              break;
            default:
              throw new u(
                Qe,
                "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'",
              );
          }
          if (yr && !L.consume(']')) {
            const gs = L.lexer.current;
            throw new Error(
              `Unterminated square brackets. Next token is '${gs.type}' with text '${gs.text}'`,
            );
          }
          return { type: 'JsdocTypeNamePath', left: $(Z), right: Vt, pathType: qe };
        }, 'namePathParslet');
      }
      O(Q, 'createNamePathParslet');
      function re({ allowedAdditionalTokens: l }) {
        return W({
          name: 'nameParslet',
          accept: O(
            (y) => y === 'Identifier' || y === 'this' || y === 'new' || l.includes(y),
            'accept',
          ),
          parsePrefix: O((y) => {
            const { type: T, text: C } = y.lexer.current;
            return (y.consume(T), { type: 'JsdocTypeName', value: C });
          }, 'parsePrefix'),
        });
      }
      O(re, 'createNameParslet');
      const oe = W({
        name: 'stringValueParslet',
        accept: O((l) => l === 'StringValue', 'accept'),
        parsePrefix: O((l) => {
          const y = l.lexer.current.text;
          return (
            l.consume('StringValue'),
            {
              type: 'JsdocTypeStringValue',
              value: y.slice(1, -1),
              meta: { quote: y[0] === "'" ? 'single' : 'double' },
            }
          );
        }, 'parsePrefix'),
      });
      function ne({ pathGrammar: l, allowedTypes: y }) {
        return W({
          name: 'specialNamePathParslet',
          accept: O((T) => y.includes(T), 'accept'),
          parsePrefix: O((T) => {
            const C = T.lexer.current.type;
            if ((T.consume(C), !T.consume(':'))) return { type: 'JsdocTypeName', value: C };
            let L,
              G = T.lexer.current;
            if (T.consume('StringValue'))
              L = {
                type: 'JsdocTypeSpecialNamePath',
                value: G.text.slice(1, -1),
                specialType: C,
                meta: { quote: G.text[0] === "'" ? 'single' : 'double' },
              };
            else {
              let _e = '';
              const Te = ['Identifier', '@', '/'];
              for (; Te.some((qe) => T.consume(qe)); ) ((_e += G.text), (G = T.lexer.current));
              L = {
                type: 'JsdocTypeSpecialNamePath',
                value: _e,
                specialType: C,
                meta: { quote: void 0 },
              };
            }
            const Z = new X(l, T.lexer, T),
              ce = Z.parseInfixIntermediateType(L, k.ALL);
            return (T.acceptLexerState(Z), $(ce));
          }, 'parsePrefix'),
        });
      }
      O(ne, 'createSpecialNamePathParslet');
      const de = [
          re({ allowedAdditionalTokens: ['external', 'module'] }),
          oe,
          be,
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: null }),
        ],
        ye = [...de, ne({ allowedTypes: ['event'], pathGrammar: de })];
      function pe(l) {
        let y;
        if (l.type === 'JsdocTypeParameterList') y = l.elements;
        else if (l.type === 'JsdocTypeParenthesis') y = [l.element];
        else throw new u(l);
        return y.map((T) => N(T));
      }
      O(pe, 'getParameters');
      function Fe(l) {
        const y = pe(l);
        if (y.some((T) => T.type === 'JsdocTypeKeyValue'))
          throw new Error('No parameter should be named');
        return y;
      }
      O(Fe, 'getUnnamedParameters');
      function ot({
        allowNamedParameters: l,
        allowNoReturnType: y,
        allowWithoutParenthesis: T,
        allowNewAsFunctionKeyword: C,
      }) {
        return W({
          name: 'functionParslet',
          accept: O((L, G) => L === 'function' || (C && L === 'new' && G === '('), 'accept'),
          parsePrefix: O((L) => {
            const G = L.consume('new');
            L.consume('function');
            const Z = L.lexer.current.type === '(';
            if (!Z) {
              if (!T) throw new Error('function is missing parameter list');
              return { type: 'JsdocTypeName', value: 'function' };
            }
            let ce = {
              type: 'JsdocTypeFunction',
              parameters: [],
              arrow: !1,
              constructor: G,
              parenthesis: Z,
            };
            const _e = L.parseIntermediateType(k.FUNCTION);
            if (l === void 0) ce.parameters = Fe(_e);
            else {
              if (G && _e.type === 'JsdocTypeFunction' && _e.arrow)
                return ((ce = _e), (ce.constructor = !0), ce);
              ce.parameters = pe(_e);
              for (const Te of ce.parameters)
                if (Te.type === 'JsdocTypeKeyValue' && !l.includes(Te.key))
                  throw new Error(
                    `only allowed named parameters are ${l.join(', ')} but got ${Te.type}`,
                  );
            }
            if (L.consume(':')) ce.returnType = L.parseType(k.PREFIX);
            else if (!y) throw new Error('function is missing return type');
            return ce;
          }, 'parsePrefix'),
        });
      }
      O(ot, 'createFunctionParslet');
      function ft({ allowPostfix: l, allowEnclosingBrackets: y }) {
        return W({
          name: 'variadicParslet',
          accept: O((T) => T === '...', 'accept'),
          precedence: k.PREFIX,
          parsePrefix: O((T) => {
            T.consume('...');
            const C = y && T.consume('[');
            try {
              const L = T.parseType(k.PREFIX);
              if (C && !T.consume(']')) throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: 'JsdocTypeVariadic',
                element: $(L),
                meta: { position: 'prefix', squareBrackets: C },
              };
            } catch (L) {
              if (L instanceof i) {
                if (C) throw new Error('Empty square brackets for variadic are not allowed.');
                return {
                  type: 'JsdocTypeVariadic',
                  meta: { position: void 0, squareBrackets: !1 },
                };
              } else throw L;
            }
          }, 'parsePrefix'),
          parseInfix: l
            ? (T, C) => (
                T.consume('...'),
                {
                  type: 'JsdocTypeVariadic',
                  element: $(C),
                  meta: { position: 'suffix', squareBrackets: !1 },
                }
              )
            : void 0,
        });
      }
      O(ft, 'createVariadicParslet');
      const _t = W({
          name: 'symbolParslet',
          accept: O((l) => l === '(', 'accept'),
          precedence: k.SYMBOL,
          parseInfix: O((l, y) => {
            if (y.type !== 'JsdocTypeName')
              throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
            l.consume('(');
            const T = { type: 'JsdocTypeSymbol', value: y.value };
            if (!l.consume(')')) {
              const C = l.parseIntermediateType(k.SYMBOL);
              if (((T.element = x(C)), !l.consume(')')))
                throw new Error('Symbol does not end after value');
            }
            return T;
          }, 'parseInfix'),
        }),
        st = W({
          name: 'arrayBracketsParslet',
          precedence: k.ARRAY_BRACKETS,
          accept: O((l, y) => l === '[' && y === ']', 'accept'),
          parseInfix: O(
            (l, y) => (
              l.consume('['),
              l.consume(']'),
              {
                type: 'JsdocTypeGeneric',
                left: { type: 'JsdocTypeName', value: 'Array' },
                elements: [$(y)],
                meta: { brackets: 'square', dot: !1 },
              }
            ),
            'parseInfix',
          ),
        });
      function mt({ objectFieldGrammar: l, allowKeyTypes: y }) {
        return W({
          name: 'objectParslet',
          accept: O((T) => T === '{', 'accept'),
          parsePrefix: O((T) => {
            T.consume('{');
            const C = { type: 'JsdocTypeObject', meta: { separator: 'comma' }, elements: [] };
            if (!T.consume('}')) {
              let L;
              const G = new X(l, T.lexer, T);
              for (;;) {
                G.acceptLexerState(T);
                let Z = G.parseIntermediateType(k.OBJECT);
                (T.acceptLexerState(G),
                  Z === void 0 && y && (Z = T.parseIntermediateType(k.OBJECT)));
                let ce = !1;
                if (
                  (Z.type === 'JsdocTypeNullable' && ((ce = !0), (Z = Z.element)),
                  Z.type === 'JsdocTypeNumber' ||
                    Z.type === 'JsdocTypeName' ||
                    Z.type === 'JsdocTypeStringValue')
                ) {
                  let Te;
                  (Z.type === 'JsdocTypeStringValue' && (Te = Z.meta.quote),
                    C.elements.push({
                      type: 'JsdocTypeObjectField',
                      key: Z.value.toString(),
                      right: void 0,
                      optional: ce,
                      readonly: !1,
                      meta: { quote: Te },
                    }));
                } else if (
                  Z.type === 'JsdocTypeObjectField' ||
                  Z.type === 'JsdocTypeJsdocObjectField'
                )
                  C.elements.push(Z);
                else throw new u(Z);
                if (T.lexer.current.startOfLine)
                  ((L = 'linebreak'), T.consume(',') || T.consume(';'));
                else if (T.consume(',')) L = 'comma';
                else if (T.consume(';')) L = 'semicolon';
                else break;
                if (T.lexer.current.type === '}') break;
              }
              if (
                ((C.meta.separator = L ?? 'comma'),
                L === 'linebreak' && (C.meta.propertyIndent = '  '),
                !T.consume('}'))
              )
                throw new Error("Unterminated record type. Missing '}'");
            }
            return C;
          }, 'parsePrefix'),
        });
      }
      O(mt, 'createObjectParslet');
      function yt({
        allowSquaredProperties: l,
        allowKeyTypes: y,
        allowReadonly: T,
        allowOptional: C,
      }) {
        return W({
          name: 'objectFieldParslet',
          precedence: k.KEY_VALUE,
          accept: O((L) => L === ':', 'accept'),
          parseInfix: O((L, G) => {
            var Z;
            let ce = !1,
              _e = !1;
            (C && G.type === 'JsdocTypeNullable' && ((ce = !0), (G = G.element)),
              T && G.type === 'JsdocTypeReadonlyProperty' && ((_e = !0), (G = G.element)));
            const Te = (Z = L.baseParser) !== null && Z !== void 0 ? Z : L;
            if (
              (Te.acceptLexerState(L),
              G.type === 'JsdocTypeNumber' ||
                G.type === 'JsdocTypeName' ||
                G.type === 'JsdocTypeStringValue' ||
                F(G))
            ) {
              if (F(G) && !l) throw new u(G);
              Te.consume(':');
              let qe;
              G.type === 'JsdocTypeStringValue' && (qe = G.meta.quote);
              const yr = Te.parseType(k.KEY_VALUE);
              return (
                L.acceptLexerState(Te),
                {
                  type: 'JsdocTypeObjectField',
                  key: F(G) ? G : G.value.toString(),
                  right: yr,
                  optional: ce,
                  readonly: _e,
                  meta: { quote: qe },
                }
              );
            } else {
              if (!y) throw new u(G);
              Te.consume(':');
              const qe = Te.parseType(k.KEY_VALUE);
              return (
                L.acceptLexerState(Te),
                { type: 'JsdocTypeJsdocObjectField', left: $(G), right: qe }
              );
            }
          }, 'parseInfix'),
        });
      }
      O(yt, 'createObjectFieldParslet');
      function ht({ allowOptional: l, allowVariadic: y }) {
        return W({
          name: 'keyValueParslet',
          precedence: k.KEY_VALUE,
          accept: O((T) => T === ':', 'accept'),
          parseInfix: O((T, C) => {
            let L = !1,
              G = !1;
            if (
              (l && C.type === 'JsdocTypeNullable' && ((L = !0), (C = C.element)),
              y &&
                C.type === 'JsdocTypeVariadic' &&
                C.element !== void 0 &&
                ((G = !0), (C = C.element)),
              C.type !== 'JsdocTypeName')
            )
              throw new u(C);
            T.consume(':');
            const Z = T.parseType(k.KEY_VALUE);
            return { type: 'JsdocTypeKeyValue', key: C.value, right: Z, optional: L, variadic: G };
          }, 'parseInfix'),
        });
      }
      O(ht, 'createKeyValueParslet');
      const sn = [
          ...J,
          ot({
            allowWithoutParenthesis: !0,
            allowNamedParameters: ['this', 'new'],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1,
          }),
          oe,
          ne({ allowedTypes: ['module', 'external', 'event'], pathGrammar: ye }),
          ft({ allowEnclosingBrackets: !0, allowPostfix: !0 }),
          re({ allowedAdditionalTokens: ['keyof'] }),
          _t,
          st,
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
        ],
        Go = [
          ...sn,
          mt({
            objectFieldGrammar: [
              re({ allowedAdditionalTokens: ['typeof', 'module', 'in'] }),
              yt({
                allowSquaredProperties: !1,
                allowKeyTypes: !0,
                allowOptional: !1,
                allowReadonly: !1,
              }),
              ...sn,
            ],
            allowKeyTypes: !0,
          }),
          ht({ allowOptional: !0, allowVariadic: !0 }),
        ],
        an = W({
          name: 'typeOfParslet',
          accept: O((l) => l === 'typeof', 'accept'),
          parsePrefix: O(
            (l) => (
              l.consume('typeof'),
              { type: 'JsdocTypeTypeof', element: l.parseType(k.KEY_OF_TYPE_OF) }
            ),
            'parsePrefix',
          ),
        }),
        Wo = [
          re({ allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'] }),
          ie,
          ae,
          oe,
          be,
          yt({
            allowSquaredProperties: !1,
            allowKeyTypes: !1,
            allowOptional: !1,
            allowReadonly: !1,
          }),
        ],
        Ko = [
          ...J,
          mt({ allowKeyTypes: !1, objectFieldGrammar: Wo }),
          re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
          an,
          ot({
            allowWithoutParenthesis: !1,
            allowNamedParameters: ['this', 'new'],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1,
          }),
          ft({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
          re({ allowedAdditionalTokens: ['keyof'] }),
          ne({ allowedTypes: ['module'], pathGrammar: ye }),
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
          ht({ allowOptional: !1, allowVariadic: !1 }),
          _t,
        ],
        Yo = W({
          name: 'assertsParslet',
          accept: O((l) => l === 'asserts', 'accept'),
          parsePrefix: O((l) => {
            l.consume('asserts');
            const y = l.parseIntermediateType(k.SYMBOL);
            if (y.type !== 'JsdocTypeName')
              throw new u(y, 'A typescript asserts always has to have a name on the left side.');
            return l.consume('is')
              ? { type: 'JsdocTypeAsserts', left: y, right: $(l.parseIntermediateType(k.INFIX)) }
              : { type: 'JsdocTypeAssertsPlain', element: y };
          }, 'parsePrefix'),
        });
      function ln({ allowQuestionMark: l }) {
        return W({
          name: 'tupleParslet',
          accept: O((y) => y === '[', 'accept'),
          parsePrefix: O((y) => {
            y.consume('[');
            const T = { type: 'JsdocTypeTuple', elements: [] };
            if (y.consume(']')) return T;
            const C = y.parseIntermediateType(k.ALL);
            if (
              (C.type === 'JsdocTypeParameterList'
                ? C.elements[0].type === 'JsdocTypeKeyValue'
                  ? (T.elements = C.elements.map(H))
                  : (T.elements = C.elements.map($))
                : C.type === 'JsdocTypeKeyValue'
                  ? (T.elements = [H(C)])
                  : (T.elements = [$(C)]),
              !y.consume(']'))
            )
              throw new Error("Unterminated '['");
            if (T.elements.some((L) => L.type === 'JsdocTypeUnknown'))
              throw new Error('Question mark in tuple not allowed');
            return T;
          }, 'parsePrefix'),
        });
      }
      O(ln, 'createTupleParslet');
      const Xo = W({
          name: 'keyOfParslet',
          accept: O((l) => l === 'keyof', 'accept'),
          parsePrefix: O(
            (l) => (
              l.consume('keyof'),
              { type: 'JsdocTypeKeyof', element: $(l.parseType(k.KEY_OF_TYPE_OF)) }
            ),
            'parsePrefix',
          ),
        }),
        Qo = W({
          name: 'importParslet',
          accept: O((l) => l === 'import', 'accept'),
          parsePrefix: O((l) => {
            if ((l.consume('import'), !l.consume('(')))
              throw new Error('Missing parenthesis after import keyword');
            const y = l.parseType(k.PREFIX);
            if (y.type !== 'JsdocTypeStringValue')
              throw new Error('Only string values are allowed as paths for imports');
            if (!l.consume(')'))
              throw new Error('Missing closing parenthesis after import keyword');
            return { type: 'JsdocTypeImport', element: y };
          }, 'parsePrefix'),
        }),
        Zo = W({
          name: 'readonlyPropertyParslet',
          accept: O((l) => l === 'readonly', 'accept'),
          parsePrefix: O(
            (l) => (
              l.consume('readonly'),
              { type: 'JsdocTypeReadonlyProperty', element: l.parseIntermediateType(k.KEY_VALUE) }
            ),
            'parsePrefix',
          ),
        }),
        es = W({
          name: 'arrowFunctionParslet',
          precedence: k.ARROW,
          accept: O((l) => l === '=>', 'accept'),
          parseInfix: O(
            (l, y) => (
              l.consume('=>'),
              {
                type: 'JsdocTypeFunction',
                parameters: pe(y).map(V),
                arrow: !0,
                constructor: !1,
                parenthesis: !0,
                returnType: l.parseType(k.OBJECT),
              }
            ),
            'parseInfix',
          ),
        }),
        ts = W({
          name: 'genericArrowFunctionParslet',
          accept: O((l) => l === '<', 'accept'),
          parsePrefix: O((l) => {
            const y = [];
            l.consume('<');
            do {
              let C,
                L = l.parseIntermediateType(k.SYMBOL);
              if (
                (L.type === 'JsdocTypeOptional' && ((L = L.element), (C = l.parseType(k.SYMBOL))),
                L.type !== 'JsdocTypeName')
              )
                throw new u(L);
              let G;
              l.consume('extends') &&
                ((G = l.parseType(k.SYMBOL)),
                G.type === 'JsdocTypeOptional' && ((G = G.element), (C = l.parseType(k.SYMBOL))));
              const Z = { type: 'JsdocTypeTypeParameter', name: L };
              if (
                (G !== void 0 && (Z.constraint = G),
                C !== void 0 && (Z.defaultValue = C),
                y.push(Z),
                l.consume('>'))
              )
                break;
            } while (l.consume(','));
            const T = l.parseIntermediateType(k.SYMBOL);
            return ((T.typeParameters = y), T);
          }, 'parsePrefix'),
        }),
        rs = W({
          name: 'intersectionParslet',
          accept: O((l) => l === '&', 'accept'),
          precedence: k.INTERSECTION,
          parseInfix: O((l, y) => {
            l.consume('&');
            const T = [];
            do T.push(l.parseType(k.INTERSECTION));
            while (l.consume('&'));
            return { type: 'JsdocTypeIntersection', elements: [$(y), ...T] };
          }, 'parseInfix'),
        }),
        ns = W({
          name: 'predicateParslet',
          precedence: k.INFIX,
          accept: O((l) => l === 'is', 'accept'),
          parseInfix: O((l, y) => {
            if (y.type !== 'JsdocTypeName')
              throw new u(y, 'A typescript predicate always has to have a name on the left side.');
            return (
              l.consume('is'),
              { type: 'JsdocTypePredicate', left: y, right: $(l.parseIntermediateType(k.INFIX)) }
            );
          }, 'parseInfix'),
        }),
        os = W({
          name: 'objectSquareBracketPropertyParslet',
          accept: O((l) => l === '[', 'accept'),
          parsePrefix: O((l) => {
            if (l.baseParser === void 0) throw new Error('Only allowed inside object grammar');
            l.consume('[');
            const y = l.lexer.current.text;
            l.consume('Identifier');
            let T;
            if (l.consume(':')) {
              const C = l.baseParser;
              (C.acceptLexerState(l),
                (T = {
                  type: 'JsdocTypeIndexSignature',
                  key: y,
                  right: C.parseType(k.INDEX_BRACKETS),
                }),
                l.acceptLexerState(C));
            } else if (l.consume('in')) {
              const C = l.baseParser;
              (C.acceptLexerState(l),
                (T = { type: 'JsdocTypeMappedType', key: y, right: C.parseType(k.ARRAY_BRACKETS) }),
                l.acceptLexerState(C));
            } else throw new Error("Missing ':' or 'in' inside square bracketed property.");
            if (!l.consume(']')) throw new Error('Unterminated square brackets');
            return T;
          }, 'parsePrefix'),
        }),
        ss = W({
          name: 'readonlyArrayParslet',
          accept: O((l) => l === 'readonly', 'accept'),
          parsePrefix: O(
            (l) => (
              l.consume('readonly'),
              { type: 'JsdocTypeReadonlyArray', element: D(l.parseIntermediateType(k.ALL)) }
            ),
            'parsePrefix',
          ),
        }),
        is = W({
          name: 'conditionalParslet',
          precedence: k.INFIX,
          accept: O((l) => l === 'extends', 'accept'),
          parseInfix: O((l, y) => {
            l.consume('extends');
            const T = l.parseType(k.KEY_OF_TYPE_OF).element,
              C = l.parseType(k.INFIX);
            return (
              l.consume(':'),
              {
                type: 'JsdocTypeConditional',
                checksType: $(y),
                extendsType: T,
                trueType: C,
                falseType: l.parseType(k.INFIX),
              }
            );
          }, 'parseInfix'),
        }),
        as = [
          Zo,
          re({ allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'] }),
          ie,
          ae,
          oe,
          be,
          yt({
            allowSquaredProperties: !0,
            allowKeyTypes: !1,
            allowOptional: !0,
            allowReadonly: !0,
          }),
          os,
        ],
        ls = [
          ...J,
          mt({ allowKeyTypes: !1, objectFieldGrammar: as }),
          ss,
          an,
          Xo,
          Qo,
          oe,
          ot({
            allowWithoutParenthesis: !0,
            allowNoReturnType: !1,
            allowNamedParameters: ['this', 'new', 'args'],
            allowNewAsFunctionKeyword: !0,
          }),
          ln({ allowQuestionMark: !1 }),
          ft({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
          Yo,
          is,
          re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
          ne({ allowedTypes: ['module'], pathGrammar: ye }),
          st,
          es,
          ts,
          Q({ allowSquareBracketsOnAnyType: !0, allowJsdocNamePaths: !1, pathGrammar: ye }),
          rs,
          ns,
          ht({ allowVariadic: !0, allowOptional: !0 }),
        ];
      function pr(l, y) {
        switch (y) {
          case 'closure':
            return new X(Ko, l).parse();
          case 'jsdoc':
            return new X(Go, l).parse();
          case 'typescript':
            return new X(ls, l).parse();
        }
      }
      O(pr, 'parse');
      function cn(l, y = ['typescript', 'closure', 'jsdoc']) {
        let T;
        for (const C of y)
          try {
            return pr(l, C);
          } catch (L) {
            T = L;
          }
        throw T;
      }
      O(cn, 'tryParse');
      function Y(l, y) {
        const T = l[y.type];
        if (T === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${y.type}.`);
        return T(y, (C) => Y(l, C));
      }
      O(Y, 'transform');
      function le(l) {
        throw new Error(
          'This transform is not available. Are you trying the correct parsing mode?',
        );
      }
      O(le, 'notAvailableTransform');
      function Mt(l) {
        const y = { params: [] };
        for (const T of l.parameters)
          T.type === 'JsdocTypeKeyValue'
            ? T.key === 'this'
              ? (y.this = T.right)
              : T.key === 'new'
                ? (y.new = T.right)
                : y.params.push(T)
            : y.params.push(T);
        return y;
      }
      O(Mt, 'extractSpecialParams');
      function Ut(l, y, T) {
        return l === 'prefix' ? T + y : y + T;
      }
      O(Ut, 'applyPosition');
      function Ye(l, y) {
        switch (y) {
          case 'double':
            return `"${l}"`;
          case 'single':
            return `'${l}'`;
          case void 0:
            return l;
        }
      }
      O(Ye, 'quote');
      function un() {
        return {
          JsdocTypeParenthesis: O(
            (l, y) => `(${l.element !== void 0 ? y(l.element) : ''})`,
            'JsdocTypeParenthesis',
          ),
          JsdocTypeKeyof: O((l, y) => `keyof ${y(l.element)}`, 'JsdocTypeKeyof'),
          JsdocTypeFunction: O((l, y) => {
            var T;
            if (l.arrow) {
              if (l.returnType === void 0) throw new Error('Arrow function needs a return type.');
              let C = `${l.typeParameters !== void 0 ? `<${(T = l.typeParameters.map(y).join(', ')) !== null && T !== void 0 ? T : ''}>` : ''}(${l.parameters.map(y).join(', ')}) => ${y(l.returnType)}`;
              return (l.constructor && (C = 'new ' + C), C);
            } else {
              let C = l.constructor ? 'new' : 'function';
              return (
                l.parenthesis &&
                  ((C += `(${l.parameters.map(y).join(', ')})`),
                  l.returnType !== void 0 && (C += `: ${y(l.returnType)}`)),
                C
              );
            }
          }, 'JsdocTypeFunction'),
          JsdocTypeName: O((l) => l.value, 'JsdocTypeName'),
          JsdocTypeTuple: O((l, y) => `[${l.elements.map(y).join(', ')}]`, 'JsdocTypeTuple'),
          JsdocTypeVariadic: O(
            (l, y) =>
              l.meta.position === void 0 ? '...' : Ut(l.meta.position, y(l.element), '...'),
            'JsdocTypeVariadic',
          ),
          JsdocTypeNamePath: O((l, y) => {
            const T = y(l.left),
              C = y(l.right);
            switch (l.pathType) {
              case 'inner':
                return `${T}~${C}`;
              case 'instance':
                return `${T}#${C}`;
              case 'property':
                return `${T}.${C}`;
              case 'property-brackets':
                return `${T}[${C}]`;
            }
          }, 'JsdocTypeNamePath'),
          JsdocTypeStringValue: O((l) => Ye(l.value, l.meta.quote), 'JsdocTypeStringValue'),
          JsdocTypeAny: O(() => '*', 'JsdocTypeAny'),
          JsdocTypeGeneric: O((l, y) => {
            if (l.meta.brackets === 'square') {
              const T = l.elements[0],
                C = y(T);
              return T.type === 'JsdocTypeUnion' || T.type === 'JsdocTypeIntersection'
                ? `(${C})[]`
                : `${C}[]`;
            } else
              return `${y(l.left)}${l.meta.dot ? '.' : ''}<${l.infer === !0 ? 'infer ' : ''}${l.elements.map(y).join(', ')}>`;
          }, 'JsdocTypeGeneric'),
          JsdocTypeImport: O((l, y) => `import(${y(l.element)})`, 'JsdocTypeImport'),
          JsdocTypeObjectField: O((l, y) => {
            let T = '';
            return (
              l.readonly && (T += 'readonly '),
              typeof l.key == 'string' ? (T += Ye(l.key, l.meta.quote)) : (T += y(l.key)),
              l.optional && (T += '?'),
              l.right === void 0 ? T : T + `: ${y(l.right)}`
            );
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: O(
            (l, y) => `${y(l.left)}: ${y(l.right)}`,
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeKeyValue: O((l, y) => {
            let T = l.key;
            return (
              l.optional && (T += '?'),
              l.variadic && (T = '...' + T),
              l.right === void 0 ? T : T + `: ${y(l.right)}`
            );
          }, 'JsdocTypeKeyValue'),
          JsdocTypeSpecialNamePath: O(
            (l) => `${l.specialType}:${Ye(l.value, l.meta.quote)}`,
            'JsdocTypeSpecialNamePath',
          ),
          JsdocTypeNotNullable: O(
            (l, y) => Ut(l.meta.position, y(l.element), '!'),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeNull: O(() => 'null', 'JsdocTypeNull'),
          JsdocTypeNullable: O(
            (l, y) => Ut(l.meta.position, y(l.element), '?'),
            'JsdocTypeNullable',
          ),
          JsdocTypeNumber: O((l) => l.value.toString(), 'JsdocTypeNumber'),
          JsdocTypeObject: O((l, y) => {
            var T, C;
            return `{${
              (l.meta.separator === 'linebreak' && l.elements.length > 1
                ? `
` + ((T = l.meta.propertyIndent) !== null && T !== void 0 ? T : '')
                : '') +
              l.elements.map(y).join(
                l.meta.separator === 'comma'
                  ? ', '
                  : l.meta.separator === 'linebreak'
                    ? `
` + ((C = l.meta.propertyIndent) !== null && C !== void 0 ? C : '')
                    : '; ',
              ) +
              (l.meta.separator === 'linebreak' && l.elements.length > 1
                ? `
`
                : '')
            }}`;
          }, 'JsdocTypeObject'),
          JsdocTypeOptional: O(
            (l, y) => Ut(l.meta.position, y(l.element), '='),
            'JsdocTypeOptional',
          ),
          JsdocTypeSymbol: O(
            (l, y) => `${l.value}(${l.element !== void 0 ? y(l.element) : ''})`,
            'JsdocTypeSymbol',
          ),
          JsdocTypeTypeof: O((l, y) => `typeof ${y(l.element)}`, 'JsdocTypeTypeof'),
          JsdocTypeUndefined: O(() => 'undefined', 'JsdocTypeUndefined'),
          JsdocTypeUnion: O((l, y) => l.elements.map(y).join(' | '), 'JsdocTypeUnion'),
          JsdocTypeUnknown: O(() => '?', 'JsdocTypeUnknown'),
          JsdocTypeIntersection: O(
            (l, y) => l.elements.map(y).join(' & '),
            'JsdocTypeIntersection',
          ),
          JsdocTypeProperty: O((l) => Ye(l.value, l.meta.quote), 'JsdocTypeProperty'),
          JsdocTypePredicate: O((l, y) => `${y(l.left)} is ${y(l.right)}`, 'JsdocTypePredicate'),
          JsdocTypeIndexSignature: O(
            (l, y) => `[${l.key}: ${y(l.right)}]`,
            'JsdocTypeIndexSignature',
          ),
          JsdocTypeMappedType: O((l, y) => `[${l.key} in ${y(l.right)}]`, 'JsdocTypeMappedType'),
          JsdocTypeAsserts: O(
            (l, y) => `asserts ${y(l.left)} is ${y(l.right)}`,
            'JsdocTypeAsserts',
          ),
          JsdocTypeReadonlyArray: O((l, y) => `readonly ${y(l.element)}`, 'JsdocTypeReadonlyArray'),
          JsdocTypeAssertsPlain: O((l, y) => `asserts ${y(l.element)}`, 'JsdocTypeAssertsPlain'),
          JsdocTypeConditional: O(
            (l, y) =>
              `${y(l.checksType)} extends ${y(l.extendsType)} ? ${y(l.trueType)} : ${y(l.falseType)}`,
            'JsdocTypeConditional',
          ),
          JsdocTypeTypeParameter: O(
            (l, y) =>
              `${y(l.name)}${l.constraint !== void 0 ? ` extends ${y(l.constraint)}` : ''}${l.defaultValue !== void 0 ? ` = ${y(l.defaultValue)}` : ''}`,
            'JsdocTypeTypeParameter',
          ),
        };
      }
      O(un, 'stringifyRules');
      const Jc = un();
      function cs(l) {
        return Y(Jc, l);
      }
      O(cs, 'stringify');
      const Uc = [
        'null',
        'true',
        'false',
        'break',
        'case',
        'catch',
        'class',
        'const',
        'continue',
        'debugger',
        'default',
        'delete',
        'do',
        'else',
        'export',
        'extends',
        'finally',
        'for',
        'function',
        'if',
        'import',
        'in',
        'instanceof',
        'new',
        'return',
        'super',
        'switch',
        'this',
        'throw',
        'try',
        'typeof',
        'var',
        'void',
        'while',
        'with',
        'yield',
      ];
      function Xe(l) {
        const y = { type: 'NameExpression', name: l };
        return (Uc.includes(l) && (y.reservedWord = !0), y);
      }
      O(Xe, 'makeName');
      const Vc = {
        JsdocTypeOptional: O((l, y) => {
          const T = y(l.element);
          return ((T.optional = !0), T);
        }, 'JsdocTypeOptional'),
        JsdocTypeNullable: O((l, y) => {
          const T = y(l.element);
          return ((T.nullable = !0), T);
        }, 'JsdocTypeNullable'),
        JsdocTypeNotNullable: O((l, y) => {
          const T = y(l.element);
          return ((T.nullable = !1), T);
        }, 'JsdocTypeNotNullable'),
        JsdocTypeVariadic: O((l, y) => {
          if (l.element === void 0)
            throw new Error('dots without value are not allowed in catharsis mode');
          const T = y(l.element);
          return ((T.repeatable = !0), T);
        }, 'JsdocTypeVariadic'),
        JsdocTypeAny: O(() => ({ type: 'AllLiteral' }), 'JsdocTypeAny'),
        JsdocTypeNull: O(() => ({ type: 'NullLiteral' }), 'JsdocTypeNull'),
        JsdocTypeStringValue: O((l) => Xe(Ye(l.value, l.meta.quote)), 'JsdocTypeStringValue'),
        JsdocTypeUndefined: O(() => ({ type: 'UndefinedLiteral' }), 'JsdocTypeUndefined'),
        JsdocTypeUnknown: O(() => ({ type: 'UnknownLiteral' }), 'JsdocTypeUnknown'),
        JsdocTypeFunction: O((l, y) => {
          const T = Mt(l),
            C = { type: 'FunctionType', params: T.params.map(y) };
          return (
            T.this !== void 0 && (C.this = y(T.this)),
            T.new !== void 0 && (C.new = y(T.new)),
            l.returnType !== void 0 && (C.result = y(l.returnType)),
            C
          );
        }, 'JsdocTypeFunction'),
        JsdocTypeGeneric: O(
          (l, y) => ({
            type: 'TypeApplication',
            applications: l.elements.map((T) => y(T)),
            expression: y(l.left),
          }),
          'JsdocTypeGeneric',
        ),
        JsdocTypeSpecialNamePath: O(
          (l) => Xe(l.specialType + ':' + Ye(l.value, l.meta.quote)),
          'JsdocTypeSpecialNamePath',
        ),
        JsdocTypeName: O(
          (l) => (l.value !== 'function' ? Xe(l.value) : { type: 'FunctionType', params: [] }),
          'JsdocTypeName',
        ),
        JsdocTypeNumber: O((l) => Xe(l.value.toString()), 'JsdocTypeNumber'),
        JsdocTypeObject: O((l, y) => {
          const T = { type: 'RecordType', fields: [] };
          for (const C of l.elements)
            C.type !== 'JsdocTypeObjectField' && C.type !== 'JsdocTypeJsdocObjectField'
              ? T.fields.push({ type: 'FieldType', key: y(C), value: void 0 })
              : T.fields.push(y(C));
          return T;
        }, 'JsdocTypeObject'),
        JsdocTypeObjectField: O((l, y) => {
          if (typeof l.key != 'string')
            throw new Error('Index signatures and mapped types are not supported');
          return {
            type: 'FieldType',
            key: Xe(Ye(l.key, l.meta.quote)),
            value: l.right === void 0 ? void 0 : y(l.right),
          };
        }, 'JsdocTypeObjectField'),
        JsdocTypeJsdocObjectField: O(
          (l, y) => ({ type: 'FieldType', key: y(l.left), value: y(l.right) }),
          'JsdocTypeJsdocObjectField',
        ),
        JsdocTypeUnion: O(
          (l, y) => ({ type: 'TypeUnion', elements: l.elements.map((T) => y(T)) }),
          'JsdocTypeUnion',
        ),
        JsdocTypeKeyValue: O(
          (l, y) => ({
            type: 'FieldType',
            key: Xe(l.key),
            value: l.right === void 0 ? void 0 : y(l.right),
          }),
          'JsdocTypeKeyValue',
        ),
        JsdocTypeNamePath: O((l, y) => {
          const T = y(l.left);
          let C;
          l.right.type === 'JsdocTypeSpecialNamePath'
            ? (C = y(l.right).name)
            : (C = Ye(l.right.value, l.right.meta.quote));
          const L = l.pathType === 'inner' ? '~' : l.pathType === 'instance' ? '#' : '.';
          return Xe(`${T.name}${L}${C}`);
        }, 'JsdocTypeNamePath'),
        JsdocTypeSymbol: O((l) => {
          let y = '',
            T = l.element,
            C = !1;
          return (
            T?.type === 'JsdocTypeVariadic' &&
              (T.meta.position === 'prefix' ? (y = '...') : (C = !0), (T = T.element)),
            T?.type === 'JsdocTypeName'
              ? (y += T.value)
              : T?.type === 'JsdocTypeNumber' && (y += T.value.toString()),
            C && (y += '...'),
            Xe(`${l.value}(${y})`)
          );
        }, 'JsdocTypeSymbol'),
        JsdocTypeParenthesis: O((l, y) => y($(l.element)), 'JsdocTypeParenthesis'),
        JsdocTypeMappedType: le,
        JsdocTypeIndexSignature: le,
        JsdocTypeImport: le,
        JsdocTypeKeyof: le,
        JsdocTypeTuple: le,
        JsdocTypeTypeof: le,
        JsdocTypeIntersection: le,
        JsdocTypeProperty: le,
        JsdocTypePredicate: le,
        JsdocTypeAsserts: le,
        JsdocTypeReadonlyArray: le,
        JsdocTypeAssertsPlain: le,
        JsdocTypeConditional: le,
        JsdocTypeTypeParameter: le,
      };
      function us(l) {
        return Y(Vc, l);
      }
      O(us, 'catharsisTransform');
      function it(l) {
        switch (l) {
          case void 0:
            return 'none';
          case 'single':
            return 'single';
          case 'double':
            return 'double';
        }
      }
      O(it, 'getQuoteStyle');
      function ds(l) {
        switch (l) {
          case 'inner':
            return 'INNER_MEMBER';
          case 'instance':
            return 'INSTANCE_MEMBER';
          case 'property':
            return 'MEMBER';
          case 'property-brackets':
            return 'MEMBER';
        }
      }
      O(ds, 'getMemberType');
      function fr(l, y) {
        return y.length === 2
          ? { type: l, left: y[0], right: y[1] }
          : { type: l, left: y[0], right: fr(l, y.slice(1)) };
      }
      O(fr, 'nestResults');
      const Hc = {
        JsdocTypeOptional: O(
          (l, y) => ({
            type: 'OPTIONAL',
            value: y(l.element),
            meta: {
              syntax: l.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN',
            },
          }),
          'JsdocTypeOptional',
        ),
        JsdocTypeNullable: O(
          (l, y) => ({
            type: 'NULLABLE',
            value: y(l.element),
            meta: {
              syntax:
                l.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK',
            },
          }),
          'JsdocTypeNullable',
        ),
        JsdocTypeNotNullable: O(
          (l, y) => ({
            type: 'NOT_NULLABLE',
            value: y(l.element),
            meta: { syntax: l.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG' },
          }),
          'JsdocTypeNotNullable',
        ),
        JsdocTypeVariadic: O((l, y) => {
          const T = {
            type: 'VARIADIC',
            meta: {
              syntax:
                l.meta.position === 'prefix'
                  ? 'PREFIX_DOTS'
                  : l.meta.position === 'suffix'
                    ? 'SUFFIX_DOTS'
                    : 'ONLY_DOTS',
            },
          };
          return (l.element !== void 0 && (T.value = y(l.element)), T);
        }, 'JsdocTypeVariadic'),
        JsdocTypeName: O((l) => ({ type: 'NAME', name: l.value }), 'JsdocTypeName'),
        JsdocTypeTypeof: O(
          (l, y) => ({ type: 'TYPE_QUERY', name: y(l.element) }),
          'JsdocTypeTypeof',
        ),
        JsdocTypeTuple: O(
          (l, y) => ({ type: 'TUPLE', entries: l.elements.map(y) }),
          'JsdocTypeTuple',
        ),
        JsdocTypeKeyof: O((l, y) => ({ type: 'KEY_QUERY', value: y(l.element) }), 'JsdocTypeKeyof'),
        JsdocTypeImport: O(
          (l) => ({
            type: 'IMPORT',
            path: {
              type: 'STRING_VALUE',
              quoteStyle: it(l.element.meta.quote),
              string: l.element.value,
            },
          }),
          'JsdocTypeImport',
        ),
        JsdocTypeUndefined: O(() => ({ type: 'NAME', name: 'undefined' }), 'JsdocTypeUndefined'),
        JsdocTypeAny: O(() => ({ type: 'ANY' }), 'JsdocTypeAny'),
        JsdocTypeFunction: O((l, y) => {
          const T = Mt(l),
            C = {
              type: l.arrow ? 'ARROW' : 'FUNCTION',
              params: T.params.map((L) => {
                if (L.type === 'JsdocTypeKeyValue') {
                  if (L.right === void 0)
                    throw new Error(
                      "Function parameter without ':' is not expected to be 'KEY_VALUE'",
                    );
                  return { type: 'NAMED_PARAMETER', name: L.key, typeName: y(L.right) };
                } else return y(L);
              }),
              new: null,
              returns: null,
            };
          return (
            T.this !== void 0 ? (C.this = y(T.this)) : l.arrow || (C.this = null),
            T.new !== void 0 && (C.new = y(T.new)),
            l.returnType !== void 0 && (C.returns = y(l.returnType)),
            C
          );
        }, 'JsdocTypeFunction'),
        JsdocTypeGeneric: O((l, y) => {
          const T = {
            type: 'GENERIC',
            subject: y(l.left),
            objects: l.elements.map(y),
            meta: {
              syntax:
                l.meta.brackets === 'square'
                  ? 'SQUARE_BRACKET'
                  : l.meta.dot
                    ? 'ANGLE_BRACKET_WITH_DOT'
                    : 'ANGLE_BRACKET',
            },
          };
          return (
            l.meta.brackets === 'square' &&
              l.elements[0].type === 'JsdocTypeFunction' &&
              !l.elements[0].parenthesis &&
              (T.objects[0] = { type: 'NAME', name: 'function' }),
            T
          );
        }, 'JsdocTypeGeneric'),
        JsdocTypeObjectField: O((l, y) => {
          if (typeof l.key != 'string')
            throw new Error('Index signatures and mapped types are not supported');
          if (l.right === void 0)
            return {
              type: 'RECORD_ENTRY',
              key: l.key,
              quoteStyle: it(l.meta.quote),
              value: null,
              readonly: !1,
            };
          let T = y(l.right);
          return (
            l.optional &&
              (T = { type: 'OPTIONAL', value: T, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
            {
              type: 'RECORD_ENTRY',
              key: l.key.toString(),
              quoteStyle: it(l.meta.quote),
              value: T,
              readonly: !1,
            }
          );
        }, 'JsdocTypeObjectField'),
        JsdocTypeJsdocObjectField: O(() => {
          throw new Error('Keys may not be typed in jsdoctypeparser.');
        }, 'JsdocTypeJsdocObjectField'),
        JsdocTypeKeyValue: O((l, y) => {
          if (l.right === void 0)
            return {
              type: 'RECORD_ENTRY',
              key: l.key,
              quoteStyle: 'none',
              value: null,
              readonly: !1,
            };
          let T = y(l.right);
          return (
            l.optional &&
              (T = { type: 'OPTIONAL', value: T, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
            { type: 'RECORD_ENTRY', key: l.key, quoteStyle: 'none', value: T, readonly: !1 }
          );
        }, 'JsdocTypeKeyValue'),
        JsdocTypeObject: O((l, y) => {
          const T = [];
          for (const C of l.elements)
            (C.type === 'JsdocTypeObjectField' || C.type === 'JsdocTypeJsdocObjectField') &&
              T.push(y(C));
          return { type: 'RECORD', entries: T };
        }, 'JsdocTypeObject'),
        JsdocTypeSpecialNamePath: O((l) => {
          if (l.specialType !== 'module')
            throw new Error(
              `jsdoctypeparser does not support type ${l.specialType} at this point.`,
            );
          return {
            type: 'MODULE',
            value: { type: 'FILE_PATH', quoteStyle: it(l.meta.quote), path: l.value },
          };
        }, 'JsdocTypeSpecialNamePath'),
        JsdocTypeNamePath: O((l, y) => {
          let T = !1,
            C,
            L;
          l.right.type === 'JsdocTypeSpecialNamePath' && l.right.specialType === 'event'
            ? ((T = !0), (C = l.right.value), (L = it(l.right.meta.quote)))
            : ((C = l.right.value), (L = it(l.right.meta.quote)));
          const G = {
            type: ds(l.pathType),
            owner: y(l.left),
            name: C,
            quoteStyle: L,
            hasEventPrefix: T,
          };
          if (G.owner.type === 'MODULE') {
            const Z = G.owner;
            return ((G.owner = G.owner.value), (Z.value = G), Z);
          } else return G;
        }, 'JsdocTypeNamePath'),
        JsdocTypeUnion: O((l, y) => fr('UNION', l.elements.map(y)), 'JsdocTypeUnion'),
        JsdocTypeParenthesis: O(
          (l, y) => ({ type: 'PARENTHESIS', value: y($(l.element)) }),
          'JsdocTypeParenthesis',
        ),
        JsdocTypeNull: O(() => ({ type: 'NAME', name: 'null' }), 'JsdocTypeNull'),
        JsdocTypeUnknown: O(() => ({ type: 'UNKNOWN' }), 'JsdocTypeUnknown'),
        JsdocTypeStringValue: O(
          (l) => ({ type: 'STRING_VALUE', quoteStyle: it(l.meta.quote), string: l.value }),
          'JsdocTypeStringValue',
        ),
        JsdocTypeIntersection: O(
          (l, y) => fr('INTERSECTION', l.elements.map(y)),
          'JsdocTypeIntersection',
        ),
        JsdocTypeNumber: O(
          (l) => ({ type: 'NUMBER_VALUE', number: l.value.toString() }),
          'JsdocTypeNumber',
        ),
        JsdocTypeSymbol: le,
        JsdocTypeProperty: le,
        JsdocTypePredicate: le,
        JsdocTypeMappedType: le,
        JsdocTypeIndexSignature: le,
        JsdocTypeAsserts: le,
        JsdocTypeReadonlyArray: le,
        JsdocTypeAssertsPlain: le,
        JsdocTypeConditional: le,
        JsdocTypeTypeParameter: le,
      };
      function ps(l) {
        return Y(Hc, l);
      }
      O(ps, 'jtpTransform');
      function fs() {
        return {
          JsdocTypeIntersection: O(
            (l, y) => ({ type: 'JsdocTypeIntersection', elements: l.elements.map(y) }),
            'JsdocTypeIntersection',
          ),
          JsdocTypeGeneric: O(
            (l, y) => ({
              type: 'JsdocTypeGeneric',
              left: y(l.left),
              elements: l.elements.map(y),
              meta: { dot: l.meta.dot, brackets: l.meta.brackets },
            }),
            'JsdocTypeGeneric',
          ),
          JsdocTypeNullable: O((l) => l, 'JsdocTypeNullable'),
          JsdocTypeUnion: O(
            (l, y) => ({ type: 'JsdocTypeUnion', elements: l.elements.map(y) }),
            'JsdocTypeUnion',
          ),
          JsdocTypeUnknown: O((l) => l, 'JsdocTypeUnknown'),
          JsdocTypeUndefined: O((l) => l, 'JsdocTypeUndefined'),
          JsdocTypeTypeof: O(
            (l, y) => ({ type: 'JsdocTypeTypeof', element: y(l.element) }),
            'JsdocTypeTypeof',
          ),
          JsdocTypeSymbol: O((l, y) => {
            const T = { type: 'JsdocTypeSymbol', value: l.value };
            return (l.element !== void 0 && (T.element = y(l.element)), T);
          }, 'JsdocTypeSymbol'),
          JsdocTypeOptional: O(
            (l, y) => ({
              type: 'JsdocTypeOptional',
              element: y(l.element),
              meta: { position: l.meta.position },
            }),
            'JsdocTypeOptional',
          ),
          JsdocTypeObject: O(
            (l, y) => ({
              type: 'JsdocTypeObject',
              meta: { separator: 'comma' },
              elements: l.elements.map(y),
            }),
            'JsdocTypeObject',
          ),
          JsdocTypeNumber: O((l) => l, 'JsdocTypeNumber'),
          JsdocTypeNull: O((l) => l, 'JsdocTypeNull'),
          JsdocTypeNotNullable: O(
            (l, y) => ({
              type: 'JsdocTypeNotNullable',
              element: y(l.element),
              meta: { position: l.meta.position },
            }),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeSpecialNamePath: O((l) => l, 'JsdocTypeSpecialNamePath'),
          JsdocTypeObjectField: O(
            (l, y) => ({
              type: 'JsdocTypeObjectField',
              key: l.key,
              right: l.right === void 0 ? void 0 : y(l.right),
              optional: l.optional,
              readonly: l.readonly,
              meta: l.meta,
            }),
            'JsdocTypeObjectField',
          ),
          JsdocTypeJsdocObjectField: O(
            (l, y) => ({ type: 'JsdocTypeJsdocObjectField', left: y(l.left), right: y(l.right) }),
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeKeyValue: O(
            (l, y) => ({
              type: 'JsdocTypeKeyValue',
              key: l.key,
              right: l.right === void 0 ? void 0 : y(l.right),
              optional: l.optional,
              variadic: l.variadic,
            }),
            'JsdocTypeKeyValue',
          ),
          JsdocTypeImport: O(
            (l, y) => ({ type: 'JsdocTypeImport', element: y(l.element) }),
            'JsdocTypeImport',
          ),
          JsdocTypeAny: O((l) => l, 'JsdocTypeAny'),
          JsdocTypeStringValue: O((l) => l, 'JsdocTypeStringValue'),
          JsdocTypeNamePath: O((l) => l, 'JsdocTypeNamePath'),
          JsdocTypeVariadic: O((l, y) => {
            const T = {
              type: 'JsdocTypeVariadic',
              meta: { position: l.meta.position, squareBrackets: l.meta.squareBrackets },
            };
            return (l.element !== void 0 && (T.element = y(l.element)), T);
          }, 'JsdocTypeVariadic'),
          JsdocTypeTuple: O(
            (l, y) => ({ type: 'JsdocTypeTuple', elements: l.elements.map(y) }),
            'JsdocTypeTuple',
          ),
          JsdocTypeName: O((l) => l, 'JsdocTypeName'),
          JsdocTypeFunction: O((l, y) => {
            const T = {
              type: 'JsdocTypeFunction',
              arrow: l.arrow,
              parameters: l.parameters.map(y),
              constructor: l.constructor,
              parenthesis: l.parenthesis,
            };
            return (l.returnType !== void 0 && (T.returnType = y(l.returnType)), T);
          }, 'JsdocTypeFunction'),
          JsdocTypeKeyof: O(
            (l, y) => ({ type: 'JsdocTypeKeyof', element: y(l.element) }),
            'JsdocTypeKeyof',
          ),
          JsdocTypeParenthesis: O(
            (l, y) => ({ type: 'JsdocTypeParenthesis', element: y(l.element) }),
            'JsdocTypeParenthesis',
          ),
          JsdocTypeProperty: O((l) => l, 'JsdocTypeProperty'),
          JsdocTypePredicate: O(
            (l, y) => ({ type: 'JsdocTypePredicate', left: y(l.left), right: y(l.right) }),
            'JsdocTypePredicate',
          ),
          JsdocTypeIndexSignature: O(
            (l, y) => ({ type: 'JsdocTypeIndexSignature', key: l.key, right: y(l.right) }),
            'JsdocTypeIndexSignature',
          ),
          JsdocTypeMappedType: O(
            (l, y) => ({ type: 'JsdocTypeMappedType', key: l.key, right: y(l.right) }),
            'JsdocTypeMappedType',
          ),
          JsdocTypeAsserts: O(
            (l, y) => ({ type: 'JsdocTypeAsserts', left: y(l.left), right: y(l.right) }),
            'JsdocTypeAsserts',
          ),
          JsdocTypeReadonlyArray: O(
            (l, y) => ({ type: 'JsdocTypeReadonlyArray', element: y(l.element) }),
            'JsdocTypeReadonlyArray',
          ),
          JsdocTypeAssertsPlain: O(
            (l, y) => ({ type: 'JsdocTypeAssertsPlain', element: y(l.element) }),
            'JsdocTypeAssertsPlain',
          ),
          JsdocTypeConditional: O(
            (l, y) => ({
              type: 'JsdocTypeConditional',
              checksType: y(l.checksType),
              extendsType: y(l.extendsType),
              trueType: y(l.trueType),
              falseType: y(l.falseType),
            }),
            'JsdocTypeConditional',
          ),
          JsdocTypeTypeParameter: O(
            (l, y) => ({
              type: 'JsdocTypeTypeParameter',
              name: y(l.name),
              constraint: l.constraint !== void 0 ? y(l.constraint) : void 0,
              defaultValue: l.defaultValue !== void 0 ? y(l.defaultValue) : void 0,
            }),
            'JsdocTypeTypeParameter',
          ),
        };
      }
      O(fs, 'identityTransformRules');
      const ms = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ['parameters', 'returnType'],
        JsdocTypeGeneric: ['left', 'elements'],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ['right'],
        JsdocTypeIntersection: ['elements'],
        JsdocTypeKeyof: ['element'],
        JsdocTypeKeyValue: ['right'],
        JsdocTypeMappedType: ['right'],
        JsdocTypeName: [],
        JsdocTypeNamePath: ['left', 'right'],
        JsdocTypeNotNullable: ['element'],
        JsdocTypeNull: [],
        JsdocTypeNullable: ['element'],
        JsdocTypeNumber: [],
        JsdocTypeObject: ['elements'],
        JsdocTypeObjectField: ['right'],
        JsdocTypeJsdocObjectField: ['left', 'right'],
        JsdocTypeOptional: ['element'],
        JsdocTypeParenthesis: ['element'],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ['element'],
        JsdocTypeTuple: ['elements'],
        JsdocTypeTypeof: ['element'],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ['elements'],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ['element'],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ['left', 'right'],
        JsdocTypeAsserts: ['left', 'right'],
        JsdocTypeReadonlyArray: ['element'],
        JsdocTypeAssertsPlain: ['element'],
        JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],
        JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue'],
      };
      function mr(l, y, T, C, L) {
        C?.(l, y, T);
        const G = ms[l.type];
        for (const Z of G) {
          const ce = l[Z];
          if (ce !== void 0)
            if (Array.isArray(ce)) for (const _e of ce) mr(_e, l, Z, C, L);
            else mr(ce, l, Z, C, L);
        }
        L?.(l, y, T);
      }
      O(mr, '_traverse');
      function ys(l, y, T) {
        mr(l, void 0, void 0, y, T);
      }
      (O(ys, 'traverse'),
        (r.catharsisTransform = us),
        (r.identityTransformRules = fs),
        (r.jtpTransform = ps),
        (r.parse = pr),
        (r.stringify = cs),
        (r.stringifyRules = un),
        (r.transform = Y),
        (r.traverse = ys),
        (r.tryParse = cn),
        (r.visitorKeys = ms));
    });
  },
});
const { UnknownArgTypesError: $5 } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__,
  { UnknownArgTypesError: k5 } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
var az = ['null', 'undefined'];
function Fc(e) {
  return az.some((t) => t === e);
}
O(Fc, 'isDefaultValueBlacklisted');
var lz = O((e) => {
  if (!e) return '';
  if (typeof e == 'string') return e;
  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);
}, 'str');
function zh(e) {
  return !!e.__docgenInfo;
}
O(zh, 'hasDocgen');
function cz(e) {
  return e != null && Object.keys(e).length > 0;
}
O(cz, 'isValidDocgenSection');
function uz(e, t) {
  return zh(e) ? e.__docgenInfo[t] : null;
}
O(uz, 'getDocgenSection');
function EN(e) {
  return zh(e) ? lz(e.__docgenInfo.description) : '';
}
O(EN, 'getDocgenDescription');
var Gr;
(function (e) {
  ((e.start = '/**'), (e.nostart = '/***'), (e.delim = '*'), (e.end = '*/'));
})((Gr = Gr || (Gr = {})));
function wN(e) {
  return /^\s+$/.test(e);
}
O(wN, 'isSpace');
function SN(e) {
  const t = e.match(/\r+$/);
  return t == null ? ['', e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];
}
O(SN, 'splitCR');
function An(e) {
  const t = e.match(/^\s+/);
  return t == null ? ['', e] : [e.slice(0, t[0].length), e.slice(t[0].length)];
}
O(An, 'splitSpace');
function _N(e) {
  return e.split(/\n/);
}
O(_N, 'splitLines');
function AN(e = {}) {
  return Object.assign(
    { tag: '', name: '', type: '', optional: !1, description: '', problems: [], source: [] },
    e,
  );
}
O(AN, 'seedSpec');
function RN(e = {}) {
  return Object.assign(
    {
      start: '',
      delimiter: '',
      postDelimiter: '',
      tag: '',
      postTag: '',
      name: '',
      postName: '',
      type: '',
      postType: '',
      description: '',
      end: '',
      lineEnd: '',
    },
    e,
  );
}
O(RN, 'seedTokens');
var dz = /^@\S+/;
function xN({ fence: e = '```' } = {}) {
  const t = PN(e),
    r = O((n, o) => (t(n) ? !o : o), 'toggleFence');
  return O(function (o) {
    const i = [[]];
    let a = !1;
    for (const c of o)
      (dz.test(c.tokens.description) && !a ? i.push([c]) : i[i.length - 1].push(c),
        (a = r(c.tokens.description, a)));
    return i;
  }, 'parseBlock');
}
O(xN, 'getParser');
function PN(e) {
  return typeof e == 'string' ? (t) => t.split(e).length % 2 === 0 : e;
}
O(PN, 'getFencer');
function ON({ startLine: e = 0, markers: t = Gr } = {}) {
  let r = null,
    n = e;
  return O(function (i) {
    let a = i;
    const c = RN();
    if (
      (([c.lineEnd, a] = SN(a)),
      ([c.start, a] = An(a)),
      r === null &&
        a.startsWith(t.start) &&
        !a.startsWith(t.nostart) &&
        ((r = []),
        (c.delimiter = a.slice(0, t.start.length)),
        (a = a.slice(t.start.length)),
        ([c.postDelimiter, a] = An(a))),
      r === null)
    )
      return (n++, null);
    const d = a.trimRight().endsWith(t.end);
    if (
      (c.delimiter === '' &&
        a.startsWith(t.delim) &&
        !a.startsWith(t.end) &&
        ((c.delimiter = t.delim), (a = a.slice(t.delim.length)), ([c.postDelimiter, a] = An(a))),
      d)
    ) {
      const u = a.trimRight();
      ((c.end = a.slice(u.length - t.end.length)), (a = u.slice(0, -t.end.length)));
    }
    if (((c.description = a), r.push({ number: n, source: i, tokens: c }), n++, d)) {
      const u = r.slice();
      return ((r = null), u);
    }
    return null;
  }, 'parseSource');
}
O(ON, 'getParser');
function CN({ tokenizers: e }) {
  return O(function (r) {
    var n;
    let o = AN({ source: r });
    for (const i of e)
      if (
        ((o = i(o)),
        !((n = o.problems[o.problems.length - 1]) === null || n === void 0) && n.critical)
      )
        break;
    return o;
  }, 'parseSpec');
}
O(CN, 'getParser');
function IN() {
  return (e) => {
    const { tokens: t } = e.source[0],
      r = t.description.match(/\s*(@(\S+))(\s*)/);
    return r === null
      ? (e.problems.push({
          code: 'spec:tag:prefix',
          message: 'tag should start with "@" symbol',
          line: e.source[0].number,
          critical: !0,
        }),
        e)
      : ((t.tag = r[1]),
        (t.postTag = r[3]),
        (t.description = t.description.slice(r[0].length)),
        (e.tag = r[2]),
        e);
  };
}
O(IN, 'tagTokenizer');
function NN(e = 'compact') {
  const t = qN(e);
  return (r) => {
    let n = 0,
      o = [];
    for (const [c, { tokens: d }] of r.source.entries()) {
      let u = '';
      if (c === 0 && d.description[0] !== '{') return r;
      for (const p of d.description)
        if ((p === '{' && n++, p === '}' && n--, (u += p), n === 0)) break;
      if ((o.push([d, u]), n === 0)) break;
    }
    if (n !== 0)
      return (
        r.problems.push({
          code: 'spec:type:unpaired-curlies',
          message: 'unpaired curlies',
          line: r.source[0].number,
          critical: !0,
        }),
        r
      );
    const i = [],
      a = o[0][0].postDelimiter.length;
    for (const [c, [d, u]] of o.entries())
      ((d.type = u),
        c > 0 &&
          ((d.type = d.postDelimiter.slice(a) + u),
          (d.postDelimiter = d.postDelimiter.slice(0, a))),
        ([d.postType, d.description] = An(d.description.slice(u.length))),
        i.push(d.type));
    return (
      (i[0] = i[0].slice(1)),
      (i[i.length - 1] = i[i.length - 1].slice(0, -1)),
      (r.type = t(i)),
      r
    );
  };
}
O(NN, 'typeTokenizer');
var pz = O((e) => e.trim(), 'trim');
function qN(e) {
  return e === 'compact'
    ? (t) => t.map(pz).join('')
    : e === 'preserve'
      ? (t) =>
          t.join(`
`)
      : e;
}
O(qN, 'getJoiner');
var fz = O((e) => e && e.startsWith('"') && e.endsWith('"'), 'isQuoted');
function MN() {
  const e = O((t, { tokens: r }, n) => (r.type === '' ? t : n), 'typeEnd');
  return (t) => {
    const { tokens: r } = t.source[t.source.reduce(e, 0)],
      n = r.description.trimLeft(),
      o = n.split('"');
    if (o.length > 1 && o[0] === '' && o.length % 2 === 1)
      return (
        (t.name = o[1]),
        (r.name = `"${o[1]}"`),
        ([r.postName, r.description] = An(n.slice(r.name.length))),
        t
      );
    let i = 0,
      a = '',
      c = !1,
      d;
    for (const p of n) {
      if (i === 0 && wN(p)) break;
      (p === '[' && i++, p === ']' && i--, (a += p));
    }
    if (i !== 0)
      return (
        t.problems.push({
          code: 'spec:name:unpaired-brackets',
          message: 'unpaired brackets',
          line: t.source[0].number,
          critical: !0,
        }),
        t
      );
    const u = a;
    if (a[0] === '[' && a[a.length - 1] === ']') {
      ((c = !0), (a = a.slice(1, -1)));
      const p = a.split('=');
      if (((a = p[0].trim()), p[1] !== void 0 && (d = p.slice(1).join('=').trim()), a === ''))
        return (
          t.problems.push({
            code: 'spec:name:empty-name',
            message: 'empty name',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
      if (d === '')
        return (
          t.problems.push({
            code: 'spec:name:empty-default',
            message: 'empty default value',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
      if (!fz(d) && /=(?!>)/.test(d))
        return (
          t.problems.push({
            code: 'spec:name:invalid-default',
            message: 'invalid default value syntax',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
    }
    return (
      (t.optional = c),
      (t.name = a),
      (r.name = u),
      d !== void 0 && (t.default = d),
      ([r.postName, r.description] = An(n.slice(r.name.length))),
      t
    );
  };
}
O(MN, 'nameTokenizer');
function jN(e = 'compact', t = Gr) {
  const r = Gh(e);
  return (n) => ((n.description = r(n.source, t)), n);
}
O(jN, 'descriptionTokenizer');
function Gh(e) {
  return e === 'compact' ? $N : e === 'preserve' ? kN : e;
}
O(Gh, 'getJoiner');
function $N(e, t = Gr) {
  return e
    .map(({ tokens: { description: r } }) => r.trim())
    .filter((r) => r !== '')
    .join(' ');
}
O($N, 'compactJoiner');
var mz = O((e, { tokens: t }, r) => (t.type === '' ? e : r), 'lineNo'),
  yz = O(
    ({ tokens: e }) => (e.delimiter === '' ? e.start : e.postDelimiter.slice(1)) + e.description,
    'getDescription',
  );
function kN(e, t = Gr) {
  if (e.length === 0) return '';
  e[0].tokens.description === '' && e[0].tokens.delimiter === t.start && (e = e.slice(1));
  const r = e[e.length - 1];
  return (
    r !== void 0 &&
      r.tokens.description === '' &&
      r.tokens.end.endsWith(t.end) &&
      (e = e.slice(0, -1)),
    (e = e.slice(e.reduce(mz, 0))),
    e.map(yz).join(`
`)
  );
}
O(kN, 'preserveJoiner');
function DN({
  startLine: e = 0,
  fence: t = '```',
  spacing: r = 'compact',
  markers: n = Gr,
  tokenizers: o = [IN(), NN(r), MN(), jN(r)],
} = {}) {
  if (e < 0 || e % 1 > 0) throw new Error('Invalid startLine');
  const i = ON({ startLine: e, markers: n }),
    a = xN({ fence: t }),
    c = CN({ tokenizers: o }),
    d = Gh(r);
  return function (u) {
    const p = [];
    for (const f of _N(u)) {
      const m = i(f);
      if (m === null) continue;
      const h = a(m),
        g = h.slice(1).map(c);
      p.push({
        description: d(h[0], n),
        tags: g,
        source: m,
        problems: g.reduce((v, E) => v.concat(E.problems), []),
      });
    }
    return p;
  };
}
O(DN, 'getParser');
function LN(e) {
  return (
    e.start +
    e.delimiter +
    e.postDelimiter +
    e.tag +
    e.postTag +
    e.type +
    e.postType +
    e.name +
    e.postName +
    e.description +
    e.end +
    e.lineEnd
  );
}
O(LN, 'join');
function hz() {
  return (e) =>
    e.source.map(({ tokens: t }) => LN(t)).join(`
`);
}
O(hz, 'getStringifier');
function FN(e, t = {}) {
  return DN(t)(e);
}
O(FN, 'parse');
var Wh = tz(iz());
function BN(e) {
  return e != null && e.includes('@');
}
O(BN, 'containsJsDoc');
function JN(e) {
  const n =
      `/**
` +
      (e ?? '')
        .split(
          `
`,
        )
        .map((i) => ` * ${i}`).join(`
`) +
      `
*/`,
    o = FN(n, { spacing: 'preserve' });
  if (!o || o.length === 0) throw new Error('Cannot parse JSDoc tags.');
  return o[0];
}
O(JN, 'parse');
var gz = { tags: ['param', 'arg', 'argument', 'returns', 'ignore', 'deprecated'] },
  bz = O((e, t = gz) => {
    if (!BN(e)) return { includesJsDoc: !1, ignore: !1 };
    const r = JN(e),
      n = UN(r, t.tags);
    return n.ignore
      ? { includesJsDoc: !0, ignore: !0 }
      : { includesJsDoc: !0, ignore: !1, description: r.description.trim(), extractedTags: n };
  }, 'parseJsDoc');
function UN(e, t) {
  const r = { params: null, deprecated: null, returns: null, ignore: !1 };
  for (const n of e.tags)
    if (!(t !== void 0 && !t.includes(n.tag)))
      if (n.tag === 'ignore') {
        r.ignore = !0;
        break;
      } else
        switch (n.tag) {
          case 'param':
          case 'arg':
          case 'argument': {
            const o = HN(n);
            o != null && (r.params == null && (r.params = []), r.params.push(o));
            break;
          }
          case 'deprecated': {
            const o = zN(n);
            o != null && (r.deprecated = o);
            break;
          }
          case 'returns': {
            const o = GN(n);
            o != null && (r.returns = o);
            break;
          }
        }
  return r;
}
O(UN, 'extractJsDocTags');
function VN(e) {
  return e.replace(/[\.-]$/, '');
}
O(VN, 'normaliseParamName');
function HN(e) {
  if (!e.name || e.name === '-') return null;
  const t = Xh(e.type);
  return {
    name: e.name,
    type: t,
    description: Yh(e.description),
    getPrettyName: O(() => VN(e.name), 'getPrettyName'),
    getTypeName: O(() => (t ? Qh(t) : null), 'getTypeName'),
  };
}
O(HN, 'extractParam');
function zN(e) {
  return e.name ? Kh(e.name, e.description) : null;
}
O(zN, 'extractDeprecated');
function Kh(e, t) {
  const r = e === '' ? t : `${e} ${t}`;
  return Yh(r);
}
O(Kh, 'joinNameAndDescription');
function Yh(e) {
  const t = e.replace(/^- /g, '').trim();
  return t === '' ? null : t;
}
O(Yh, 'normaliseDescription');
function GN(e) {
  const t = Xh(e.type);
  return t
    ? {
        type: t,
        description: Kh(e.name, e.description),
        getTypeName: O(() => Qh(t), 'getTypeName'),
      }
    : null;
}
O(GN, 'extractReturns');
var on = (0, Wh.stringifyRules)(),
  vz = on.JsdocTypeObject;
on.JsdocTypeAny = () => 'any';
on.JsdocTypeObject = (e, t) => `(${vz(e, t)})`;
on.JsdocTypeOptional = (e, t) => t(e.element);
on.JsdocTypeNullable = (e, t) => t(e.element);
on.JsdocTypeNotNullable = (e, t) => t(e.element);
on.JsdocTypeUnion = (e, t) => e.elements.map(t).join('|');
function Xh(e) {
  try {
    return (0, Wh.parse)(e, 'typescript');
  } catch {
    return null;
  }
}
O(Xh, 'extractType');
function Qh(e) {
  return (0, Wh.transform)(on, e);
}
O(Qh, 'extractTypeName');
var Tz = 90,
  Ez = 50;
function Zh(e) {
  return e.length > Tz;
}
O(Zh, 'isTooLongForTypeSummary');
function WN(e) {
  return e.length > Ez;
}
O(WN, 'isTooLongForDefaultValueSummary');
function nt(e, t) {
  return e === t ? { summary: e } : { summary: e, detail: t };
}
O(nt, 'createSummaryValue');
function wz(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!Fc(r)) return WN(r) ? nt(t?.name, r) : nt(r);
  }
  return null;
}
O(wz, 'createDefaultValue');
function eg({ name: e, value: t, elements: r, raw: n }) {
  return t ?? (r != null ? r.map(eg).join(' | ') : (n ?? e));
}
O(eg, 'generateUnionElement');
function KN({ name: e, raw: t, elements: r }) {
  return r != null ? nt(r.map(eg).join(' | ')) : t != null ? nt(t.replace(/^\|\s*/, '')) : nt(e);
}
O(KN, 'generateUnion');
function YN({ type: e, raw: t }) {
  return t != null ? nt(t) : nt(e);
}
O(YN, 'generateFuncSignature');
function XN({ type: e, raw: t }) {
  return t != null ? (Zh(t) ? nt(e, t) : nt(t)) : nt(e);
}
O(XN, 'generateObjectSignature');
function QN(e) {
  const { type: t } = e;
  return t === 'object' ? XN(e) : YN(e);
}
O(QN, 'generateSignature');
function ZN({ name: e, raw: t }) {
  return t != null ? (Zh(t) ? nt(e, t) : nt(t)) : nt(e);
}
O(ZN, 'generateDefault');
function Sz(e) {
  if (e == null) return null;
  switch (e.name) {
    case 'union':
      return KN(e);
    case 'signature':
      return QN(e);
    default:
      return ZN(e);
  }
}
O(Sz, 'createType');
function _z({ defaultValue: e }) {
  if (e != null) {
    const { value: t } = e;
    if (!Fc(t)) return nt(t);
  }
  return null;
}
O(_z, 'createDefaultValue');
function Az({ tsType: e, required: t }) {
  if (e == null) return null;
  let r = e.name;
  return (
    t || (r = r.replace(' | undefined', '')),
    nt(['Array', 'Record', 'signature'].includes(e.name) ? e.raw : r)
  );
}
O(Az, 'createType');
function eq(e) {
  return e != null ? nt(e.name) : null;
}
O(eq, 'createType');
function tq(e) {
  const { computed: t, func: r } = e;
  return typeof t > 'u' && typeof r > 'u';
}
O(tq, 'isReactDocgenTypescript');
function rq(e) {
  return e
    ? e.name === 'string'
      ? !0
      : e.name === 'enum'
        ? Array.isArray(e.value) &&
          e.value.every(
            ({ value: t }) => typeof t == 'string' && t[0] === '"' && t[t.length - 1] === '"',
          )
        : !1
    : !1;
}
O(rq, 'isStringValued');
function nq(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!Fc(r)) return tq(e) && rq(t) ? nt(JSON.stringify(r)) : nt(r);
  }
  return null;
}
O(nq, 'createDefaultValue');
function Rz(e, t, r) {
  const { description: n, required: o, defaultValue: i } = r;
  return { name: e, type: eq(t), required: o, description: n, defaultValue: nq(i, t) };
}
O(Rz, 'createBasicPropDef');
function xz(e, t) {
  if (t?.includesJsDoc) {
    const { description: r, extractedTags: n } = t;
    r != null && (e.description = t.description);
    const o = {
      ...n,
      params: n?.params?.map((i) => ({ name: i.getPrettyName(), description: i.description })),
    };
    Object.values(o).filter(Boolean).length > 0 && (e.jsDocTags = o);
  }
  return e;
}
O(xz, 'applyJsDocResult');
function Pz(e, t, r, n) {
  const o = bz(t.description);
  return o.includesJsDoc && o.ignore
    ? null
    : { propDef: n(e, t, o), jsDocTags: o.extractedTags, docgenInfo: t, typeSystem: r };
}
O(Pz, 'extractProp');
function Oz(e) {
  return e != null ? EN(e) : '';
}
O(Oz, 'extractComponentDescription');
var oq = O((...e) => {
    const t = {},
      r = e.filter(Boolean),
      n = r.reduce(
        (o, i) => (
          Object.entries(i).forEach(([a, c]) => {
            const d = o[a];
            Array.isArray(c) || typeof d > 'u'
              ? (o[a] = c)
              : ca(c) && ca(d)
                ? (t[a] = !0)
                : typeof c < 'u' && (o[a] = c);
          }),
          o
        ),
        {},
      );
    return (
      Object.keys(t).forEach((o) => {
        const i = r
          .filter(Boolean)
          .map((a) => a[o])
          .filter((a) => typeof a < 'u');
        i.every((a) => ca(a)) ? (n[o] = oq(...i)) : (n[o] = i[i.length - 1]);
      }),
      n
    );
  }, 'combineParameters'),
  sq = O((e) => {
    const {
        component: t,
        argTypes: r,
        parameters: { docs: n = {} },
      } = e,
      { extractArgTypes: o } = n;
    if (!o || !t) return r;
    const i = o(t);
    return i ? oq(i, r) : r;
  }, 'enhanceArgTypes');
const Cz = 'modulepreload',
  Iz = function (e, t) {
    return new URL(e, t).href;
  },
  rv = {},
  mn = function (t, r, n) {
    let o = Promise.resolve();
    if (r && r.length > 0) {
      let u = function (p) {
        return Promise.all(
          p.map((f) =>
            Promise.resolve(f).then(
              (m) => ({ status: 'fulfilled', value: m }),
              (m) => ({ status: 'rejected', reason: m }),
            ),
          ),
        );
      };
      const a = document.getElementsByTagName('link'),
        c = document.querySelector('meta[property=csp-nonce]'),
        d = c?.nonce || c?.getAttribute('nonce');
      o = u(
        r.map((p) => {
          if (((p = Iz(p, n)), p in rv)) return;
          rv[p] = !0;
          const f = p.endsWith('.css'),
            m = f ? '[rel="stylesheet"]' : '';
          if (n)
            for (let g = a.length - 1; g >= 0; g--) {
              const v = a[g];
              if (v.href === p && (!f || v.rel === 'stylesheet')) return;
            }
          else if (document.querySelector(`link[href="${p}"]${m}`)) return;
          const h = document.createElement('link');
          if (
            ((h.rel = f ? 'stylesheet' : Cz),
            f || (h.as = 'script'),
            (h.crossOrigin = ''),
            (h.href = p),
            d && h.setAttribute('nonce', d),
            document.head.appendChild(h),
            f)
          )
            return new Promise((g, v) => {
              (h.addEventListener('load', g),
                h.addEventListener('error', () => v(new Error(`Unable to preload CSS for ${p}`))));
            });
        }),
      );
    }
    function i(a) {
      const c = new Event('vite:preloadError', { cancelable: !0 });
      if (((c.payload = a), window.dispatchEvent(c), !c.defaultPrevented)) throw a;
    }
    return o.then((a) => {
      for (const c of a || []) c.status === 'rejected' && i(c.reason);
      return t().catch(i);
    });
  },
  Nz = {
    './src/components/badge/badge.stories.tsx': () =>
      mn(() => import('./badge.stories-BWEQF0v3.js'), [], import.meta.url),
    './src/components/button/button.stories.tsx': () =>
      mn(() => import('./button.stories-Bc1o30Fw.js'), [], import.meta.url),
    './src/components/image/image.stories.tsx': () =>
      mn(() => import('./image.stories-CBQvge_B.js'), [], import.meta.url),
    './src/components/section/section.stories.tsx': () =>
      mn(() => import('./section.stories-BZ5CU0mF.js'), [], import.meta.url),
    './src/components/typography/typography.stories.tsx': () =>
      mn(() => import('./typography.stories-CZY6Mtee.js'), [], import.meta.url),
    './src/components/wrapper/wrapper.stories.tsx': () =>
      mn(() => import('./wrapper.stories-f2xqWHpl.js'), [], import.meta.url),
  };
async function qz(e) {
  return await Nz[e]();
}
var fi = { updatable: !0, slotRelocation: !0, experimentalSlotFixes: !1 },
  Mz = Object.defineProperty,
  jz = (e, t) => {
    for (var r in t) Mz(e, r, { get: t[r], enumerable: !0 });
  },
  $z = 'http://www.w3.org/2000/svg',
  kz = 'http://www.w3.org/1999/xhtml',
  nv = (e, t) => t in e,
  ov = 'http://www.w3.org/1999/xlink',
  vn = typeof window < 'u' ? window : {},
  qo = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (e) => e(),
    raf: (e) => requestAnimationFrame(e),
    ael: (e, t, r, n) => e.addEventListener(t, r, n),
    rel: (e, t, r, n) => e.removeEventListener(t, r, n),
    ce: (e, t) => new CustomEvent(e, t),
  },
  Dz = (e) => e != null && e !== void 0,
  iq = (e) => ((e = typeof e), e === 'object' || e === 'function'),
  Lz = (e) => e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
  Fz = {};
jz(Fz, { err: () => aq, map: () => Bz, ok: () => bp, unwrap: () => Jz, unwrapErr: () => Uz });
var bp = (e) => ({ isOk: !0, isErr: !1, value: e }),
  aq = (e) => ({ isOk: !1, isErr: !0, value: e });
function Bz(e, t) {
  if (e.isOk) {
    const r = t(e.value);
    return r instanceof Promise ? r.then((n) => bp(n)) : bp(r);
  }
  if (e.isErr) {
    const r = e.value;
    return aq(r);
  }
  throw 'should never get here';
}
var Jz = (e) => {
    if (e.isOk) return e.value;
    throw e.value;
  },
  Uz = (e) => {
    if (e.isErr) return e.value;
    throw e.value;
  },
  lq = (e) => {
    const t = iv(e, 'childNodes');
    e.tagName &&
      e.tagName.includes('-') &&
      e['s-cr'] &&
      e.tagName !== 'SLOT-FB' &&
      cq(t, e.tagName).forEach((n) => {
        n.nodeType === 1 &&
          n.tagName === 'SLOT-FB' &&
          (Hz(n, tg(n), !1).length ? (n.hidden = !0) : (n.hidden = !1));
      });
    let r = 0;
    for (r = 0; r < t.length; r++) {
      const n = t[r];
      n.nodeType === 1 && iv(n, 'childNodes').length && lq(n);
    }
  },
  Vz = (e) => {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r]['s-nr'] || void 0;
      n && n.isConnected && t.push(n);
    }
    return t;
  };
function cq(e, t, r) {
  let n = 0,
    o = [],
    i;
  for (; n < e.length; n++)
    ((i = e[n]),
      i['s-sr'] && (!t || i['s-hn'] === t) && r === void 0 && o.push(i),
      (o = [...o, ...cq(i.childNodes, t, r)]));
  return o;
}
var Hz = (e, t, r = !0) => {
    const n = [];
    ((r && e['s-sr']) || !e['s-sr']) && n.push(e);
    let o = e;
    for (; (o = o.nextSibling); ) tg(o) === t && (r || !o['s-sr']) && n.push(o);
    return n;
  },
  sv = (e, t) =>
    e.nodeType === 1
      ? (e.getAttribute('slot') === null && t === '') || e.getAttribute('slot') === t
      : e['s-sn'] === t
        ? !0
        : t === '',
  tg = (e) =>
    typeof e['s-sn'] == 'string'
      ? e['s-sn']
      : (e.nodeType === 1 && e.getAttribute('slot')) || void 0;
function zz(e) {
  if (e.assignedElements || e.assignedNodes || !e['s-sr']) return;
  const t = (r) =>
    function (n) {
      const o = [],
        i = this['s-sn'];
      n?.flatten &&
        console.error(`
          Flattening is not supported for Stencil non-shadow slots.
          You can use \`.childNodes\` to nested slot fallback content.
          If you have a particular use case, please open an issue on the Stencil repo.
        `);
      const a = this['s-cr'].parentElement;
      return (
        (a.__childNodes ? a.childNodes : Vz(a.childNodes)).forEach((d) => {
          i === tg(d) && o.push(d);
        }),
        r ? o.filter((d) => d.nodeType === 1) : o
      );
    }.bind(e);
  ((e.assignedElements = t(!0)), (e.assignedNodes = t(!1)));
}
function iv(e, t) {
  if ('__' + t in e) {
    const r = e['__' + t];
    return typeof r != 'function' ? r : r.bind(e);
  } else return typeof e[t] != 'function' ? e[t] : e[t].bind(e);
}
var al = (e, t, ...r) => {
    let n = null,
      o = null,
      i = null,
      a = !1,
      c = !1;
    const d = [],
      u = (f) => {
        for (let m = 0; m < f.length; m++)
          ((n = f[m]),
            Array.isArray(n)
              ? u(n)
              : n != null &&
                typeof n != 'boolean' &&
                ((a = typeof e != 'function' && !iq(n)) && (n = String(n)),
                a && c ? (d[d.length - 1].$text$ += n) : d.push(a ? ll(null, n) : n),
                (c = a)));
      };
    if ((u(r), t)) {
      (t.key && (o = t.key), t.name && (i = t.name));
      {
        const f = t.className || t.class;
        f &&
          (t.class =
            typeof f != 'object'
              ? f
              : Object.keys(f)
                  .filter((m) => f[m])
                  .join(' '));
      }
    }
    if (typeof e == 'function') return e(t === null ? {} : t, d, Kz);
    const p = ll(e, null);
    return ((p.$attrs$ = t), d.length > 0 && (p.$children$ = d), (p.$key$ = o), (p.$name$ = i), p);
  },
  ll = (e, t) => {
    const r = { $flags$: 0, $tag$: e, $text$: t, $elm$: null, $children$: null };
    return ((r.$attrs$ = null), (r.$key$ = null), (r.$name$ = null), r);
  },
  Gz = {},
  Wz = (e) => e && e.$tag$ === Gz,
  Kz = { forEach: (e, t) => e.map(av).forEach(t), map: (e, t) => e.map(av).map(t).map(Yz) },
  av = (e) => ({
    vattrs: e.$attrs$,
    vchildren: e.$children$,
    vkey: e.$key$,
    vname: e.$name$,
    vtag: e.$tag$,
    vtext: e.$text$,
  }),
  Yz = (e) => {
    if (typeof e.vtag == 'function') {
      const r = { ...e.vattrs };
      return (
        e.vkey && (r.key = e.vkey),
        e.vname && (r.name = e.vname),
        al(e.vtag, r, ...(e.vchildren || []))
      );
    }
    const t = ll(e.vtag, e.vtext);
    return (
      (t.$attrs$ = e.vattrs),
      (t.$children$ = e.vchildren),
      (t.$key$ = e.vkey),
      (t.$name$ = e.vname),
      t
    );
  },
  rg = (e) => {
    const t = Lz(e);
    return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`, 'g');
  };
rg('::slotted');
rg(':host');
rg(':host-context');
var lv = (e, t, r, n, o, i, a) => {
    if (r === n) return;
    let c = nv(e, t),
      d = t.toLowerCase();
    if (t === 'class') {
      const u = e.classList,
        p = cv(r);
      let f = cv(n);
      (u.remove(...p.filter((m) => m && !f.includes(m))),
        u.add(...f.filter((m) => m && !p.includes(m))));
    } else if (t === 'style') {
      for (const u in r)
        (!n || n[u] == null) && (u.includes('-') ? e.style.removeProperty(u) : (e.style[u] = ''));
      for (const u in n)
        (!r || n[u] !== r[u]) &&
          (u.includes('-') ? e.style.setProperty(u, n[u]) : (e.style[u] = n[u]));
    } else if (t !== 'key')
      if (t === 'ref') n && n(e);
      else if (!e.__lookupSetter__(t) && t[0] === 'o' && t[1] === 'n') {
        if (
          (t[2] === '-' ? (t = t.slice(3)) : nv(vn, d) ? (t = d.slice(2)) : (t = d[2] + t.slice(3)),
          r || n)
        ) {
          const u = t.endsWith(uq);
          ((t = t.replace(Qz, '')), r && qo.rel(e, t, r, u), n && qo.ael(e, t, n, u));
        }
      } else {
        const u = iq(n);
        if ((c || (u && n !== null)) && !o)
          try {
            if (e.tagName.includes('-')) e[t] !== n && (e[t] = n);
            else {
              const f = n ?? '';
              t === 'list'
                ? (c = !1)
                : (r == null || e[t] != f) &&
                  (typeof e.__lookupSetter__(t) == 'function' ? (e[t] = f) : e.setAttribute(t, f));
            }
          } catch {}
        let p = !1;
        (d !== (d = d.replace(/^xlink\:?/, '')) && ((t = d), (p = !0)),
          n == null || n === !1
            ? (n !== !1 || e.getAttribute(t) === '') &&
              (p ? e.removeAttributeNS(ov, t) : e.removeAttribute(t))
            : (!c || i & 4 || o) &&
              !u &&
              e.nodeType === 1 &&
              ((n = n === !0 ? '' : n), p ? e.setAttributeNS(ov, t, n) : e.setAttribute(t, n)));
      }
  },
  Xz = /\s/,
  cv = (e) => (
    typeof e == 'object' && e && 'baseVal' in e && (e = e.baseVal),
    !e || typeof e != 'string' ? [] : e.split(Xz)
  ),
  uq = 'Capture',
  Qz = new RegExp(uq + '$'),
  vp = (e, t, r, n) => {
    const o = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$,
      i = (e && e.$attrs$) || {},
      a = t.$attrs$ || {};
    for (const c of uv(Object.keys(i))) c in a || lv(o, c, i[c], void 0, r, t.$flags$);
    for (const c of uv(Object.keys(a))) lv(o, c, i[c], a[c], r, t.$flags$);
  };
function uv(e) {
  return e.includes('ref') ? [...e.filter((t) => t !== 'ref'), 'ref'] : e;
}
var da,
  cl,
  mi,
  Tp = !1,
  ul = !1,
  ng = !1,
  Tt = !1,
  dl = (e, t, r) => {
    var n;
    const o = t.$children$[r];
    let i = 0,
      a,
      c,
      d;
    if (
      (Tp || ((ng = !0), o.$tag$ === 'slot' && (o.$flags$ |= o.$children$ ? 2 : 1)),
      o.$text$ !== null)
    )
      a = o.$elm$ = vn.document.createTextNode(o.$text$);
    else if (o.$flags$ & 1) ((a = o.$elm$ = vn.document.createTextNode('')), vp(null, o, Tt));
    else {
      if ((Tt || (Tt = o.$tag$ === 'svg'), !vn.document))
        throw new Error(
          "You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.",
        );
      if (
        ((a = o.$elm$ =
          vn.document.createElementNS(
            Tt ? $z : kz,
            !Tp && fi.slotRelocation && o.$flags$ & 2 ? 'slot-fb' : o.$tag$,
          )),
        Tt && o.$tag$ === 'foreignObject' && (Tt = !1),
        vp(null, o, Tt),
        Dz(da) && a['s-si'] !== da && a.classList.add((a['s-si'] = da)),
        o.$children$)
      )
        for (i = 0; i < o.$children$.length; ++i) ((c = dl(e, o, i)), c && a.appendChild(c));
      o.$tag$ === 'svg' ? (Tt = !1) : a.tagName === 'foreignObject' && (Tt = !0);
    }
    return (
      (a['s-hn'] = mi),
      o.$flags$ & 3 &&
        ((a['s-sr'] = !0),
        (a['s-cr'] = cl),
        (a['s-sn'] = o.$name$ || ''),
        (a['s-rf'] = (n = o.$attrs$) == null ? void 0 : n.ref),
        zz(a),
        (d = e && e.$children$ && e.$children$[r]),
        d && d.$tag$ === o.$tag$ && e.$elm$ && yi(e.$elm$, !1),
        yq(cl, a, t.$elm$, e?.$elm$)),
      a
    );
  },
  yi = (e, t) => {
    qo.$flags$ |= 1;
    const r = Array.from(e.__childNodes || e.childNodes);
    e['s-sr'] && fi.experimentalSlotFixes;
    for (let n = r.length - 1; n >= 0; n--) {
      const o = r[n];
      (o['s-hn'] !== mi &&
        o['s-ol'] &&
        (Rn(hi(o).parentNode, o, hi(o)),
        o['s-ol'].remove(),
        (o['s-ol'] = void 0),
        (o['s-sh'] = void 0),
        (ng = !0)),
        t && yi(o, t));
    }
    qo.$flags$ &= -2;
  },
  dq = (e, t, r, n, o, i) => {
    let a = (e['s-cr'] && e['s-cr'].parentNode) || e,
      c;
    for (a.shadowRoot && a.tagName === mi && (a = a.shadowRoot); o <= i; ++o)
      n[o] && ((c = dl(null, r, o)), c && ((n[o].$elm$ = c), Rn(a, c, hi(t))));
  },
  pq = (e, t, r) => {
    for (let n = t; n <= r; ++n) {
      const o = e[n];
      if (o) {
        const i = o.$elm$;
        (mq(o), i && ((ul = !0), i['s-ol'] ? i['s-ol'].remove() : yi(i, !0), i.remove()));
      }
    }
  },
  Zz = (e, t, r, n, o = !1) => {
    let i = 0,
      a = 0,
      c = 0,
      d = 0,
      u = t.length - 1,
      p = t[0],
      f = t[u],
      m = n.length - 1,
      h = n[0],
      g = n[m],
      v,
      E;
    for (; i <= u && a <= m; )
      if (p == null) p = t[++i];
      else if (f == null) f = t[--u];
      else if (h == null) h = n[++a];
      else if (g == null) g = n[--m];
      else if (zi(p, h, o)) (Qn(p, h, o), (p = t[++i]), (h = n[++a]));
      else if (zi(f, g, o)) (Qn(f, g, o), (f = t[--u]), (g = n[--m]));
      else if (zi(p, g, o))
        ((p.$tag$ === 'slot' || g.$tag$ === 'slot') && yi(p.$elm$.parentNode, !1),
          Qn(p, g, o),
          Rn(e, p.$elm$, f.$elm$.nextSibling),
          (p = t[++i]),
          (g = n[--m]));
      else if (zi(f, h, o))
        ((p.$tag$ === 'slot' || g.$tag$ === 'slot') && yi(f.$elm$.parentNode, !1),
          Qn(f, h, o),
          Rn(e, f.$elm$, p.$elm$),
          (f = t[--u]),
          (h = n[++a]));
      else {
        for (c = -1, d = i; d <= u; ++d)
          if (t[d] && t[d].$key$ !== null && t[d].$key$ === h.$key$) {
            c = d;
            break;
          }
        (c >= 0
          ? ((E = t[c]),
            E.$tag$ !== h.$tag$
              ? (v = dl(t && t[a], r, c))
              : (Qn(E, h, o), (t[c] = void 0), (v = E.$elm$)),
            (h = n[++a]))
          : ((v = dl(t && t[a], r, a)), (h = n[++a])),
          v && Rn(hi(p.$elm$).parentNode, v, hi(p.$elm$)));
      }
    i > u ? dq(e, n[m + 1] == null ? null : n[m + 1].$elm$, r, n, a, m) : a > m && pq(t, i, u);
  },
  zi = (e, t, r = !1) =>
    e.$tag$ === t.$tag$
      ? e.$tag$ === 'slot'
        ? e.$name$ === t.$name$
        : r
          ? (r && !e.$key$ && t.$key$ && (e.$key$ = t.$key$), !0)
          : e.$key$ === t.$key$
      : !1,
  hi = (e) => (e && e['s-ol']) || e,
  Qn = (e, t, r = !1) => {
    const n = (t.$elm$ = e.$elm$),
      o = e.$children$,
      i = t.$children$,
      a = t.$tag$,
      c = t.$text$;
    let d;
    c === null
      ? ((Tt = a === 'svg' ? !0 : a === 'foreignObject' ? !1 : Tt),
        vp(e, t, Tt),
        o !== null && i !== null
          ? Zz(n, o, t, i, r)
          : i !== null
            ? (e.$text$ !== null && (n.textContent = ''), dq(n, null, t, i, 0, i.length - 1))
            : !r && fi.updatable && o !== null && pq(o, 0, o.length - 1),
        Tt && a === 'svg' && (Tt = !1))
      : (d = n['s-cr'])
        ? (d.parentNode.textContent = c)
        : e.$text$ !== c && (n.data = c);
  },
  _r = [],
  fq = (e) => {
    let t, r, n;
    const o = e.__childNodes || e.childNodes;
    for (const i of o) {
      if (i['s-sr'] && (t = i['s-cr']) && t.parentNode) {
        r = t.parentNode.__childNodes || t.parentNode.childNodes;
        const a = i['s-sn'];
        for (n = r.length - 1; n >= 0; n--)
          if (((t = r[n]), !t['s-cn'] && !t['s-nr'] && t['s-hn'] !== i['s-hn']))
            if (sv(t, a)) {
              let c = _r.find((d) => d.$nodeToRelocate$ === t);
              ((ul = !0),
                (t['s-sn'] = t['s-sn'] || a),
                c
                  ? ((c.$nodeToRelocate$['s-sh'] = i['s-hn']), (c.$slotRefNode$ = i))
                  : ((t['s-sh'] = i['s-hn']), _r.push({ $slotRefNode$: i, $nodeToRelocate$: t })),
                t['s-sr'] &&
                  _r.map((d) => {
                    sv(d.$nodeToRelocate$, t['s-sn']) &&
                      ((c = _r.find((u) => u.$nodeToRelocate$ === t)),
                      c && !d.$slotRefNode$ && (d.$slotRefNode$ = c.$slotRefNode$));
                  }));
            } else _r.some((c) => c.$nodeToRelocate$ === t) || _r.push({ $nodeToRelocate$: t });
      }
      i.nodeType === 1 && fq(i);
    }
  },
  mq = (e) => {
    (e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(mq));
  },
  Rn = (e, t, r) => (
    typeof t['s-sn'] == 'string' && t['s-sr'] && t['s-cr'] && yq(t['s-cr'], t, e, t.parentElement),
    e?.insertBefore(t, r)
  );
function yq(e, t, r, n) {
  var o, i;
  let a;
  if (
    e &&
    typeof t['s-sn'] == 'string' &&
    t['s-sr'] &&
    e.parentNode &&
    e.parentNode['s-sc'] &&
    (a = t['s-si'] || e.parentNode['s-sc'])
  ) {
    const c = t['s-sn'],
      d = t['s-hn'];
    if (
      ((o = r.classList) == null || o.add(a + '-s'),
      n && (i = n.classList) != null && i.contains(a + '-s'))
    ) {
      let u = (n.__childNodes || n.childNodes)[0],
        p = !1;
      for (; u; ) {
        if (u['s-sn'] !== c && u['s-hn'] === d && u['s-sr']) {
          p = !0;
          break;
        }
        u = u.nextSibling;
      }
      p || n.classList.remove(a + '-s');
    }
  }
}
var eG = (e, t, r = !1) => {
  var n, o, i, a, c;
  const d = e.$hostElement$,
    u = e.$cmpMeta$,
    p = e.$vnode$ || ll(null, null),
    m = Wz(t) ? t : al(null, null, t);
  if (
    ((mi = d.tagName),
    u.$attrsToReflect$ &&
      ((m.$attrs$ = m.$attrs$ || {}),
      u.$attrsToReflect$.forEach(([h, g]) => {
        fi.serializer && e.$serializerValues$.has(h)
          ? (m.$attrs$[g] = e.$serializerValues$.get(h))
          : (m.$attrs$[g] = d[h]);
      })),
    r && m.$attrs$)
  )
    for (const h of Object.keys(m.$attrs$))
      d.hasAttribute(h) && !['key', 'ref', 'style', 'class'].includes(h) && (m.$attrs$[h] = d[h]);
  ((m.$tag$ = null),
    (m.$flags$ |= 4),
    (e.$vnode$ = m),
    (m.$elm$ = p.$elm$ = d.shadowRoot || d),
    (da = d['s-sc']),
    (Tp = !!(u.$flags$ & 1) && !(u.$flags$ & 128)),
    (cl = d['s-cr']),
    (ul = !1),
    Qn(p, m, r));
  {
    if (((qo.$flags$ |= 1), ng)) {
      fq(m.$elm$);
      for (const h of _r) {
        const g = h.$nodeToRelocate$;
        if (!g['s-ol'] && vn.document) {
          const v = vn.document.createTextNode('');
          ((v['s-nr'] = g), Rn(g.parentNode, (g['s-ol'] = v), g));
        }
      }
      for (const h of _r) {
        const g = h.$nodeToRelocate$,
          v = h.$slotRefNode$;
        if (v) {
          const E = v.parentNode;
          let b = v.nextSibling;
          {
            let I = (n = g['s-ol']) == null ? void 0 : n.previousSibling;
            for (; I; ) {
              let q = (o = I['s-nr']) != null ? o : null;
              if (q && q['s-sn'] === g['s-sn'] && E === (q.__parentNode || q.parentNode)) {
                for (q = q.nextSibling; q === g || q?.['s-sr']; ) q = q?.nextSibling;
                if (!q || !q['s-nr']) {
                  b = q;
                  break;
                }
              }
              I = I.previousSibling;
            }
          }
          const S = g.__parentNode || g.parentNode,
            R = g.__nextSibling || g.nextSibling;
          (((!b && E !== S) || R !== b) &&
            g !== b &&
            (!g['s-hn'] && g['s-ol'] && (g['s-hn'] = g['s-ol'].parentNode.nodeName),
            Rn(E, g, b),
            g.nodeType === 1 &&
              g.tagName !== 'SLOT-FB' &&
              (g.hidden = (i = g['s-ih']) != null ? i : !1)),
            g && typeof v['s-rf'] == 'function' && v['s-rf'](v));
        } else
          g.nodeType === 1 && (r && (g['s-ih'] = (a = g.hidden) != null ? a : !1), (g.hidden = !0));
      }
    }
    (ul && lq(m.$elm$), (qo.$flags$ &= -2), (_r.length = 0));
  }
  if (fi.experimentalScopedSlotChanges && u.$flags$ & 2) {
    const h = m.$elm$.__childNodes || m.$elm$.childNodes;
    for (const g of h)
      g['s-hn'] !== mi &&
        !g['s-sh'] &&
        (r && g['s-ih'] == null && (g['s-ih'] = (c = g.hidden) != null ? c : !1), (g.hidden = !0));
  }
  cl = void 0;
};
function tG(e, t) {
  const n = { $cmpMeta$: { $flags$: 0, $tagName$: t.tagName }, $hostElement$: t };
  eG(n, e);
}
const { simulatePageLoad: rG } = __STORYBOOK_MODULE_PREVIEW_API__;
var nG = Object.defineProperty,
  oG = (e, t) => {
    for (var r in t) nG(e, r, { get: t[r], enumerable: !0 });
  };
const hq = (e, t) => {
  const { component: r, parameters: n } = t;
  if (Array.isArray(r))
    throw new Error(
      'If your story does not contain a render function, you must provide a component property!',
    );
  if (typeof r == 'string' && !customElements.get(r))
    throw new Error(
      'Stencil component not found. If you are not lazy loading your components with `defineCustomElements()` in preview.ts, pass a constructor value for component in your story `component: MyComponent`',
    );
  if (typeof r != 'string' && !customElements.getName(r))
    throw new Error(
      "Stencil component not found. If you are lazy loading your components with `defineCustomElements()` in preview.ts, pass a string value for component in your story `component: 'my-component'`",
    );
  const o = typeof r == 'string' ? r : customElements.getName(r),
    i = Object.entries(n.slots || []).map(([c, d]) => {
      const u = c === 'default' ? void 0 : c,
        p =
          typeof d == 'string'
            ? al(void 0, { slot: u }, d)
            : { ...d, $attrs$: { ...d.$attrs$, slot: u } };
      return ((p.$tag$ = p.$tag$ || (u ? 'span' : null)), p.$tag$ ? p : p.$children$);
    }),
    a = `${o}`;
  return al(a, { ...e }, i);
};
function gq({ storyFn: e, showMain: t, storyContext: r }, n) {
  const o = e();
  (t(),
    r.component &&
      r.component.is &&
      !customElements.get(r.component.is) &&
      customElements.define(r.component.is, r.component),
    n.firstChild && n.removeChild(n.firstChild));
  const i = document.createElement('div');
  (n.appendChild(i), tG(o, i), rG(i));
}
var sG = {};
oG(sG, {
  argTypesEnhancers: () => vq,
  parameters: () => bq,
  render: () => hq,
  renderToCanvas: () => gq,
});
const bq = { renderer: 'stencil' },
  vq = [sq],
  iG = Object.freeze(
    Object.defineProperty(
      { __proto__: null, argTypesEnhancers: vq, parameters: bq, render: hq, renderToCanvas: gq },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  { global: Ep } = __STORYBOOK_MODULE_GLOBAL__,
  { setDefaultProjectAnnotations: D5, setProjectAnnotations: L5 } =
    __STORYBOOK_MODULE_PREVIEW_API__;
function aG(e) {
  if (!e) return !1;
  if (typeof e == 'string') return !0;
  throw new Error('Provided component needs to be a string. e.g. component: "my-element"');
}
function lG(e) {
  if (!e) return !1;
  if (e.components && Array.isArray(e.components)) return !0;
  throw new Error(
    'You need to setup valid meta data in your stencil.config.js via docs-json output target.',
  );
}
function cG(e) {
  Ep.__STORYBOOK_CUSTOM_ELEMENTS_MANIFEST__ = e;
}
function Tq() {
  return Ep.__STORYBOOK_CUSTOM_ELEMENTS__ || Ep.__STORYBOOK_CUSTOM_ELEMENTS_MANIFEST__;
}
const { logger: uG } = __STORYBOOK_MODULE_CLIENT_LOGGER__,
  dG = (e) => {
    const t = ['string', 'number', 'boolean', 'symbol'];
    return e.type.toLowerCase() in t
      ? { name: e.type.toLowerCase(), raw: e.type, required: e.required }
      : /^\(.*\)\s*=>\s*.*$/.test(e.type)
        ? { name: 'function', raw: e.type, required: e.required }
        : { name: 'other', value: e.type, raw: e.type, required: e.required };
  },
  Eq = (e) =>
    e.values.filter((t) => ['string', 'number'].includes(t.type)).map(({ value: t }) => t),
  pG = (e) => {
    switch (e.type) {
      case 'string':
      case 'string | undefined':
        return { type: 'text' };
      case 'number':
      case 'number | undefined':
        return { type: 'number' };
      case 'boolean':
      case 'boolean | undefined':
        return { type: 'boolean' };
      case 'Date':
      case 'Date | string':
        return { type: 'date' };
      case 'function':
      case 'function | undefined':
      case 'void':
      case 'void | undefined':
        return null;
      default:
        const t = Eq(e);
        return t.length === 0
          ? { type: 'object' }
          : t.length < 5
            ? { type: 'radio' }
            : { type: 'select' };
    }
  },
  Bc = (e, t) => {
    if (!t || t.length === 0) return e;
    const r = [],
      n = [],
      o = t.filter((d) => d.name === 'deprecated');
    o.length > 0 &&
      o.forEach((d) => {
        d.text ? n.push(`** DEPRECATED:** ${d.text}`) : n.push('** DEPRECATED**');
      });
    const i = t.filter((d) => d.name === 'see');
    if (i.length > 0) {
      const d = i
        .map((u) => {
          const p = u.text?.trim();
          return p ? `[${p}](${p})` : '';
        })
        .filter(Boolean)
        .join(', ');
      d && r.push(`**See:** ${d}`);
    }
    const a = t.filter((d) => d.name === 'since');
    if (a.length > 0) {
      const d = a
        .map((u) => u.text)
        .filter(Boolean)
        .join(', ');
      d && r.push(`**Since:** ${d}`);
    }
    return [...n, e, ...r].filter(Boolean).join(`

`);
  },
  bu = (e, t) =>
    e.reduce(
      (r, n) => (
        (r[n.name] = {
          name: n.name,
          description: Bc(n.docs, n.docsTags),
          control: !1,
          table: { category: t },
        }),
        r
      ),
      {},
    ),
  fG = (e) =>
    e.reduce(
      (t, r) => (
        (t[r.name] = {
          name: r.name,
          description: Bc(r.docs, r.docsTags),
          control: null,
          type: { name: 'function' },
          table: { category: 'methods', type: { summary: r.signature } },
        }),
        t
      ),
      {},
    ),
  mG = (e) =>
    e.reduce((t, r) => {
      let n = r.event
        .replace(/(-|_|:|\.|\s)+(.)?/g, (o, i, a) => (a ? a.toUpperCase() : ''))
        .replace(/^([A-Z])/, (o) => o.toLowerCase());
      return (
        (n = `on${n.charAt(0).toUpperCase() + n.slice(1)}`),
        (t[n] = {
          name: n,
          description: Bc(r.docs, r.docsTags),
          control: null,
          table: { category: 'events', type: { summary: r.detail } },
          type: { name: 'function' },
        }),
        t
      );
    }, {}),
  yG = (e) =>
    e.reduce(
      (t, r) => (
        (t[r.name] = {
          name: r.attr || r.name,
          description: Bc(r.docs, r.docsTags),
          control: pG(r),
          table: {
            category: 'properties',
            type: { summary: r.complexType?.original },
            defaultValue: { summary: r.default },
          },
          options: Eq(r),
          type: dG(r),
        }),
        t
      ),
      {},
    ),
  wq = (e, t) => {
    if (!aG(e) || !lG(t)) return null;
    const r = t.components.find((n) => n.tag.toUpperCase() === e.toUpperCase());
    return (r || uG.warn(`Component not found in custom-elements.json: ${e}`), r);
  },
  hG = (e, t) => {
    const r = wq(e, t);
    return (
      r && {
        ...yG(r.props),
        ...mG(r.events),
        ...fG(r.methods),
        ...bu(r.slots, 'slots'),
        ...bu(r.parts, 'parts'),
        ...bu(r.styles, 'styles'),
      }
    );
  },
  gG = (e) => {
    const t = Tq(),
      r = typeof e == 'string' ? e : e?.is;
    return hG(r, t);
  },
  bG = (e) => {
    const t = typeof e == 'string' ? e : e?.is,
      r = wq(t, Tq());
    return r && r.docs;
  },
  vG = { docs: { extractArgTypes: gG, extractComponentDescription: bG } },
  TG = [sq],
  EG = Object.freeze(
    Object.defineProperty(
      { __proto__: null, argTypesEnhancers: TG, parameters: vG },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  wG = 'uxbit',
  pl = { hydratedSelectorName: 'hydrated', lazyLoad: !0, propChangeCallback: !0, updatable: !0 };
var SG = Object.defineProperty,
  _G = (e, t) => {
    for (var r in t) SG(e, r, { get: t[r], enumerable: !0 });
  },
  ar = (e) => {
    if (e.__stencil__getHostRef) return e.__stencil__getHostRef();
  },
  AG = (e, t) => {
    const r = {
      $flags$: 0,
      $hostElement$: e,
      $cmpMeta$: t,
      $instanceValues$: new Map(),
      $serializerValues$: new Map(),
    };
    ((r.$onReadyPromise$ = new Promise((o) => (r.$onReadyResolve$ = o))),
      (e['s-p'] = []),
      (e['s-rc'] = []),
      (r.$fetchedCbList$ = []));
    const n = r;
    return ((e.__stencil__getHostRef = () => n), n);
  },
  dv = (e, t) => t in e,
  zo = (e, t) => (0, console.error)(e, t),
  pv = new Map(),
  RG = (e, t, r) => {
    const n = e.$tagName$.replace(/-/g, '_'),
      o = e.$lazyBundleId$;
    if (!o) return;
    const i = pv.get(o);
    if (i) return i[n];
    return mn(() => import(`./${o}.entry.js`), [], import.meta.url).then(
      (a) => (pv.set(o, a), a[n]),
      (a) => {
        zo(a, t.$hostElement$);
      },
    );
  },
  fl = new Map(),
  xG = '{visibility:hidden}.hydrated{visibility:inherit}',
  Sq = 'slot-fb{display:contents}slot-fb[hidden]{display:none}',
  fv = 'http://www.w3.org/1999/xlink',
  lt = typeof window < 'u' ? window : {},
  at = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (e) => e(),
    raf: (e) => requestAnimationFrame(e),
    ael: (e, t, r, n) => e.addEventListener(t, r, n),
    rel: (e, t, r, n) => e.removeEventListener(t, r, n),
    ce: (e, t) => new CustomEvent(e, t),
  },
  PG = (e) => Promise.resolve(e),
  og = (() => {
    try {
      return (new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == 'function');
    } catch {}
    return !1;
  })(),
  wp = og
    ? !!lt.document &&
      Object.getOwnPropertyDescriptor(lt.document.adoptedStyleSheets, 'length').writable
    : !1,
  Sp = !1,
  mv = [],
  _q = [],
  OG = (e, t) => (r) => {
    (e.push(r), Sp || ((Sp = !0), at.$flags$ & 4 ? sg(_p) : at.raf(_p)));
  },
  yv = (e) => {
    for (let t = 0; t < e.length; t++)
      try {
        e[t](performance.now());
      } catch (r) {
        zo(r);
      }
    e.length = 0;
  },
  _p = () => {
    (yv(mv), yv(_q), (Sp = mv.length > 0) && at.raf(_p));
  },
  sg = (e) => PG().then(e),
  CG = OG(_q),
  ig = (e) => ((e = typeof e), e === 'object' || e === 'function');
function Aq(e) {
  var t, r, n;
  return (n =
    (r = (t = e.head) == null ? void 0 : t.querySelector('meta[name="csp-nonce"]')) == null
      ? void 0
      : r.getAttribute('content')) != null
    ? n
    : void 0;
}
var IG = (e) => e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
  NG = {};
_G(NG, { err: () => Rq, map: () => qG, ok: () => Ap, unwrap: () => MG, unwrapErr: () => jG });
var Ap = (e) => ({ isOk: !0, isErr: !1, value: e }),
  Rq = (e) => ({ isOk: !1, isErr: !0, value: e });
function qG(e, t) {
  if (e.isOk) {
    const r = t(e.value);
    return r instanceof Promise ? r.then((n) => Ap(n)) : Ap(r);
  }
  if (e.isErr) {
    const r = e.value;
    return Rq(r);
  }
  throw 'should never get here';
}
var MG = (e) => {
    if (e.isOk) return e.value;
    throw e.value;
  },
  jG = (e) => {
    if (e.isErr) return e.value;
    throw e.value;
  };
var Ss;
function $G(e) {
  var t;
  const r = this.attachShadow({ mode: 'open' });
  (Ss === void 0 && (Ss = (t = void 0) != null ? t : null),
    Ss &&
      (wp
        ? r.adoptedStyleSheets.push(Ss)
        : (r.adoptedStyleSheets = [...r.adoptedStyleSheets, Ss])));
}
var Ir =
    (e, t = '') =>
    () => {},
  kG = (e, t) => () => {},
  so = new WeakMap(),
  DG = (e, t, r) => {
    let n = fl.get(e);
    (og && r
      ? ((n = n || new CSSStyleSheet()), typeof n == 'string' ? (n = t) : n.replaceSync(t))
      : (n = t),
      fl.set(e, n));
  },
  LG = (e, t, r) => {
    var n;
    const o = xq(t),
      i = fl.get(o);
    if (!lt.document) return o;
    if (((e = e.nodeType === 11 ? e : lt.document), i))
      if (typeof i == 'string') {
        e = e.head || e;
        let a = so.get(e),
          c;
        if ((a || so.set(e, (a = new Set())), !a.has(o))) {
          {
            ((c = lt.document.createElement('style')), (c.innerHTML = i));
            const d = (n = at.$nonce$) != null ? n : Aq(lt.document);
            if ((d != null && c.setAttribute('nonce', d), !(t.$flags$ & 1)))
              if (e.nodeName === 'HEAD') {
                const u = e.querySelectorAll('link[rel=preconnect]'),
                  p = u.length > 0 ? u[u.length - 1].nextSibling : e.querySelector('style');
                e.insertBefore(c, p?.parentNode === e ? p : null);
              } else if ('host' in e)
                if (og) {
                  const u = new CSSStyleSheet();
                  (u.replaceSync(i),
                    wp
                      ? e.adoptedStyleSheets.unshift(u)
                      : (e.adoptedStyleSheets = [u, ...e.adoptedStyleSheets]));
                } else {
                  const u = e.querySelector('style');
                  u ? (u.innerHTML = i + u.innerHTML) : e.prepend(c);
                }
              else e.append(c);
            t.$flags$ & 1 && e.insertBefore(c, null);
          }
          (t.$flags$ & 4 && (c.innerHTML += Sq), a && a.add(o));
        }
      } else
        e.adoptedStyleSheets.includes(i) ||
          (wp
            ? e.adoptedStyleSheets.push(i)
            : (e.adoptedStyleSheets = [...e.adoptedStyleSheets, i]));
    return o;
  },
  FG = (e) => {
    const t = e.$cmpMeta$,
      r = e.$hostElement$,
      n = t.$flags$,
      o = Ir('attachStyles', t.$tagName$),
      i = LG(r.shadowRoot ? r.shadowRoot : r.getRootNode(), t);
    (n & 10 && ((r['s-sc'] = i), r.classList.add(i + '-h')), o());
  },
  xq = (e, t) => 'sc-' + e.$tagName$,
  BG = (e, t, ...r) => {
    let n = null,
      o = null,
      i = !1,
      a = !1;
    const c = [],
      d = (p) => {
        for (let f = 0; f < p.length; f++)
          ((n = p[f]),
            Array.isArray(n)
              ? d(n)
              : n != null &&
                typeof n != 'boolean' &&
                ((i = !ig(n)) && (n = String(n)),
                i && a ? (c[c.length - 1].$text$ += n) : c.push(i ? Rp(null, n) : n),
                (a = i)));
      };
    d(r);
    const u = Rp(e, null);
    return ((u.$attrs$ = t), c.length > 0 && (u.$children$ = c), (u.$key$ = o), u);
  },
  Rp = (e, t) => {
    const r = { $flags$: 0, $tag$: e, $text$: t, $elm$: null, $children$: null };
    return ((r.$attrs$ = null), (r.$key$ = null), r);
  },
  JG = {},
  UG = (e) => e && e.$tag$ === JG,
  ag = (e) => {
    const t = IG(e);
    return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`, 'g');
  };
ag('::slotted');
ag(':host');
ag(':host-context');
var xp = (e, t, r) =>
    e != null && !ig(e)
      ? t & 4
        ? e === 'false'
          ? !1
          : e === '' || !!e
        : t & 2
          ? typeof e == 'string'
            ? parseFloat(e)
            : typeof e == 'number'
              ? e
              : NaN
          : t & 1
            ? String(e)
            : e
      : e,
  VG = (e, t, r) => {
    const n = at.ce(t, r);
    return (e.dispatchEvent(n), n);
  },
  hv = (e, t, r, n, o, i, a) => {
    if (r === n) return;
    let c = dv(e, t),
      d = t.toLowerCase();
    if (t === 'class') {
      const u = e.classList,
        p = gv(r);
      let f = gv(n);
      (u.remove(...p.filter((m) => m && !f.includes(m))),
        u.add(...f.filter((m) => m && !p.includes(m))));
    } else if (t === 'style') {
      for (const u in r)
        (!n || n[u] == null) && (u.includes('-') ? e.style.removeProperty(u) : (e.style[u] = ''));
      for (const u in n)
        (!r || n[u] !== r[u]) &&
          (u.includes('-') ? e.style.setProperty(u, n[u]) : (e.style[u] = n[u]));
    } else if (t !== 'key')
      if (t === 'ref') n && n(e);
      else if (!c && t[0] === 'o' && t[1] === 'n') {
        if (
          (t[2] === '-' ? (t = t.slice(3)) : dv(lt, d) ? (t = d.slice(2)) : (t = d[2] + t.slice(3)),
          r || n)
        ) {
          const u = t.endsWith(Pq);
          ((t = t.replace(zG, '')), r && at.rel(e, t, r, u), n && at.ael(e, t, n, u));
        }
      } else {
        const u = ig(n);
        if (c || (u && n !== null))
          try {
            if (e.tagName.includes('-')) e[t] !== n && (e[t] = n);
            else {
              const f = n ?? '';
              t === 'list'
                ? (c = !1)
                : (r == null || e[t] != f) &&
                  (typeof e.__lookupSetter__(t) == 'function' ? (e[t] = f) : e.setAttribute(t, f));
            }
          } catch {}
        let p = !1;
        (d !== (d = d.replace(/^xlink\:?/, '')) && ((t = d), (p = !0)),
          n == null || n === !1
            ? (n !== !1 || e.getAttribute(t) === '') &&
              (p ? e.removeAttributeNS(fv, t) : e.removeAttribute(t))
            : (!c || i & 4 || o) &&
              !u &&
              e.nodeType === 1 &&
              ((n = n === !0 ? '' : n), p ? e.setAttributeNS(fv, t, n) : e.setAttribute(t, n)));
      }
  },
  HG = /\s/,
  gv = (e) => (
    typeof e == 'object' && e && 'baseVal' in e && (e = e.baseVal),
    !e || typeof e != 'string' ? [] : e.split(HG)
  ),
  Pq = 'Capture',
  zG = new RegExp(Pq + '$'),
  Oq = (e, t, r, n) => {
    const o = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$,
      i = (e && e.$attrs$) || {},
      a = t.$attrs$ || {};
    for (const c of bv(Object.keys(i))) c in a || hv(o, c, i[c], void 0, r, t.$flags$);
    for (const c of bv(Object.keys(a))) hv(o, c, i[c], a[c], r, t.$flags$);
  };
function bv(e) {
  return e.includes('ref') ? [...e.filter((t) => t !== 'ref'), 'ref'] : e;
}
var lg,
  Cq = !1,
  ml = (e, t, r) => {
    const n = t.$children$[r];
    let o = 0,
      i,
      a;
    if (n.$text$ !== null) i = n.$elm$ = lt.document.createTextNode(n.$text$);
    else {
      if (!lt.document)
        throw new Error(
          "You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.",
        );
      if (((i = n.$elm$ = lt.document.createElement(n.$tag$)), Oq(null, n, Cq), n.$children$))
        for (o = 0; o < n.$children$.length; ++o) ((a = ml(e, n, o)), a && i.appendChild(a));
    }
    return ((i['s-hn'] = lg), i);
  },
  Iq = (e, t, r, n, o, i) => {
    let a = e,
      c;
    for (a.shadowRoot && a.tagName === lg && (a = a.shadowRoot); o <= i; ++o)
      n[o] && ((c = ml(null, r, o)), c && ((n[o].$elm$ = c), pa(a, c, t)));
  },
  Nq = (e, t, r) => {
    for (let n = t; n <= r; ++n) {
      const o = e[n];
      if (o) {
        const i = o.$elm$;
        (qq(o), i && i.remove());
      }
    }
  },
  GG = (e, t, r, n, o = !1) => {
    let i = 0,
      a = 0,
      c = 0,
      d = 0,
      u = t.length - 1,
      p = t[0],
      f = t[u],
      m = n.length - 1,
      h = n[0],
      g = n[m],
      v,
      E;
    for (; i <= u && a <= m; )
      if (p == null) p = t[++i];
      else if (f == null) f = t[--u];
      else if (h == null) h = n[++a];
      else if (g == null) g = n[--m];
      else if (Gi(p, h, o)) (Zn(p, h, o), (p = t[++i]), (h = n[++a]));
      else if (Gi(f, g, o)) (Zn(f, g, o), (f = t[--u]), (g = n[--m]));
      else if (Gi(p, g, o))
        (Zn(p, g, o), pa(e, p.$elm$, f.$elm$.nextSibling), (p = t[++i]), (g = n[--m]));
      else if (Gi(f, h, o)) (Zn(f, h, o), pa(e, f.$elm$, p.$elm$), (f = t[--u]), (h = n[++a]));
      else {
        for (c = -1, d = i; d <= u; ++d)
          if (t[d] && t[d].$key$ !== null && t[d].$key$ === h.$key$) {
            c = d;
            break;
          }
        (c >= 0
          ? ((E = t[c]),
            E.$tag$ !== h.$tag$
              ? (v = ml(t && t[a], r, c))
              : (Zn(E, h, o), (t[c] = void 0), (v = E.$elm$)),
            (h = n[++a]))
          : ((v = ml(t && t[a], r, a)), (h = n[++a])),
          v && pa(p.$elm$.parentNode, v, p.$elm$));
      }
    i > u ? Iq(e, n[m + 1] == null ? null : n[m + 1].$elm$, r, n, a, m) : a > m && Nq(t, i, u);
  },
  Gi = (e, t, r = !1) =>
    e.$tag$ === t.$tag$
      ? r
        ? (r && !e.$key$ && t.$key$ && (e.$key$ = t.$key$), !0)
        : e.$key$ === t.$key$
      : !1,
  Zn = (e, t, r = !1) => {
    const n = (t.$elm$ = e.$elm$),
      o = e.$children$,
      i = t.$children$,
      a = t.$text$;
    a === null
      ? (Oq(e, t, Cq),
        o !== null && i !== null
          ? GG(n, o, t, i, r)
          : i !== null
            ? (e.$text$ !== null && (n.textContent = ''), Iq(n, null, t, i, 0, i.length - 1))
            : !r && pl.updatable && o !== null && Nq(o, 0, o.length - 1))
      : e.$text$ !== a && (n.data = a);
  },
  qq = (e) => {
    (e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(qq));
  },
  pa = (e, t, r) => e?.insertBefore(t, r),
  WG = (e, t, r = !1) => {
    const n = e.$hostElement$,
      o = e.$cmpMeta$,
      i = e.$vnode$ || Rp(null, null),
      c = UG(t) ? t : BG(null, null, t);
    if (
      ((lg = n.tagName),
      o.$attrsToReflect$ &&
        ((c.$attrs$ = c.$attrs$ || {}),
        o.$attrsToReflect$.forEach(([d, u]) => {
          c.$attrs$[u] = n[d];
        })),
      r && c.$attrs$)
    )
      for (const d of Object.keys(c.$attrs$))
        n.hasAttribute(d) && !['key', 'ref', 'style', 'class'].includes(d) && (c.$attrs$[d] = n[d]);
    ((c.$tag$ = null),
      (c.$flags$ |= 4),
      (e.$vnode$ = c),
      (c.$elm$ = i.$elm$ = n.shadowRoot || n),
      Zn(i, c, r));
  },
  Mq = (e, t) => {
    if (t && !e.$onRenderResolve$ && t['s-p']) {
      const r = t['s-p'].push(
        new Promise(
          (n) =>
            (e.$onRenderResolve$ = () => {
              (t['s-p'].splice(r - 1, 1), n());
            }),
        ),
      );
    }
  },
  cg = (e, t) => {
    if (((e.$flags$ |= 16), e.$flags$ & 4)) {
      e.$flags$ |= 512;
      return;
    }
    Mq(e, e.$ancestorComponent$);
    const r = () => KG(e, t);
    if (t) {
      queueMicrotask(() => {
        r();
      });
      return;
    }
    return CG(r);
  },
  KG = (e, t) => {
    const r = e.$hostElement$,
      n = Ir('scheduleUpdate', e.$cmpMeta$.$tagName$),
      o = e.$lazyInstance$;
    if (!o)
      throw new Error(
        `Can't render component <${r.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`,
      );
    let i;
    return (
      t
        ? (e.$fetchedCbList$.length && e.$fetchedCbList$.forEach((a) => a(r)),
          (i = Wr(o, 'componentWillLoad', void 0, r)))
        : (i = Wr(o, 'componentWillUpdate', void 0, r)),
      (i = vv(i, () => Wr(o, 'componentWillRender', void 0, r))),
      n(),
      vv(i, () => XG(e, o, t))
    );
  },
  vv = (e, t) =>
    YG(e)
      ? e.then(t).catch((r) => {
          (console.error(r), t());
        })
      : t(),
  YG = (e) => e instanceof Promise || (e && e.then && typeof e.then == 'function'),
  XG = async (e, t, r) => {
    var n;
    const o = e.$hostElement$,
      i = Ir('update', e.$cmpMeta$.$tagName$),
      a = o['s-rc'];
    r && FG(e);
    const c = Ir('render', e.$cmpMeta$.$tagName$);
    (QG(e, t, o, r), a && (a.map((d) => d()), (o['s-rc'] = void 0)), c(), i());
    {
      const d = (n = o['s-p']) != null ? n : [],
        u = () => ZG(e);
      d.length === 0 ? u() : (Promise.all(d).then(u), (e.$flags$ |= 4), (d.length = 0));
    }
  },
  QG = (e, t, r, n) => {
    try {
      ((t = t.render()), (e.$flags$ &= -17), (e.$flags$ |= 2), WG(e, t, n));
    } catch (o) {
      zo(o, e.$hostElement$);
    }
    return null;
  },
  ZG = (e) => {
    const t = e.$cmpMeta$.$tagName$,
      r = e.$hostElement$,
      n = Ir('postUpdate', t),
      o = e.$lazyInstance$,
      i = e.$ancestorComponent$;
    (Wr(o, 'componentDidRender', void 0, r),
      e.$flags$ & 64
        ? (Wr(o, 'componentDidUpdate', void 0, r), n())
        : ((e.$flags$ |= 64),
          eW(r),
          Wr(o, 'componentDidLoad', void 0, r),
          n(),
          e.$onReadyResolve$(r),
          i || jq()),
      e.$onRenderResolve$ && (e.$onRenderResolve$(), (e.$onRenderResolve$ = void 0)),
      e.$flags$ & 512 && sg(() => cg(e, !1)),
      (e.$flags$ &= -517));
  },
  jq = (e) => {
    sg(() => VG(lt, 'appload', { detail: { namespace: wG } }));
  },
  Wr = (e, t, r, n) => {
    if (e && e[t])
      try {
        return e[t](r);
      } catch (o) {
        zo(o, n);
      }
  },
  eW = (e) => {
    var t;
    return e.classList.add((t = pl.hydratedSelectorName) != null ? t : 'hydrated');
  },
  tW = (e, t) => ar(e).$instanceValues$.get(t),
  vu = (e, t, r, n) => {
    const o = ar(e);
    if (!o) return;
    if (!o)
      throw new Error(
        `Couldn't find host element for "${n.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/stenciljs/core/issues/5457).`,
      );
    const i = o.$hostElement$,
      a = o.$instanceValues$.get(t),
      c = o.$flags$,
      d = o.$lazyInstance$;
    r = xp(r, n.$members$[t][0]);
    const u = Number.isNaN(a) && Number.isNaN(r),
      p = r !== a && !u;
    if ((!(c & 8) || a === void 0) && p && (o.$instanceValues$.set(t, r), d)) {
      if (n.$watchers$ && c & 128) {
        const f = n.$watchers$[t];
        f &&
          f.map((m) => {
            try {
              d[m](r, a, t);
            } catch (h) {
              zo(h, i);
            }
          });
      }
      if ((c & 18) === 2) {
        if (d.componentShouldUpdate && d.componentShouldUpdate(r, a, t) === !1) return;
        cg(o, !1);
      }
    }
  },
  $q = (e, t, r) => {
    var n, o;
    const i = e.prototype;
    if (t.$members$ || pl.propChangeCallback) {
      (e.watchers && !t.$watchers$ && (t.$watchers$ = e.watchers),
        e.deserializers && !t.$deserializers$ && (t.$deserializers$ = e.deserializers),
        e.serializers && !t.$serializers$ && (t.$serializers$ = e.serializers));
      const a = Object.entries((n = t.$members$) != null ? n : {});
      if (
        (a.map(([c, [d]]) => {
          if (d & 31 || (r & 2 && d & 32)) {
            const { get: u, set: p } = Object.getOwnPropertyDescriptor(i, c) || {};
            (u && (t.$members$[c][0] |= 2048),
              p && (t.$members$[c][0] |= 4096),
              (r & 1 || !u) &&
                Object.defineProperty(i, c, {
                  get() {
                    {
                      if ((t.$members$[c][0] & 2048) === 0) return tW(this, c);
                      const f = ar(this),
                        m = f ? f.$lazyInstance$ : i;
                      return m ? m[c] : void 0;
                    }
                  },
                  configurable: !0,
                  enumerable: !0,
                }),
              Object.defineProperty(i, c, {
                set(f) {
                  const m = ar(this);
                  if (m) {
                    if (p) {
                      (typeof (d & 32 ? this[c] : m.$hostElement$[c]) > 'u' &&
                        m.$instanceValues$.get(c) &&
                        (f = m.$instanceValues$.get(c)),
                        p.apply(this, [xp(f, d)]),
                        (f = d & 32 ? this[c] : m.$hostElement$[c]),
                        vu(this, c, f, t));
                      return;
                    }
                    {
                      if ((r & 1) === 0 || (t.$members$[c][0] & 4096) === 0) {
                        (vu(this, c, f, t),
                          r & 1 &&
                            !m.$lazyInstance$ &&
                            m.$fetchedCbList$.push(() => {
                              t.$members$[c][0] & 4096 &&
                                m.$lazyInstance$[c] !== m.$instanceValues$.get(c) &&
                                (m.$lazyInstance$[c] = f);
                            }));
                        return;
                      }
                      const h = () => {
                        const g = m.$lazyInstance$[c];
                        (!m.$instanceValues$.get(c) && g && m.$instanceValues$.set(c, g),
                          (m.$lazyInstance$[c] = xp(f, d)),
                          vu(this, c, m.$lazyInstance$[c], t));
                      };
                      m.$lazyInstance$
                        ? h()
                        : m.$fetchedCbList$.push(() => {
                            h();
                          });
                    }
                  }
                },
              }));
          }
        }),
        r & 1)
      ) {
        const c = new Map();
        ((i.attributeChangedCallback = function (d, u, p) {
          at.jmp(() => {
            var f;
            const m = c.get(d),
              h = ar(this);
            if (
              (this.hasOwnProperty(m) && pl.lazyLoad && ((p = this[m]), delete this[m]),
              i.hasOwnProperty(m) && typeof this[m] == 'number' && this[m] == p)
            )
              return;
            if (m == null) {
              const E = h?.$flags$;
              if (h && E && !(E & 8) && E & 128 && p !== u) {
                const b = h.$lazyInstance$,
                  S = (f = t.$watchers$) == null ? void 0 : f[d];
                S?.forEach((R) => {
                  b[R] != null && b[R].call(b, p, u, d);
                });
              }
              return;
            }
            const g = a.find(([E]) => E === m);
            g && g[1][0] & 4 && (p = !(p === null || p === 'false'));
            const v = Object.getOwnPropertyDescriptor(i, m);
            p != this[m] && (!v.get || v.set) && (this[m] = p);
          });
        }),
          (e.observedAttributes = Array.from(
            new Set([
              ...Object.keys((o = t.$watchers$) != null ? o : {}),
              ...a
                .filter(([d, u]) => u[0] & 31)
                .map(([d, u]) => {
                  var p;
                  const f = u[1] || d;
                  return (
                    c.set(f, d),
                    u[0] & 512 && ((p = t.$attrsToReflect$) == null || p.push([d, f])),
                    f
                  );
                }),
            ]),
          )));
      }
    }
    return e;
  },
  rW = async (e, t, r, n) => {
    let o;
    if ((t.$flags$ & 32) === 0) {
      if (((t.$flags$ |= 32), r.$lazyBundleId$)) {
        const d = RG(r, t);
        if (d && 'then' in d) {
          const p = kG();
          ((o = await d), p());
        } else o = d;
        if (!o) throw new Error(`Constructor for "${r.$tagName$}#${t.$modeName$}" was not found`);
        o.isProxied ||
          ((r.$watchers$ = o.watchers),
          (r.$serializers$ = o.serializers),
          (r.$deserializers$ = o.deserializers),
          $q(o, r, 2),
          (o.isProxied = !0));
        const u = Ir('createInstance', r.$tagName$);
        t.$flags$ |= 8;
        try {
          new o(t);
        } catch (p) {
          zo(p, e);
        }
        ((t.$flags$ &= -9), (t.$flags$ |= 128), u(), Pp(t.$lazyInstance$, e));
      } else {
        o = e.constructor;
        const d = e.localName;
        customElements.whenDefined(d).then(() => (t.$flags$ |= 128));
      }
      if (o && o.style) {
        let d;
        typeof o.style == 'string' && (d = o.style);
        const u = xq(r);
        if (!fl.has(u)) {
          const p = Ir('registerStyles', r.$tagName$);
          (DG(u, d, !!(r.$flags$ & 1)), p());
        }
      }
    }
    const i = t.$ancestorComponent$,
      a = () => cg(t, !0);
    i && i['s-rc'] ? i['s-rc'].push(a) : a();
  },
  Pp = (e, t) => {
    Wr(e, 'connectedCallback', void 0, t);
  },
  nW = (e) => {
    if ((at.$flags$ & 1) === 0) {
      const t = ar(e);
      if (!t) return;
      const r = t.$cmpMeta$,
        n = Ir('connectedCallback', r.$tagName$);
      if (t.$flags$ & 1)
        t?.$lazyInstance$
          ? Pp(t.$lazyInstance$, e)
          : t?.$onReadyPromise$ && t.$onReadyPromise$.then(() => Pp(t.$lazyInstance$, e));
      else {
        t.$flags$ |= 1;
        {
          let o = e;
          for (; (o = o.parentNode || o.host); )
            if (o['s-p']) {
              Mq(t, (t.$ancestorComponent$ = o));
              break;
            }
        }
        (r.$members$ &&
          Object.entries(r.$members$).map(([o, [i]]) => {
            if (i & 31 && o in e && e[o] !== Object.prototype[o]) {
              const a = e[o];
              (delete e[o], (e[o] = a));
            }
          }),
          rW(e, t, r));
      }
      n();
    }
  },
  Tv = (e, t) => {
    Wr(e, 'disconnectedCallback', void 0, t || e);
  },
  oW = async (e) => {
    if ((at.$flags$ & 1) === 0) {
      const t = ar(e);
      t?.$lazyInstance$
        ? Tv(t.$lazyInstance$, e)
        : t?.$onReadyPromise$ && t.$onReadyPromise$.then(() => Tv(t.$lazyInstance$, e));
    }
    (so.has(e) && so.delete(e), e.shadowRoot && so.has(e.shadowRoot) && so.delete(e.shadowRoot));
  },
  sW = (e, t = {}) => {
    var r;
    if (!lt.document) {
      console.warn('Stencil: No document found. Skipping bootstrapping lazy components.');
      return;
    }
    const n = Ir(),
      o = [],
      i = t.exclude || [],
      a = lt.customElements,
      c = lt.document.head,
      d = c.querySelector('meta[charset]'),
      u = lt.document.createElement('style'),
      p = [];
    let f,
      m = !0;
    (Object.assign(at, t),
      (at.$resourcesUrl$ = new URL(t.resourcesUrl || './', lt.document.baseURI).href));
    let h = !1;
    if (
      (e.map((g) => {
        g[1].map((v) => {
          var E, b, S;
          const R = { $flags$: v[0], $tagName$: v[1], $members$: v[2], $listeners$: v[3] };
          (R.$flags$ & 4 && (h = !0),
            (R.$members$ = v[2]),
            (R.$attrsToReflect$ = []),
            (R.$watchers$ = (E = v[4]) != null ? E : {}),
            (R.$serializers$ = (b = v[5]) != null ? b : {}),
            (R.$deserializers$ = (S = v[6]) != null ? S : {}));
          const I = R.$tagName$,
            q = class extends HTMLElement {
              constructor(P) {
                if (
                  (super(P),
                  (this.hasRegisteredEventListeners = !1),
                  (P = this),
                  AG(P, R),
                  R.$flags$ & 1)
                ) {
                  if (!P.shadowRoot) $G.call(P, R);
                  else if (P.shadowRoot.mode !== 'open')
                    throw new Error(
                      `Unable to re-use existing shadow root for ${R.$tagName$}! Mode is set to ${P.shadowRoot.mode} but Stencil only supports open shadow roots.`,
                    );
                }
              }
              connectedCallback() {
                ar(this) &&
                  (this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = !0),
                  f && (clearTimeout(f), (f = null)),
                  m ? p.push(this) : at.jmp(() => nW(this)));
              }
              disconnectedCallback() {
                (at.jmp(() => oW(this)),
                  at.raf(() => {
                    var P;
                    const A = ar(this);
                    if (!A) return;
                    const w = p.findIndex((_) => _ === this);
                    (w > -1 && p.splice(w, 1),
                      ((P = A?.$vnode$) == null ? void 0 : P.$elm$) instanceof Node &&
                        !A.$vnode$.$elm$.isConnected &&
                        delete A.$vnode$.$elm$);
                  }));
              }
              componentOnReady() {
                var P;
                return (P = ar(this)) == null ? void 0 : P.$onReadyPromise$;
              }
            };
          ((R.$lazyBundleId$ = g[0]),
            !i.includes(I) && !a.get(I) && (o.push(I), a.define(I, $q(q, R, 1))));
        });
      }),
      o.length > 0 &&
        (h && (u.textContent += Sq), (u.textContent += o.sort() + xG), u.innerHTML.length))
    ) {
      u.setAttribute('data-styles', '');
      const g = (r = at.$nonce$) != null ? r : Aq(lt.document);
      (g != null && u.setAttribute('nonce', g),
        c.insertBefore(u, d ? d.nextSibling : c.firstChild));
    }
    ((m = !1),
      p.length ? p.map((g) => g.connectedCallback()) : at.jmp(() => (f = setTimeout(jq, 30))),
      n());
  };
const iW = () => {},
  aW = async (e, t) => {
    if (!(typeof window > 'u'))
      return (
        await iW(),
        sW(
          [
            [
              'tinto-button_5',
              [
                [
                  769,
                  'tinto-button',
                  {
                    variant: [513],
                    size: [513],
                    pill: [516],
                    block: [516],
                    elevated: [516],
                    outline: [516],
                    radius: [513],
                    disabled: [516],
                    loading: [516],
                    toggle: [516],
                    pressed: [1540],
                    type: [513],
                    href: [513],
                    target: [513],
                    label: [513],
                    textFamily: [513, 'text-family'],
                    textSize: [513, 'text-size'],
                    textWeight: [513, 'text-weight'],
                    textColor: [513, 'text-color'],
                  },
                  null,
                  {
                    textFamily: ['handleStyleTokenChange'],
                    textSize: ['handleStyleTokenChange'],
                    textWeight: ['handleStyleTokenChange'],
                    textColor: ['handleStyleTokenChange'],
                    radius: ['handleStyleTokenChange'],
                  },
                ],
                [
                  769,
                  'tinto-image',
                  {
                    src: [513],
                    alt: [513],
                    ratio: [513],
                    fit: [513],
                    position: [513],
                    radius: [513],
                    rounded: [513],
                    border: [513],
                    shadow: [513],
                    background: [513],
                    width: [513],
                    height: [513],
                    loading: [513],
                    priority: [516],
                    placeholder: [513],
                    srcset: [513],
                    sizes: [513],
                    decoding: [513],
                    crossorigin: [513],
                    referrerpolicy: [513],
                    href: [513],
                    target: [513],
                    rel: [513],
                    download: [513],
                    as: [513],
                    disabled: [516],
                    animation: [513],
                    play: [516],
                    rotate: [513],
                    duration: [514],
                    repeat: [520],
                    pauseOnHover: [516, 'pause-on-hover'],
                    startOnViewport: [516, 'start-on-viewport'],
                  },
                  null,
                  {
                    ratio: ['applyFrameStyles'],
                    fit: ['applyFrameStyles'],
                    position: ['applyFrameStyles'],
                    radius: ['applyFrameStyles'],
                    rounded: ['applyFrameStyles'],
                    border: ['applyFrameStyles'],
                    shadow: ['applyFrameStyles'],
                    background: ['applyFrameStyles'],
                    width: ['syncHostBoxSize'],
                    height: ['syncHostBoxSize'],
                    src: ['updateImageAttrs'],
                    alt: ['updateImageAttrs'],
                    srcset: ['updateImageAttrs'],
                    sizes: ['updateImageAttrs'],
                    loading: ['updateImageAttrs'],
                    priority: ['updateImageAttrs'],
                    placeholder: ['updateImageAttrs'],
                    decoding: ['updateImageAttrs'],
                    crossorigin: ['updateImageAttrs'],
                    referrerpolicy: ['updateImageAttrs'],
                    href: ['onStructureChanged'],
                    as: ['onStructureChanged'],
                    target: ['onStructureChanged'],
                    rel: ['onStructureChanged'],
                    download: ['onStructureChanged'],
                    disabled: ['onStructureChanged'],
                    animation: ['applyAnimation'],
                    play: ['applyAnimation'],
                    rotate: ['applyAnimation'],
                    duration: ['applyAnimation'],
                    repeat: ['applyAnimation'],
                    pauseOnHover: ['applyAnimation'],
                    startOnViewport: ['applyAnimation'],
                  },
                ],
                [
                  769,
                  'tinto-section',
                  {
                    direction: [513],
                    wrap: [513],
                    justify: [513],
                    align: [513],
                    gap: [513],
                    maxWidth: [513, 'max-width'],
                    padding: [513],
                    margin: [513],
                    background: [513],
                    color: [513],
                    radius: [513],
                    shadow: [513],
                    center: [516],
                    heightMode: [513, 'height-mode'],
                    scrollable: [516],
                  },
                ],
                [
                  769,
                  'tinto-typography',
                  {
                    variant: [513],
                    as: [513],
                    font: [513],
                    fontSize: [513, 'font-size'],
                    color: [513],
                    align: [513],
                    weight: [520],
                    inline: [516],
                    underline: [516],
                    highlight: [513],
                    visible: [516],
                    href: [513],
                    target: [513],
                    rel: [513],
                    rolling: [516],
                    rollSpeed: [514, 'roll-speed'],
                    rollAxis: [513, 'roll-axis'],
                    rollClone: [514, 'roll-clone'],
                    rollGap: [513, 'roll-gap'],
                    rollPlay: [516, 'roll-play'],
                    rollStartOnViewport: [516, 'roll-start-on-viewport'],
                    pauseOnHover: [516, 'pause-on-hover'],
                    typingTexts: [513, 'typing-texts'],
                    typingDuration: [514, 'typing-duration'],
                    typingEraseDuration: [514, 'typing-erase-duration'],
                    typingLoop: [516, 'typing-loop'],
                    typingCursor: [516, 'typing-cursor'],
                    typingUnit: [513, 'typing-unit'],
                  },
                  null,
                  { fontSize: ['handleFontSizeChange'] },
                ],
                [
                  769,
                  'tinto-wrapper',
                  {
                    direction: [513],
                    wrap: [513],
                    justify: [513],
                    align: [513],
                    gap: [513],
                    directionDesktop: [513, 'direction-desktop'],
                    wrapDesktop: [513, 'wrap-desktop'],
                    justifyDesktop: [513, 'justify-desktop'],
                    alignDesktop: [513, 'align-desktop'],
                    gapDesktop: [513, 'gap-desktop'],
                    padding: [513],
                    margin: [513],
                    radius: [513],
                    shadow: [513],
                    border: [513],
                    color: [513],
                    background: [513],
                    src: [513],
                    bgSize: [513, 'bg-size'],
                    bgPosition: [513, 'bg-position'],
                    bgRepeat: [513, 'bg-repeat'],
                    bgAttachment: [513, 'bg-attachment'],
                    bgBlend: [513, 'bg-blend'],
                    overlay: [513],
                    overlayOpacity: [514, 'overlay-opacity'],
                    fill: [516],
                  },
                ],
              ],
            ],
            [
              'tinto-badge',
              [
                [
                  769,
                  'tinto-badge',
                  { variant: [513], size: [513], pill: [516], soft: [516], outline: [516] },
                ],
              ],
            ],
          ],
          t,
        )
      );
  };
(function () {
  if (typeof window < 'u' && window.Reflect !== void 0 && window.customElements !== void 0) {
    var e = HTMLElement;
    ((window.HTMLElement = function () {
      return Reflect.construct(e, [], this.constructor);
    }),
      (HTMLElement.prototype = e.prototype),
      (HTMLElement.prototype.constructor = HTMLElement),
      Object.setPrototypeOf(HTMLElement, e));
  }
})();
const lW = '2025-11-26T06:45:29',
  cW = { name: '@stencil/core', version: '4.38.3', typescriptVersion: '5.9.3' },
  uW = JSON.parse(
    `[{"filePath":"src/components/badge/badge.tsx","encapsulation":"shadow","tag":"tinto-badge","docs":"","docsTags":[],"usage":{},"props":[{"name":"outline","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"outline","reflectToAttr":true,"docs":"  ( , border)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"pill","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"pill","reflectToAttr":true,"docs":"pill   (full radius)","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"size","type":"\\"md\\" | \\"sm\\"","complexType":{"original":"TintoBadgeSize","resolved":"\\"md\\" | \\"sm\\"","references":{"TintoBadgeSize":{"location":"local","path":"/Users/tintolab/Desktop/uxbit/src/components/badge/badge.tsx","id":"src/components/badge/badge.tsx::TintoBadgeSize"}}},"mutable":false,"attr":"size","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'md'"}],"default":"'md'","values":[{"value":"md","type":"string"},{"value":"sm","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"soft","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"soft","reflectToAttr":true,"docs":"  (  )","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"variant","type":"\\"danger\\" | \\"neutral\\" | \\"primary\\" | \\"success\\" | \\"warning\\"","complexType":{"original":"TintoBadgeVariant","resolved":"\\"danger\\" | \\"neutral\\" | \\"primary\\" | \\"success\\" | \\"warning\\"","references":{"TintoBadgeVariant":{"location":"local","path":"/Users/tintolab/Desktop/uxbit/src/components/badge/badge.tsx","id":"src/components/badge/badge.tsx::TintoBadgeVariant"}}},"mutable":false,"attr":"variant","reflectToAttr":true,"docs":"/ ","docsTags":[{"name":"default","text":"'neutral'"}],"default":"'neutral'","values":[{"value":"danger","type":"string"},{"value":"neutral","type":"string"},{"value":"primary","type":"string"},{"value":"success","type":"string"},{"value":"warning","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false}],"methods":[],"events":[],"listeners":[],"styles":[],"slots":[],"parts":[],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/button/button.tsx","encapsulation":"shadow","tag":"tinto-button","docs":"","docsTags":[],"usage":{},"props":[{"name":"block","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"block","reflectToAttr":true,"docs":"   ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"disabled","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"disabled","reflectToAttr":true,"docs":" ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"elevated","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"elevated","reflectToAttr":true,"docs":"      ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"href","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"href","reflectToAttr":true,"docs":"    href","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"label","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"label","reflectToAttr":true,"docs":" (   )","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"loading","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"loading","reflectToAttr":true,"docs":"  (  +  )","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"outline","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"outline","reflectToAttr":true,"docs":"outline   (filled  )","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"pill","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"pill","reflectToAttr":true,"docs":"pill  ( )","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"pressed","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":true,"attr":"pressed","reflectToAttr":true,"docs":"  (toggle=true   , mutable)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"radius","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"radius","reflectToAttr":true,"docs":"border-radius (  px )","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"size","type":"\\"lg\\" | \\"md\\" | \\"sm\\"","complexType":{"original":"ButtonSize","resolved":"\\"lg\\" | \\"md\\" | \\"sm\\"","references":{"ButtonSize":{"location":"import","path":"./button.types","id":"src/components/button/button.types.ts::ButtonSize"}}},"mutable":false,"attr":"size","reflectToAttr":true,"docs":" (primitives  )","docsTags":[{"name":"default","text":"'md'"}],"default":"'md'","values":[{"value":"lg","type":"string"},{"value":"md","type":"string"},{"value":"sm","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"target","type":"\\"_blank\\" | \\"_parent\\" | \\"_self\\" | \\"_top\\"","complexType":{"original":"'_self' | '_blank' | '_parent' | '_top'","resolved":"\\"_blank\\" | \\"_parent\\" | \\"_self\\" | \\"_top\\"","references":{}},"mutable":false,"attr":"target","reflectToAttr":true,"docs":"  (href  )","docsTags":[],"values":[{"value":"_blank","type":"string"},{"value":"_parent","type":"string"},{"value":"_self","type":"string"},{"value":"_top","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"textColor","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"text-color","reflectToAttr":true,"docs":"  ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"textFamily","type":"string","complexType":{"original":"ButtonTextFamilyToken | string","resolved":"string","references":{"ButtonTextFamilyToken":{"location":"import","path":"./button.types","id":"src/components/button/button.types.ts::ButtonTextFamilyToken"}}},"mutable":false,"attr":"text-family","reflectToAttr":true,"docs":"   ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"textSize","type":"string","complexType":{"original":"ButtonTextSizeToken | string","resolved":"string","references":{"ButtonTextSizeToken":{"location":"import","path":"./button.types","id":"src/components/button/button.types.ts::ButtonTextSizeToken"}}},"mutable":false,"attr":"text-size","reflectToAttr":true,"docs":"     raw  (ex. \\"18px\\")","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"textWeight","type":"string","complexType":{"original":"ButtonTextWeightToken | string","resolved":"string","references":{"ButtonTextWeightToken":{"location":"import","path":"./button.types","id":"src/components/button/button.types.ts::ButtonTextWeightToken"}}},"mutable":false,"attr":"text-weight","reflectToAttr":true,"docs":"     raw ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"toggle","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"toggle","reflectToAttr":true,"docs":"   (pressed )","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"type","type":"\\"button\\" | \\"reset\\" | \\"submit\\"","complexType":{"original":"ButtonNativeType","resolved":"\\"button\\" | \\"reset\\" | \\"submit\\"","references":{"ButtonNativeType":{"location":"import","path":"./button.types","id":"src/components/button/button.types.ts::ButtonNativeType"}}},"mutable":false,"attr":"type","reflectToAttr":true,"docs":"form  \\n- \\"button\\":  (   )\\n- \\"submit\\":  form submit\\n- \\"reset\\":  form reset","docsTags":[{"name":"default","text":"'button'"}],"default":"'button'","values":[{"value":"button","type":"string"},{"value":"reset","type":"string"},{"value":"submit","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"variant","type":"\\"primary\\" | \\"secondary\\" | \\"tertiary\\"","complexType":{"original":"ButtonVariant","resolved":"\\"primary\\" | \\"secondary\\" | \\"tertiary\\"","references":{"ButtonVariant":{"location":"import","path":"./button.types","id":"src/components/button/button.types.ts::ButtonVariant"}}},"mutable":false,"attr":"variant","reflectToAttr":true,"docs":"/  (primary / secondary / ghost )","docsTags":[{"name":"default","text":"'primary'"}],"default":"'primary'","values":[{"value":"primary","type":"string"},{"value":"secondary","type":"string"},{"value":"tertiary","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false}],"methods":[],"events":[{"event":"tintoToggle","detail":"ButtonToggleDetail","bubbles":true,"complexType":{"original":"ButtonToggleDetail","resolved":"ButtonToggleDetail","references":{"ButtonToggleDetail":{"location":"import","path":"./button.types","id":"src/components/button/button.types.ts::ButtonToggleDetail"}}},"cancelable":true,"composed":true,"docs":"    (pressed  )","docsTags":[]}],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"button","docs":""},{"name":"label","docs":""},{"name":"prefix","docs":""},{"name":"spinner","docs":""},{"name":"suffix","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/image/image.tsx","encapsulation":"shadow","tag":"tinto-image","readme":"# tinto-image\\n","docs":"<tinto-image>\\n- Image/media props + simple animations (spin/float/wobble/pulse)\\n- If placeholder exists, main image loads eagerly by default (fast swap)\\n- rounded=\\"oval\\" => rounds TOP corners only (bottom corners are square)","docsTags":[],"usage":{},"props":[{"name":"alt","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"alt","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"animation","type":"\\"\\" | \\"float\\" | \\"pulse\\" | \\"spin\\" | \\"wobble\\"","complexType":{"original":"ImageAnimation","resolved":"\\"\\" | \\"float\\" | \\"pulse\\" | \\"spin\\" | \\"wobble\\"","references":{"ImageAnimation":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::ImageAnimation"}}},"mutable":false,"attr":"animation","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"''"}],"default":"''","values":[{"type":"\\"\\""},{"value":"float","type":"string"},{"value":"pulse","type":"string"},{"value":"spin","type":"string"},{"value":"wobble","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"as","type":"\\"button\\"","complexType":{"original":"AsKind","resolved":"\\"button\\"","references":{"AsKind":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::AsKind"}}},"mutable":false,"attr":"as","reflectToAttr":true,"docs":"as=\\"button\\" support","docsTags":[],"values":[{"value":"button","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"background","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"background","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"border","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"border","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"crossorigin","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"crossorigin","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"decoding","type":"\\"async\\" | \\"auto\\" | \\"sync\\"","complexType":{"original":"'async' | 'sync' | 'auto'","resolved":"\\"async\\" | \\"auto\\" | \\"sync\\"","references":{}},"mutable":false,"attr":"decoding","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'async'"}],"default":"'async'","values":[{"value":"async","type":"string"},{"value":"auto","type":"string"},{"value":"sync","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"disabled","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"disabled","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"download","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"download","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"duration","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"duration","reflectToAttr":true,"docs":"seconds (e.g., 20)","docsTags":[{"name":"default","text":"20"}],"default":"20","values":[{"type":"number"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"fit","type":"\\"contain\\" | \\"cover\\" | \\"fill\\" | \\"none\\" | \\"scale-down\\"","complexType":{"original":"ImageFit","resolved":"\\"contain\\" | \\"cover\\" | \\"fill\\" | \\"none\\" | \\"scale-down\\"","references":{"ImageFit":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::ImageFit"}}},"mutable":false,"attr":"fit","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'cover'"}],"default":"'cover'","values":[{"value":"contain","type":"string"},{"value":"cover","type":"string"},{"value":"fill","type":"string"},{"value":"none","type":"string"},{"value":"scale-down","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"height","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"height","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"href","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"href","reflectToAttr":true,"docs":"Wrap with anchor when href provided","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"loading","type":"\\"eager\\" | \\"lazy\\"","complexType":{"original":"'lazy' | 'eager'","resolved":"\\"eager\\" | \\"lazy\\"","references":{}},"mutable":false,"attr":"loading","reflectToAttr":true,"docs":"Loading policy","docsTags":[],"values":[{"value":"eager","type":"string"},{"value":"lazy","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"pauseOnHover","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"pause-on-hover","reflectToAttr":true,"docs":"pause on hover","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"placeholder","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"placeholder","reflectToAttr":true,"docs":"Blurred/low-res placeholder URL","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"play","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"play","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"position","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"position","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'50% 50%'"}],"default":"'50% 50%'","values":[{"type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"priority","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"priority","reflectToAttr":true,"docs":"Priority: eager + inject <link rel=\\"preload\\" as=\\"image\\">","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"radius","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"radius","reflectToAttr":true,"docs":"If radius exists, it overrides rounded preset","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"ratio","type":"\\"16:9\\" | \\"1:1\\" | \\"1:2\\" | \\"1:3\\" | \\"2:1\\" | \\"2:3\\" | \\"3:1\\" | \\"3:2\\" | \\"3:4\\" | \\"4:3\\" | \\"9:16\\"","complexType":{"original":"AspectRatio","resolved":"\\"16:9\\" | \\"1:1\\" | \\"1:2\\" | \\"1:3\\" | \\"2:1\\" | \\"2:3\\" | \\"3:1\\" | \\"3:2\\" | \\"3:4\\" | \\"4:3\\" | \\"9:16\\"","references":{"AspectRatio":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::AspectRatio"}}},"mutable":false,"attr":"ratio","reflectToAttr":true,"docs":"\\"w:h\\", e.g. \\"16:9\\", \\"1:1\\"","docsTags":[{"name":"default","text":"'16:9'"}],"default":"'16:9'","values":[{"value":"16:9","type":"string"},{"value":"1:1","type":"string"},{"value":"1:2","type":"string"},{"value":"1:3","type":"string"},{"value":"2:1","type":"string"},{"value":"2:3","type":"string"},{"value":"3:1","type":"string"},{"value":"3:2","type":"string"},{"value":"3:4","type":"string"},{"value":"4:3","type":"string"},{"value":"9:16","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"referrerpolicy","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"referrerpolicy","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"rel","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"rel","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"repeat","type":"number | string","complexType":{"original":"RepeatValue","resolved":"number | string","references":{"RepeatValue":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::RepeatValue"}}},"mutable":false,"attr":"repeat","reflectToAttr":true,"docs":"'infinite' or finite count (string/number)","docsTags":[{"name":"default","text":"'infinite'"}],"default":"'infinite'","values":[{"type":"number"},{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"rotate","type":"\\"left\\" | \\"right\\"","complexType":{"original":"AnimationRotate","resolved":"\\"left\\" | \\"right\\"","references":{"AnimationRotate":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::AnimationRotate"}}},"mutable":false,"attr":"rotate","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'right'"}],"default":"'right'","values":[{"value":"left","type":"string"},{"value":"right","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"rounded","type":"\\"base\\" | \\"circle\\" | \\"diagonal\\" | \\"full\\" | \\"lr\\" | \\"oval\\" | \\"soft\\" | \\"t\\" | \\"top\\"","complexType":{"original":"RoundedPreset","resolved":"\\"base\\" | \\"circle\\" | \\"diagonal\\" | \\"full\\" | \\"lr\\" | \\"oval\\" | \\"soft\\" | \\"t\\" | \\"top\\"","references":{"RoundedPreset":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::RoundedPreset"}}},"mutable":false,"attr":"rounded","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"value":"base","type":"string"},{"value":"circle","type":"string"},{"value":"diagonal","type":"string"},{"value":"full","type":"string"},{"value":"lr","type":"string"},{"value":"oval","type":"string"},{"value":"soft","type":"string"},{"value":"t","type":"string"},{"value":"top","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"shadow","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"shadow","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"sizes","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"sizes","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"src","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"src","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"srcset","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"srcset","reflectToAttr":true,"docs":"Responsive images","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"startOnViewport","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"start-on-viewport","reflectToAttr":true,"docs":"play/pause on viewport","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"target","type":"string","complexType":{"original":"LinkTarget","resolved":"string","references":{"LinkTarget":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::LinkTarget"}}},"mutable":false,"attr":"target","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"width","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"width","reflectToAttr":true,"docs":"Host box size (CSS inline/block size)","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false}],"methods":[],"events":[{"event":"tinto:error","detail":"TintoImageErrorDetail","bubbles":true,"complexType":{"original":"TintoImageErrorDetail","resolved":"TintoImageErrorDetail","references":{"TintoImageErrorDetail":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::TintoImageErrorDetail"}}},"cancelable":true,"composed":true,"docs":"","docsTags":[]},{"event":"tinto:loaded","detail":"TintoImageLoadedDetail","bubbles":true,"complexType":{"original":"TintoImageLoadedDetail","resolved":"TintoImageLoadedDetail","references":{"TintoImageLoadedDetail":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::TintoImageLoadedDetail"}}},"cancelable":true,"composed":true,"docs":"","docsTags":[]},{"event":"tinto:press","detail":"TintoImagePressDetail","bubbles":true,"complexType":{"original":"TintoImagePressDetail","resolved":"TintoImagePressDetail","references":{"TintoImagePressDetail":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::TintoImagePressDetail"}}},"cancelable":true,"composed":true,"docs":"","docsTags":[]}],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"button","docs":""},{"name":"frame","docs":""},{"name":"img","docs":""},{"name":"layer","docs":""},{"name":"link","docs":""},{"name":"placeholder","docs":""},{"name":"plain","docs":""},{"name":"spacer","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/section/section.tsx","encapsulation":"shadow","tag":"tinto-section","readme":"# tinto-section\\n","docs":"","docsTags":[],"usage":{},"props":[{"name":"align","type":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","complexType":{"original":"AlignItems","resolved":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","references":{"AlignItems":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::AlignItems"}}},"mutable":false,"attr":"align","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'stretch'"}],"default":"'stretch'","values":[{"value":"baseline","type":"string"},{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"stretch","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"background","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"background","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"center","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"center","reflectToAttr":true,"docs":"  (maxWidth   margin-inline:auto)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"color","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"color","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"direction","type":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","complexType":{"original":"FlexDirection","resolved":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","references":{"FlexDirection":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::FlexDirection"}}},"mutable":false,"attr":"direction","reflectToAttr":true,"docs":"Flex  ( ,    )","docsTags":[{"name":"default","text":"'column'"}],"default":"'column'","values":[{"value":"column","type":"string"},{"value":"column-reverse","type":"string"},{"value":"row","type":"string"},{"value":"row-reverse","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"gap","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"gap","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"heightMode","type":"\\"auto\\" | \\"dvh\\" | \\"screen\\"","complexType":{"original":"HeightMode","resolved":"\\"auto\\" | \\"dvh\\" | \\"screen\\"","references":{"HeightMode":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::HeightMode"}}},"mutable":false,"attr":"height-mode","reflectToAttr":true,"docs":" \\n- auto:  ()\\n- dvh:    / \\n- screen:  100dvh","docsTags":[{"name":"default","text":"'auto'"}],"default":"'auto'","values":[{"value":"auto","type":"string"},{"value":"dvh","type":"string"},{"value":"screen","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"justify","type":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","complexType":{"original":"Justify","resolved":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","references":{"Justify":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::Justify"}}},"mutable":false,"attr":"justify","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'flex-start'"}],"default":"'flex-start'","values":[{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"space-around","type":"string"},{"value":"space-between","type":"string"},{"value":"space-evenly","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"margin","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"margin","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"maxWidth","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"max-width","reflectToAttr":true,"docs":"//  ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"padding","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"padding","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"radius","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"radius","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"scrollable","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"scrollable","reflectToAttr":true,"docs":"heightMode dvh/screen    ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"shadow","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"shadow","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"wrap","type":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","complexType":{"original":"FlexWrap","resolved":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","references":{"FlexWrap":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::FlexWrap"}}},"mutable":false,"attr":"wrap","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'nowrap'"}],"default":"'nowrap'","values":[{"value":"nowrap","type":"string"},{"value":"wrap","type":"string"},{"value":"wrap-reverse","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false}],"methods":[],"events":[],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"root","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/typography/typography.tsx","encapsulation":"shadow","tag":"tinto-typography","readme":"# tinto-typography\\n","docs":"","docsTags":[],"usage":{},"props":[{"name":"align","type":"\\"center\\" | \\"justify\\" | \\"left\\" | \\"right\\"","complexType":{"original":"Align","resolved":"\\"center\\" | \\"justify\\" | \\"left\\" | \\"right\\"","references":{"Align":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::Align"}}},"mutable":false,"attr":"align","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'left'"}],"default":"'left'","values":[{"value":"center","type":"string"},{"value":"justify","type":"string"},{"value":"left","type":"string"},{"value":"right","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"as","type":"\\"h1\\" | \\"h2\\" | \\"h3\\" | \\"p\\" | \\"span\\"","complexType":{"original":"'h1' | 'h2' | 'h3' | 'p' | 'span'","resolved":"\\"h1\\" | \\"h2\\" | \\"h3\\" | \\"p\\" | \\"span\\"","references":{}},"mutable":false,"attr":"as","reflectToAttr":true,"docs":"   (: variant=\\"h1\\" + as=\\"h2\\")","docsTags":[],"values":[{"value":"h1","type":"string"},{"value":"h2","type":"string"},{"value":"h3","type":"string"},{"value":"p","type":"string"},{"value":"span","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"color","type":"string","complexType":{"original":"Color","resolved":"string","references":{"Color":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::Color"}}},"mutable":false,"attr":"color","reflectToAttr":true,"docs":"  ( )","docsTags":[{"name":"default","text":"'inherit'"}],"default":"'inherit'","values":[{"type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"font","type":"\\"clash-display\\" | \\"climate-crisis\\" | \\"paperlogy\\" | \\"pretendard\\" | \\"system\\"","complexType":{"original":"FontFamily","resolved":"\\"clash-display\\" | \\"climate-crisis\\" | \\"paperlogy\\" | \\"pretendard\\" | \\"system\\"","references":{"FontFamily":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::FontFamily"}}},"mutable":false,"attr":"font","reflectToAttr":true,"docs":"  preset","docsTags":[{"name":"default","text":"'system'"}],"default":"'system'","values":[{"value":"clash-display","type":"string"},{"value":"climate-crisis","type":"string"},{"value":"paperlogy","type":"string"},{"value":"pretendard","type":"string"},{"value":"system","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"fontSize","type":"string","complexType":{"original":"FontSize | string","resolved":"string","references":{"FontSize":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::FontSize"}}},"mutable":false,"attr":"font-size","reflectToAttr":true,"docs":"      (: \\"lg\\", \\"32px\\", \\"2.5rem\\")","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"highlight","type":"string","complexType":{"original":"HighlightColor","resolved":"string","references":{"HighlightColor":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::HighlightColor"}}},"mutable":false,"attr":"highlight","reflectToAttr":true,"docs":" ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"href","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"href","reflectToAttr":true,"docs":" URL (  <a> )","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"inline","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"inline","reflectToAttr":true,"docs":"  ( block)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"pauseOnHover","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"pause-on-hover","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rel","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"rel","reflectToAttr":true,"docs":" rel (target _blank    )","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"rollAxis","type":"\\"x\\" | \\"y\\"","complexType":{"original":"'x' | 'y'","resolved":"\\"x\\" | \\"y\\"","references":{}},"mutable":false,"attr":"roll-axis","reflectToAttr":true,"docs":" props     API  ","docsTags":[{"name":"default","text":"'x'"}],"default":"'x'","values":[{"value":"x","type":"string"},{"value":"y","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollClone","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"roll-clone","reflectToAttr":true,"docs":"   (    ,  3)","docsTags":[{"name":"default","text":"3"}],"default":"3","values":[{"type":"number"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollGap","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"roll-gap","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'2rem'"}],"default":"'2rem'","values":[{"type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollPlay","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"roll-play","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollSpeed","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"roll-speed","reflectToAttr":true,"docs":"()  duration  (1~10)   typingDuration  fallback","docsTags":[{"name":"default","text":"5"}],"default":"5","values":[{"type":"number"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollStartOnViewport","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"roll-start-on-viewport","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rolling","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"rolling","reflectToAttr":true,"docs":"rolling=true    ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"target","type":"\\"_blank\\" | \\"_parent\\" | \\"_self\\" | \\"_top\\"","complexType":{"original":"'_blank' | '_self' | '_parent' | '_top'","resolved":"\\"_blank\\" | \\"_parent\\" | \\"_self\\" | \\"_top\\"","references":{}},"mutable":false,"attr":"target","reflectToAttr":true,"docs":"  (_blank, _self, _parent, _top)","docsTags":[],"values":[{"value":"_blank","type":"string"},{"value":"_parent","type":"string"},{"value":"_self","type":"string"},{"value":"_top","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"typingCursor","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"typing-cursor","reflectToAttr":true,"docs":"( | )  ","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"typingDuration","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"typing-duration","reflectToAttr":true,"docs":"   duration  (1~10)","docsTags":[],"values":[{"type":"number"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"typingEraseDuration","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"typing-erase-duration","reflectToAttr":true,"docs":" duration  (1~10,  typingDuration )","docsTags":[],"values":[{"type":"number"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"typingLoop","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"typing-loop","reflectToAttr":true,"docs":"     ","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"typingTexts","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"typing-texts","reflectToAttr":true,"docs":"   .\\n-  JSON: '[\\"1\\",\\"2\\"]'\\n-   : '1|2|3'\\n   rollClone( 3)  .","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"typingUnit","type":"\\"char\\" | \\"word\\"","complexType":{"original":"TypingUnit","resolved":"\\"char\\" | \\"word\\"","references":{"TypingUnit":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::TypingUnit"}}},"mutable":false,"attr":"typing-unit","reflectToAttr":true,"docs":"  /  ","docsTags":[{"name":"default","text":"'char'"}],"default":"'char'","values":[{"value":"char","type":"string"},{"value":"word","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"underline","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"underline","reflectToAttr":true,"docs":" ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"variant","type":"\\"h1\\" | \\"h2\\" | \\"h3\\" | \\"p\\" | \\"span\\"","complexType":{"original":"Variant","resolved":"\\"h1\\" | \\"h2\\" | \\"h3\\" | \\"p\\" | \\"span\\"","references":{"Variant":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::Variant"}}},"mutable":false,"attr":"variant","reflectToAttr":true,"docs":" HTML   ( as  )","docsTags":[{"name":"default","text":"'p'"}],"default":"'p'","values":[{"value":"h1","type":"string"},{"value":"h2","type":"string"},{"value":"h3","type":"string"},{"value":"p","type":"string"},{"value":"span","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"visible","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"visible","reflectToAttr":true,"docs":"  (false  hidden)","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"weight","type":"number | string","complexType":{"original":"number | string","resolved":"number | string","references":{}},"mutable":false,"attr":"weight","reflectToAttr":true,"docs":" (: 400, 500, 700, 'bold')","docsTags":[],"values":[{"type":"number"},{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false}],"methods":[],"events":[],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"link","docs":""},{"name":"root","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/wrapper/wrapper.tsx","encapsulation":"shadow","tag":"tinto-wrapper","readme":"# tinto-wrapper\\n","docs":"","docsTags":[],"usage":{},"props":[{"name":"align","type":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","complexType":{"original":"AlignItems","resolved":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","references":{"AlignItems":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::AlignItems"}}},"mutable":false,"attr":"align","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'stretch'"}],"default":"'stretch'","values":[{"value":"baseline","type":"string"},{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"stretch","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"alignDesktop","type":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","complexType":{"original":"AlignItems","resolved":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","references":{"AlignItems":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::AlignItems"}}},"mutable":false,"attr":"align-desktop","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"value":"baseline","type":"string"},{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"stretch","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"background","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"background","reflectToAttr":true,"docs":"(/) +  ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgAttachment","type":"string","complexType":{"original":"BgAttachment","resolved":"string","references":{"BgAttachment":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::BgAttachment"}}},"mutable":false,"attr":"bg-attachment","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'scroll'"}],"default":"'scroll'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgBlend","type":"string","complexType":{"original":"BgBlend","resolved":"string","references":{"BgBlend":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::BgBlend"}}},"mutable":false,"attr":"bg-blend","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'normal'"}],"default":"'normal'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgPosition","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"bg-position","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'50% 50%'"}],"default":"'50% 50%'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgRepeat","type":"string","complexType":{"original":"BgRepeat","resolved":"string","references":{"BgRepeat":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::BgRepeat"}}},"mutable":false,"attr":"bg-repeat","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'no-repeat'"}],"default":"'no-repeat'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgSize","type":"string","complexType":{"original":"BgSize","resolved":"string","references":{"BgSize":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::BgSize"}}},"mutable":false,"attr":"bg-size","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'cover'"}],"default":"'cover'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"border","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"border","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"color","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"color","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"direction","type":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","complexType":{"original":"FlexDirection","resolved":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","references":{"FlexDirection":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::FlexDirection"}}},"mutable":false,"attr":"direction","reflectToAttr":true,"docs":"Flex ( )","docsTags":[{"name":"default","text":"'row'"}],"default":"'row'","values":[{"value":"column","type":"string"},{"value":"column-reverse","type":"string"},{"value":"row","type":"string"},{"value":"row-reverse","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"directionDesktop","type":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","complexType":{"original":"FlexDirection","resolved":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","references":{"FlexDirection":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::FlexDirection"}}},"mutable":false,"attr":"direction-desktop","reflectToAttr":true,"docs":"Flex ( , >=1920px)","docsTags":[],"values":[{"value":"column","type":"string"},{"value":"column-reverse","type":"string"},{"value":"row","type":"string"},{"value":"row-reverse","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"fill","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"fill","reflectToAttr":true,"docs":"   (absolute; inset:0)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"gap","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"gap","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"gapDesktop","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"gap-desktop","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"justify","type":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","complexType":{"original":"Justify","resolved":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","references":{"Justify":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::Justify"}}},"mutable":false,"attr":"justify","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'flex-start'"}],"default":"'flex-start'","values":[{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"space-around","type":"string"},{"value":"space-between","type":"string"},{"value":"space-evenly","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"justifyDesktop","type":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","complexType":{"original":"Justify","resolved":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","references":{"Justify":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::Justify"}}},"mutable":false,"attr":"justify-desktop","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"space-around","type":"string"},{"value":"space-between","type":"string"},{"value":"space-evenly","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"margin","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"margin","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"overlay","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"overlay","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"overlayOpacity","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"overlay-opacity","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"number"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"padding","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"padding","reflectToAttr":true,"docs":"Box / Visual","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"radius","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"radius","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"shadow","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"shadow","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"src","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"src","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"wrap","type":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","complexType":{"original":"FlexWrap","resolved":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","references":{"FlexWrap":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::FlexWrap"}}},"mutable":false,"attr":"wrap","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'nowrap'"}],"default":"'nowrap'","values":[{"value":"nowrap","type":"string"},{"value":"wrap","type":"string"},{"value":"wrap-reverse","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"wrapDesktop","type":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","complexType":{"original":"FlexWrap","resolved":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","references":{"FlexWrap":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::FlexWrap"}}},"mutable":false,"attr":"wrap-desktop","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"value":"nowrap","type":"string"},{"value":"wrap","type":"string"},{"value":"wrap-reverse","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false}],"methods":[],"events":[],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"inner","docs":""},{"name":"root","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}}]`,
  ),
  dW = {
    'src/components/badge/badge.tsx::TintoBadgeVariant': {
      declaration:
        "export type TintoBadgeVariant = 'neutral' | 'primary' | 'success' | 'warning' | 'danger';",
      docstring: '',
      path: 'src/components/badge/badge.tsx',
    },
    'src/components/badge/badge.tsx::TintoBadgeSize': {
      declaration: "export type TintoBadgeSize = 'sm' | 'md';",
      docstring: '',
      path: 'src/components/badge/badge.tsx',
    },
    'src/components/button/button.types.ts::ButtonVariant': {
      declaration: "export type ButtonVariant = 'primary' | 'secondary' | 'tertiary';",
      docstring: '',
      path: 'src/components/button/button.types.ts',
    },
    'src/components/button/button.types.ts::ButtonSize': {
      declaration: "export type ButtonSize = 'sm' | 'md' | 'lg';",
      docstring: '',
      path: 'src/components/button/button.types.ts',
    },
    'src/components/button/button.types.ts::ButtonNativeType': {
      declaration: "export type ButtonNativeType = 'button' | 'submit' | 'reset';",
      docstring: '',
      path: 'src/components/button/button.types.ts',
    },
    'src/components/button/button.types.ts::ButtonTextFamilyToken': {
      declaration: `export type ButtonTextFamilyToken =
  | 'system'
  | 'pretendard'
  | 'paperlogy'
  | 'clash-display'
  | 'climate-crisis';`,
      docstring: '',
      path: 'src/components/button/button.types.ts',
    },
    'src/components/button/button.types.ts::ButtonTextSizeToken': {
      declaration: "export type ButtonTextSizeToken = 'sm' | 'md' | 'lg' | 'xl';",
      docstring: '',
      path: 'src/components/button/button.types.ts',
    },
    'src/components/button/button.types.ts::ButtonTextWeightToken': {
      declaration:
        "export type ButtonTextWeightToken = 'regular' | 'medium' | 'semibold' | 'bold' | 'black';",
      docstring: '',
      path: 'src/components/button/button.types.ts',
    },
    'src/components/button/button.types.ts::ButtonToggleDetail': {
      declaration: `export interface ButtonToggleDetail {
  pressed: boolean;
}`,
      docstring: '',
      path: 'src/components/button/button.types.ts',
    },
    'src/components/image/image.types.ts::AspectRatio': {
      declaration: `export type AspectRatio =
  | '1:1'
  | '2:1'
  | '3:2'
  | '4:3'
  | '16:9'
  | '3:1'
  | '1:2'
  | '2:3'
  | '3:4'
  | '9:16'
  | '1:3';`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::ImageFit': {
      declaration: "export type ImageFit = 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';",
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::RoundedPreset': {
      declaration: `export type RoundedPreset =
  | 'soft'
  | 'oval'
  | 'top'
  | 'diagonal'
  | 'circle'
  // alias ( )
  | 'base'
  | 'full'
  | 't'
  | 'lr';`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::LinkTarget': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::AsKind': {
      declaration: '"button"',
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::ImageAnimation': {
      declaration: "export type ImageAnimation = '' | 'spin' | 'float' | 'wobble' | 'pulse';",
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::AnimationRotate': {
      declaration: "export type AnimationRotate = 'left' | 'right';",
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::RepeatValue': {
      declaration: "export type RepeatValue = 'infinite' | number | string;",
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::TintoImageLoadedDetail': {
      declaration: `export interface TintoImageLoadedDetail {
  width: number;
  height: number;
  src?: string;
}`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::TintoImageErrorDetail': {
      declaration: `export interface TintoImageErrorDetail {
  src?: string;
}`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::TintoImagePressDetail': {
      declaration: `export interface TintoImagePressDetail {
  kind: PressKind;
}`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/section/section.types.ts::FlexDirection': {
      declaration:
        "export type FlexDirection = 'row' | 'row-reverse' | 'column' | 'column-reverse';",
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/section/section.types.ts::FlexWrap': {
      declaration: "export type FlexWrap = 'nowrap' | 'wrap' | 'wrap-reverse';",
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/section/section.types.ts::Justify': {
      declaration: `export type Justify =
  | 'flex-start'
  | 'center'
  | 'flex-end'
  | 'space-between'
  | 'space-around'
  | 'space-evenly';`,
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/section/section.types.ts::AlignItems': {
      declaration:
        "export type AlignItems = 'stretch' | 'flex-start' | 'center' | 'flex-end' | 'baseline';",
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/section/section.types.ts::HeightMode': {
      declaration: "export type HeightMode = 'auto' | 'dvh' | 'screen';",
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/typography/typography.types.ts::Variant': {
      declaration: "export type Variant = 'h1' | 'h2' | 'h3' | 'p' | 'span';",
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::FontFamily': {
      declaration: '"system" | "pretendard" | "paperlogy" | "clash-display" | "climate-crisis"',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::FontSize': {
      declaration: '"sm" | "md" | "lg" | "xl" | "xs" | "xxl"',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::Color': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::Align': {
      declaration: "export type Align = 'left' | 'center' | 'right' | 'justify';",
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::HighlightColor': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::TypingUnit': {
      declaration: '"char" | "word"',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::FlexDirection': {
      declaration:
        "export type FlexDirection = 'row' | 'row-reverse' | 'column' | 'column-reverse';",
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::FlexWrap': {
      declaration: "export type FlexWrap = 'nowrap' | 'wrap' | 'wrap-reverse';",
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::Justify': {
      declaration: `export type Justify =
  | 'flex-start'
  | 'center'
  | 'flex-end'
  | 'space-between'
  | 'space-around'
  | 'space-evenly';`,
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::AlignItems': {
      declaration:
        "export type AlignItems = 'stretch' | 'flex-start' | 'center' | 'flex-end' | 'baseline';",
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::BgSize': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::BgRepeat': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::BgAttachment': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::BgBlend': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
  },
  pW = { timestamp: lW, compiler: cW, components: uW, typeLibrary: dW };
aW();
cG(pW);
const fW = Object.freeze(
  Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: 'Module' }),
);
Uh();
const { composeConfigs: mW, PreviewWeb: yW } = __STORYBOOK_MODULE_PREVIEW_API__,
  hW = (e = []) => {
    const t = [e[0] ?? iG, e[1] ?? EG, e[2] ?? fW];
    return mW(t);
  };
window.__STORYBOOK_PREVIEW__ = window.__STORYBOOK_PREVIEW__ || new yW(qz, hW);
window.__STORYBOOK_STORY_STORE__ =
  window.__STORYBOOK_STORY_STORE__ || window.__STORYBOOK_PREVIEW__.storyStore;
export { al as h };
