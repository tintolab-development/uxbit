var cq = Object.defineProperty;
var uq = (e, t, r) =>
  t in e ? cq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r);
var Be = (e, t, r) => uq(e, typeof t != 'symbol' ? t + '' : t, r);
(function () {
  const t = document.createElement('link').relList;
  if (t && t.supports && t.supports('modulepreload')) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) n(o);
  new MutationObserver((o) => {
    for (const i of o)
      if (i.type === 'childList')
        for (const a of i.addedNodes) a.tagName === 'LINK' && a.rel === 'modulepreload' && n(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function r(o) {
    const i = {};
    return (
      o.integrity && (i.integrity = o.integrity),
      o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy),
      o.crossOrigin === 'use-credentials'
        ? (i.credentials = 'include')
        : o.crossOrigin === 'anonymous'
          ? (i.credentials = 'omit')
          : (i.credentials = 'same-origin'),
      i
    );
  }
  function n(o) {
    if (o.ep) return;
    o.ep = !0;
    const i = r(o);
    fetch(o.href, i);
  }
})();
var Pu = {},
  dq = Object.create,
  wl = Object.defineProperty,
  pq = Object.getOwnPropertyDescriptor,
  Bv = Object.getOwnPropertyNames,
  fq = Object.getPrototypeOf,
  mq = Object.prototype.hasOwnProperty,
  s = (e, t) => wl(e, 'name', { value: t, configurable: !0 }),
  Hi = ((e) =>
    typeof require < 'u'
      ? require
      : typeof Proxy < 'u'
        ? new Proxy(e, { get: (t, r) => (typeof require < 'u' ? require : t)[r] })
        : e)(function (e) {
    if (typeof require < 'u') return require.apply(this, arguments);
    throw Error('Dynamic require of "' + e + '" is not supported');
  }),
  B = (e, t) =>
    function () {
      return (t || (0, e[Bv(e)[0]])((t = { exports: {} }).exports, t), t.exports);
    },
  Rt = (e, t) => {
    for (var r in t) wl(e, r, { get: t[r], enumerable: !0 });
  },
  yq = (e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let o of Bv(t))
        !mq.call(e, o) &&
          o !== r &&
          wl(e, o, { get: () => t[o], enumerable: !(n = pq(t, o)) || n.enumerable });
    return e;
  },
  Ke = (e, t, r) => (
    (r = e != null ? dq(fq(e)) : {}),
    yq(t || !e || !e.__esModule ? wl(r, 'default', { value: e, enumerable: !0 }) : r, e)
  ),
  hq = B({
    '../node_modules/@ngard/tiny-isequal/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.isEqual = (function () {
          var t = Object.prototype.toString,
            r = Object.getPrototypeOf,
            n = Object.getOwnPropertySymbols
              ? function (o) {
                  return Object.keys(o).concat(Object.getOwnPropertySymbols(o));
                }
              : Object.keys;
          return function (o, i) {
            return s(function a(l, d, u) {
              var p,
                f,
                m,
                h = t.call(l),
                g = t.call(d);
              if (l === d) return !0;
              if (l == null || d == null) return !1;
              if (u.indexOf(l) > -1 && u.indexOf(d) > -1) return !0;
              if (
                (u.push(l, d),
                h != g ||
                  ((p = n(l)),
                  (f = n(d)),
                  p.length != f.length ||
                    p.some(function (v) {
                      return !a(l[v], d[v], u);
                    })))
              )
                return !1;
              switch (h.slice(8, -1)) {
                case 'Symbol':
                  return l.valueOf() == d.valueOf();
                case 'Date':
                case 'Number':
                  return +l == +d || (+l != +l && +d != +d);
                case 'RegExp':
                case 'Function':
                case 'String':
                case 'Boolean':
                  return '' + l == '' + d;
                case 'Set':
                case 'Map':
                  ((p = l.entries()), (f = d.entries()));
                  do if (!a((m = p.next()).value, f.next().value, u)) return !1;
                  while (!m.done);
                  return !0;
                case 'ArrayBuffer':
                  ((l = new Uint8Array(l)), (d = new Uint8Array(d)));
                case 'DataView':
                  ((l = new Uint8Array(l.buffer)), (d = new Uint8Array(d.buffer)));
                case 'Float32Array':
                case 'Float64Array':
                case 'Int8Array':
                case 'Int16Array':
                case 'Int32Array':
                case 'Uint8Array':
                case 'Uint16Array':
                case 'Uint32Array':
                case 'Uint8ClampedArray':
                case 'Arguments':
                case 'Array':
                  if (l.length != d.length) return !1;
                  for (m = 0; m < l.length; m++)
                    if ((m in l || m in d) && (m in l != m in d || !a(l[m], d[m], u))) return !1;
                  return !0;
                case 'Object':
                  return a(r(l), r(d), u);
                default:
                  return !1;
              }
            }, 'n')(o, i, []);
          };
        })()));
    },
  }),
  gq = B({
    '../node_modules/min-indent/index.js'(e, t) {
      t.exports = (r) => {
        const n = r.match(/^[ \t]*(?=\S)/gm);
        return n ? n.reduce((o, i) => Math.min(o, i.length), 1 / 0) : 0;
      };
    },
  }),
  bq = B({
    '../node_modules/strip-indent/index.js'(e, t) {
      var r = gq();
      t.exports = (n) => {
        const o = r(n);
        if (o === 0) return n;
        const i = new RegExp(`^[ \\t]{${o}}`, 'gm');
        return n.replace(i, '');
      };
    },
  }),
  vq = B({
    '../node_modules/indent-string/index.js'(e, t) {
      t.exports = (r, n = 1, o) => {
        if (((o = { indent: ' ', includeEmptyLines: !1, ...o }), typeof r != 'string'))
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof r}\``);
        if (typeof n != 'number')
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof n}\``);
        if (typeof o.indent != 'string')
          throw new TypeError(
            `Expected \`options.indent\` to be a \`string\`, got \`${typeof o.indent}\``,
          );
        if (n === 0) return r;
        const i = o.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return r.replace(i, o.indent.repeat(n));
      };
    },
  }),
  Jv = B({
    '../node_modules/redent/index.js'(e, t) {
      var r = bq(),
        n = vq();
      t.exports = (o, i = 0, a) => n(r(o), i, a);
    },
  }),
  Tq = B({
    '../node_modules/aria-query/lib/util/iteratorProxy.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      function t() {
        var r = this,
          n = 0,
          o = {
            '@@iterator': s(function () {
              return o;
            }, 'iterator'),
            next: s(function () {
              if (n < r.length) {
                var a = r[n];
                return ((n = n + 1), { done: !1, value: a });
              } else return { done: !0 };
            }, 'next'),
          };
        return o;
      }
      (s(t, 'iteratorProxy'), (e.default = t));
    },
  }),
  wi = B({
    '../node_modules/aria-query/lib/util/iterationDecorator.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = o));
      var t = r(Tq());
      function r(i) {
        return i && i.__esModule ? i : { default: i };
      }
      s(r, '_interopRequireDefault');
      function n(i) {
        '@babel/helpers - typeof';
        return (
          (n =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (a) {
                  return typeof a;
                }
              : function (a) {
                  return a &&
                    typeof Symbol == 'function' &&
                    a.constructor === Symbol &&
                    a !== Symbol.prototype
                    ? 'symbol'
                    : typeof a;
                }),
          n(i)
        );
      }
      s(n, '_typeof');
      function o(i, a) {
        return (
          typeof Symbol == 'function' &&
            n(Symbol.iterator) === 'symbol' &&
            Object.defineProperty(i, Symbol.iterator, { value: t.default.bind(a) }),
          i
        );
      }
      s(o, 'iterationDecorator');
    },
  }),
  Eq = B({
    '../node_modules/aria-query/lib/ariaPropsMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = r(wi());
      function r(f) {
        return f && f.__esModule ? f : { default: f };
      }
      s(r, '_interopRequireDefault');
      function n(f, m) {
        return d(f) || l(f, m) || i(f, m) || o();
      }
      s(n, '_slicedToArray');
      function o() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(o, '_nonIterableRest');
      function i(f, m) {
        if (f) {
          if (typeof f == 'string') return a(f, m);
          var h = {}.toString.call(f).slice(8, -1);
          return (
            h === 'Object' && f.constructor && (h = f.constructor.name),
            h === 'Map' || h === 'Set'
              ? Array.from(f)
              : h === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)
                ? a(f, m)
                : void 0
          );
        }
      }
      s(i, '_unsupportedIterableToArray');
      function a(f, m) {
        (m == null || m > f.length) && (m = f.length);
        for (var h = 0, g = Array(m); h < m; h++) g[h] = f[h];
        return g;
      }
      s(a, '_arrayLikeToArray');
      function l(f, m) {
        var h = f == null ? null : (typeof Symbol < 'u' && f[Symbol.iterator]) || f['@@iterator'];
        if (h != null) {
          var g,
            v,
            E,
            b,
            S = [],
            R = !0,
            I = !1;
          try {
            if (((E = (h = h.call(f)).next), m === 0)) {
              if (Object(h) !== h) return;
              R = !1;
            } else for (; !(R = (g = E.call(h)).done) && (S.push(g.value), S.length !== m); R = !0);
          } catch ($) {
            ((I = !0), (v = $));
          } finally {
            try {
              if (!R && h.return != null && ((b = h.return()), Object(b) !== b)) return;
            } finally {
              if (I) throw v;
            }
          }
          return S;
        }
      }
      s(l, '_iterableToArrayLimit');
      function d(f) {
        if (Array.isArray(f)) return f;
      }
      s(d, '_arrayWithHoles');
      var u = [
          ['aria-activedescendant', { type: 'id' }],
          ['aria-atomic', { type: 'boolean' }],
          ['aria-autocomplete', { type: 'token', values: ['inline', 'list', 'both', 'none'] }],
          ['aria-braillelabel', { type: 'string' }],
          ['aria-brailleroledescription', { type: 'string' }],
          ['aria-busy', { type: 'boolean' }],
          ['aria-checked', { type: 'tristate' }],
          ['aria-colcount', { type: 'integer' }],
          ['aria-colindex', { type: 'integer' }],
          ['aria-colspan', { type: 'integer' }],
          ['aria-controls', { type: 'idlist' }],
          [
            'aria-current',
            { type: 'token', values: ['page', 'step', 'location', 'date', 'time', !0, !1] },
          ],
          ['aria-describedby', { type: 'idlist' }],
          ['aria-description', { type: 'string' }],
          ['aria-details', { type: 'id' }],
          ['aria-disabled', { type: 'boolean' }],
          [
            'aria-dropeffect',
            { type: 'tokenlist', values: ['copy', 'execute', 'link', 'move', 'none', 'popup'] },
          ],
          ['aria-errormessage', { type: 'id' }],
          ['aria-expanded', { type: 'boolean', allowundefined: !0 }],
          ['aria-flowto', { type: 'idlist' }],
          ['aria-grabbed', { type: 'boolean', allowundefined: !0 }],
          [
            'aria-haspopup',
            { type: 'token', values: [!1, !0, 'menu', 'listbox', 'tree', 'grid', 'dialog'] },
          ],
          ['aria-hidden', { type: 'boolean', allowundefined: !0 }],
          ['aria-invalid', { type: 'token', values: ['grammar', !1, 'spelling', !0] }],
          ['aria-keyshortcuts', { type: 'string' }],
          ['aria-label', { type: 'string' }],
          ['aria-labelledby', { type: 'idlist' }],
          ['aria-level', { type: 'integer' }],
          ['aria-live', { type: 'token', values: ['assertive', 'off', 'polite'] }],
          ['aria-modal', { type: 'boolean' }],
          ['aria-multiline', { type: 'boolean' }],
          ['aria-multiselectable', { type: 'boolean' }],
          ['aria-orientation', { type: 'token', values: ['vertical', 'undefined', 'horizontal'] }],
          ['aria-owns', { type: 'idlist' }],
          ['aria-placeholder', { type: 'string' }],
          ['aria-posinset', { type: 'integer' }],
          ['aria-pressed', { type: 'tristate' }],
          ['aria-readonly', { type: 'boolean' }],
          [
            'aria-relevant',
            { type: 'tokenlist', values: ['additions', 'all', 'removals', 'text'] },
          ],
          ['aria-required', { type: 'boolean' }],
          ['aria-roledescription', { type: 'string' }],
          ['aria-rowcount', { type: 'integer' }],
          ['aria-rowindex', { type: 'integer' }],
          ['aria-rowspan', { type: 'integer' }],
          ['aria-selected', { type: 'boolean', allowundefined: !0 }],
          ['aria-setsize', { type: 'integer' }],
          ['aria-sort', { type: 'token', values: ['ascending', 'descending', 'none', 'other'] }],
          ['aria-valuemax', { type: 'number' }],
          ['aria-valuemin', { type: 'number' }],
          ['aria-valuenow', { type: 'number' }],
          ['aria-valuetext', { type: 'string' }],
        ],
        p = {
          entries: s(function () {
            return u;
          }, 'entries'),
          forEach: s(function (m) {
            for (
              var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                g = 0,
                v = u;
              g < v.length;
              g++
            ) {
              var E = n(v[g], 2),
                b = E[0],
                S = E[1];
              m.call(h, S, b, u);
            }
          }, 'forEach'),
          get: s(function (m) {
            var h = u.filter(function (g) {
              return g[0] === m;
            })[0];
            return h && h[1];
          }, 'get'),
          has: s(function (m) {
            return !!p.get(m);
          }, 'has'),
          keys: s(function () {
            return u.map(function (m) {
              var h = n(m, 1),
                g = h[0];
              return g;
            });
          }, 'keys'),
          values: s(function () {
            return u.map(function (m) {
              var h = n(m, 2),
                g = h[1];
              return g;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(p, p.entries());
    },
  }),
  wq = B({
    '../node_modules/aria-query/lib/domMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = r(wi());
      function r(f) {
        return f && f.__esModule ? f : { default: f };
      }
      s(r, '_interopRequireDefault');
      function n(f, m) {
        return d(f) || l(f, m) || i(f, m) || o();
      }
      s(n, '_slicedToArray');
      function o() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(o, '_nonIterableRest');
      function i(f, m) {
        if (f) {
          if (typeof f == 'string') return a(f, m);
          var h = {}.toString.call(f).slice(8, -1);
          return (
            h === 'Object' && f.constructor && (h = f.constructor.name),
            h === 'Map' || h === 'Set'
              ? Array.from(f)
              : h === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)
                ? a(f, m)
                : void 0
          );
        }
      }
      s(i, '_unsupportedIterableToArray');
      function a(f, m) {
        (m == null || m > f.length) && (m = f.length);
        for (var h = 0, g = Array(m); h < m; h++) g[h] = f[h];
        return g;
      }
      s(a, '_arrayLikeToArray');
      function l(f, m) {
        var h = f == null ? null : (typeof Symbol < 'u' && f[Symbol.iterator]) || f['@@iterator'];
        if (h != null) {
          var g,
            v,
            E,
            b,
            S = [],
            R = !0,
            I = !1;
          try {
            if (((E = (h = h.call(f)).next), m === 0)) {
              if (Object(h) !== h) return;
              R = !1;
            } else for (; !(R = (g = E.call(h)).done) && (S.push(g.value), S.length !== m); R = !0);
          } catch ($) {
            ((I = !0), (v = $));
          } finally {
            try {
              if (!R && h.return != null && ((b = h.return()), Object(b) !== b)) return;
            } finally {
              if (I) throw v;
            }
          }
          return S;
        }
      }
      s(l, '_iterableToArrayLimit');
      function d(f) {
        if (Array.isArray(f)) return f;
      }
      s(d, '_arrayWithHoles');
      var u = [
          ['a', { reserved: !1 }],
          ['abbr', { reserved: !1 }],
          ['acronym', { reserved: !1 }],
          ['address', { reserved: !1 }],
          ['applet', { reserved: !1 }],
          ['area', { reserved: !1 }],
          ['article', { reserved: !1 }],
          ['aside', { reserved: !1 }],
          ['audio', { reserved: !1 }],
          ['b', { reserved: !1 }],
          ['base', { reserved: !0 }],
          ['bdi', { reserved: !1 }],
          ['bdo', { reserved: !1 }],
          ['big', { reserved: !1 }],
          ['blink', { reserved: !1 }],
          ['blockquote', { reserved: !1 }],
          ['body', { reserved: !1 }],
          ['br', { reserved: !1 }],
          ['button', { reserved: !1 }],
          ['canvas', { reserved: !1 }],
          ['caption', { reserved: !1 }],
          ['center', { reserved: !1 }],
          ['cite', { reserved: !1 }],
          ['code', { reserved: !1 }],
          ['col', { reserved: !0 }],
          ['colgroup', { reserved: !0 }],
          ['content', { reserved: !1 }],
          ['data', { reserved: !1 }],
          ['datalist', { reserved: !1 }],
          ['dd', { reserved: !1 }],
          ['del', { reserved: !1 }],
          ['details', { reserved: !1 }],
          ['dfn', { reserved: !1 }],
          ['dialog', { reserved: !1 }],
          ['dir', { reserved: !1 }],
          ['div', { reserved: !1 }],
          ['dl', { reserved: !1 }],
          ['dt', { reserved: !1 }],
          ['em', { reserved: !1 }],
          ['embed', { reserved: !1 }],
          ['fieldset', { reserved: !1 }],
          ['figcaption', { reserved: !1 }],
          ['figure', { reserved: !1 }],
          ['font', { reserved: !1 }],
          ['footer', { reserved: !1 }],
          ['form', { reserved: !1 }],
          ['frame', { reserved: !1 }],
          ['frameset', { reserved: !1 }],
          ['h1', { reserved: !1 }],
          ['h2', { reserved: !1 }],
          ['h3', { reserved: !1 }],
          ['h4', { reserved: !1 }],
          ['h5', { reserved: !1 }],
          ['h6', { reserved: !1 }],
          ['head', { reserved: !0 }],
          ['header', { reserved: !1 }],
          ['hgroup', { reserved: !1 }],
          ['hr', { reserved: !1 }],
          ['html', { reserved: !0 }],
          ['i', { reserved: !1 }],
          ['iframe', { reserved: !1 }],
          ['img', { reserved: !1 }],
          ['input', { reserved: !1 }],
          ['ins', { reserved: !1 }],
          ['kbd', { reserved: !1 }],
          ['keygen', { reserved: !1 }],
          ['label', { reserved: !1 }],
          ['legend', { reserved: !1 }],
          ['li', { reserved: !1 }],
          ['link', { reserved: !0 }],
          ['main', { reserved: !1 }],
          ['map', { reserved: !1 }],
          ['mark', { reserved: !1 }],
          ['marquee', { reserved: !1 }],
          ['menu', { reserved: !1 }],
          ['menuitem', { reserved: !1 }],
          ['meta', { reserved: !0 }],
          ['meter', { reserved: !1 }],
          ['nav', { reserved: !1 }],
          ['noembed', { reserved: !0 }],
          ['noscript', { reserved: !0 }],
          ['object', { reserved: !1 }],
          ['ol', { reserved: !1 }],
          ['optgroup', { reserved: !1 }],
          ['option', { reserved: !1 }],
          ['output', { reserved: !1 }],
          ['p', { reserved: !1 }],
          ['param', { reserved: !0 }],
          ['picture', { reserved: !0 }],
          ['pre', { reserved: !1 }],
          ['progress', { reserved: !1 }],
          ['q', { reserved: !1 }],
          ['rp', { reserved: !1 }],
          ['rt', { reserved: !1 }],
          ['rtc', { reserved: !1 }],
          ['ruby', { reserved: !1 }],
          ['s', { reserved: !1 }],
          ['samp', { reserved: !1 }],
          ['script', { reserved: !0 }],
          ['section', { reserved: !1 }],
          ['select', { reserved: !1 }],
          ['small', { reserved: !1 }],
          ['source', { reserved: !0 }],
          ['spacer', { reserved: !1 }],
          ['span', { reserved: !1 }],
          ['strike', { reserved: !1 }],
          ['strong', { reserved: !1 }],
          ['style', { reserved: !0 }],
          ['sub', { reserved: !1 }],
          ['summary', { reserved: !1 }],
          ['sup', { reserved: !1 }],
          ['table', { reserved: !1 }],
          ['tbody', { reserved: !1 }],
          ['td', { reserved: !1 }],
          ['textarea', { reserved: !1 }],
          ['tfoot', { reserved: !1 }],
          ['th', { reserved: !1 }],
          ['thead', { reserved: !1 }],
          ['time', { reserved: !1 }],
          ['title', { reserved: !0 }],
          ['tr', { reserved: !1 }],
          ['track', { reserved: !0 }],
          ['tt', { reserved: !1 }],
          ['u', { reserved: !1 }],
          ['ul', { reserved: !1 }],
          ['var', { reserved: !1 }],
          ['video', { reserved: !1 }],
          ['wbr', { reserved: !1 }],
          ['xmp', { reserved: !1 }],
        ],
        p = {
          entries: s(function () {
            return u;
          }, 'entries'),
          forEach: s(function (m) {
            for (
              var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                g = 0,
                v = u;
              g < v.length;
              g++
            ) {
              var E = n(v[g], 2),
                b = E[0],
                S = E[1];
              m.call(h, S, b, u);
            }
          }, 'forEach'),
          get: s(function (m) {
            var h = u.filter(function (g) {
              return g[0] === m;
            })[0];
            return h && h[1];
          }, 'get'),
          has: s(function (m) {
            return !!p.get(m);
          }, 'has'),
          keys: s(function () {
            return u.map(function (m) {
              var h = n(m, 1),
                g = h[0];
              return g;
            });
          }, 'keys'),
          values: s(function () {
            return u.map(function (m) {
              var h = n(m, 2),
                g = h[1];
              return g;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(p, p.entries());
    },
  }),
  Sq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  _q = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-activedescendant': null, 'aria-disabled': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  Aq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-disabled': null },
        relatedConcepts: [{ concept: { name: 'input' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  Rq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Pq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuemax': null, 'aria-valuemin': null, 'aria-valuenow': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  xq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {
          'aria-atomic': null,
          'aria-busy': null,
          'aria-controls': null,
          'aria-current': null,
          'aria-describedby': null,
          'aria-details': null,
          'aria-dropeffect': null,
          'aria-flowto': null,
          'aria-grabbed': null,
          'aria-hidden': null,
          'aria-keyshortcuts': null,
          'aria-label': null,
          'aria-labelledby': null,
          'aria-live': null,
          'aria-owns': null,
          'aria-relevant': null,
          'aria-roledescription': null,
        },
        relatedConcepts: [
          { concept: { name: 'role' }, module: 'XHTML' },
          { concept: { name: 'type' }, module: 'Dublin Core' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [],
      };
      e.default = t;
    },
  }),
  Oq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'frontmatter' }, module: 'DTB' },
          { concept: { name: 'level' }, module: 'DTB' },
          { concept: { name: 'level' }, module: 'SMIL' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  Cq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  Iq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'structure', 'section', 'group'],
        ],
      };
      e.default = t;
    },
  }),
  Nq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  $q = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  qq = B({
    '../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-modal': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  Mq = B({
    '../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = h(Sq()),
        r = h(_q()),
        n = h(Aq()),
        o = h(Rq()),
        i = h(Pq()),
        a = h(xq()),
        l = h(Oq()),
        d = h(Cq()),
        u = h(Iq()),
        p = h(Nq()),
        f = h($q()),
        m = h(qq());
      function h(v) {
        return v && v.__esModule ? v : { default: v };
      }
      s(h, '_interopRequireDefault');
      var g = [
        ['command', t.default],
        ['composite', r.default],
        ['input', n.default],
        ['landmark', o.default],
        ['range', i.default],
        ['roletype', a.default],
        ['section', l.default],
        ['sectionhead', d.default],
        ['select', u.default],
        ['structure', p.default],
        ['widget', f.default],
        ['window', m.default],
      ];
      e.default = g;
    },
  }),
  jq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/alertRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-atomic': 'true', 'aria-live': 'assertive' },
        relatedConcepts: [{ concept: { name: 'alert' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  kq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'alert' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'alert'],
          ['roletype', 'window', 'dialog'],
        ],
      };
      e.default = t;
    },
  }),
  Dq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'Device Independence Delivery Unit' } }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  Lq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/articleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [{ concept: { name: 'article' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'document']],
      };
      e.default = t;
    },
  }),
  Fq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { constraints: ['scoped to the body element'], name: 'header' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Bq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'blockquote' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Jq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-pressed': null,
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'button' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'image' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'reset' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'submit' }], name: 'input' },
            module: 'HTML',
          },
          { concept: { name: 'button' }, module: 'HTML' },
          { concept: { name: 'trigger' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  Uq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/captionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'caption' }, module: 'HTML' }],
        requireContextRole: ['figure', 'grid', 'table'],
        requiredContextRole: ['figure', 'grid', 'table'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Vq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/cellRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-colindex': null,
          'aria-colspan': null,
          'aria-rowindex': null,
          'aria-rowspan': null,
        },
        relatedConcepts: [
          {
            concept: { constraints: ['ancestor table element has table role'], name: 'td' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Hq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'checkbox' }], name: 'input' },
            module: 'HTML',
          },
          { concept: { name: 'option' }, module: 'ARIA' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  zq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/codeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'code' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Gq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-sort': null },
        relatedConcepts: [
          { concept: { name: 'th' }, module: 'HTML' },
          {
            concept: { attributes: [{ name: 'scope', value: 'col' }], name: 'th' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'scope', value: 'colgroup' }], name: 'th' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'structure', 'section', 'cell', 'gridcell'],
          ['roletype', 'widget', 'gridcell'],
          ['roletype', 'structure', 'sectionhead'],
        ],
      };
      e.default = t;
    },
  }),
  Wq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-autocomplete': null,
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-expanded': 'false',
          'aria-haspopup': 'listbox',
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'email' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'search' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'tel' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'text' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'multiple' },
                { constraints: ['undefined'], name: 'size' },
              ],
              constraints: [
                'the multiple attribute is not set and the size attribute does not have a value greater than 1',
              ],
              name: 'select',
            },
            module: 'HTML',
          },
          { concept: { name: 'select' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-controls': null, 'aria-expanded': 'false' },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  Kq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              constraints: ['scoped to the body element', 'scoped to the main element'],
              name: 'aside',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-label' }],
              constraints: [
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'aside',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              constraints: [
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'aside',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Yq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { constraints: ['scoped to the body element'], name: 'footer' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Xq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'dd' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Qq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'del' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Zq = B({
    '../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'dialog' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'window']],
      };
      e.default = t;
    },
  }),
  eM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ module: 'DAISY Guide' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'list']],
      };
      e.default = t;
    },
  }),
  tM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/documentRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'Device Independence Delivery Unit' } },
          { concept: { name: 'html' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  rM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'em' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  nM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/feedRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['article']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'list']],
      };
      e.default = t;
    },
  }),
  oM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/figureRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'figure' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  sM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/formRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'aria-label' }], name: 'form' },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              name: 'form',
            },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['set'], name: 'name' }], name: 'form' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  iM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/genericRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [
          { concept: { name: 'a' }, module: 'HTML' },
          { concept: { name: 'area' }, module: 'HTML' },
          { concept: { name: 'aside' }, module: 'HTML' },
          { concept: { name: 'b' }, module: 'HTML' },
          { concept: { name: 'bdo' }, module: 'HTML' },
          { concept: { name: 'body' }, module: 'HTML' },
          { concept: { name: 'data' }, module: 'HTML' },
          { concept: { name: 'div' }, module: 'HTML' },
          {
            concept: {
              constraints: [
                'scoped to the main element',
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'footer',
            },
            module: 'HTML',
          },
          {
            concept: {
              constraints: [
                'scoped to the main element',
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'header',
            },
            module: 'HTML',
          },
          { concept: { name: 'hgroup' }, module: 'HTML' },
          { concept: { name: 'i' }, module: 'HTML' },
          { concept: { name: 'pre' }, module: 'HTML' },
          { concept: { name: 'q' }, module: 'HTML' },
          { concept: { name: 'samp' }, module: 'HTML' },
          { concept: { name: 'section' }, module: 'HTML' },
          { concept: { name: 'small' }, module: 'HTML' },
          { concept: { name: 'span' }, module: 'HTML' },
          { concept: { name: 'u' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  aM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/gridRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-multiselectable': null, 'aria-readonly': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'structure', 'section', 'table'],
        ],
      };
      e.default = t;
    },
  }),
  lM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-selected': null,
        },
        relatedConcepts: [
          {
            concept: {
              constraints: [
                'ancestor table element has grid role',
                'ancestor table element has treegrid role',
              ],
              name: 'td',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  cM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/groupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-activedescendant': null, 'aria-disabled': null },
        relatedConcepts: [
          { concept: { name: 'details' }, module: 'HTML' },
          { concept: { name: 'fieldset' }, module: 'HTML' },
          { concept: { name: 'optgroup' }, module: 'HTML' },
          { concept: { name: 'address' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  uM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/headingRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-level': '2' },
        relatedConcepts: [
          { concept: { name: 'h1' }, module: 'HTML' },
          { concept: { name: 'h2' }, module: 'HTML' },
          { concept: { name: 'h3' }, module: 'HTML' },
          { concept: { name: 'h4' }, module: 'HTML' },
          { concept: { name: 'h5' }, module: 'HTML' },
          { concept: { name: 'h6' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-level': '2' },
        superClass: [['roletype', 'structure', 'sectionhead']],
      };
      e.default = t;
    },
  }),
  dM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/imgRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'alt' }], name: 'img' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['undefined'], name: 'alt' }], name: 'img' },
            module: 'HTML',
          },
          { concept: { name: 'imggroup' }, module: 'DTB' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  pM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'ins' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  fM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/linkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-disabled': null, 'aria-expanded': null, 'aria-haspopup': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'href' }], name: 'a' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['set'], name: 'href' }], name: 'area' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  mM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/listRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'menu' }, module: 'HTML' },
          { concept: { name: 'ol' }, module: 'HTML' },
          { concept: { name: 'ul' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['listitem']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  yM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-invalid': null,
          'aria-multiselectable': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-orientation': 'vertical',
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [{ constraints: ['>1'], name: 'size' }],
              constraints: ['the size attribute value is greater than 1'],
              name: 'select',
            },
            module: 'HTML',
          },
          { concept: { attributes: [{ name: 'multiple' }], name: 'select' }, module: 'HTML' },
          { concept: { name: 'datalist' }, module: 'HTML' },
          { concept: { name: 'list' }, module: 'ARIA' },
          { concept: { name: 'select' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['option', 'group'], ['option']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  hM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-level': null, 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [
          {
            concept: {
              constraints: [
                'direct descendant of ol',
                'direct descendant of ul',
                'direct descendant of menu',
              ],
              name: 'li',
            },
            module: 'HTML',
          },
          { concept: { name: 'item' }, module: 'XForms' },
        ],
        requireContextRole: ['directory', 'list'],
        requiredContextRole: ['directory', 'list'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  gM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/logRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-live': 'polite' },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  bM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/mainRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'main' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  vM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/markRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
        },
        relatedConcepts: [{ concept: { name: 'mark' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  TM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  EM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/mathRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'math' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  wM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menuRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'vertical' },
        relatedConcepts: [
          { concept: { name: 'MENU' }, module: 'JAPI' },
          { concept: { name: 'list' }, module: 'ARIA' },
          { concept: { name: 'select' }, module: 'XForms' },
          { concept: { name: 'sidebar' }, module: 'DTB' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
          ['menuitem', 'group'],
          ['menuitemradio', 'group'],
          ['menuitemcheckbox', 'group'],
          ['menuitem'],
          ['menuitemcheckbox'],
          ['menuitemradio'],
        ],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  SM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'horizontal' },
        relatedConcepts: [{ concept: { name: 'toolbar' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
          ['menuitem', 'group'],
          ['menuitemradio', 'group'],
          ['menuitemcheckbox', 'group'],
          ['menuitem'],
          ['menuitemcheckbox'],
          ['menuitemradio'],
        ],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select', 'menu'],
          ['roletype', 'structure', 'section', 'group', 'select', 'menu'],
        ],
      };
      e.default = t;
    },
  }),
  _M = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-posinset': null,
          'aria-setsize': null,
        },
        relatedConcepts: [
          { concept: { name: 'MENU_ITEM' }, module: 'JAPI' },
          { concept: { name: 'listitem' }, module: 'ARIA' },
          { concept: { name: 'option' }, module: 'ARIA' },
        ],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  AM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'menuitem' }, module: 'ARIA' }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [
          ['roletype', 'widget', 'input', 'checkbox'],
          ['roletype', 'widget', 'command', 'menuitem'],
        ],
      };
      e.default = t;
    },
  }),
  RM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'menuitem' }, module: 'ARIA' }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [
          ['roletype', 'widget', 'input', 'checkbox', 'menuitemcheckbox'],
          ['roletype', 'widget', 'command', 'menuitem', 'menuitemcheckbox'],
          ['roletype', 'widget', 'input', 'radio'],
        ],
      };
      e.default = t;
    },
  }),
  PM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/meterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuetext': null, 'aria-valuemax': '100', 'aria-valuemin': '0' },
        relatedConcepts: [{ concept: { name: 'meter' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-valuenow': null },
        superClass: [['roletype', 'structure', 'range']],
      };
      e.default = t;
    },
  }),
  xM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'nav' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  OM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/noneRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [],
      };
      e.default = t;
    },
  }),
  CM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/noteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  IM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/optionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-posinset': null,
          'aria-setsize': null,
          'aria-selected': 'false',
        },
        relatedConcepts: [
          { concept: { name: 'item' }, module: 'XForms' },
          { concept: { name: 'listitem' }, module: 'ARIA' },
          { concept: { name: 'option' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-selected': 'false' },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  NM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'p' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  $M = B({
    '../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [
          { concept: { attributes: [{ name: 'alt', value: '' }], name: 'img' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  qM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuetext': null },
        relatedConcepts: [
          { concept: { name: 'progress' }, module: 'HTML' },
          { concept: { name: 'status' }, module: 'ARIA' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'range'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  MM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/radioRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-checked': null, 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'radio' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  jM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [{ concept: { name: 'list' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['radio']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  kM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/regionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-label' }],
              name: 'section',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              name: 'section',
            },
            module: 'HTML',
          },
          { concept: { name: 'Device Independence Glossart perceivable unit' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  DM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/rowRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-colindex': null,
          'aria-expanded': null,
          'aria-level': null,
          'aria-posinset': null,
          'aria-rowindex': null,
          'aria-selected': null,
          'aria-setsize': null,
        },
        relatedConcepts: [{ concept: { name: 'tr' }, module: 'HTML' }],
        requireContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
        requiredContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
        requiredOwnedElements: [['cell'], ['columnheader'], ['gridcell'], ['rowheader']],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'group'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  LM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'tbody' }, module: 'HTML' },
          { concept: { name: 'tfoot' }, module: 'HTML' },
          { concept: { name: 'thead' }, module: 'HTML' },
        ],
        requireContextRole: ['grid', 'table', 'treegrid'],
        requiredContextRole: ['grid', 'table', 'treegrid'],
        requiredOwnedElements: [['row']],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  FM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-sort': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'scope', value: 'row' }], name: 'th' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'scope', value: 'rowgroup' }], name: 'th' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row', 'rowgroup'],
        requiredContextRole: ['row', 'rowgroup'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'structure', 'section', 'cell', 'gridcell'],
          ['roletype', 'widget', 'gridcell'],
          ['roletype', 'structure', 'sectionhead'],
        ],
      };
      e.default = t;
    },
  }),
  BM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-valuetext': null,
          'aria-orientation': 'vertical',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-controls': null, 'aria-valuenow': null },
        superClass: [
          ['roletype', 'structure', 'range'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  JM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/searchRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  UM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'search' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'input', 'textbox']],
      };
      e.default = t;
    },
  }),
  VM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-orientation': 'horizontal',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
          'aria-valuenow': null,
          'aria-valuetext': null,
        },
        relatedConcepts: [{ concept: { name: 'hr' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  HM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-valuetext': null,
          'aria-orientation': 'horizontal',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'range' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-valuenow': null },
        superClass: [
          ['roletype', 'widget', 'input'],
          ['roletype', 'structure', 'range'],
        ],
      };
      e.default = t;
    },
  }),
  zM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-valuetext': null,
          'aria-valuenow': '0',
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'number' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'widget', 'input'],
          ['roletype', 'structure', 'range'],
        ],
      };
      e.default = t;
    },
  }),
  GM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/statusRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-atomic': 'true', 'aria-live': 'polite' },
        relatedConcepts: [{ concept: { name: 'output' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  WM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/strongRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'strong' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  KM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'sub' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  YM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'sup' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  XM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/switchRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'button' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input', 'checkbox']],
      };
      e.default = t;
    },
  }),
  QM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tabRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-posinset': null,
          'aria-setsize': null,
          'aria-selected': 'false',
        },
        relatedConcepts: [],
        requireContextRole: ['tablist'],
        requiredContextRole: ['tablist'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'sectionhead'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  ZM = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tableRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-colcount': null, 'aria-rowcount': null },
        relatedConcepts: [{ concept: { name: 'table' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  ej = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-level': null,
          'aria-multiselectable': null,
          'aria-orientation': 'horizontal',
        },
        relatedConcepts: [{ module: 'DAISY', concept: { name: 'guide' } }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['tab']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite']],
      };
      e.default = t;
    },
  }),
  tj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  rj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/termRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'dfn' }, module: 'HTML' },
          { concept: { name: 'dt' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  nj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-autocomplete': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-multiline': null,
          'aria-placeholder': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'type' },
                { constraints: ['undefined'], name: 'list' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'email' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'tel' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'text' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          { concept: { name: 'input' }, module: 'XForms' },
          { concept: { name: 'textarea' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  oj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/timeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'time' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  sj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/timerRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'status']],
      };
      e.default = t;
    },
  }),
  ij = B({
    '../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'horizontal' },
        relatedConcepts: [{ concept: { name: 'menubar' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group']],
      };
      e.default = t;
    },
  }),
  aj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  lj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/treeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-multiselectable': null,
          'aria-required': null,
          'aria-orientation': 'vertical',
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['treeitem', 'group'], ['treeitem']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  cj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'grid'],
          ['roletype', 'structure', 'section', 'table', 'grid'],
          ['roletype', 'widget', 'composite', 'select', 'tree'],
          ['roletype', 'structure', 'section', 'group', 'select', 'tree'],
        ],
      };
      e.default = t;
    },
  }),
  uj = B({
    '../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-expanded': null, 'aria-haspopup': null },
        relatedConcepts: [],
        requireContextRole: ['group', 'tree'],
        requiredContextRole: ['group', 'tree'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-selected': null },
        superClass: [
          ['roletype', 'structure', 'section', 'listitem'],
          ['roletype', 'widget', 'input', 'option'],
        ],
      };
      e.default = t;
    },
  }),
  dj = B({
    '../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = Y(jq()),
        r = Y(kq()),
        n = Y(Dq()),
        o = Y(Lq()),
        i = Y(Fq()),
        a = Y(Bq()),
        l = Y(Jq()),
        d = Y(Uq()),
        u = Y(Vq()),
        p = Y(Hq()),
        f = Y(zq()),
        m = Y(Gq()),
        h = Y(Wq()),
        g = Y(Kq()),
        v = Y(Yq()),
        E = Y(Xq()),
        b = Y(Qq()),
        S = Y(Zq()),
        R = Y(eM()),
        I = Y(tM()),
        $ = Y(rM()),
        x = Y(nM()),
        A = Y(oM()),
        w = Y(sM()),
        _ = Y(iM()),
        j = Y(aM()),
        N = Y(lM()),
        V = Y(cM()),
        H = Y(uM()),
        P = Y(dM()),
        D = Y(pM()),
        F = Y(fM()),
        k = Y(mM()),
        K = Y(yM()),
        X = Y(hM()),
        se = Y(gM()),
        ie = Y(bM()),
        W = Y(vM()),
        ae = Y(TM()),
        be = Y(EM()),
        ue = Y(wM()),
        ee = Y(SM()),
        Pe = Y(_M()),
        xe = Y(AM()),
        He = Y(RM()),
        Xe = Y(PM()),
        J = Y(xM()),
        Q = Y(OM()),
        re = Y(CM()),
        oe = Y(IM()),
        ne = Y(NM()),
        de = Y($M()),
        ye = Y(qM()),
        pe = Y(MM()),
        Fe = Y(jM()),
        it = Y(kM()),
        yt = Y(DM()),
        Pt = Y(LM()),
        at = Y(FM()),
        ht = Y(BM()),
        gt = Y(JM()),
        bt = Y(UM()),
        un = Y(VM()),
        Qo = Y(HM()),
        dn = Y(zM()),
        Zo = Y(GM()),
        es = Y(WM()),
        ts = Y(KM()),
        pn = Y(YM()),
        rs = Y(XM()),
        ns = Y(QM()),
        os = Y(ZM()),
        ss = Y(ej()),
        is = Y(tj()),
        as = Y(rj()),
        ls = Y(nj()),
        cs = Y(oj()),
        us = Y(sj()),
        ds = Y(ij()),
        ps = Y(aj()),
        fs = Y(lj()),
        yr = Y(cj()),
        fn = Y(uj());
      function Y(kt) {
        return kt && kt.__esModule ? kt : { default: kt };
      }
      s(Y, '_interopRequireDefault');
      var le = [
        ['alert', t.default],
        ['alertdialog', r.default],
        ['application', n.default],
        ['article', o.default],
        ['banner', i.default],
        ['blockquote', a.default],
        ['button', l.default],
        ['caption', d.default],
        ['cell', u.default],
        ['checkbox', p.default],
        ['code', f.default],
        ['columnheader', m.default],
        ['combobox', h.default],
        ['complementary', g.default],
        ['contentinfo', v.default],
        ['definition', E.default],
        ['deletion', b.default],
        ['dialog', S.default],
        ['directory', R.default],
        ['document', I.default],
        ['emphasis', $.default],
        ['feed', x.default],
        ['figure', A.default],
        ['form', w.default],
        ['generic', _.default],
        ['grid', j.default],
        ['gridcell', N.default],
        ['group', V.default],
        ['heading', H.default],
        ['img', P.default],
        ['insertion', D.default],
        ['link', F.default],
        ['list', k.default],
        ['listbox', K.default],
        ['listitem', X.default],
        ['log', se.default],
        ['main', ie.default],
        ['mark', W.default],
        ['marquee', ae.default],
        ['math', be.default],
        ['menu', ue.default],
        ['menubar', ee.default],
        ['menuitem', Pe.default],
        ['menuitemcheckbox', xe.default],
        ['menuitemradio', He.default],
        ['meter', Xe.default],
        ['navigation', J.default],
        ['none', Q.default],
        ['note', re.default],
        ['option', oe.default],
        ['paragraph', ne.default],
        ['presentation', de.default],
        ['progressbar', ye.default],
        ['radio', pe.default],
        ['radiogroup', Fe.default],
        ['region', it.default],
        ['row', yt.default],
        ['rowgroup', Pt.default],
        ['rowheader', at.default],
        ['scrollbar', ht.default],
        ['search', gt.default],
        ['searchbox', bt.default],
        ['separator', un.default],
        ['slider', Qo.default],
        ['spinbutton', dn.default],
        ['status', Zo.default],
        ['strong', es.default],
        ['subscript', ts.default],
        ['superscript', pn.default],
        ['switch', rs.default],
        ['tab', ns.default],
        ['table', os.default],
        ['tablist', ss.default],
        ['tabpanel', is.default],
        ['term', as.default],
        ['textbox', ls.default],
        ['time', cs.default],
        ['timer', us.default],
        ['toolbar', ds.default],
        ['tooltip', ps.default],
        ['tree', fs.default],
        ['treegrid', yr.default],
        ['treeitem', fn.default],
      ];
      e.default = le;
    },
  }),
  pj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'abstract [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  fj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'acknowledgments [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  mj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'afterword [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  yj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'appendix [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  hj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'referrer [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  gj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'EPUB biblioentry [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: ['doc-bibliography'],
        requiredContextRole: ['doc-bibliography'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'listitem']],
      };
      e.default = t;
    },
  }),
  bj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'bibliography [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['doc-biblioentry']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  vj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'biblioref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  Tj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'chapter [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Ej = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'colophon [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  wj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'conclusion [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Sj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'cover [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'img']],
      };
      e.default = t;
    },
  }),
  _j = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'credit [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Aj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'credits [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Rj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'dedication [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Pj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'rearnote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: ['doc-endnotes'],
        requiredContextRole: ['doc-endnotes'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'listitem']],
      };
      e.default = t;
    },
  }),
  xj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'rearnotes [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['doc-endnote']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Oj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'epigraph [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Cj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'epilogue [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Ij = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'errata [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Nj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  $j = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'footnote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  qj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'foreword [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Mj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'glossary [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['definition'], ['term']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  jj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'glossref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  kj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'index [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  Dj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'introduction [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Lj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'noteref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  Fj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'notice [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'note']],
      };
      e.default = t;
    },
  }),
  Bj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'pagebreak [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'separator']],
      };
      e.default = t;
    },
  }),
  Jj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Uj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Vj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'page-list [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  Hj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'part [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  zj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'preface [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Gj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'prologue [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Wj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'pullquote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['none']],
      };
      e.default = t;
    },
  }),
  Kj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'qna [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Yj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'subtitle [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'sectionhead']],
      };
      e.default = t;
    },
  }),
  Xj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'help [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'note']],
      };
      e.default = t;
    },
  }),
  Qj = B({
    '../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'toc [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  Zj = B({
    '../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = ee(pj()),
        r = ee(fj()),
        n = ee(mj()),
        o = ee(yj()),
        i = ee(hj()),
        a = ee(gj()),
        l = ee(bj()),
        d = ee(vj()),
        u = ee(Tj()),
        p = ee(Ej()),
        f = ee(wj()),
        m = ee(Sj()),
        h = ee(_j()),
        g = ee(Aj()),
        v = ee(Rj()),
        E = ee(Pj()),
        b = ee(xj()),
        S = ee(Oj()),
        R = ee(Cj()),
        I = ee(Ij()),
        $ = ee(Nj()),
        x = ee($j()),
        A = ee(qj()),
        w = ee(Mj()),
        _ = ee(jj()),
        j = ee(kj()),
        N = ee(Dj()),
        V = ee(Lj()),
        H = ee(Fj()),
        P = ee(Bj()),
        D = ee(Jj()),
        F = ee(Uj()),
        k = ee(Vj()),
        K = ee(Hj()),
        X = ee(zj()),
        se = ee(Gj()),
        ie = ee(Wj()),
        W = ee(Kj()),
        ae = ee(Yj()),
        be = ee(Xj()),
        ue = ee(Qj());
      function ee(xe) {
        return xe && xe.__esModule ? xe : { default: xe };
      }
      s(ee, '_interopRequireDefault');
      var Pe = [
        ['doc-abstract', t.default],
        ['doc-acknowledgments', r.default],
        ['doc-afterword', n.default],
        ['doc-appendix', o.default],
        ['doc-backlink', i.default],
        ['doc-biblioentry', a.default],
        ['doc-bibliography', l.default],
        ['doc-biblioref', d.default],
        ['doc-chapter', u.default],
        ['doc-colophon', p.default],
        ['doc-conclusion', f.default],
        ['doc-cover', m.default],
        ['doc-credit', h.default],
        ['doc-credits', g.default],
        ['doc-dedication', v.default],
        ['doc-endnote', E.default],
        ['doc-endnotes', b.default],
        ['doc-epigraph', S.default],
        ['doc-epilogue', R.default],
        ['doc-errata', I.default],
        ['doc-example', $.default],
        ['doc-footnote', x.default],
        ['doc-foreword', A.default],
        ['doc-glossary', w.default],
        ['doc-glossref', _.default],
        ['doc-index', j.default],
        ['doc-introduction', N.default],
        ['doc-noteref', V.default],
        ['doc-notice', H.default],
        ['doc-pagebreak', P.default],
        ['doc-pagefooter', D.default],
        ['doc-pageheader', F.default],
        ['doc-pagelist', k.default],
        ['doc-part', K.default],
        ['doc-preface', X.default],
        ['doc-prologue', se.default],
        ['doc-pullquote', ie.default],
        ['doc-qna', W.default],
        ['doc-subtitle', ae.default],
        ['doc-tip', be.default],
        ['doc-toc', ue.default],
      ];
      e.default = Pe;
    },
  }),
  e1 = B({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [
          { module: 'GRAPHICS', concept: { name: 'graphics-object' } },
          { module: 'ARIA', concept: { name: 'img' } },
          { module: 'ARIA', concept: { name: 'article' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'document']],
      };
      e.default = t;
    },
  }),
  t1 = B({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [
          { module: 'GRAPHICS', concept: { name: 'graphics-document' } },
          { module: 'ARIA', concept: { name: 'group' } },
          { module: 'ARIA', concept: { name: 'img' } },
          { module: 'GRAPHICS', concept: { name: 'graphics-symbol' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group']],
      };
      e.default = t;
    },
  }),
  r1 = B({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'img']],
      };
      e.default = t;
    },
  }),
  n1 = B({
    '../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = o(e1()),
        r = o(t1()),
        n = o(r1());
      function o(a) {
        return a && a.__esModule ? a : { default: a };
      }
      s(o, '_interopRequireDefault');
      var i = [
        ['graphics-document', t.default],
        ['graphics-object', r.default],
        ['graphics-symbol', n.default],
      ];
      e.default = i;
    },
  }),
  Lp = B({
    '../node_modules/aria-query/lib/rolesMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = a(Mq()),
        r = a(dj()),
        n = a(Zj()),
        o = a(n1()),
        i = a(wi());
      function a(E) {
        return E && E.__esModule ? E : { default: E };
      }
      s(a, '_interopRequireDefault');
      function l(E, b) {
        var S = (typeof Symbol < 'u' && E[Symbol.iterator]) || E['@@iterator'];
        if (!S) {
          if (Array.isArray(E) || (S = p(E)) || (b && E && typeof E.length == 'number')) {
            S && (E = S);
            var R = 0,
              I = s(function () {}, 'F');
            return {
              s: I,
              n: s(function () {
                return R >= E.length ? { done: !0 } : { done: !1, value: E[R++] };
              }, 'n'),
              e: s(function (_) {
                throw _;
              }, 'e'),
              f: I,
            };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var $,
          x = !0,
          A = !1;
        return {
          s: s(function () {
            S = S.call(E);
          }, 's'),
          n: s(function () {
            var _ = S.next();
            return ((x = _.done), _);
          }, 'n'),
          e: s(function (_) {
            ((A = !0), ($ = _));
          }, 'e'),
          f: s(function () {
            try {
              x || S.return == null || S.return();
            } finally {
              if (A) throw $;
            }
          }, 'f'),
        };
      }
      s(l, '_createForOfIteratorHelper');
      function d(E, b) {
        return h(E) || m(E, b) || p(E, b) || u();
      }
      s(d, '_slicedToArray');
      function u() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(u, '_nonIterableRest');
      function p(E, b) {
        if (E) {
          if (typeof E == 'string') return f(E, b);
          var S = {}.toString.call(E).slice(8, -1);
          return (
            S === 'Object' && E.constructor && (S = E.constructor.name),
            S === 'Map' || S === 'Set'
              ? Array.from(E)
              : S === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(S)
                ? f(E, b)
                : void 0
          );
        }
      }
      s(p, '_unsupportedIterableToArray');
      function f(E, b) {
        (b == null || b > E.length) && (b = E.length);
        for (var S = 0, R = Array(b); S < b; S++) R[S] = E[S];
        return R;
      }
      s(f, '_arrayLikeToArray');
      function m(E, b) {
        var S = E == null ? null : (typeof Symbol < 'u' && E[Symbol.iterator]) || E['@@iterator'];
        if (S != null) {
          var R,
            I,
            $,
            x,
            A = [],
            w = !0,
            _ = !1;
          try {
            if ((($ = (S = S.call(E)).next), b === 0)) {
              if (Object(S) !== S) return;
              w = !1;
            } else for (; !(w = (R = $.call(S)).done) && (A.push(R.value), A.length !== b); w = !0);
          } catch (j) {
            ((_ = !0), (I = j));
          } finally {
            try {
              if (!w && S.return != null && ((x = S.return()), Object(x) !== x)) return;
            } finally {
              if (_) throw I;
            }
          }
          return A;
        }
      }
      s(m, '_iterableToArrayLimit');
      function h(E) {
        if (Array.isArray(E)) return E;
      }
      s(h, '_arrayWithHoles');
      var g = [].concat(t.default, r.default, n.default, o.default);
      g.forEach(function (E) {
        var b = d(E, 2),
          S = b[1],
          R = l(S.superClass),
          I;
        try {
          for (R.s(); !(I = R.n()).done; ) {
            var $ = I.value,
              x = l($),
              A;
            try {
              var w = s(function () {
                var j = A.value,
                  N = g.filter(function (F) {
                    var k = d(F, 1),
                      K = k[0];
                    return K === j;
                  })[0];
                if (N)
                  for (var V = N[1], H = 0, P = Object.keys(V.props); H < P.length; H++) {
                    var D = P[H];
                    Object.prototype.hasOwnProperty.call(S.props, D) || (S.props[D] = V.props[D]);
                  }
              }, '_loop');
              for (x.s(); !(A = x.n()).done; ) w();
            } catch (_) {
              x.e(_);
            } finally {
              x.f();
            }
          }
        } catch (_) {
          R.e(_);
        } finally {
          R.f();
        }
      });
      var v = {
        entries: s(function () {
          return g;
        }, 'entries'),
        forEach: s(function (b) {
          var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
            R = l(g),
            I;
          try {
            for (R.s(); !(I = R.n()).done; ) {
              var $ = d(I.value, 2),
                x = $[0],
                A = $[1];
              b.call(S, A, x, g);
            }
          } catch (w) {
            R.e(w);
          } finally {
            R.f();
          }
        }, 'forEach'),
        get: s(function (b) {
          var S = g.filter(function (R) {
            return R[0] === b;
          })[0];
          return S && S[1];
        }, 'get'),
        has: s(function (b) {
          return !!v.get(b);
        }, 'has'),
        keys: s(function () {
          return g.map(function (b) {
            var S = d(b, 1),
              R = S[0];
            return R;
          });
        }, 'keys'),
        values: s(function () {
          return g.map(function (b) {
            var S = d(b, 2),
              R = S[1];
            return R;
          });
        }, 'values'),
      };
      e.default = (0, i.default)(v, v.entries());
    },
  }),
  o1 = B({
    '../node_modules/aria-query/lib/elementRoleMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = n(wi()),
        r = n(Lp());
      function n(x) {
        return x && x.__esModule ? x : { default: x };
      }
      s(n, '_interopRequireDefault');
      function o(x, A) {
        return u(x) || d(x, A) || a(x, A) || i();
      }
      s(o, '_slicedToArray');
      function i() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(i, '_nonIterableRest');
      function a(x, A) {
        if (x) {
          if (typeof x == 'string') return l(x, A);
          var w = {}.toString.call(x).slice(8, -1);
          return (
            w === 'Object' && x.constructor && (w = x.constructor.name),
            w === 'Map' || w === 'Set'
              ? Array.from(x)
              : w === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w)
                ? l(x, A)
                : void 0
          );
        }
      }
      s(a, '_unsupportedIterableToArray');
      function l(x, A) {
        (A == null || A > x.length) && (A = x.length);
        for (var w = 0, _ = Array(A); w < A; w++) _[w] = x[w];
        return _;
      }
      s(l, '_arrayLikeToArray');
      function d(x, A) {
        var w = x == null ? null : (typeof Symbol < 'u' && x[Symbol.iterator]) || x['@@iterator'];
        if (w != null) {
          var _,
            j,
            N,
            V,
            H = [],
            P = !0,
            D = !1;
          try {
            if (((N = (w = w.call(x)).next), A === 0)) {
              if (Object(w) !== w) return;
              P = !1;
            } else for (; !(P = (_ = N.call(w)).done) && (H.push(_.value), H.length !== A); P = !0);
          } catch (F) {
            ((D = !0), (j = F));
          } finally {
            try {
              if (!P && w.return != null && ((V = w.return()), Object(V) !== V)) return;
            } finally {
              if (D) throw j;
            }
          }
          return H;
        }
      }
      s(d, '_iterableToArrayLimit');
      function u(x) {
        if (Array.isArray(x)) return x;
      }
      s(u, '_arrayWithHoles');
      var p = [],
        f = r.default.keys();
      for (b = 0; b < f.length; b++)
        if (((m = f[b]), (h = r.default.get(m)), h))
          for (
            g = [].concat(h.baseConcepts, h.relatedConcepts),
              v = s(function () {
                var A = g[E];
                if (A.module === 'HTML') {
                  var w = A.concept;
                  if (w) {
                    var _ = p.filter(function (H) {
                        return R(H[0], w);
                      })[0],
                      j;
                    _ ? (j = _[1]) : (j = []);
                    for (var N = !0, V = 0; V < j.length; V++)
                      if (j[V] === m) {
                        N = !1;
                        break;
                      }
                    (N && j.push(m), _ || p.push([w, j]));
                  }
                }
              }, '_loop'),
              E = 0;
            E < g.length;
            E++
          )
            v();
      var m,
        h,
        g,
        v,
        E,
        b,
        S = {
          entries: s(function () {
            return p;
          }, 'entries'),
          forEach: s(function (A) {
            for (
              var w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                _ = 0,
                j = p;
              _ < j.length;
              _++
            ) {
              var N = o(j[_], 2),
                V = N[0],
                H = N[1];
              A.call(w, H, V, p);
            }
          }, 'forEach'),
          get: s(function (A) {
            var w = p.filter(function (_) {
              return A.name === _[0].name && $(A.attributes, _[0].attributes);
            })[0];
            return w && w[1];
          }, 'get'),
          has: s(function (A) {
            return !!S.get(A);
          }, 'has'),
          keys: s(function () {
            return p.map(function (A) {
              var w = o(A, 1),
                _ = w[0];
              return _;
            });
          }, 'keys'),
          values: s(function () {
            return p.map(function (A) {
              var w = o(A, 2),
                _ = w[1];
              return _;
            });
          }, 'values'),
        };
      function R(x, A) {
        return (
          x.name === A.name && I(x.constraints, A.constraints) && $(x.attributes, A.attributes)
        );
      }
      s(R, 'ariaRoleRelationConceptEquals');
      function I(x, A) {
        if ((x === void 0 && A !== void 0) || (x !== void 0 && A === void 0)) return !1;
        if (x !== void 0 && A !== void 0) {
          if (x.length !== A.length) return !1;
          for (var w = 0; w < x.length; w++) if (x[w] !== A[w]) return !1;
        }
        return !0;
      }
      s(I, 'ariaRoleRelationConstraintsEquals');
      function $(x, A) {
        if ((x === void 0 && A !== void 0) || (x !== void 0 && A === void 0)) return !1;
        if (x !== void 0 && A !== void 0) {
          if (x.length !== A.length) return !1;
          for (var w = 0; w < x.length; w++) {
            if (
              x[w].name !== A[w].name ||
              x[w].value !== A[w].value ||
              (x[w].constraints === void 0 && A[w].constraints !== void 0) ||
              (x[w].constraints !== void 0 && A[w].constraints === void 0)
            )
              return !1;
            if (x[w].constraints !== void 0 && A[w].constraints !== void 0) {
              if (x[w].constraints.length !== A[w].constraints.length) return !1;
              for (var _ = 0; _ < x[w].constraints.length; _++)
                if (x[w].constraints[_] !== A[w].constraints[_]) return !1;
            }
          }
        }
        return !0;
      }
      (s($, 'ariaRoleRelationConceptAttributeEquals'),
        (e.default = (0, t.default)(S, S.entries())));
    },
  }),
  s1 = B({
    '../node_modules/aria-query/lib/roleElementMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = n(wi()),
        r = n(Lp());
      function n($) {
        return $ && $.__esModule ? $ : { default: $ };
      }
      s(n, '_interopRequireDefault');
      function o($, x) {
        return u($) || d($, x) || a($, x) || i();
      }
      s(o, '_slicedToArray');
      function i() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      s(i, '_nonIterableRest');
      function a($, x) {
        if ($) {
          if (typeof $ == 'string') return l($, x);
          var A = {}.toString.call($).slice(8, -1);
          return (
            A === 'Object' && $.constructor && (A = $.constructor.name),
            A === 'Map' || A === 'Set'
              ? Array.from($)
              : A === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(A)
                ? l($, x)
                : void 0
          );
        }
      }
      s(a, '_unsupportedIterableToArray');
      function l($, x) {
        (x == null || x > $.length) && (x = $.length);
        for (var A = 0, w = Array(x); A < x; A++) w[A] = $[A];
        return w;
      }
      s(l, '_arrayLikeToArray');
      function d($, x) {
        var A = $ == null ? null : (typeof Symbol < 'u' && $[Symbol.iterator]) || $['@@iterator'];
        if (A != null) {
          var w,
            _,
            j,
            N,
            V = [],
            H = !0,
            P = !1;
          try {
            if (((j = (A = A.call($)).next), x === 0)) {
              if (Object(A) !== A) return;
              H = !1;
            } else for (; !(H = (w = j.call(A)).done) && (V.push(w.value), V.length !== x); H = !0);
          } catch (D) {
            ((P = !0), (_ = D));
          } finally {
            try {
              if (!H && A.return != null && ((N = A.return()), Object(N) !== N)) return;
            } finally {
              if (P) throw _;
            }
          }
          return V;
        }
      }
      s(d, '_iterableToArrayLimit');
      function u($) {
        if (Array.isArray($)) return $;
      }
      s(u, '_arrayWithHoles');
      var p = [],
        f = r.default.keys();
      for (R = 0; R < f.length; R++)
        if (((m = f[R]), (h = r.default.get(m)), (g = []), h)) {
          for (v = [].concat(h.baseConcepts, h.relatedConcepts), S = 0; S < v.length; S++)
            ((E = v[S]), E.module === 'HTML' && ((b = E.concept), b != null && g.push(b)));
          g.length > 0 && p.push([m, g]);
        }
      var m,
        h,
        g,
        v,
        E,
        b,
        S,
        R,
        I = {
          entries: s(function () {
            return p;
          }, 'entries'),
          forEach: s(function (x) {
            for (
              var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                w = 0,
                _ = p;
              w < _.length;
              w++
            ) {
              var j = o(_[w], 2),
                N = j[0],
                V = j[1];
              x.call(A, V, N, p);
            }
          }, 'forEach'),
          get: s(function (x) {
            var A = p.filter(function (w) {
              return w[0] === x;
            })[0];
            return A && A[1];
          }, 'get'),
          has: s(function (x) {
            return !!I.get(x);
          }, 'has'),
          keys: s(function () {
            return p.map(function (x) {
              var A = o(x, 1),
                w = A[0];
              return w;
            });
          }, 'keys'),
          values: s(function () {
            return p.map(function (x) {
              var A = o(x, 2),
                w = A[1];
              return w;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(I, I.entries());
    },
  }),
  Fp = B({
    '../node_modules/aria-query/lib/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.roles = e.roleElements = e.elementRoles = e.dom = e.aria = void 0));
      var t = a(Eq()),
        r = a(wq()),
        n = a(Lp()),
        o = a(o1()),
        i = a(s1());
      function a(l) {
        return l && l.__esModule ? l : { default: l };
      }
      (s(a, '_interopRequireDefault'),
        (e.aria = t.default),
        (e.dom = r.default),
        (e.roles = n.default),
        (e.elementRoles = o.default),
        (e.roleElements = i.default));
    },
  }),
  Uv = B({
    '../node_modules/picocolors/picocolors.browser.js'(e, t) {
      var r = String,
        n = s(function () {
          return {
            isColorSupported: !1,
            reset: r,
            bold: r,
            dim: r,
            italic: r,
            underline: r,
            inverse: r,
            hidden: r,
            strikethrough: r,
            black: r,
            red: r,
            green: r,
            yellow: r,
            blue: r,
            magenta: r,
            cyan: r,
            white: r,
            gray: r,
            bgBlack: r,
            bgRed: r,
            bgGreen: r,
            bgYellow: r,
            bgBlue: r,
            bgMagenta: r,
            bgCyan: r,
            bgWhite: r,
            blackBright: r,
            redBright: r,
            greenBright: r,
            yellowBright: r,
            blueBright: r,
            magentaBright: r,
            cyanBright: r,
            whiteBright: r,
            bgBlackBright: r,
            bgRedBright: r,
            bgGreenBright: r,
            bgYellowBright: r,
            bgBlueBright: r,
            bgMagentaBright: r,
            bgCyanBright: r,
            bgWhiteBright: r,
          };
        }, 'create');
      ((t.exports = n()), (t.exports.createColors = n));
    },
  }),
  Vv = B({
    '../node_modules/css.escape/css.escape.js'(e, t) {
      (function (r, n) {
        typeof e == 'object'
          ? (t.exports = n(r))
          : typeof define == 'function' && define.amd
            ? define([], n.bind(r, r))
            : n(r);
      })(typeof global < 'u' ? global : e, function (r) {
        if (r.CSS && r.CSS.escape) return r.CSS.escape;
        var n = s(function (o) {
          if (arguments.length == 0) throw new TypeError('`CSS.escape` requires an argument.');
          for (var i = String(o), a = i.length, l = -1, d, u = '', p = i.charCodeAt(0); ++l < a; ) {
            if (((d = i.charCodeAt(l)), d == 0)) {
              u += '';
              continue;
            }
            if (
              (d >= 1 && d <= 31) ||
              d == 127 ||
              (l == 0 && d >= 48 && d <= 57) ||
              (l == 1 && d >= 48 && d <= 57 && p == 45)
            ) {
              u += '\\' + d.toString(16) + ' ';
              continue;
            }
            if (l == 0 && a == 1 && d == 45) {
              u += '\\' + i.charAt(l);
              continue;
            }
            if (
              d >= 128 ||
              d == 45 ||
              d == 95 ||
              (d >= 48 && d <= 57) ||
              (d >= 65 && d <= 90) ||
              (d >= 97 && d <= 122)
            ) {
              u += i.charAt(l);
              continue;
            }
            u += '\\' + i.charAt(l);
          }
          return u;
        }, 'cssEscape');
        return (r.CSS || (r.CSS = {}), (r.CSS.escape = n), n);
      });
    },
  }),
  Hv = B({
    '../node_modules/pretty-format/node_modules/ansi-styles/index.js'(e, t) {
      var r = 10,
        n = s(
          (a = 0) =>
            (l) =>
              `\x1B[${38 + a};5;${l}m`,
          'wrapAnsi256',
        ),
        o = s(
          (a = 0) =>
            (l, d, u) =>
              `\x1B[${38 + a};2;${l};${d};${u}m`,
          'wrapAnsi16m',
        );
      function i() {
        const a = new Map(),
          l = {
            modifier: {
              reset: [0, 0],
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              overline: [53, 55],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29],
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              blackBright: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39],
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49],
            },
          };
        ((l.color.gray = l.color.blackBright),
          (l.bgColor.bgGray = l.bgColor.bgBlackBright),
          (l.color.grey = l.color.blackBright),
          (l.bgColor.bgGrey = l.bgColor.bgBlackBright));
        for (const [d, u] of Object.entries(l)) {
          for (const [p, f] of Object.entries(u))
            ((l[p] = { open: `\x1B[${f[0]}m`, close: `\x1B[${f[1]}m` }),
              (u[p] = l[p]),
              a.set(f[0], f[1]));
          Object.defineProperty(l, d, { value: u, enumerable: !1 });
        }
        return (
          Object.defineProperty(l, 'codes', { value: a, enumerable: !1 }),
          (l.color.close = '\x1B[39m'),
          (l.bgColor.close = '\x1B[49m'),
          (l.color.ansi256 = n()),
          (l.color.ansi16m = o()),
          (l.bgColor.ansi256 = n(r)),
          (l.bgColor.ansi16m = o(r)),
          Object.defineProperties(l, {
            rgbToAnsi256: {
              value: s(
                (d, u, p) =>
                  d === u && u === p
                    ? d < 8
                      ? 16
                      : d > 248
                        ? 231
                        : Math.round(((d - 8) / 247) * 24) + 232
                    : 16 +
                      36 * Math.round((d / 255) * 5) +
                      6 * Math.round((u / 255) * 5) +
                      Math.round((p / 255) * 5),
                'value',
              ),
              enumerable: !1,
            },
            hexToRgb: {
              value: s((d) => {
                const u = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(d.toString(16));
                if (!u) return [0, 0, 0];
                let { colorString: p } = u.groups;
                p.length === 3 &&
                  (p = p
                    .split('')
                    .map((m) => m + m)
                    .join(''));
                const f = Number.parseInt(p, 16);
                return [(f >> 16) & 255, (f >> 8) & 255, f & 255];
              }, 'value'),
              enumerable: !1,
            },
            hexToAnsi256: {
              value: s((d) => l.rgbToAnsi256(...l.hexToRgb(d)), 'value'),
              enumerable: !1,
            },
          }),
          l
        );
      }
      (s(i, 'assembleStyles'), Object.defineProperty(t, 'exports', { enumerable: !0, get: i }));
    },
  }),
  Sl = B({
    '../node_modules/pretty-format/build/collections.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.printIteratorEntries = r),
        (e.printIteratorValues = n),
        (e.printListItems = o),
        (e.printObjectProperties = i));
      var t = s((a, l) => {
        const d = Object.keys(a).sort(l);
        return (
          Object.getOwnPropertySymbols &&
            Object.getOwnPropertySymbols(a).forEach((u) => {
              Object.getOwnPropertyDescriptor(a, u).enumerable && d.push(u);
            }),
          d
        );
      }, 'getKeysOfEnumerableProperties');
      function r(a, l, d, u, p, f, m = ': ') {
        let h = '',
          g = a.next();
        if (!g.done) {
          h += l.spacingOuter;
          const v = d + l.indent;
          for (; !g.done; ) {
            const E = f(g.value[0], l, v, u, p),
              b = f(g.value[1], l, v, u, p);
            ((h += v + E + m + b),
              (g = a.next()),
              g.done ? l.min || (h += ',') : (h += ',' + l.spacingInner));
          }
          h += l.spacingOuter + d;
        }
        return h;
      }
      s(r, 'printIteratorEntries');
      function n(a, l, d, u, p, f) {
        let m = '',
          h = a.next();
        if (!h.done) {
          m += l.spacingOuter;
          const g = d + l.indent;
          for (; !h.done; )
            ((m += g + f(h.value, l, g, u, p)),
              (h = a.next()),
              h.done ? l.min || (m += ',') : (m += ',' + l.spacingInner));
          m += l.spacingOuter + d;
        }
        return m;
      }
      s(n, 'printIteratorValues');
      function o(a, l, d, u, p, f) {
        let m = '';
        if (a.length) {
          m += l.spacingOuter;
          const h = d + l.indent;
          for (let g = 0; g < a.length; g++)
            ((m += h),
              g in a && (m += f(a[g], l, h, u, p)),
              g < a.length - 1 ? (m += ',' + l.spacingInner) : l.min || (m += ','));
          m += l.spacingOuter + d;
        }
        return m;
      }
      s(o, 'printListItems');
      function i(a, l, d, u, p, f) {
        let m = '';
        const h = t(a, l.compareKeys);
        if (h.length) {
          m += l.spacingOuter;
          const g = d + l.indent;
          for (let v = 0; v < h.length; v++) {
            const E = h[v],
              b = f(E, l, g, u, p),
              S = f(a[E], l, g, u, p);
            ((m += g + b + ': ' + S),
              v < h.length - 1 ? (m += ',' + l.spacingInner) : l.min || (m += ','));
          }
          m += l.spacingOuter + d;
        }
        return m;
      }
      s(i, 'printObjectProperties');
    },
  }),
  i1 = B({
    '../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Sl(),
        r = (function () {
          return typeof globalThis < 'u'
            ? globalThis
            : typeof r < 'u'
              ? r
              : typeof self < 'u'
                ? self
                : typeof window < 'u'
                  ? window
                  : Function('return this')();
        })(),
        n = r['jest-symbol-do-not-touch'] || r.Symbol,
        o = typeof n == 'function' && n.for ? n.for('jest.asymmetricMatcher') : 1267621,
        i = ' ',
        a = s((p, f, m, h, g, v) => {
          const E = p.toString();
          return E === 'ArrayContaining' || E === 'ArrayNotContaining'
            ? ++h > f.maxDepth
              ? '[' + E + ']'
              : E + i + '[' + (0, t.printListItems)(p.sample, f, m, h, g, v) + ']'
            : E === 'ObjectContaining' || E === 'ObjectNotContaining'
              ? ++h > f.maxDepth
                ? '[' + E + ']'
                : E + i + '{' + (0, t.printObjectProperties)(p.sample, f, m, h, g, v) + '}'
              : E === 'StringMatching' ||
                  E === 'StringNotMatching' ||
                  E === 'StringContaining' ||
                  E === 'StringNotContaining'
                ? E + i + v(p.sample, f, m, h, g)
                : p.toAsymmetricMatcher();
        }, 'serialize');
      e.serialize = a;
      var l = s((p) => p && p.$$typeof === o, 'test');
      e.test = l;
      var d = { serialize: a, test: l },
        u = d;
      e.default = u;
    },
  }),
  a1 = B({
    '../node_modules/pretty-format/node_modules/ansi-regex/index.js'(e, t) {
      t.exports = ({ onlyFirst: r = !1 } = {}) => {
        const n = [
          '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
          '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
        ].join('|');
        return new RegExp(n, r ? void 0 : 'g');
      };
    },
  }),
  l1 = B({
    '../node_modules/pretty-format/build/plugins/ConvertAnsi.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = n(a1()),
        r = n(Hv());
      function n(u) {
        return u && u.__esModule ? u : { default: u };
      }
      s(n, '_interopRequireDefault');
      var o = s(
          (u) =>
            u.replace((0, t.default)(), (p) => {
              switch (p) {
                case r.default.red.close:
                case r.default.green.close:
                case r.default.cyan.close:
                case r.default.gray.close:
                case r.default.white.close:
                case r.default.yellow.close:
                case r.default.bgRed.close:
                case r.default.bgGreen.close:
                case r.default.bgYellow.close:
                case r.default.inverse.close:
                case r.default.dim.close:
                case r.default.bold.close:
                case r.default.reset.open:
                case r.default.reset.close:
                  return '</>';
                case r.default.red.open:
                  return '<red>';
                case r.default.green.open:
                  return '<green>';
                case r.default.cyan.open:
                  return '<cyan>';
                case r.default.gray.open:
                  return '<gray>';
                case r.default.white.open:
                  return '<white>';
                case r.default.yellow.open:
                  return '<yellow>';
                case r.default.bgRed.open:
                  return '<bgRed>';
                case r.default.bgGreen.open:
                  return '<bgGreen>';
                case r.default.bgYellow.open:
                  return '<bgYellow>';
                case r.default.inverse.open:
                  return '<inverse>';
                case r.default.dim.open:
                  return '<dim>';
                case r.default.bold.open:
                  return '<bold>';
                default:
                  return '';
              }
            }),
          'toHumanReadableAnsi',
        ),
        i = s((u) => typeof u == 'string' && !!u.match((0, t.default)()), 'test');
      e.test = i;
      var a = s((u, p, f, m, h, g) => g(o(u), p, f, m, h), 'serialize');
      e.serialize = a;
      var l = { serialize: a, test: i },
        d = l;
      e.default = d;
    },
  }),
  c1 = B({
    '../node_modules/pretty-format/build/plugins/DOMCollection.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Sl(),
        r = ' ',
        n = ['DOMStringMap', 'NamedNodeMap'],
        o = /^(HTML\w*Collection|NodeList)$/,
        i = s((f) => n.indexOf(f) !== -1 || o.test(f), 'testName'),
        a = s((f) => f && f.constructor && !!f.constructor.name && i(f.constructor.name), 'test');
      e.test = a;
      var l = s((f) => f.constructor.name === 'NamedNodeMap', 'isNamedNodeMap'),
        d = s((f, m, h, g, v, E) => {
          const b = f.constructor.name;
          return ++g > m.maxDepth
            ? '[' + b + ']'
            : (m.min ? '' : b + r) +
                (n.indexOf(b) !== -1
                  ? '{' +
                    (0, t.printObjectProperties)(
                      l(f)
                        ? Array.from(f).reduce((S, R) => ((S[R.name] = R.value), S), {})
                        : { ...f },
                      m,
                      h,
                      g,
                      v,
                      E,
                    ) +
                    '}'
                  : '[' + (0, t.printListItems)(Array.from(f), m, h, g, v, E) + ']');
        }, 'serialize');
      e.serialize = d;
      var u = { serialize: d, test: a },
        p = u;
      e.default = p;
    },
  }),
  u1 = B({
    '../node_modules/pretty-format/build/plugins/lib/escapeHTML.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = t));
      function t(r) {
        return r.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      s(t, 'escapeHTML');
    },
  }),
  Bp = B({
    '../node_modules/pretty-format/build/plugins/lib/markup.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.printText =
          e.printProps =
          e.printElementAsLeaf =
          e.printElement =
          e.printComment =
          e.printChildren =
            void 0));
      var t = r(u1());
      function r(u) {
        return u && u.__esModule ? u : { default: u };
      }
      s(r, '_interopRequireDefault');
      var n = s((u, p, f, m, h, g, v) => {
        const E = m + f.indent,
          b = f.colors;
        return u
          .map((S) => {
            const R = p[S];
            let I = v(R, f, E, h, g);
            return (
              typeof R != 'string' &&
                (I.indexOf(`
`) !== -1 && (I = f.spacingOuter + E + I + f.spacingOuter + m),
                (I = '{' + I + '}')),
              f.spacingInner +
                m +
                b.prop.open +
                S +
                b.prop.close +
                '=' +
                b.value.open +
                I +
                b.value.close
            );
          })
          .join('');
      }, 'printProps');
      e.printProps = n;
      var o = s(
        (u, p, f, m, h, g) =>
          u
            .map((v) => p.spacingOuter + f + (typeof v == 'string' ? i(v, p) : g(v, p, f, m, h)))
            .join(''),
        'printChildren',
      );
      e.printChildren = o;
      var i = s((u, p) => {
        const f = p.colors.content;
        return f.open + (0, t.default)(u) + f.close;
      }, 'printText');
      e.printText = i;
      var a = s((u, p) => {
        const f = p.colors.comment;
        return f.open + '<!--' + (0, t.default)(u) + '-->' + f.close;
      }, 'printComment');
      e.printComment = a;
      var l = s((u, p, f, m, h) => {
        const g = m.colors.tag;
        return (
          g.open +
          '<' +
          u +
          (p && g.close + p + m.spacingOuter + h + g.open) +
          (f
            ? '>' + g.close + f + m.spacingOuter + h + g.open + '</' + u
            : (p && !m.min ? '' : ' ') + '/') +
          '>' +
          g.close
        );
      }, 'printElement');
      e.printElement = l;
      var d = s((u, p) => {
        const f = p.colors.tag;
        return f.open + '<' + u + f.close + ' ' + f.open + ' />' + f.close;
      }, 'printElementAsLeaf');
      e.printElementAsLeaf = d;
    },
  }),
  d1 = B({
    '../node_modules/pretty-format/build/plugins/DOMElement.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Bp(),
        r = 1,
        n = 3,
        o = 8,
        i = 11,
        a = /^((HTML|SVG)\w*)?Element$/,
        l = s((E) => {
          try {
            return typeof E.hasAttribute == 'function' && E.hasAttribute('is');
          } catch {
            return !1;
          }
        }, 'testHasAttribute'),
        d = s((E) => {
          const b = E.constructor.name,
            { nodeType: S, tagName: R } = E,
            I = (typeof R == 'string' && R.includes('-')) || l(E);
          return (
            (S === r && (a.test(b) || I)) ||
            (S === n && b === 'Text') ||
            (S === o && b === 'Comment') ||
            (S === i && b === 'DocumentFragment')
          );
        }, 'testNode'),
        u = s((E) => {
          var b;
          return (
            (E == null || (b = E.constructor) === null || b === void 0 ? void 0 : b.name) && d(E)
          );
        }, 'test');
      e.test = u;
      function p(E) {
        return E.nodeType === n;
      }
      s(p, 'nodeIsText');
      function f(E) {
        return E.nodeType === o;
      }
      s(f, 'nodeIsComment');
      function m(E) {
        return E.nodeType === i;
      }
      s(m, 'nodeIsFragment');
      var h = s((E, b, S, R, I, $) => {
        if (p(E)) return (0, t.printText)(E.data, b);
        if (f(E)) return (0, t.printComment)(E.data, b);
        const x = m(E) ? 'DocumentFragment' : E.tagName.toLowerCase();
        return ++R > b.maxDepth
          ? (0, t.printElementAsLeaf)(x, b)
          : (0, t.printElement)(
              x,
              (0, t.printProps)(
                m(E)
                  ? []
                  : Array.from(E.attributes)
                      .map((A) => A.name)
                      .sort(),
                m(E)
                  ? {}
                  : Array.from(E.attributes).reduce((A, w) => ((A[w.name] = w.value), A), {}),
                b,
                S + b.indent,
                R,
                I,
                $,
              ),
              (0, t.printChildren)(
                Array.prototype.slice.call(E.childNodes || E.children),
                b,
                S + b.indent,
                R,
                I,
                $,
              ),
              b,
              S,
            );
      }, 'serialize');
      e.serialize = h;
      var g = { serialize: h, test: u },
        v = g;
      e.default = v;
    },
  }),
  p1 = B({
    '../node_modules/pretty-format/build/plugins/Immutable.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Sl(),
        r = '@@__IMMUTABLE_ITERABLE__@@',
        n = '@@__IMMUTABLE_LIST__@@',
        o = '@@__IMMUTABLE_KEYED__@@',
        i = '@@__IMMUTABLE_MAP__@@',
        a = '@@__IMMUTABLE_ORDERED__@@',
        l = '@@__IMMUTABLE_RECORD__@@',
        d = '@@__IMMUTABLE_SEQ__@@',
        u = '@@__IMMUTABLE_SET__@@',
        p = '@@__IMMUTABLE_STACK__@@',
        f = s((w) => 'Immutable.' + w, 'getImmutableName'),
        m = s((w) => '[' + w + ']', 'printAsLeaf'),
        h = ' ',
        g = '',
        v = s(
          (w, _, j, N, V, H, P) =>
            ++N > _.maxDepth
              ? m(f(P))
              : f(P) + h + '{' + (0, t.printIteratorEntries)(w.entries(), _, j, N, V, H) + '}',
          'printImmutableEntries',
        );
      function E(w) {
        let _ = 0;
        return {
          next() {
            if (_ < w._keys.length) {
              const j = w._keys[_++];
              return { done: !1, value: [j, w.get(j)] };
            }
            return { done: !0, value: void 0 };
          },
        };
      }
      s(E, 'getRecordEntries');
      var b = s((w, _, j, N, V, H) => {
          const P = f(w._name || 'Record');
          return ++N > _.maxDepth
            ? m(P)
            : P + h + '{' + (0, t.printIteratorEntries)(E(w), _, j, N, V, H) + '}';
        }, 'printImmutableRecord'),
        S = s((w, _, j, N, V, H) => {
          const P = f('Seq');
          return ++N > _.maxDepth
            ? m(P)
            : w[o]
              ? P +
                h +
                '{' +
                (w._iter || w._object
                  ? (0, t.printIteratorEntries)(w.entries(), _, j, N, V, H)
                  : g) +
                '}'
              : P +
                h +
                '[' +
                (w._iter || w._array || w._collection || w._iterable
                  ? (0, t.printIteratorValues)(w.values(), _, j, N, V, H)
                  : g) +
                ']';
        }, 'printImmutableSeq'),
        R = s(
          (w, _, j, N, V, H, P) =>
            ++N > _.maxDepth
              ? m(f(P))
              : f(P) + h + '[' + (0, t.printIteratorValues)(w.values(), _, j, N, V, H) + ']',
          'printImmutableValues',
        ),
        I = s(
          (w, _, j, N, V, H) =>
            w[i]
              ? v(w, _, j, N, V, H, w[a] ? 'OrderedMap' : 'Map')
              : w[n]
                ? R(w, _, j, N, V, H, 'List')
                : w[u]
                  ? R(w, _, j, N, V, H, w[a] ? 'OrderedSet' : 'Set')
                  : w[p]
                    ? R(w, _, j, N, V, H, 'Stack')
                    : w[d]
                      ? S(w, _, j, N, V, H)
                      : b(w, _, j, N, V, H),
          'serialize',
        );
      e.serialize = I;
      var $ = s((w) => w && (w[r] === !0 || w[l] === !0), 'test');
      e.test = $;
      var x = { serialize: I, test: $ },
        A = x;
      e.default = A;
    },
  }),
  f1 = B({
    '../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js'(e) {
      var t = 60103,
        r = 60106,
        n = 60107,
        o = 60108,
        i = 60114,
        a = 60109,
        l = 60110,
        d = 60112,
        u = 60113,
        p = 60120,
        f = 60115,
        m = 60116,
        h = 60121,
        g = 60122,
        v = 60117,
        E = 60129,
        b = 60131;
      typeof Symbol == 'function' &&
        Symbol.for &&
        ((S = Symbol.for),
        (t = S('react.element')),
        (r = S('react.portal')),
        (n = S('react.fragment')),
        (o = S('react.strict_mode')),
        (i = S('react.profiler')),
        (a = S('react.provider')),
        (l = S('react.context')),
        (d = S('react.forward_ref')),
        (u = S('react.suspense')),
        (p = S('react.suspense_list')),
        (f = S('react.memo')),
        (m = S('react.lazy')),
        (h = S('react.block')),
        (g = S('react.server.block')),
        (v = S('react.fundamental')),
        (E = S('react.debug_trace_mode')),
        (b = S('react.legacy_hidden')));
      var S;
      function R(P) {
        if (typeof P == 'object' && P !== null) {
          var D = P.$$typeof;
          switch (D) {
            case t:
              switch (((P = P.type), P)) {
                case n:
                case i:
                case o:
                case u:
                case p:
                  return P;
                default:
                  switch (((P = P && P.$$typeof), P)) {
                    case l:
                    case d:
                    case m:
                    case f:
                    case a:
                      return P;
                    default:
                      return D;
                  }
              }
            case r:
              return D;
          }
        }
      }
      s(R, 'y');
      var I = a,
        $ = t,
        x = d,
        A = n,
        w = m,
        _ = f,
        j = r,
        N = i,
        V = o,
        H = u;
      ((e.ContextConsumer = l),
        (e.ContextProvider = I),
        (e.Element = $),
        (e.ForwardRef = x),
        (e.Fragment = A),
        (e.Lazy = w),
        (e.Memo = _),
        (e.Portal = j),
        (e.Profiler = N),
        (e.StrictMode = V),
        (e.Suspense = H),
        (e.isAsyncMode = function () {
          return !1;
        }),
        (e.isConcurrentMode = function () {
          return !1;
        }),
        (e.isContextConsumer = function (P) {
          return R(P) === l;
        }),
        (e.isContextProvider = function (P) {
          return R(P) === a;
        }),
        (e.isElement = function (P) {
          return typeof P == 'object' && P !== null && P.$$typeof === t;
        }),
        (e.isForwardRef = function (P) {
          return R(P) === d;
        }),
        (e.isFragment = function (P) {
          return R(P) === n;
        }),
        (e.isLazy = function (P) {
          return R(P) === m;
        }),
        (e.isMemo = function (P) {
          return R(P) === f;
        }),
        (e.isPortal = function (P) {
          return R(P) === r;
        }),
        (e.isProfiler = function (P) {
          return R(P) === i;
        }),
        (e.isStrictMode = function (P) {
          return R(P) === o;
        }),
        (e.isSuspense = function (P) {
          return R(P) === u;
        }),
        (e.isValidElementType = function (P) {
          return (
            typeof P == 'string' ||
            typeof P == 'function' ||
            P === n ||
            P === i ||
            P === E ||
            P === o ||
            P === u ||
            P === p ||
            P === b ||
            (typeof P == 'object' &&
              P !== null &&
              (P.$$typeof === m ||
                P.$$typeof === f ||
                P.$$typeof === a ||
                P.$$typeof === l ||
                P.$$typeof === d ||
                P.$$typeof === v ||
                P.$$typeof === h ||
                P[0] === g))
          );
        }),
        (e.typeOf = R));
    },
  }),
  m1 = B({
    '../node_modules/pretty-format/node_modules/react-is/index.js'(e, t) {
      t.exports = f1();
    },
  }),
  y1 = B({
    '../node_modules/pretty-format/build/plugins/ReactElement.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = o(m1()),
        r = Bp();
      function n(m) {
        if (typeof WeakMap != 'function') return null;
        var h = new WeakMap(),
          g = new WeakMap();
        return (n = s(function (v) {
          return v ? g : h;
        }, '_getRequireWildcardCache'))(m);
      }
      s(n, '_getRequireWildcardCache');
      function o(m, h) {
        if (!h && m && m.__esModule) return m;
        if (m === null || (typeof m != 'object' && typeof m != 'function')) return { default: m };
        var g = n(h);
        if (g && g.has(m)) return g.get(m);
        var v = {},
          E = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var b in m)
          if (b !== 'default' && Object.prototype.hasOwnProperty.call(m, b)) {
            var S = E ? Object.getOwnPropertyDescriptor(m, b) : null;
            S && (S.get || S.set) ? Object.defineProperty(v, b, S) : (v[b] = m[b]);
          }
        return ((v.default = m), g && g.set(m, v), v);
      }
      s(o, '_interopRequireWildcard');
      var i = s(
          (m, h = []) => (
            Array.isArray(m)
              ? m.forEach((g) => {
                  i(g, h);
                })
              : m != null && m !== !1 && h.push(m),
            h
          ),
          'getChildren',
        ),
        a = s((m) => {
          const h = m.type;
          if (typeof h == 'string') return h;
          if (typeof h == 'function') return h.displayName || h.name || 'Unknown';
          if (t.isFragment(m)) return 'React.Fragment';
          if (t.isSuspense(m)) return 'React.Suspense';
          if (typeof h == 'object' && h !== null) {
            if (t.isContextProvider(m)) return 'Context.Provider';
            if (t.isContextConsumer(m)) return 'Context.Consumer';
            if (t.isForwardRef(m)) {
              if (h.displayName) return h.displayName;
              const g = h.render.displayName || h.render.name || '';
              return g !== '' ? 'ForwardRef(' + g + ')' : 'ForwardRef';
            }
            if (t.isMemo(m)) {
              const g = h.displayName || h.type.displayName || h.type.name || '';
              return g !== '' ? 'Memo(' + g + ')' : 'Memo';
            }
          }
          return 'UNDEFINED';
        }, 'getType'),
        l = s((m) => {
          const { props: h } = m;
          return Object.keys(h)
            .filter((g) => g !== 'children' && h[g] !== void 0)
            .sort();
        }, 'getPropKeys'),
        d = s(
          (m, h, g, v, E, b) =>
            ++v > h.maxDepth
              ? (0, r.printElementAsLeaf)(a(m), h)
              : (0, r.printElement)(
                  a(m),
                  (0, r.printProps)(l(m), m.props, h, g + h.indent, v, E, b),
                  (0, r.printChildren)(i(m.props.children), h, g + h.indent, v, E, b),
                  h,
                  g,
                ),
          'serialize',
        );
      e.serialize = d;
      var u = s((m) => m != null && t.isElement(m), 'test');
      e.test = u;
      var p = { serialize: d, test: u },
        f = p;
      e.default = f;
    },
  }),
  h1 = B({
    '../node_modules/pretty-format/build/plugins/ReactTestComponent.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Bp(),
        r = (function () {
          return typeof globalThis < 'u'
            ? globalThis
            : typeof r < 'u'
              ? r
              : typeof self < 'u'
                ? self
                : typeof window < 'u'
                  ? window
                  : Function('return this')();
        })(),
        n = r['jest-symbol-do-not-touch'] || r.Symbol,
        o = typeof n == 'function' && n.for ? n.for('react.test.json') : 245830487,
        i = s((p) => {
          const { props: f } = p;
          return f
            ? Object.keys(f)
                .filter((m) => f[m] !== void 0)
                .sort()
            : [];
        }, 'getPropKeys'),
        a = s(
          (p, f, m, h, g, v) =>
            ++h > f.maxDepth
              ? (0, t.printElementAsLeaf)(p.type, f)
              : (0, t.printElement)(
                  p.type,
                  p.props ? (0, t.printProps)(i(p), p.props, f, m + f.indent, h, g, v) : '',
                  p.children ? (0, t.printChildren)(p.children, f, m + f.indent, h, g, v) : '',
                  f,
                  m,
                ),
          'serialize',
        );
      e.serialize = a;
      var l = s((p) => p && p.$$typeof === o, 'test');
      e.test = l;
      var d = { serialize: a, test: l },
        u = d;
      e.default = u;
    },
  }),
  g1 = B({
    '../node_modules/pretty-format/build/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = e.DEFAULT_OPTIONS = void 0),
        (e.format = xe),
        (e.plugins = void 0));
      var t = p(Hv()),
        r = Sl(),
        n = p(i1()),
        o = p(l1()),
        i = p(c1()),
        a = p(d1()),
        l = p(p1()),
        d = p(y1()),
        u = p(h1());
      function p(J) {
        return J && J.__esModule ? J : { default: J };
      }
      s(p, '_interopRequireDefault');
      var f = Object.prototype.toString,
        m = Date.prototype.toISOString,
        h = Error.prototype.toString,
        g = RegExp.prototype.toString,
        v = s(
          (J) => (typeof J.constructor == 'function' && J.constructor.name) || 'Object',
          'getConstructorName',
        ),
        E = s((J) => typeof window < 'u' && J === window, 'isWindow'),
        b = /^Symbol\((.*)\)(.*)$/,
        S = /\n/gi,
        R = class extends Error {
          constructor(Q, re) {
            (super(Q), (this.stack = re), (this.name = this.constructor.name));
          }
        };
      s(R, 'PrettyFormatPluginError');
      var I = R;
      function $(J) {
        return (
          J === '[object Array]' ||
          J === '[object ArrayBuffer]' ||
          J === '[object DataView]' ||
          J === '[object Float32Array]' ||
          J === '[object Float64Array]' ||
          J === '[object Int8Array]' ||
          J === '[object Int16Array]' ||
          J === '[object Int32Array]' ||
          J === '[object Uint8Array]' ||
          J === '[object Uint8ClampedArray]' ||
          J === '[object Uint16Array]' ||
          J === '[object Uint32Array]'
        );
      }
      s($, 'isToStringedArrayType');
      function x(J) {
        return Object.is(J, -0) ? '-0' : String(J);
      }
      s(x, 'printNumber');
      function A(J) {
        return `${J}n`;
      }
      s(A, 'printBigInt');
      function w(J, Q) {
        return Q ? '[Function ' + (J.name || 'anonymous') + ']' : '[Function]';
      }
      s(w, 'printFunction');
      function _(J) {
        return String(J).replace(b, 'Symbol($1)');
      }
      s(_, 'printSymbol');
      function j(J) {
        return '[' + h.call(J) + ']';
      }
      s(j, 'printError');
      function N(J, Q, re, oe) {
        if (J === !0 || J === !1) return '' + J;
        if (J === void 0) return 'undefined';
        if (J === null) return 'null';
        const ne = typeof J;
        if (ne === 'number') return x(J);
        if (ne === 'bigint') return A(J);
        if (ne === 'string') return oe ? '"' + J.replace(/"|\\/g, '\\$&') + '"' : '"' + J + '"';
        if (ne === 'function') return w(J, Q);
        if (ne === 'symbol') return _(J);
        const de = f.call(J);
        return de === '[object WeakMap]'
          ? 'WeakMap {}'
          : de === '[object WeakSet]'
            ? 'WeakSet {}'
            : de === '[object Function]' || de === '[object GeneratorFunction]'
              ? w(J, Q)
              : de === '[object Symbol]'
                ? _(J)
                : de === '[object Date]'
                  ? isNaN(+J)
                    ? 'Date { NaN }'
                    : m.call(J)
                  : de === '[object Error]'
                    ? j(J)
                    : de === '[object RegExp]'
                      ? re
                        ? g.call(J).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&')
                        : g.call(J)
                      : J instanceof Error
                        ? j(J)
                        : null;
      }
      s(N, 'printBasicValue');
      function V(J, Q, re, oe, ne, de) {
        if (ne.indexOf(J) !== -1) return '[Circular]';
        ((ne = ne.slice()), ne.push(J));
        const ye = ++oe > Q.maxDepth,
          pe = Q.min;
        if (Q.callToJSON && !ye && J.toJSON && typeof J.toJSON == 'function' && !de)
          return F(J.toJSON(), Q, re, oe, ne, !0);
        const Fe = f.call(J);
        return Fe === '[object Arguments]'
          ? ye
            ? '[Arguments]'
            : (pe ? '' : 'Arguments ') + '[' + (0, r.printListItems)(J, Q, re, oe, ne, F) + ']'
          : $(Fe)
            ? ye
              ? '[' + J.constructor.name + ']'
              : (pe || (!Q.printBasicPrototype && J.constructor.name === 'Array')
                  ? ''
                  : J.constructor.name + ' ') +
                '[' +
                (0, r.printListItems)(J, Q, re, oe, ne, F) +
                ']'
            : Fe === '[object Map]'
              ? ye
                ? '[Map]'
                : 'Map {' + (0, r.printIteratorEntries)(J.entries(), Q, re, oe, ne, F, ' => ') + '}'
              : Fe === '[object Set]'
                ? ye
                  ? '[Set]'
                  : 'Set {' + (0, r.printIteratorValues)(J.values(), Q, re, oe, ne, F) + '}'
                : ye || E(J)
                  ? '[' + v(J) + ']'
                  : (pe || (!Q.printBasicPrototype && v(J) === 'Object') ? '' : v(J) + ' ') +
                    '{' +
                    (0, r.printObjectProperties)(J, Q, re, oe, ne, F) +
                    '}';
      }
      s(V, 'printComplexValue');
      function H(J) {
        return J.serialize != null;
      }
      s(H, 'isNewPlugin');
      function P(J, Q, re, oe, ne, de) {
        let ye;
        try {
          ye = H(J)
            ? J.serialize(Q, re, oe, ne, de, F)
            : J.print(
                Q,
                (pe) => F(pe, re, oe, ne, de),
                (pe) => {
                  const Fe = oe + re.indent;
                  return (
                    Fe +
                    pe.replace(
                      S,
                      `
` + Fe,
                    )
                  );
                },
                { edgeSpacing: re.spacingOuter, min: re.min, spacing: re.spacingInner },
                re.colors,
              );
        } catch (pe) {
          throw new I(pe.message, pe.stack);
        }
        if (typeof ye != 'string')
          throw new Error(
            `pretty-format: Plugin must return type "string" but instead returned "${typeof ye}".`,
          );
        return ye;
      }
      s(P, 'printPlugin');
      function D(J, Q) {
        for (let re = 0; re < J.length; re++)
          try {
            if (J[re].test(Q)) return J[re];
          } catch (oe) {
            throw new I(oe.message, oe.stack);
          }
        return null;
      }
      s(D, 'findPlugin');
      function F(J, Q, re, oe, ne, de) {
        const ye = D(Q.plugins, J);
        if (ye !== null) return P(ye, J, Q, re, oe, ne);
        const pe = N(J, Q.printFunctionName, Q.escapeRegex, Q.escapeString);
        return pe !== null ? pe : V(J, Q, re, oe, ne, de);
      }
      s(F, 'printer');
      var k = { comment: 'gray', content: 'reset', prop: 'yellow', tag: 'cyan', value: 'green' },
        K = Object.keys(k),
        X = {
          callToJSON: !0,
          compareKeys: void 0,
          escapeRegex: !1,
          escapeString: !0,
          highlight: !1,
          indent: 2,
          maxDepth: 1 / 0,
          min: !1,
          plugins: [],
          printBasicPrototype: !0,
          printFunctionName: !0,
          theme: k,
        };
      e.DEFAULT_OPTIONS = X;
      function se(J) {
        if (
          (Object.keys(J).forEach((Q) => {
            if (!X.hasOwnProperty(Q)) throw new Error(`pretty-format: Unknown option "${Q}".`);
          }),
          J.min && J.indent !== void 0 && J.indent !== 0)
        )
          throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
        if (J.theme !== void 0) {
          if (J.theme === null) throw new Error('pretty-format: Option "theme" must not be null.');
          if (typeof J.theme != 'object')
            throw new Error(
              `pretty-format: Option "theme" must be of type "object" but instead received "${typeof J.theme}".`,
            );
        }
      }
      s(se, 'validateOptions');
      var ie = s(
          (J) =>
            K.reduce((Q, re) => {
              const oe = J.theme && J.theme[re] !== void 0 ? J.theme[re] : k[re],
                ne = oe && t.default[oe];
              if (ne && typeof ne.close == 'string' && typeof ne.open == 'string') Q[re] = ne;
              else
                throw new Error(
                  `pretty-format: Option "theme" has a key "${re}" whose value "${oe}" is undefined in ansi-styles.`,
                );
              return Q;
            }, Object.create(null)),
          'getColorsHighlight',
        ),
        W = s(
          () => K.reduce((J, Q) => ((J[Q] = { close: '', open: '' }), J), Object.create(null)),
          'getColorsEmpty',
        ),
        ae = s(
          (J) => (J && J.printFunctionName !== void 0 ? J.printFunctionName : X.printFunctionName),
          'getPrintFunctionName',
        ),
        be = s(
          (J) => (J && J.escapeRegex !== void 0 ? J.escapeRegex : X.escapeRegex),
          'getEscapeRegex',
        ),
        ue = s(
          (J) => (J && J.escapeString !== void 0 ? J.escapeString : X.escapeString),
          'getEscapeString',
        ),
        ee = s((J) => {
          var Q;
          return {
            callToJSON: J && J.callToJSON !== void 0 ? J.callToJSON : X.callToJSON,
            colors: J && J.highlight ? ie(J) : W(),
            compareKeys: J && typeof J.compareKeys == 'function' ? J.compareKeys : X.compareKeys,
            escapeRegex: be(J),
            escapeString: ue(J),
            indent: J && J.min ? '' : Pe(J && J.indent !== void 0 ? J.indent : X.indent),
            maxDepth: J && J.maxDepth !== void 0 ? J.maxDepth : X.maxDepth,
            min: J && J.min !== void 0 ? J.min : X.min,
            plugins: J && J.plugins !== void 0 ? J.plugins : X.plugins,
            printBasicPrototype: (Q = J?.printBasicPrototype) !== null && Q !== void 0 ? Q : !0,
            printFunctionName: ae(J),
            spacingInner:
              J && J.min
                ? ' '
                : `
`,
            spacingOuter:
              J && J.min
                ? ''
                : `
`,
          };
        }, 'getConfig');
      function Pe(J) {
        return new Array(J + 1).join(' ');
      }
      s(Pe, 'createIndent');
      function xe(J, Q) {
        if (Q && (se(Q), Q.plugins)) {
          const oe = D(Q.plugins, J);
          if (oe !== null) return P(oe, J, ee(Q), '', 0, []);
        }
        const re = N(J, ae(Q), be(Q), ue(Q));
        return re !== null ? re : V(J, ee(Q), '', 0, []);
      }
      s(xe, 'format');
      var He = {
        AsymmetricMatcher: n.default,
        ConvertAnsi: o.default,
        DOMCollection: i.default,
        DOMElement: a.default,
        Immutable: l.default,
        ReactElement: d.default,
        ReactTestComponent: u.default,
      };
      e.plugins = He;
      var Xe = xe;
      e.default = Xe;
    },
  }),
  b1 = B({
    '../node_modules/lz-string/libs/lz-string.js'(e, t) {
      var r = (function () {
        var n = String.fromCharCode,
          o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$',
          a = {};
        function l(u, p) {
          if (!a[u]) {
            a[u] = {};
            for (var f = 0; f < u.length; f++) a[u][u.charAt(f)] = f;
          }
          return a[u][p];
        }
        s(l, 'getBaseValue');
        var d = {
          compressToBase64: s(function (u) {
            if (u == null) return '';
            var p = d._compress(u, 6, function (f) {
              return o.charAt(f);
            });
            switch (p.length % 4) {
              default:
              case 0:
                return p;
              case 1:
                return p + '===';
              case 2:
                return p + '==';
              case 3:
                return p + '=';
            }
          }, 'compressToBase64'),
          decompressFromBase64: s(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 32, function (p) {
                    return l(o, u.charAt(p));
                  });
          }, 'decompressFromBase64'),
          compressToUTF16: s(function (u) {
            return u == null
              ? ''
              : d._compress(u, 15, function (p) {
                  return n(p + 32);
                }) + ' ';
          }, 'compressToUTF16'),
          decompressFromUTF16: s(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 16384, function (p) {
                    return u.charCodeAt(p) - 32;
                  });
          }, 'decompressFromUTF16'),
          compressToUint8Array: s(function (u) {
            for (
              var p = d.compress(u), f = new Uint8Array(p.length * 2), m = 0, h = p.length;
              m < h;
              m++
            ) {
              var g = p.charCodeAt(m);
              ((f[m * 2] = g >>> 8), (f[m * 2 + 1] = g % 256));
            }
            return f;
          }, 'compressToUint8Array'),
          decompressFromUint8Array: s(function (u) {
            if (u == null) return d.decompress(u);
            for (var p = new Array(u.length / 2), f = 0, m = p.length; f < m; f++)
              p[f] = u[f * 2] * 256 + u[f * 2 + 1];
            var h = [];
            return (
              p.forEach(function (g) {
                h.push(n(g));
              }),
              d.decompress(h.join(''))
            );
          }, 'decompressFromUint8Array'),
          compressToEncodedURIComponent: s(function (u) {
            return u == null
              ? ''
              : d._compress(u, 6, function (p) {
                  return i.charAt(p);
                });
          }, 'compressToEncodedURIComponent'),
          decompressFromEncodedURIComponent: s(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : ((u = u.replace(/ /g, '+')),
                  d._decompress(u.length, 32, function (p) {
                    return l(i, u.charAt(p));
                  }));
          }, 'decompressFromEncodedURIComponent'),
          compress: s(function (u) {
            return d._compress(u, 16, function (p) {
              return n(p);
            });
          }, 'compress'),
          _compress: s(function (u, p, f) {
            if (u == null) return '';
            var m,
              h,
              g = {},
              v = {},
              E = '',
              b = '',
              S = '',
              R = 2,
              I = 3,
              $ = 2,
              x = [],
              A = 0,
              w = 0,
              _;
            for (_ = 0; _ < u.length; _ += 1)
              if (
                ((E = u.charAt(_)),
                Object.prototype.hasOwnProperty.call(g, E) || ((g[E] = I++), (v[E] = !0)),
                (b = S + E),
                Object.prototype.hasOwnProperty.call(g, b))
              )
                S = b;
              else {
                if (Object.prototype.hasOwnProperty.call(v, S)) {
                  if (S.charCodeAt(0) < 256) {
                    for (m = 0; m < $; m++)
                      ((A = A << 1), w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++);
                    for (h = S.charCodeAt(0), m = 0; m < 8; m++)
                      ((A = (A << 1) | (h & 1)),
                        w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                        (h = h >> 1));
                  } else {
                    for (h = 1, m = 0; m < $; m++)
                      ((A = (A << 1) | h),
                        w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                        (h = 0));
                    for (h = S.charCodeAt(0), m = 0; m < 16; m++)
                      ((A = (A << 1) | (h & 1)),
                        w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                        (h = h >> 1));
                  }
                  (R--, R == 0 && ((R = Math.pow(2, $)), $++), delete v[S]);
                } else
                  for (h = g[S], m = 0; m < $; m++)
                    ((A = (A << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                      (h = h >> 1));
                (R--, R == 0 && ((R = Math.pow(2, $)), $++), (g[b] = I++), (S = String(E)));
              }
            if (S !== '') {
              if (Object.prototype.hasOwnProperty.call(v, S)) {
                if (S.charCodeAt(0) < 256) {
                  for (m = 0; m < $; m++)
                    ((A = A << 1), w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++);
                  for (h = S.charCodeAt(0), m = 0; m < 8; m++)
                    ((A = (A << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                      (h = h >> 1));
                } else {
                  for (h = 1, m = 0; m < $; m++)
                    ((A = (A << 1) | h),
                      w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                      (h = 0));
                  for (h = S.charCodeAt(0), m = 0; m < 16; m++)
                    ((A = (A << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                      (h = h >> 1));
                }
                (R--, R == 0 && ((R = Math.pow(2, $)), $++), delete v[S]);
              } else
                for (h = g[S], m = 0; m < $; m++)
                  ((A = (A << 1) | (h & 1)),
                    w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                    (h = h >> 1));
              (R--, R == 0 && ((R = Math.pow(2, $)), $++));
            }
            for (h = 2, m = 0; m < $; m++)
              ((A = (A << 1) | (h & 1)),
                w == p - 1 ? ((w = 0), x.push(f(A)), (A = 0)) : w++,
                (h = h >> 1));
            for (;;)
              if (((A = A << 1), w == p - 1)) {
                x.push(f(A));
                break;
              } else w++;
            return x.join('');
          }, '_compress'),
          decompress: s(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 32768, function (p) {
                    return u.charCodeAt(p);
                  });
          }, 'decompress'),
          _decompress: s(function (u, p, f) {
            var m = [],
              h = 4,
              g = 4,
              v = 3,
              E = '',
              b = [],
              S,
              R,
              I,
              $,
              x,
              A,
              w,
              _ = { val: f(0), position: p, index: 1 };
            for (S = 0; S < 3; S += 1) m[S] = S;
            for (I = 0, x = Math.pow(2, 2), A = 1; A != x; )
              (($ = _.val & _.position),
                (_.position >>= 1),
                _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                (I |= ($ > 0 ? 1 : 0) * A),
                (A <<= 1));
            switch (I) {
              case 0:
                for (I = 0, x = Math.pow(2, 8), A = 1; A != x; )
                  (($ = _.val & _.position),
                    (_.position >>= 1),
                    _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                    (I |= ($ > 0 ? 1 : 0) * A),
                    (A <<= 1));
                w = n(I);
                break;
              case 1:
                for (I = 0, x = Math.pow(2, 16), A = 1; A != x; )
                  (($ = _.val & _.position),
                    (_.position >>= 1),
                    _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                    (I |= ($ > 0 ? 1 : 0) * A),
                    (A <<= 1));
                w = n(I);
                break;
              case 2:
                return '';
            }
            for (m[3] = w, R = w, b.push(w); ; ) {
              if (_.index > u) return '';
              for (I = 0, x = Math.pow(2, v), A = 1; A != x; )
                (($ = _.val & _.position),
                  (_.position >>= 1),
                  _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                  (I |= ($ > 0 ? 1 : 0) * A),
                  (A <<= 1));
              switch ((w = I)) {
                case 0:
                  for (I = 0, x = Math.pow(2, 8), A = 1; A != x; )
                    (($ = _.val & _.position),
                      (_.position >>= 1),
                      _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                      (I |= ($ > 0 ? 1 : 0) * A),
                      (A <<= 1));
                  ((m[g++] = n(I)), (w = g - 1), h--);
                  break;
                case 1:
                  for (I = 0, x = Math.pow(2, 16), A = 1; A != x; )
                    (($ = _.val & _.position),
                      (_.position >>= 1),
                      _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                      (I |= ($ > 0 ? 1 : 0) * A),
                      (A <<= 1));
                  ((m[g++] = n(I)), (w = g - 1), h--);
                  break;
                case 2:
                  return b.join('');
              }
              if ((h == 0 && ((h = Math.pow(2, v)), v++), m[w])) E = m[w];
              else if (w === g) E = R + R.charAt(0);
              else return null;
              (b.push(E),
                (m[g++] = R + E.charAt(0)),
                h--,
                (R = E),
                h == 0 && ((h = Math.pow(2, v)), v++));
            }
          }, '_decompress'),
        };
        return d;
      })();
      typeof define == 'function' && define.amd
        ? define(function () {
            return r;
          })
        : typeof t < 'u' && t != null
          ? (t.exports = r)
          : typeof angular < 'u' &&
            angular != null &&
            angular.module('LZString', []).factory('LZString', function () {
              return r;
            });
    },
  }),
  zv = B({
    '../node_modules/memoizerific/memoizerific.js'(e, t) {
      (function (r) {
        if (typeof e == 'object' && typeof t < 'u') t.exports = r();
        else if (typeof define == 'function' && define.amd) define([], r);
        else {
          var n;
          (typeof window < 'u'
            ? (n = window)
            : typeof global < 'u'
              ? (n = global)
              : typeof self < 'u'
                ? (n = self)
                : (n = this),
            (n.memoizerific = r()));
        }
      })(function () {
        return s(function r(n, o, i) {
          function a(u, p) {
            if (!o[u]) {
              if (!n[u]) {
                var f = typeof Hi == 'function' && Hi;
                if (!p && f) return f(u, !0);
                if (l) return l(u, !0);
                var m = new Error("Cannot find module '" + u + "'");
                throw ((m.code = 'MODULE_NOT_FOUND'), m);
              }
              var h = (o[u] = { exports: {} });
              n[u][0].call(
                h.exports,
                function (g) {
                  var v = n[u][1][g];
                  return a(v || g);
                },
                h,
                h.exports,
                r,
                n,
                o,
                i,
              );
            }
            return o[u].exports;
          }
          s(a, 's');
          for (var l = typeof Hi == 'function' && Hi, d = 0; d < i.length; d++) a(i[d]);
          return a;
        }, 'e')(
          {
            1: [
              function (r, n, o) {
                n.exports = function (i) {
                  if (typeof Map != 'function' || i) {
                    var a = r('./similar');
                    return new a();
                  } else return new Map();
                };
              },
              { './similar': 2 },
            ],
            2: [
              function (r, n, o) {
                function i() {
                  return ((this.list = []), (this.lastItem = void 0), (this.size = 0), this);
                }
                (s(i, 'Similar'),
                  (i.prototype.get = function (a) {
                    var l;
                    if (this.lastItem && this.isEqual(this.lastItem.key, a))
                      return this.lastItem.val;
                    if (((l = this.indexOf(a)), l >= 0))
                      return ((this.lastItem = this.list[l]), this.list[l].val);
                  }),
                  (i.prototype.set = function (a, l) {
                    var d;
                    return this.lastItem && this.isEqual(this.lastItem.key, a)
                      ? ((this.lastItem.val = l), this)
                      : ((d = this.indexOf(a)),
                        d >= 0
                          ? ((this.lastItem = this.list[d]), (this.list[d].val = l), this)
                          : ((this.lastItem = { key: a, val: l }),
                            this.list.push(this.lastItem),
                            this.size++,
                            this));
                  }),
                  (i.prototype.delete = function (a) {
                    var l;
                    if (
                      (this.lastItem &&
                        this.isEqual(this.lastItem.key, a) &&
                        (this.lastItem = void 0),
                      (l = this.indexOf(a)),
                      l >= 0)
                    )
                      return (this.size--, this.list.splice(l, 1)[0]);
                  }),
                  (i.prototype.has = function (a) {
                    var l;
                    return this.lastItem && this.isEqual(this.lastItem.key, a)
                      ? !0
                      : ((l = this.indexOf(a)), l >= 0 ? ((this.lastItem = this.list[l]), !0) : !1);
                  }),
                  (i.prototype.forEach = function (a, l) {
                    var d;
                    for (d = 0; d < this.size; d++)
                      a.call(l || this, this.list[d].val, this.list[d].key, this);
                  }),
                  (i.prototype.indexOf = function (a) {
                    var l;
                    for (l = 0; l < this.size; l++) if (this.isEqual(this.list[l].key, a)) return l;
                    return -1;
                  }),
                  (i.prototype.isEqual = function (a, l) {
                    return a === l || (a !== a && l !== l);
                  }),
                  (n.exports = i));
              },
              {},
            ],
            3: [
              function (r, n, o) {
                var i = r('map-or-similar');
                n.exports = function (u) {
                  var p = new i(!1),
                    f = [];
                  return function (m) {
                    var h = s(function () {
                      var g = p,
                        v,
                        E,
                        b = arguments.length - 1,
                        S = Array(b + 1),
                        R = !0,
                        I;
                      if ((h.numArgs || h.numArgs === 0) && h.numArgs !== b + 1)
                        throw new Error(
                          'Memoizerific functions should always be called with the same number of arguments',
                        );
                      for (I = 0; I < b; I++) {
                        if (((S[I] = { cacheItem: g, arg: arguments[I] }), g.has(arguments[I]))) {
                          g = g.get(arguments[I]);
                          continue;
                        }
                        ((R = !1), (v = new i(!1)), g.set(arguments[I], v), (g = v));
                      }
                      return (
                        R && (g.has(arguments[b]) ? (E = g.get(arguments[b])) : (R = !1)),
                        R || ((E = m.apply(null, arguments)), g.set(arguments[b], E)),
                        u > 0 &&
                          ((S[b] = { cacheItem: g, arg: arguments[b] }),
                          R ? a(f, S) : f.push(S),
                          f.length > u && l(f.shift())),
                        (h.wasMemoized = R),
                        (h.numArgs = b + 1),
                        E
                      );
                    }, 'memoizerific');
                    return ((h.limit = u), (h.wasMemoized = !1), (h.cache = p), (h.lru = f), h);
                  };
                };
                function a(u, p) {
                  var f = u.length,
                    m = p.length,
                    h,
                    g,
                    v;
                  for (g = 0; g < f; g++) {
                    for (h = !0, v = 0; v < m; v++)
                      if (!d(u[g][v].arg, p[v].arg)) {
                        h = !1;
                        break;
                      }
                    if (h) break;
                  }
                  u.push(u.splice(g, 1)[0]);
                }
                s(a, 'moveToMostRecentLru');
                function l(u) {
                  var p = u.length,
                    f = u[p - 1],
                    m,
                    h;
                  for (
                    f.cacheItem.delete(f.arg), h = p - 2;
                    h >= 0 && ((f = u[h]), (m = f.cacheItem.get(f.arg)), !m || !m.size);
                    h--
                  )
                    f.cacheItem.delete(f.arg);
                }
                s(l, 'removeCachedResult');
                function d(u, p) {
                  return u === p || (u !== u && p !== p);
                }
                s(d, 'isEqual');
              },
              { 'map-or-similar': 1 },
            ],
          },
          {},
          [3],
        )(3);
      });
    },
  }),
  Gv = B({
    '../node_modules/picoquery/lib/string-util.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.encodeString = n));
      var t = Array.from(
          { length: 256 },
          (o, i) => '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase(),
        ),
        r = new Int8Array([
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
          0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 0, 0, 0, 1, 0,
        ]);
      function n(o) {
        const i = o.length;
        if (i === 0) return '';
        let a = '',
          l = 0,
          d = 0;
        e: for (; d < i; d++) {
          let u = o.charCodeAt(d);
          for (; u < 128; ) {
            if (
              (r[u] !== 1 && (l < d && (a += o.slice(l, d)), (l = d + 1), (a += t[u])), ++d === i)
            )
              break e;
            u = o.charCodeAt(d);
          }
          if ((l < d && (a += o.slice(l, d)), u < 2048)) {
            ((l = d + 1), (a += t[192 | (u >> 6)] + t[128 | (u & 63)]));
            continue;
          }
          if (u < 55296 || u >= 57344) {
            ((l = d + 1), (a += t[224 | (u >> 12)] + t[128 | ((u >> 6) & 63)] + t[128 | (u & 63)]));
            continue;
          }
          if ((++d, d >= i)) throw new Error('URI malformed');
          const p = o.charCodeAt(d) & 1023;
          ((l = d + 1),
            (u = 65536 + (((u & 1023) << 10) | p)),
            (a +=
              t[240 | (u >> 18)] +
              t[128 | ((u >> 12) & 63)] +
              t[128 | ((u >> 6) & 63)] +
              t[128 | (u & 63)]));
        }
        return l === 0 ? o : l < i ? a + o.slice(l) : a;
      }
      s(n, 'encodeString');
    },
  }),
  Jp = B({
    '../node_modules/picoquery/lib/shared.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.defaultOptions = e.defaultShouldSerializeObject = e.defaultValueSerializer = void 0));
      var t = Gv(),
        r = s((i) => {
          switch (typeof i) {
            case 'string':
              return (0, t.encodeString)(i);
            case 'bigint':
            case 'boolean':
              return '' + i;
            case 'number':
              if (Number.isFinite(i)) return i < 1e21 ? '' + i : (0, t.encodeString)('' + i);
              break;
          }
          return i instanceof Date ? (0, t.encodeString)(i.toISOString()) : '';
        }, 'defaultValueSerializer');
      e.defaultValueSerializer = r;
      var n = s((i) => i instanceof Date, 'defaultShouldSerializeObject');
      e.defaultShouldSerializeObject = n;
      var o = s((i) => i, 'identityFunc');
      e.defaultOptions = {
        nesting: !0,
        nestingSyntax: 'dot',
        arrayRepeat: !1,
        arrayRepeatSyntax: 'repeat',
        delimiter: 38,
        valueDeserializer: o,
        valueSerializer: e.defaultValueSerializer,
        keyDeserializer: o,
        shouldSerializeObject: e.defaultShouldSerializeObject,
      };
    },
  }),
  Wv = B({
    '../node_modules/picoquery/lib/object-util.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.getDeepObject = o),
        (e.stringifyObject = p));
      var t = Jp(),
        r = Gv();
      function n(f) {
        return f === '__proto__' || f === 'constructor' || f === 'prototype';
      }
      s(n, 'isPrototypeKey');
      function o(f, m, h, g, v) {
        if (n(m)) return f;
        const E = f[m];
        return typeof E == 'object' && E !== null
          ? E
          : !g &&
              (v ||
                typeof h == 'number' ||
                (typeof h == 'string' && h * 0 === 0 && h.indexOf('.') === -1))
            ? (f[m] = [])
            : (f[m] = {});
      }
      s(o, 'getDeepObject');
      var i = 20,
        a = '[]',
        l = '[',
        d = ']',
        u = '.';
      function p(f, m, h = 0, g, v) {
        const {
            nestingSyntax: E = t.defaultOptions.nestingSyntax,
            arrayRepeat: b = t.defaultOptions.arrayRepeat,
            arrayRepeatSyntax: S = t.defaultOptions.arrayRepeatSyntax,
            nesting: R = t.defaultOptions.nesting,
            delimiter: I = t.defaultOptions.delimiter,
            valueSerializer: $ = t.defaultOptions.valueSerializer,
            shouldSerializeObject: x = t.defaultOptions.shouldSerializeObject,
          } = m,
          A = typeof I == 'number' ? String.fromCharCode(I) : I,
          w = v === !0 && b,
          _ = E === 'dot' || (E === 'js' && !v);
        if (h > i) return '';
        let j = '',
          N = !0,
          V = !1;
        for (const H in f) {
          const P = f[H];
          if (P === void 0) continue;
          let D;
          (g
            ? ((D = g),
              w
                ? S === 'bracket' && (D += a)
                : _
                  ? ((D += u), (D += H))
                  : ((D += l), (D += H), (D += d)))
            : (D = H),
            N || (j += A),
            typeof P == 'object' && P !== null && !x(P)
              ? ((V = P.pop !== void 0), (R || (b && V)) && (j += p(P, m, h + 1, D, V)))
              : ((j += (0, r.encodeString)(D)), (j += '='), (j += $(P, H))),
            N && (N = !1));
        }
        return j;
      }
      s(p, 'stringifyObject');
    },
  }),
  v1 = B({
    '../node_modules/picoquery/lib/decode-uri-component.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.decodeURIComponent = o));
      var t = 12,
        r = 0,
        n = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,
          10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,
          0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7,
        ];
      function o(l) {
        let d = l.indexOf('%');
        if (d === -1) return l;
        const u = l.length;
        let p = '',
          f = 0,
          m = 0,
          h = d,
          g = t;
        for (; d > -1 && d < u; ) {
          const v = a(l[d + 1], 4),
            E = a(l[d + 2], 0),
            b = v | E,
            S = n[b];
          if (((g = n[256 + g + S]), (m = (m << 6) | (b & n[364 + S])), g === t))
            ((p += l.slice(f, h)),
              (p +=
                m <= 65535
                  ? String.fromCharCode(m)
                  : String.fromCharCode(55232 + (m >> 10), 56320 + (m & 1023))),
              (m = 0),
              (f = d + 3),
              (d = h = l.indexOf('%', f)));
          else {
            if (g === r) return null;
            if (((d += 3), d < u && l.charCodeAt(d) === 37)) continue;
            return null;
          }
        }
        return p + l.slice(f);
      }
      s(o, 'decodeURIComponent');
      var i = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15,
      };
      function a(l, d) {
        const u = i[l];
        return u === void 0 ? 255 : u << d;
      }
      s(a, 'hexCodeToInt');
    },
  }),
  T1 = B({
    '../node_modules/picoquery/lib/parse.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.numberValueDeserializer = e.numberKeyDeserializer = void 0),
        (e.parse = u));
      var t = Wv(),
        r = Jp(),
        n = v1(),
        o = s((p) => {
          const f = Number(p);
          return Number.isNaN(f) ? p : f;
        }, 'numberKeyDeserializer');
      e.numberKeyDeserializer = o;
      var i = s((p) => {
        const f = Number(p);
        return Number.isNaN(f) ? p : f;
      }, 'numberValueDeserializer');
      e.numberValueDeserializer = i;
      var a = /\+/g,
        l = s(function () {}, 'Empty');
      l.prototype = Object.create(null);
      function d(p, f, m, h, g) {
        let v = p.substring(f, m);
        return (h && (v = v.replace(a, ' ')), g && (v = (0, n.decodeURIComponent)(v) || v), v);
      }
      s(d, 'computeKeySlice');
      function u(p, f) {
        const {
            valueDeserializer: m = r.defaultOptions.valueDeserializer,
            keyDeserializer: h = r.defaultOptions.keyDeserializer,
            arrayRepeatSyntax: g = r.defaultOptions.arrayRepeatSyntax,
            nesting: v = r.defaultOptions.nesting,
            arrayRepeat: E = r.defaultOptions.arrayRepeat,
            nestingSyntax: b = r.defaultOptions.nestingSyntax,
            delimiter: S = r.defaultOptions.delimiter,
          } = f ?? {},
          R = typeof S == 'string' ? S.charCodeAt(0) : S,
          I = b === 'js',
          $ = new l();
        if (typeof p != 'string') return $;
        const x = p.length;
        let A = '',
          w = -1,
          _ = -1,
          j = -1,
          N = $,
          V,
          H = '',
          P = '',
          D = !1,
          F = !1,
          k = !1,
          K = !1,
          X = !1,
          se = !1,
          ie = 0,
          W = -1,
          ae = -1,
          be = -1;
        for (let ue = 0; ue < x + 1; ue++) {
          if (((ie = ue !== x ? p.charCodeAt(ue) : R), ie === R)) {
            if (
              ((se = _ > w),
              se || (_ = ue),
              j !== _ - 1 &&
                ((P = d(p, j + 1, W > -1 ? W : _, k, D)),
                (H = h(P)),
                V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I && X, void 0))),
              se || H !== '')
            ) {
              se &&
                ((A = p.slice(_ + 1, ue)),
                K && (A = A.replace(a, ' ')),
                F && (A = (0, n.decodeURIComponent)(A) || A));
              const ee = m(A, H);
              if (E) {
                const Pe = N[H];
                Pe === void 0
                  ? W > -1
                    ? (N[H] = [ee])
                    : (N[H] = ee)
                  : Pe.pop
                    ? Pe.push(ee)
                    : (N[H] = [Pe, ee]);
              } else N[H] = ee;
            }
            ((A = ''),
              (w = ue),
              (_ = ue),
              (D = !1),
              (F = !1),
              (k = !1),
              (K = !1),
              (X = !1),
              (W = -1),
              (j = ue),
              (N = $),
              (V = void 0),
              (H = ''));
          } else
            ie === 93
              ? (E && g === 'bracket' && be === 91 && (W = ae),
                v &&
                  (b === 'index' || I) &&
                  _ <= w &&
                  (j !== ae &&
                    ((P = d(p, j + 1, ue, k, D)),
                    (H = h(P)),
                    V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, void 0, void 0)),
                    (V = H),
                    (k = !1),
                    (D = !1)),
                  (j = ue),
                  (X = !1)))
              : ie === 46
                ? v &&
                  (b === 'dot' || I) &&
                  _ <= w &&
                  (j !== ae &&
                    ((P = d(p, j + 1, ue, k, D)),
                    (H = h(P)),
                    V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I)),
                    (V = H),
                    (k = !1),
                    (D = !1)),
                  (X = !0),
                  (j = ue))
                : ie === 91
                  ? v &&
                    (b === 'index' || I) &&
                    _ <= w &&
                    (j !== ae &&
                      ((P = d(p, j + 1, ue, k, D)),
                      (H = h(P)),
                      I && V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I)),
                      (V = H),
                      (k = !1),
                      (D = !1),
                      (X = !1)),
                    (j = ue))
                  : ie === 61
                    ? _ <= w
                      ? (_ = ue)
                      : (F = !0)
                    : ie === 43
                      ? _ > w
                        ? (K = !0)
                        : (k = !0)
                      : ie === 37 && (_ > w ? (F = !0) : (D = !0));
          ((ae = ue), (be = ie));
        }
        return $;
      }
      s(u, 'parse');
    },
  }),
  E1 = B({
    '../node_modules/picoquery/lib/stringify.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.stringify = r));
      var t = Wv();
      function r(n, o) {
        if (n === null || typeof n != 'object') return '';
        const i = o ?? {};
        return (0, t.stringifyObject)(n, i);
      }
      s(r, 'stringify');
    },
  }),
  Up = B({
    '../node_modules/picoquery/lib/main.js'(e) {
      var t =
          (e && e.__createBinding) ||
          (Object.create
            ? function (i, a, l, d) {
                d === void 0 && (d = l);
                var u = Object.getOwnPropertyDescriptor(a, l);
                ((!u || ('get' in u ? !a.__esModule : u.writable || u.configurable)) &&
                  (u = {
                    enumerable: !0,
                    get: s(function () {
                      return a[l];
                    }, 'get'),
                  }),
                  Object.defineProperty(i, d, u));
              }
            : function (i, a, l, d) {
                (d === void 0 && (d = l), (i[d] = a[l]));
              }),
        r =
          (e && e.__exportStar) ||
          function (i, a) {
            for (var l in i)
              l !== 'default' && !Object.prototype.hasOwnProperty.call(a, l) && t(a, i, l);
          };
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.stringify = e.parse = void 0));
      var n = T1();
      Object.defineProperty(e, 'parse', {
        enumerable: !0,
        get: s(function () {
          return n.parse;
        }, 'get'),
      });
      var o = E1();
      (Object.defineProperty(e, 'stringify', {
        enumerable: !0,
        get: s(function () {
          return o.stringify;
        }, 'get'),
      }),
        r(Jp(), e));
    },
  }),
  Kv = B({
    '../node_modules/entities/lib/maps/entities.json'(e, t) {
      t.exports = {
        Aacute: '',
        aacute: '',
        Abreve: '',
        abreve: '',
        ac: '',
        acd: '',
        acE: '',
        Acirc: '',
        acirc: '',
        acute: '',
        Acy: '',
        acy: '',
        AElig: '',
        aelig: '',
        af: '',
        Afr: '',
        afr: '',
        Agrave: '',
        agrave: '',
        alefsym: '',
        aleph: '',
        Alpha: '',
        alpha: '',
        Amacr: '',
        amacr: '',
        amalg: '',
        amp: '&',
        AMP: '&',
        andand: '',
        And: '',
        and: '',
        andd: '',
        andslope: '',
        andv: '',
        ang: '',
        ange: '',
        angle: '',
        angmsdaa: '',
        angmsdab: '',
        angmsdac: '',
        angmsdad: '',
        angmsdae: '',
        angmsdaf: '',
        angmsdag: '',
        angmsdah: '',
        angmsd: '',
        angrt: '',
        angrtvb: '',
        angrtvbd: '',
        angsph: '',
        angst: '',
        angzarr: '',
        Aogon: '',
        aogon: '',
        Aopf: '',
        aopf: '',
        apacir: '',
        ap: '',
        apE: '',
        ape: '',
        apid: '',
        apos: "'",
        ApplyFunction: '',
        approx: '',
        approxeq: '',
        Aring: '',
        aring: '',
        Ascr: '',
        ascr: '',
        Assign: '',
        ast: '*',
        asymp: '',
        asympeq: '',
        Atilde: '',
        atilde: '',
        Auml: '',
        auml: '',
        awconint: '',
        awint: '',
        backcong: '',
        backepsilon: '',
        backprime: '',
        backsim: '',
        backsimeq: '',
        Backslash: '',
        Barv: '',
        barvee: '',
        barwed: '',
        Barwed: '',
        barwedge: '',
        bbrk: '',
        bbrktbrk: '',
        bcong: '',
        Bcy: '',
        bcy: '',
        bdquo: '',
        becaus: '',
        because: '',
        Because: '',
        bemptyv: '',
        bepsi: '',
        bernou: '',
        Bernoullis: '',
        Beta: '',
        beta: '',
        beth: '',
        between: '',
        Bfr: '',
        bfr: '',
        bigcap: '',
        bigcirc: '',
        bigcup: '',
        bigodot: '',
        bigoplus: '',
        bigotimes: '',
        bigsqcup: '',
        bigstar: '',
        bigtriangledown: '',
        bigtriangleup: '',
        biguplus: '',
        bigvee: '',
        bigwedge: '',
        bkarow: '',
        blacklozenge: '',
        blacksquare: '',
        blacktriangle: '',
        blacktriangledown: '',
        blacktriangleleft: '',
        blacktriangleright: '',
        blank: '',
        blk12: '',
        blk14: '',
        blk34: '',
        block: '',
        bne: '=',
        bnequiv: '',
        bNot: '',
        bnot: '',
        Bopf: '',
        bopf: '',
        bot: '',
        bottom: '',
        bowtie: '',
        boxbox: '',
        boxdl: '',
        boxdL: '',
        boxDl: '',
        boxDL: '',
        boxdr: '',
        boxdR: '',
        boxDr: '',
        boxDR: '',
        boxh: '',
        boxH: '',
        boxhd: '',
        boxHd: '',
        boxhD: '',
        boxHD: '',
        boxhu: '',
        boxHu: '',
        boxhU: '',
        boxHU: '',
        boxminus: '',
        boxplus: '',
        boxtimes: '',
        boxul: '',
        boxuL: '',
        boxUl: '',
        boxUL: '',
        boxur: '',
        boxuR: '',
        boxUr: '',
        boxUR: '',
        boxv: '',
        boxV: '',
        boxvh: '',
        boxvH: '',
        boxVh: '',
        boxVH: '',
        boxvl: '',
        boxvL: '',
        boxVl: '',
        boxVL: '',
        boxvr: '',
        boxvR: '',
        boxVr: '',
        boxVR: '',
        bprime: '',
        breve: '',
        Breve: '',
        brvbar: '',
        bscr: '',
        Bscr: '',
        bsemi: '',
        bsim: '',
        bsime: '',
        bsolb: '',
        bsol: '\\',
        bsolhsub: '',
        bull: '',
        bullet: '',
        bump: '',
        bumpE: '',
        bumpe: '',
        Bumpeq: '',
        bumpeq: '',
        Cacute: '',
        cacute: '',
        capand: '',
        capbrcup: '',
        capcap: '',
        cap: '',
        Cap: '',
        capcup: '',
        capdot: '',
        CapitalDifferentialD: '',
        caps: '',
        caret: '',
        caron: '',
        Cayleys: '',
        ccaps: '',
        Ccaron: '',
        ccaron: '',
        Ccedil: '',
        ccedil: '',
        Ccirc: '',
        ccirc: '',
        Cconint: '',
        ccups: '',
        ccupssm: '',
        Cdot: '',
        cdot: '',
        cedil: '',
        Cedilla: '',
        cemptyv: '',
        cent: '',
        centerdot: '',
        CenterDot: '',
        cfr: '',
        Cfr: '',
        CHcy: '',
        chcy: '',
        check: '',
        checkmark: '',
        Chi: '',
        chi: '',
        circ: '',
        circeq: '',
        circlearrowleft: '',
        circlearrowright: '',
        circledast: '',
        circledcirc: '',
        circleddash: '',
        CircleDot: '',
        circledR: '',
        circledS: '',
        CircleMinus: '',
        CirclePlus: '',
        CircleTimes: '',
        cir: '',
        cirE: '',
        cire: '',
        cirfnint: '',
        cirmid: '',
        cirscir: '',
        ClockwiseContourIntegral: '',
        CloseCurlyDoubleQuote: '',
        CloseCurlyQuote: '',
        clubs: '',
        clubsuit: '',
        colon: ':',
        Colon: '',
        Colone: '',
        colone: '',
        coloneq: '',
        comma: ',',
        commat: '@',
        comp: '',
        compfn: '',
        complement: '',
        complexes: '',
        cong: '',
        congdot: '',
        Congruent: '',
        conint: '',
        Conint: '',
        ContourIntegral: '',
        copf: '',
        Copf: '',
        coprod: '',
        Coproduct: '',
        copy: '',
        COPY: '',
        copysr: '',
        CounterClockwiseContourIntegral: '',
        crarr: '',
        cross: '',
        Cross: '',
        Cscr: '',
        cscr: '',
        csub: '',
        csube: '',
        csup: '',
        csupe: '',
        ctdot: '',
        cudarrl: '',
        cudarrr: '',
        cuepr: '',
        cuesc: '',
        cularr: '',
        cularrp: '',
        cupbrcap: '',
        cupcap: '',
        CupCap: '',
        cup: '',
        Cup: '',
        cupcup: '',
        cupdot: '',
        cupor: '',
        cups: '',
        curarr: '',
        curarrm: '',
        curlyeqprec: '',
        curlyeqsucc: '',
        curlyvee: '',
        curlywedge: '',
        curren: '',
        curvearrowleft: '',
        curvearrowright: '',
        cuvee: '',
        cuwed: '',
        cwconint: '',
        cwint: '',
        cylcty: '',
        dagger: '',
        Dagger: '',
        daleth: '',
        darr: '',
        Darr: '',
        dArr: '',
        dash: '',
        Dashv: '',
        dashv: '',
        dbkarow: '',
        dblac: '',
        Dcaron: '',
        dcaron: '',
        Dcy: '',
        dcy: '',
        ddagger: '',
        ddarr: '',
        DD: '',
        dd: '',
        DDotrahd: '',
        ddotseq: '',
        deg: '',
        Del: '',
        Delta: '',
        delta: '',
        demptyv: '',
        dfisht: '',
        Dfr: '',
        dfr: '',
        dHar: '',
        dharl: '',
        dharr: '',
        DiacriticalAcute: '',
        DiacriticalDot: '',
        DiacriticalDoubleAcute: '',
        DiacriticalGrave: '`',
        DiacriticalTilde: '',
        diam: '',
        diamond: '',
        Diamond: '',
        diamondsuit: '',
        diams: '',
        die: '',
        DifferentialD: '',
        digamma: '',
        disin: '',
        div: '',
        divide: '',
        divideontimes: '',
        divonx: '',
        DJcy: '',
        djcy: '',
        dlcorn: '',
        dlcrop: '',
        dollar: '$',
        Dopf: '',
        dopf: '',
        Dot: '',
        dot: '',
        DotDot: '',
        doteq: '',
        doteqdot: '',
        DotEqual: '',
        dotminus: '',
        dotplus: '',
        dotsquare: '',
        doublebarwedge: '',
        DoubleContourIntegral: '',
        DoubleDot: '',
        DoubleDownArrow: '',
        DoubleLeftArrow: '',
        DoubleLeftRightArrow: '',
        DoubleLeftTee: '',
        DoubleLongLeftArrow: '',
        DoubleLongLeftRightArrow: '',
        DoubleLongRightArrow: '',
        DoubleRightArrow: '',
        DoubleRightTee: '',
        DoubleUpArrow: '',
        DoubleUpDownArrow: '',
        DoubleVerticalBar: '',
        DownArrowBar: '',
        downarrow: '',
        DownArrow: '',
        Downarrow: '',
        DownArrowUpArrow: '',
        DownBreve: '',
        downdownarrows: '',
        downharpoonleft: '',
        downharpoonright: '',
        DownLeftRightVector: '',
        DownLeftTeeVector: '',
        DownLeftVectorBar: '',
        DownLeftVector: '',
        DownRightTeeVector: '',
        DownRightVectorBar: '',
        DownRightVector: '',
        DownTeeArrow: '',
        DownTee: '',
        drbkarow: '',
        drcorn: '',
        drcrop: '',
        Dscr: '',
        dscr: '',
        DScy: '',
        dscy: '',
        dsol: '',
        Dstrok: '',
        dstrok: '',
        dtdot: '',
        dtri: '',
        dtrif: '',
        duarr: '',
        duhar: '',
        dwangle: '',
        DZcy: '',
        dzcy: '',
        dzigrarr: '',
        Eacute: '',
        eacute: '',
        easter: '',
        Ecaron: '',
        ecaron: '',
        Ecirc: '',
        ecirc: '',
        ecir: '',
        ecolon: '',
        Ecy: '',
        ecy: '',
        eDDot: '',
        Edot: '',
        edot: '',
        eDot: '',
        ee: '',
        efDot: '',
        Efr: '',
        efr: '',
        eg: '',
        Egrave: '',
        egrave: '',
        egs: '',
        egsdot: '',
        el: '',
        Element: '',
        elinters: '',
        ell: '',
        els: '',
        elsdot: '',
        Emacr: '',
        emacr: '',
        empty: '',
        emptyset: '',
        EmptySmallSquare: '',
        emptyv: '',
        EmptyVerySmallSquare: '',
        emsp13: '',
        emsp14: '',
        emsp: '',
        ENG: '',
        eng: '',
        ensp: '',
        Eogon: '',
        eogon: '',
        Eopf: '',
        eopf: '',
        epar: '',
        eparsl: '',
        eplus: '',
        epsi: '',
        Epsilon: '',
        epsilon: '',
        epsiv: '',
        eqcirc: '',
        eqcolon: '',
        eqsim: '',
        eqslantgtr: '',
        eqslantless: '',
        Equal: '',
        equals: '=',
        EqualTilde: '',
        equest: '',
        Equilibrium: '',
        equiv: '',
        equivDD: '',
        eqvparsl: '',
        erarr: '',
        erDot: '',
        escr: '',
        Escr: '',
        esdot: '',
        Esim: '',
        esim: '',
        Eta: '',
        eta: '',
        ETH: '',
        eth: '',
        Euml: '',
        euml: '',
        euro: '',
        excl: '!',
        exist: '',
        Exists: '',
        expectation: '',
        exponentiale: '',
        ExponentialE: '',
        fallingdotseq: '',
        Fcy: '',
        fcy: '',
        female: '',
        ffilig: '',
        fflig: '',
        ffllig: '',
        Ffr: '',
        ffr: '',
        filig: '',
        FilledSmallSquare: '',
        FilledVerySmallSquare: '',
        fjlig: 'fj',
        flat: '',
        fllig: '',
        fltns: '',
        fnof: '',
        Fopf: '',
        fopf: '',
        forall: '',
        ForAll: '',
        fork: '',
        forkv: '',
        Fouriertrf: '',
        fpartint: '',
        frac12: '',
        frac13: '',
        frac14: '',
        frac15: '',
        frac16: '',
        frac18: '',
        frac23: '',
        frac25: '',
        frac34: '',
        frac35: '',
        frac38: '',
        frac45: '',
        frac56: '',
        frac58: '',
        frac78: '',
        frasl: '',
        frown: '',
        fscr: '',
        Fscr: '',
        gacute: '',
        Gamma: '',
        gamma: '',
        Gammad: '',
        gammad: '',
        gap: '',
        Gbreve: '',
        gbreve: '',
        Gcedil: '',
        Gcirc: '',
        gcirc: '',
        Gcy: '',
        gcy: '',
        Gdot: '',
        gdot: '',
        ge: '',
        gE: '',
        gEl: '',
        gel: '',
        geq: '',
        geqq: '',
        geqslant: '',
        gescc: '',
        ges: '',
        gesdot: '',
        gesdoto: '',
        gesdotol: '',
        gesl: '',
        gesles: '',
        Gfr: '',
        gfr: '',
        gg: '',
        Gg: '',
        ggg: '',
        gimel: '',
        GJcy: '',
        gjcy: '',
        gla: '',
        gl: '',
        glE: '',
        glj: '',
        gnap: '',
        gnapprox: '',
        gne: '',
        gnE: '',
        gneq: '',
        gneqq: '',
        gnsim: '',
        Gopf: '',
        gopf: '',
        grave: '`',
        GreaterEqual: '',
        GreaterEqualLess: '',
        GreaterFullEqual: '',
        GreaterGreater: '',
        GreaterLess: '',
        GreaterSlantEqual: '',
        GreaterTilde: '',
        Gscr: '',
        gscr: '',
        gsim: '',
        gsime: '',
        gsiml: '',
        gtcc: '',
        gtcir: '',
        gt: '>',
        GT: '>',
        Gt: '',
        gtdot: '',
        gtlPar: '',
        gtquest: '',
        gtrapprox: '',
        gtrarr: '',
        gtrdot: '',
        gtreqless: '',
        gtreqqless: '',
        gtrless: '',
        gtrsim: '',
        gvertneqq: '',
        gvnE: '',
        Hacek: '',
        hairsp: '',
        half: '',
        hamilt: '',
        HARDcy: '',
        hardcy: '',
        harrcir: '',
        harr: '',
        hArr: '',
        harrw: '',
        Hat: '^',
        hbar: '',
        Hcirc: '',
        hcirc: '',
        hearts: '',
        heartsuit: '',
        hellip: '',
        hercon: '',
        hfr: '',
        Hfr: '',
        HilbertSpace: '',
        hksearow: '',
        hkswarow: '',
        hoarr: '',
        homtht: '',
        hookleftarrow: '',
        hookrightarrow: '',
        hopf: '',
        Hopf: '',
        horbar: '',
        HorizontalLine: '',
        hscr: '',
        Hscr: '',
        hslash: '',
        Hstrok: '',
        hstrok: '',
        HumpDownHump: '',
        HumpEqual: '',
        hybull: '',
        hyphen: '',
        Iacute: '',
        iacute: '',
        ic: '',
        Icirc: '',
        icirc: '',
        Icy: '',
        icy: '',
        Idot: '',
        IEcy: '',
        iecy: '',
        iexcl: '',
        iff: '',
        ifr: '',
        Ifr: '',
        Igrave: '',
        igrave: '',
        ii: '',
        iiiint: '',
        iiint: '',
        iinfin: '',
        iiota: '',
        IJlig: '',
        ijlig: '',
        Imacr: '',
        imacr: '',
        image: '',
        ImaginaryI: '',
        imagline: '',
        imagpart: '',
        imath: '',
        Im: '',
        imof: '',
        imped: '',
        Implies: '',
        incare: '',
        in: '',
        infin: '',
        infintie: '',
        inodot: '',
        intcal: '',
        int: '',
        Int: '',
        integers: '',
        Integral: '',
        intercal: '',
        Intersection: '',
        intlarhk: '',
        intprod: '',
        InvisibleComma: '',
        InvisibleTimes: '',
        IOcy: '',
        iocy: '',
        Iogon: '',
        iogon: '',
        Iopf: '',
        iopf: '',
        Iota: '',
        iota: '',
        iprod: '',
        iquest: '',
        iscr: '',
        Iscr: '',
        isin: '',
        isindot: '',
        isinE: '',
        isins: '',
        isinsv: '',
        isinv: '',
        it: '',
        Itilde: '',
        itilde: '',
        Iukcy: '',
        iukcy: '',
        Iuml: '',
        iuml: '',
        Jcirc: '',
        jcirc: '',
        Jcy: '',
        jcy: '',
        Jfr: '',
        jfr: '',
        jmath: '',
        Jopf: '',
        jopf: '',
        Jscr: '',
        jscr: '',
        Jsercy: '',
        jsercy: '',
        Jukcy: '',
        jukcy: '',
        Kappa: '',
        kappa: '',
        kappav: '',
        Kcedil: '',
        kcedil: '',
        Kcy: '',
        kcy: '',
        Kfr: '',
        kfr: '',
        kgreen: '',
        KHcy: '',
        khcy: '',
        KJcy: '',
        kjcy: '',
        Kopf: '',
        kopf: '',
        Kscr: '',
        kscr: '',
        lAarr: '',
        Lacute: '',
        lacute: '',
        laemptyv: '',
        lagran: '',
        Lambda: '',
        lambda: '',
        lang: '',
        Lang: '',
        langd: '',
        langle: '',
        lap: '',
        Laplacetrf: '',
        laquo: '',
        larrb: '',
        larrbfs: '',
        larr: '',
        Larr: '',
        lArr: '',
        larrfs: '',
        larrhk: '',
        larrlp: '',
        larrpl: '',
        larrsim: '',
        larrtl: '',
        latail: '',
        lAtail: '',
        lat: '',
        late: '',
        lates: '',
        lbarr: '',
        lBarr: '',
        lbbrk: '',
        lbrace: '{',
        lbrack: '[',
        lbrke: '',
        lbrksld: '',
        lbrkslu: '',
        Lcaron: '',
        lcaron: '',
        Lcedil: '',
        lcedil: '',
        lceil: '',
        lcub: '{',
        Lcy: '',
        lcy: '',
        ldca: '',
        ldquo: '',
        ldquor: '',
        ldrdhar: '',
        ldrushar: '',
        ldsh: '',
        le: '',
        lE: '',
        LeftAngleBracket: '',
        LeftArrowBar: '',
        leftarrow: '',
        LeftArrow: '',
        Leftarrow: '',
        LeftArrowRightArrow: '',
        leftarrowtail: '',
        LeftCeiling: '',
        LeftDoubleBracket: '',
        LeftDownTeeVector: '',
        LeftDownVectorBar: '',
        LeftDownVector: '',
        LeftFloor: '',
        leftharpoondown: '',
        leftharpoonup: '',
        leftleftarrows: '',
        leftrightarrow: '',
        LeftRightArrow: '',
        Leftrightarrow: '',
        leftrightarrows: '',
        leftrightharpoons: '',
        leftrightsquigarrow: '',
        LeftRightVector: '',
        LeftTeeArrow: '',
        LeftTee: '',
        LeftTeeVector: '',
        leftthreetimes: '',
        LeftTriangleBar: '',
        LeftTriangle: '',
        LeftTriangleEqual: '',
        LeftUpDownVector: '',
        LeftUpTeeVector: '',
        LeftUpVectorBar: '',
        LeftUpVector: '',
        LeftVectorBar: '',
        LeftVector: '',
        lEg: '',
        leg: '',
        leq: '',
        leqq: '',
        leqslant: '',
        lescc: '',
        les: '',
        lesdot: '',
        lesdoto: '',
        lesdotor: '',
        lesg: '',
        lesges: '',
        lessapprox: '',
        lessdot: '',
        lesseqgtr: '',
        lesseqqgtr: '',
        LessEqualGreater: '',
        LessFullEqual: '',
        LessGreater: '',
        lessgtr: '',
        LessLess: '',
        lesssim: '',
        LessSlantEqual: '',
        LessTilde: '',
        lfisht: '',
        lfloor: '',
        Lfr: '',
        lfr: '',
        lg: '',
        lgE: '',
        lHar: '',
        lhard: '',
        lharu: '',
        lharul: '',
        lhblk: '',
        LJcy: '',
        ljcy: '',
        llarr: '',
        ll: '',
        Ll: '',
        llcorner: '',
        Lleftarrow: '',
        llhard: '',
        lltri: '',
        Lmidot: '',
        lmidot: '',
        lmoustache: '',
        lmoust: '',
        lnap: '',
        lnapprox: '',
        lne: '',
        lnE: '',
        lneq: '',
        lneqq: '',
        lnsim: '',
        loang: '',
        loarr: '',
        lobrk: '',
        longleftarrow: '',
        LongLeftArrow: '',
        Longleftarrow: '',
        longleftrightarrow: '',
        LongLeftRightArrow: '',
        Longleftrightarrow: '',
        longmapsto: '',
        longrightarrow: '',
        LongRightArrow: '',
        Longrightarrow: '',
        looparrowleft: '',
        looparrowright: '',
        lopar: '',
        Lopf: '',
        lopf: '',
        loplus: '',
        lotimes: '',
        lowast: '',
        lowbar: '_',
        LowerLeftArrow: '',
        LowerRightArrow: '',
        loz: '',
        lozenge: '',
        lozf: '',
        lpar: '(',
        lparlt: '',
        lrarr: '',
        lrcorner: '',
        lrhar: '',
        lrhard: '',
        lrm: '',
        lrtri: '',
        lsaquo: '',
        lscr: '',
        Lscr: '',
        lsh: '',
        Lsh: '',
        lsim: '',
        lsime: '',
        lsimg: '',
        lsqb: '[',
        lsquo: '',
        lsquor: '',
        Lstrok: '',
        lstrok: '',
        ltcc: '',
        ltcir: '',
        lt: '<',
        LT: '<',
        Lt: '',
        ltdot: '',
        lthree: '',
        ltimes: '',
        ltlarr: '',
        ltquest: '',
        ltri: '',
        ltrie: '',
        ltrif: '',
        ltrPar: '',
        lurdshar: '',
        luruhar: '',
        lvertneqq: '',
        lvnE: '',
        macr: '',
        male: '',
        malt: '',
        maltese: '',
        Map: '',
        map: '',
        mapsto: '',
        mapstodown: '',
        mapstoleft: '',
        mapstoup: '',
        marker: '',
        mcomma: '',
        Mcy: '',
        mcy: '',
        mdash: '',
        mDDot: '',
        measuredangle: '',
        MediumSpace: '',
        Mellintrf: '',
        Mfr: '',
        mfr: '',
        mho: '',
        micro: '',
        midast: '*',
        midcir: '',
        mid: '',
        middot: '',
        minusb: '',
        minus: '',
        minusd: '',
        minusdu: '',
        MinusPlus: '',
        mlcp: '',
        mldr: '',
        mnplus: '',
        models: '',
        Mopf: '',
        mopf: '',
        mp: '',
        mscr: '',
        Mscr: '',
        mstpos: '',
        Mu: '',
        mu: '',
        multimap: '',
        mumap: '',
        nabla: '',
        Nacute: '',
        nacute: '',
        nang: '',
        nap: '',
        napE: '',
        napid: '',
        napos: '',
        napprox: '',
        natural: '',
        naturals: '',
        natur: '',
        nbsp: '',
        nbump: '',
        nbumpe: '',
        ncap: '',
        Ncaron: '',
        ncaron: '',
        Ncedil: '',
        ncedil: '',
        ncong: '',
        ncongdot: '',
        ncup: '',
        Ncy: '',
        ncy: '',
        ndash: '',
        nearhk: '',
        nearr: '',
        neArr: '',
        nearrow: '',
        ne: '',
        nedot: '',
        NegativeMediumSpace: '',
        NegativeThickSpace: '',
        NegativeThinSpace: '',
        NegativeVeryThinSpace: '',
        nequiv: '',
        nesear: '',
        nesim: '',
        NestedGreaterGreater: '',
        NestedLessLess: '',
        NewLine: `
`,
        nexist: '',
        nexists: '',
        Nfr: '',
        nfr: '',
        ngE: '',
        nge: '',
        ngeq: '',
        ngeqq: '',
        ngeqslant: '',
        nges: '',
        nGg: '',
        ngsim: '',
        nGt: '',
        ngt: '',
        ngtr: '',
        nGtv: '',
        nharr: '',
        nhArr: '',
        nhpar: '',
        ni: '',
        nis: '',
        nisd: '',
        niv: '',
        NJcy: '',
        njcy: '',
        nlarr: '',
        nlArr: '',
        nldr: '',
        nlE: '',
        nle: '',
        nleftarrow: '',
        nLeftarrow: '',
        nleftrightarrow: '',
        nLeftrightarrow: '',
        nleq: '',
        nleqq: '',
        nleqslant: '',
        nles: '',
        nless: '',
        nLl: '',
        nlsim: '',
        nLt: '',
        nlt: '',
        nltri: '',
        nltrie: '',
        nLtv: '',
        nmid: '',
        NoBreak: '',
        NonBreakingSpace: '',
        nopf: '',
        Nopf: '',
        Not: '',
        not: '',
        NotCongruent: '',
        NotCupCap: '',
        NotDoubleVerticalBar: '',
        NotElement: '',
        NotEqual: '',
        NotEqualTilde: '',
        NotExists: '',
        NotGreater: '',
        NotGreaterEqual: '',
        NotGreaterFullEqual: '',
        NotGreaterGreater: '',
        NotGreaterLess: '',
        NotGreaterSlantEqual: '',
        NotGreaterTilde: '',
        NotHumpDownHump: '',
        NotHumpEqual: '',
        notin: '',
        notindot: '',
        notinE: '',
        notinva: '',
        notinvb: '',
        notinvc: '',
        NotLeftTriangleBar: '',
        NotLeftTriangle: '',
        NotLeftTriangleEqual: '',
        NotLess: '',
        NotLessEqual: '',
        NotLessGreater: '',
        NotLessLess: '',
        NotLessSlantEqual: '',
        NotLessTilde: '',
        NotNestedGreaterGreater: '',
        NotNestedLessLess: '',
        notni: '',
        notniva: '',
        notnivb: '',
        notnivc: '',
        NotPrecedes: '',
        NotPrecedesEqual: '',
        NotPrecedesSlantEqual: '',
        NotReverseElement: '',
        NotRightTriangleBar: '',
        NotRightTriangle: '',
        NotRightTriangleEqual: '',
        NotSquareSubset: '',
        NotSquareSubsetEqual: '',
        NotSquareSuperset: '',
        NotSquareSupersetEqual: '',
        NotSubset: '',
        NotSubsetEqual: '',
        NotSucceeds: '',
        NotSucceedsEqual: '',
        NotSucceedsSlantEqual: '',
        NotSucceedsTilde: '',
        NotSuperset: '',
        NotSupersetEqual: '',
        NotTilde: '',
        NotTildeEqual: '',
        NotTildeFullEqual: '',
        NotTildeTilde: '',
        NotVerticalBar: '',
        nparallel: '',
        npar: '',
        nparsl: '',
        npart: '',
        npolint: '',
        npr: '',
        nprcue: '',
        nprec: '',
        npreceq: '',
        npre: '',
        nrarrc: '',
        nrarr: '',
        nrArr: '',
        nrarrw: '',
        nrightarrow: '',
        nRightarrow: '',
        nrtri: '',
        nrtrie: '',
        nsc: '',
        nsccue: '',
        nsce: '',
        Nscr: '',
        nscr: '',
        nshortmid: '',
        nshortparallel: '',
        nsim: '',
        nsime: '',
        nsimeq: '',
        nsmid: '',
        nspar: '',
        nsqsube: '',
        nsqsupe: '',
        nsub: '',
        nsubE: '',
        nsube: '',
        nsubset: '',
        nsubseteq: '',
        nsubseteqq: '',
        nsucc: '',
        nsucceq: '',
        nsup: '',
        nsupE: '',
        nsupe: '',
        nsupset: '',
        nsupseteq: '',
        nsupseteqq: '',
        ntgl: '',
        Ntilde: '',
        ntilde: '',
        ntlg: '',
        ntriangleleft: '',
        ntrianglelefteq: '',
        ntriangleright: '',
        ntrianglerighteq: '',
        Nu: '',
        nu: '',
        num: '#',
        numero: '',
        numsp: '',
        nvap: '',
        nvdash: '',
        nvDash: '',
        nVdash: '',
        nVDash: '',
        nvge: '',
        nvgt: '>',
        nvHarr: '',
        nvinfin: '',
        nvlArr: '',
        nvle: '',
        nvlt: '<',
        nvltrie: '',
        nvrArr: '',
        nvrtrie: '',
        nvsim: '',
        nwarhk: '',
        nwarr: '',
        nwArr: '',
        nwarrow: '',
        nwnear: '',
        Oacute: '',
        oacute: '',
        oast: '',
        Ocirc: '',
        ocirc: '',
        ocir: '',
        Ocy: '',
        ocy: '',
        odash: '',
        Odblac: '',
        odblac: '',
        odiv: '',
        odot: '',
        odsold: '',
        OElig: '',
        oelig: '',
        ofcir: '',
        Ofr: '',
        ofr: '',
        ogon: '',
        Ograve: '',
        ograve: '',
        ogt: '',
        ohbar: '',
        ohm: '',
        oint: '',
        olarr: '',
        olcir: '',
        olcross: '',
        oline: '',
        olt: '',
        Omacr: '',
        omacr: '',
        Omega: '',
        omega: '',
        Omicron: '',
        omicron: '',
        omid: '',
        ominus: '',
        Oopf: '',
        oopf: '',
        opar: '',
        OpenCurlyDoubleQuote: '',
        OpenCurlyQuote: '',
        operp: '',
        oplus: '',
        orarr: '',
        Or: '',
        or: '',
        ord: '',
        order: '',
        orderof: '',
        ordf: '',
        ordm: '',
        origof: '',
        oror: '',
        orslope: '',
        orv: '',
        oS: '',
        Oscr: '',
        oscr: '',
        Oslash: '',
        oslash: '',
        osol: '',
        Otilde: '',
        otilde: '',
        otimesas: '',
        Otimes: '',
        otimes: '',
        Ouml: '',
        ouml: '',
        ovbar: '',
        OverBar: '',
        OverBrace: '',
        OverBracket: '',
        OverParenthesis: '',
        para: '',
        parallel: '',
        par: '',
        parsim: '',
        parsl: '',
        part: '',
        PartialD: '',
        Pcy: '',
        pcy: '',
        percnt: '%',
        period: '.',
        permil: '',
        perp: '',
        pertenk: '',
        Pfr: '',
        pfr: '',
        Phi: '',
        phi: '',
        phiv: '',
        phmmat: '',
        phone: '',
        Pi: '',
        pi: '',
        pitchfork: '',
        piv: '',
        planck: '',
        planckh: '',
        plankv: '',
        plusacir: '',
        plusb: '',
        pluscir: '',
        plus: '+',
        plusdo: '',
        plusdu: '',
        pluse: '',
        PlusMinus: '',
        plusmn: '',
        plussim: '',
        plustwo: '',
        pm: '',
        Poincareplane: '',
        pointint: '',
        popf: '',
        Popf: '',
        pound: '',
        prap: '',
        Pr: '',
        pr: '',
        prcue: '',
        precapprox: '',
        prec: '',
        preccurlyeq: '',
        Precedes: '',
        PrecedesEqual: '',
        PrecedesSlantEqual: '',
        PrecedesTilde: '',
        preceq: '',
        precnapprox: '',
        precneqq: '',
        precnsim: '',
        pre: '',
        prE: '',
        precsim: '',
        prime: '',
        Prime: '',
        primes: '',
        prnap: '',
        prnE: '',
        prnsim: '',
        prod: '',
        Product: '',
        profalar: '',
        profline: '',
        profsurf: '',
        prop: '',
        Proportional: '',
        Proportion: '',
        propto: '',
        prsim: '',
        prurel: '',
        Pscr: '',
        pscr: '',
        Psi: '',
        psi: '',
        puncsp: '',
        Qfr: '',
        qfr: '',
        qint: '',
        qopf: '',
        Qopf: '',
        qprime: '',
        Qscr: '',
        qscr: '',
        quaternions: '',
        quatint: '',
        quest: '?',
        questeq: '',
        quot: '"',
        QUOT: '"',
        rAarr: '',
        race: '',
        Racute: '',
        racute: '',
        radic: '',
        raemptyv: '',
        rang: '',
        Rang: '',
        rangd: '',
        range: '',
        rangle: '',
        raquo: '',
        rarrap: '',
        rarrb: '',
        rarrbfs: '',
        rarrc: '',
        rarr: '',
        Rarr: '',
        rArr: '',
        rarrfs: '',
        rarrhk: '',
        rarrlp: '',
        rarrpl: '',
        rarrsim: '',
        Rarrtl: '',
        rarrtl: '',
        rarrw: '',
        ratail: '',
        rAtail: '',
        ratio: '',
        rationals: '',
        rbarr: '',
        rBarr: '',
        RBarr: '',
        rbbrk: '',
        rbrace: '}',
        rbrack: ']',
        rbrke: '',
        rbrksld: '',
        rbrkslu: '',
        Rcaron: '',
        rcaron: '',
        Rcedil: '',
        rcedil: '',
        rceil: '',
        rcub: '}',
        Rcy: '',
        rcy: '',
        rdca: '',
        rdldhar: '',
        rdquo: '',
        rdquor: '',
        rdsh: '',
        real: '',
        realine: '',
        realpart: '',
        reals: '',
        Re: '',
        rect: '',
        reg: '',
        REG: '',
        ReverseElement: '',
        ReverseEquilibrium: '',
        ReverseUpEquilibrium: '',
        rfisht: '',
        rfloor: '',
        rfr: '',
        Rfr: '',
        rHar: '',
        rhard: '',
        rharu: '',
        rharul: '',
        Rho: '',
        rho: '',
        rhov: '',
        RightAngleBracket: '',
        RightArrowBar: '',
        rightarrow: '',
        RightArrow: '',
        Rightarrow: '',
        RightArrowLeftArrow: '',
        rightarrowtail: '',
        RightCeiling: '',
        RightDoubleBracket: '',
        RightDownTeeVector: '',
        RightDownVectorBar: '',
        RightDownVector: '',
        RightFloor: '',
        rightharpoondown: '',
        rightharpoonup: '',
        rightleftarrows: '',
        rightleftharpoons: '',
        rightrightarrows: '',
        rightsquigarrow: '',
        RightTeeArrow: '',
        RightTee: '',
        RightTeeVector: '',
        rightthreetimes: '',
        RightTriangleBar: '',
        RightTriangle: '',
        RightTriangleEqual: '',
        RightUpDownVector: '',
        RightUpTeeVector: '',
        RightUpVectorBar: '',
        RightUpVector: '',
        RightVectorBar: '',
        RightVector: '',
        ring: '',
        risingdotseq: '',
        rlarr: '',
        rlhar: '',
        rlm: '',
        rmoustache: '',
        rmoust: '',
        rnmid: '',
        roang: '',
        roarr: '',
        robrk: '',
        ropar: '',
        ropf: '',
        Ropf: '',
        roplus: '',
        rotimes: '',
        RoundImplies: '',
        rpar: ')',
        rpargt: '',
        rppolint: '',
        rrarr: '',
        Rrightarrow: '',
        rsaquo: '',
        rscr: '',
        Rscr: '',
        rsh: '',
        Rsh: '',
        rsqb: ']',
        rsquo: '',
        rsquor: '',
        rthree: '',
        rtimes: '',
        rtri: '',
        rtrie: '',
        rtrif: '',
        rtriltri: '',
        RuleDelayed: '',
        ruluhar: '',
        rx: '',
        Sacute: '',
        sacute: '',
        sbquo: '',
        scap: '',
        Scaron: '',
        scaron: '',
        Sc: '',
        sc: '',
        sccue: '',
        sce: '',
        scE: '',
        Scedil: '',
        scedil: '',
        Scirc: '',
        scirc: '',
        scnap: '',
        scnE: '',
        scnsim: '',
        scpolint: '',
        scsim: '',
        Scy: '',
        scy: '',
        sdotb: '',
        sdot: '',
        sdote: '',
        searhk: '',
        searr: '',
        seArr: '',
        searrow: '',
        sect: '',
        semi: ';',
        seswar: '',
        setminus: '',
        setmn: '',
        sext: '',
        Sfr: '',
        sfr: '',
        sfrown: '',
        sharp: '',
        SHCHcy: '',
        shchcy: '',
        SHcy: '',
        shcy: '',
        ShortDownArrow: '',
        ShortLeftArrow: '',
        shortmid: '',
        shortparallel: '',
        ShortRightArrow: '',
        ShortUpArrow: '',
        shy: '',
        Sigma: '',
        sigma: '',
        sigmaf: '',
        sigmav: '',
        sim: '',
        simdot: '',
        sime: '',
        simeq: '',
        simg: '',
        simgE: '',
        siml: '',
        simlE: '',
        simne: '',
        simplus: '',
        simrarr: '',
        slarr: '',
        SmallCircle: '',
        smallsetminus: '',
        smashp: '',
        smeparsl: '',
        smid: '',
        smile: '',
        smt: '',
        smte: '',
        smtes: '',
        SOFTcy: '',
        softcy: '',
        solbar: '',
        solb: '',
        sol: '/',
        Sopf: '',
        sopf: '',
        spades: '',
        spadesuit: '',
        spar: '',
        sqcap: '',
        sqcaps: '',
        sqcup: '',
        sqcups: '',
        Sqrt: '',
        sqsub: '',
        sqsube: '',
        sqsubset: '',
        sqsubseteq: '',
        sqsup: '',
        sqsupe: '',
        sqsupset: '',
        sqsupseteq: '',
        square: '',
        Square: '',
        SquareIntersection: '',
        SquareSubset: '',
        SquareSubsetEqual: '',
        SquareSuperset: '',
        SquareSupersetEqual: '',
        SquareUnion: '',
        squarf: '',
        squ: '',
        squf: '',
        srarr: '',
        Sscr: '',
        sscr: '',
        ssetmn: '',
        ssmile: '',
        sstarf: '',
        Star: '',
        star: '',
        starf: '',
        straightepsilon: '',
        straightphi: '',
        strns: '',
        sub: '',
        Sub: '',
        subdot: '',
        subE: '',
        sube: '',
        subedot: '',
        submult: '',
        subnE: '',
        subne: '',
        subplus: '',
        subrarr: '',
        subset: '',
        Subset: '',
        subseteq: '',
        subseteqq: '',
        SubsetEqual: '',
        subsetneq: '',
        subsetneqq: '',
        subsim: '',
        subsub: '',
        subsup: '',
        succapprox: '',
        succ: '',
        succcurlyeq: '',
        Succeeds: '',
        SucceedsEqual: '',
        SucceedsSlantEqual: '',
        SucceedsTilde: '',
        succeq: '',
        succnapprox: '',
        succneqq: '',
        succnsim: '',
        succsim: '',
        SuchThat: '',
        sum: '',
        Sum: '',
        sung: '',
        sup1: '',
        sup2: '',
        sup3: '',
        sup: '',
        Sup: '',
        supdot: '',
        supdsub: '',
        supE: '',
        supe: '',
        supedot: '',
        Superset: '',
        SupersetEqual: '',
        suphsol: '',
        suphsub: '',
        suplarr: '',
        supmult: '',
        supnE: '',
        supne: '',
        supplus: '',
        supset: '',
        Supset: '',
        supseteq: '',
        supseteqq: '',
        supsetneq: '',
        supsetneqq: '',
        supsim: '',
        supsub: '',
        supsup: '',
        swarhk: '',
        swarr: '',
        swArr: '',
        swarrow: '',
        swnwar: '',
        szlig: '',
        Tab: '	',
        target: '',
        Tau: '',
        tau: '',
        tbrk: '',
        Tcaron: '',
        tcaron: '',
        Tcedil: '',
        tcedil: '',
        Tcy: '',
        tcy: '',
        tdot: '',
        telrec: '',
        Tfr: '',
        tfr: '',
        there4: '',
        therefore: '',
        Therefore: '',
        Theta: '',
        theta: '',
        thetasym: '',
        thetav: '',
        thickapprox: '',
        thicksim: '',
        ThickSpace: '',
        ThinSpace: '',
        thinsp: '',
        thkap: '',
        thksim: '',
        THORN: '',
        thorn: '',
        tilde: '',
        Tilde: '',
        TildeEqual: '',
        TildeFullEqual: '',
        TildeTilde: '',
        timesbar: '',
        timesb: '',
        times: '',
        timesd: '',
        tint: '',
        toea: '',
        topbot: '',
        topcir: '',
        top: '',
        Topf: '',
        topf: '',
        topfork: '',
        tosa: '',
        tprime: '',
        trade: '',
        TRADE: '',
        triangle: '',
        triangledown: '',
        triangleleft: '',
        trianglelefteq: '',
        triangleq: '',
        triangleright: '',
        trianglerighteq: '',
        tridot: '',
        trie: '',
        triminus: '',
        TripleDot: '',
        triplus: '',
        trisb: '',
        tritime: '',
        trpezium: '',
        Tscr: '',
        tscr: '',
        TScy: '',
        tscy: '',
        TSHcy: '',
        tshcy: '',
        Tstrok: '',
        tstrok: '',
        twixt: '',
        twoheadleftarrow: '',
        twoheadrightarrow: '',
        Uacute: '',
        uacute: '',
        uarr: '',
        Uarr: '',
        uArr: '',
        Uarrocir: '',
        Ubrcy: '',
        ubrcy: '',
        Ubreve: '',
        ubreve: '',
        Ucirc: '',
        ucirc: '',
        Ucy: '',
        ucy: '',
        udarr: '',
        Udblac: '',
        udblac: '',
        udhar: '',
        ufisht: '',
        Ufr: '',
        ufr: '',
        Ugrave: '',
        ugrave: '',
        uHar: '',
        uharl: '',
        uharr: '',
        uhblk: '',
        ulcorn: '',
        ulcorner: '',
        ulcrop: '',
        ultri: '',
        Umacr: '',
        umacr: '',
        uml: '',
        UnderBar: '_',
        UnderBrace: '',
        UnderBracket: '',
        UnderParenthesis: '',
        Union: '',
        UnionPlus: '',
        Uogon: '',
        uogon: '',
        Uopf: '',
        uopf: '',
        UpArrowBar: '',
        uparrow: '',
        UpArrow: '',
        Uparrow: '',
        UpArrowDownArrow: '',
        updownarrow: '',
        UpDownArrow: '',
        Updownarrow: '',
        UpEquilibrium: '',
        upharpoonleft: '',
        upharpoonright: '',
        uplus: '',
        UpperLeftArrow: '',
        UpperRightArrow: '',
        upsi: '',
        Upsi: '',
        upsih: '',
        Upsilon: '',
        upsilon: '',
        UpTeeArrow: '',
        UpTee: '',
        upuparrows: '',
        urcorn: '',
        urcorner: '',
        urcrop: '',
        Uring: '',
        uring: '',
        urtri: '',
        Uscr: '',
        uscr: '',
        utdot: '',
        Utilde: '',
        utilde: '',
        utri: '',
        utrif: '',
        uuarr: '',
        Uuml: '',
        uuml: '',
        uwangle: '',
        vangrt: '',
        varepsilon: '',
        varkappa: '',
        varnothing: '',
        varphi: '',
        varpi: '',
        varpropto: '',
        varr: '',
        vArr: '',
        varrho: '',
        varsigma: '',
        varsubsetneq: '',
        varsubsetneqq: '',
        varsupsetneq: '',
        varsupsetneqq: '',
        vartheta: '',
        vartriangleleft: '',
        vartriangleright: '',
        vBar: '',
        Vbar: '',
        vBarv: '',
        Vcy: '',
        vcy: '',
        vdash: '',
        vDash: '',
        Vdash: '',
        VDash: '',
        Vdashl: '',
        veebar: '',
        vee: '',
        Vee: '',
        veeeq: '',
        vellip: '',
        verbar: '|',
        Verbar: '',
        vert: '|',
        Vert: '',
        VerticalBar: '',
        VerticalLine: '|',
        VerticalSeparator: '',
        VerticalTilde: '',
        VeryThinSpace: '',
        Vfr: '',
        vfr: '',
        vltri: '',
        vnsub: '',
        vnsup: '',
        Vopf: '',
        vopf: '',
        vprop: '',
        vrtri: '',
        Vscr: '',
        vscr: '',
        vsubnE: '',
        vsubne: '',
        vsupnE: '',
        vsupne: '',
        Vvdash: '',
        vzigzag: '',
        Wcirc: '',
        wcirc: '',
        wedbar: '',
        wedge: '',
        Wedge: '',
        wedgeq: '',
        weierp: '',
        Wfr: '',
        wfr: '',
        Wopf: '',
        wopf: '',
        wp: '',
        wr: '',
        wreath: '',
        Wscr: '',
        wscr: '',
        xcap: '',
        xcirc: '',
        xcup: '',
        xdtri: '',
        Xfr: '',
        xfr: '',
        xharr: '',
        xhArr: '',
        Xi: '',
        xi: '',
        xlarr: '',
        xlArr: '',
        xmap: '',
        xnis: '',
        xodot: '',
        Xopf: '',
        xopf: '',
        xoplus: '',
        xotime: '',
        xrarr: '',
        xrArr: '',
        Xscr: '',
        xscr: '',
        xsqcup: '',
        xuplus: '',
        xutri: '',
        xvee: '',
        xwedge: '',
        Yacute: '',
        yacute: '',
        YAcy: '',
        yacy: '',
        Ycirc: '',
        ycirc: '',
        Ycy: '',
        ycy: '',
        yen: '',
        Yfr: '',
        yfr: '',
        YIcy: '',
        yicy: '',
        Yopf: '',
        yopf: '',
        Yscr: '',
        yscr: '',
        YUcy: '',
        yucy: '',
        yuml: '',
        Yuml: '',
        Zacute: '',
        zacute: '',
        Zcaron: '',
        zcaron: '',
        Zcy: '',
        zcy: '',
        Zdot: '',
        zdot: '',
        zeetrf: '',
        ZeroWidthSpace: '',
        Zeta: '',
        zeta: '',
        zfr: '',
        Zfr: '',
        ZHcy: '',
        zhcy: '',
        zigrarr: '',
        zopf: '',
        Zopf: '',
        Zscr: '',
        zscr: '',
        zwj: '',
        zwnj: '',
      };
    },
  }),
  w1 = B({
    '../node_modules/entities/lib/maps/legacy.json'(e, t) {
      t.exports = {
        Aacute: '',
        aacute: '',
        Acirc: '',
        acirc: '',
        acute: '',
        AElig: '',
        aelig: '',
        Agrave: '',
        agrave: '',
        amp: '&',
        AMP: '&',
        Aring: '',
        aring: '',
        Atilde: '',
        atilde: '',
        Auml: '',
        auml: '',
        brvbar: '',
        Ccedil: '',
        ccedil: '',
        cedil: '',
        cent: '',
        copy: '',
        COPY: '',
        curren: '',
        deg: '',
        divide: '',
        Eacute: '',
        eacute: '',
        Ecirc: '',
        ecirc: '',
        Egrave: '',
        egrave: '',
        ETH: '',
        eth: '',
        Euml: '',
        euml: '',
        frac12: '',
        frac14: '',
        frac34: '',
        gt: '>',
        GT: '>',
        Iacute: '',
        iacute: '',
        Icirc: '',
        icirc: '',
        iexcl: '',
        Igrave: '',
        igrave: '',
        iquest: '',
        Iuml: '',
        iuml: '',
        laquo: '',
        lt: '<',
        LT: '<',
        macr: '',
        micro: '',
        middot: '',
        nbsp: '',
        not: '',
        Ntilde: '',
        ntilde: '',
        Oacute: '',
        oacute: '',
        Ocirc: '',
        ocirc: '',
        Ograve: '',
        ograve: '',
        ordf: '',
        ordm: '',
        Oslash: '',
        oslash: '',
        Otilde: '',
        otilde: '',
        Ouml: '',
        ouml: '',
        para: '',
        plusmn: '',
        pound: '',
        quot: '"',
        QUOT: '"',
        raquo: '',
        reg: '',
        REG: '',
        sect: '',
        shy: '',
        sup1: '',
        sup2: '',
        sup3: '',
        szlig: '',
        THORN: '',
        thorn: '',
        times: '',
        Uacute: '',
        uacute: '',
        Ucirc: '',
        ucirc: '',
        Ugrave: '',
        ugrave: '',
        uml: '',
        Uuml: '',
        uuml: '',
        Yacute: '',
        yacute: '',
        yen: '',
        yuml: '',
      };
    },
  }),
  Yv = B({
    '../node_modules/entities/lib/maps/xml.json'(e, t) {
      t.exports = { amp: '&', apos: "'", gt: '>', lt: '<', quot: '"' };
    },
  }),
  S1 = B({
    '../node_modules/entities/lib/maps/decode.json'(e, t) {
      t.exports = {
        0: 65533,
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376,
      };
    },
  }),
  _1 = B({
    '../node_modules/entities/lib/decode_codepoint.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (i) {
          return i && i.__esModule ? i : { default: i };
        };
      Object.defineProperty(e, '__esModule', { value: !0 });
      var r = t(S1()),
        n =
          String.fromCodePoint ||
          function (i) {
            var a = '';
            return (
              i > 65535 &&
                ((i -= 65536),
                (a += String.fromCharCode(((i >>> 10) & 1023) | 55296)),
                (i = 56320 | (i & 1023))),
              (a += String.fromCharCode(i)),
              a
            );
          };
      function o(i) {
        return (i >= 55296 && i <= 57343) || i > 1114111
          ? ''
          : (i in r.default && (i = r.default[i]), n(i));
      }
      (s(o, 'decodeCodePoint'), (e.default = o));
    },
  }),
  _g = B({
    '../node_modules/entities/lib/decode.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (p) {
          return p && p.__esModule ? p : { default: p };
        };
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0));
      var r = t(Kv()),
        n = t(w1()),
        o = t(Yv()),
        i = t(_1()),
        a = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
      ((e.decodeXML = l(o.default)), (e.decodeHTMLStrict = l(r.default)));
      function l(p) {
        var f = u(p);
        return function (m) {
          return String(m).replace(a, f);
        };
      }
      s(l, 'getStrictDecoder');
      var d = s(function (p, f) {
        return p < f ? 1 : -1;
      }, 'sorter');
      e.decodeHTML = (function () {
        for (
          var p = Object.keys(n.default).sort(d), f = Object.keys(r.default).sort(d), m = 0, h = 0;
          m < f.length;
          m++
        )
          p[h] === f[m] ? ((f[m] += ';?'), h++) : (f[m] += ';');
        var g = new RegExp('&(?:' + f.join('|') + '|#[xX][\\da-fA-F]+;?|#\\d+;?)', 'g'),
          v = u(r.default);
        function E(b) {
          return (b.substr(-1) !== ';' && (b += ';'), v(b));
        }
        return (
          s(E, 'replacer'),
          function (b) {
            return String(b).replace(g, E);
          }
        );
      })();
      function u(p) {
        return s(function (m) {
          if (m.charAt(1) === '#') {
            var h = m.charAt(2);
            return h === 'X' || h === 'x'
              ? i.default(parseInt(m.substr(3), 16))
              : i.default(parseInt(m.substr(2), 10));
          }
          return p[m.slice(1, -1)] || m;
        }, 'replace');
      }
      s(u, 'getReplacer');
    },
  }),
  Ag = B({
    '../node_modules/entities/lib/encode.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (S) {
          return S && S.__esModule ? S : { default: S };
        };
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = void 0));
      var r = t(Yv()),
        n = d(r.default),
        o = u(n);
      e.encodeXML = b(n);
      var i = t(Kv()),
        a = d(i.default),
        l = u(a);
      ((e.encodeHTML = h(a, l)), (e.encodeNonAsciiHTML = b(a)));
      function d(S) {
        return Object.keys(S)
          .sort()
          .reduce(function (R, I) {
            return ((R[S[I]] = '&' + I + ';'), R);
          }, {});
      }
      s(d, 'getInverseObj');
      function u(S) {
        for (var R = [], I = [], $ = 0, x = Object.keys(S); $ < x.length; $++) {
          var A = x[$];
          A.length === 1 ? R.push('\\' + A) : I.push(A);
        }
        R.sort();
        for (var w = 0; w < R.length - 1; w++) {
          for (var _ = w; _ < R.length - 1 && R[_].charCodeAt(1) + 1 === R[_ + 1].charCodeAt(1); )
            _ += 1;
          var j = 1 + _ - w;
          j < 3 || R.splice(w, j, R[w] + '-' + R[_]);
        }
        return (I.unshift('[' + R.join('') + ']'), new RegExp(I.join('|'), 'g'));
      }
      s(u, 'getInverseReplacer');
      var p =
          /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
        f =
          String.prototype.codePointAt != null
            ? function (S) {
                return S.codePointAt(0);
              }
            : function (S) {
                return (S.charCodeAt(0) - 55296) * 1024 + S.charCodeAt(1) - 56320 + 65536;
              };
      function m(S) {
        return '&#x' + (S.length > 1 ? f(S) : S.charCodeAt(0)).toString(16).toUpperCase() + ';';
      }
      s(m, 'singleCharReplacer');
      function h(S, R) {
        return function (I) {
          return I.replace(R, function ($) {
            return S[$];
          }).replace(p, m);
        };
      }
      s(h, 'getInverse');
      var g = new RegExp(o.source + '|' + p.source, 'g');
      function v(S) {
        return S.replace(g, m);
      }
      (s(v, 'escape'), (e.escape = v));
      function E(S) {
        return S.replace(o, m);
      }
      (s(E, 'escapeUTF8'), (e.escapeUTF8 = E));
      function b(S) {
        return function (R) {
          return R.replace(g, function (I) {
            return S[I] || m(I);
          });
        };
      }
      s(b, 'getASCIIEncoder');
    },
  }),
  A1 = B({
    '../node_modules/entities/lib/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeXMLStrict =
          e.decodeHTML5Strict =
          e.decodeHTML4Strict =
          e.decodeHTML5 =
          e.decodeHTML4 =
          e.decodeHTMLStrict =
          e.decodeHTML =
          e.decodeXML =
          e.encodeHTML5 =
          e.encodeHTML4 =
          e.escapeUTF8 =
          e.escape =
          e.encodeNonAsciiHTML =
          e.encodeHTML =
          e.encodeXML =
          e.encode =
          e.decodeStrict =
          e.decode =
            void 0));
      var t = _g(),
        r = Ag();
      function n(d, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTML)(d);
      }
      (s(n, 'decode'), (e.decode = n));
      function o(d, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTMLStrict)(d);
      }
      (s(o, 'decodeStrict'), (e.decodeStrict = o));
      function i(d, u) {
        return (!u || u <= 0 ? r.encodeXML : r.encodeHTML)(d);
      }
      (s(i, 'encode'), (e.encode = i));
      var a = Ag();
      (Object.defineProperty(e, 'encodeXML', {
        enumerable: !0,
        get: s(function () {
          return a.encodeXML;
        }, 'get'),
      }),
        Object.defineProperty(e, 'encodeHTML', {
          enumerable: !0,
          get: s(function () {
            return a.encodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeNonAsciiHTML', {
          enumerable: !0,
          get: s(function () {
            return a.encodeNonAsciiHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'escape', {
          enumerable: !0,
          get: s(function () {
            return a.escape;
          }, 'get'),
        }),
        Object.defineProperty(e, 'escapeUTF8', {
          enumerable: !0,
          get: s(function () {
            return a.escapeUTF8;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML4', {
          enumerable: !0,
          get: s(function () {
            return a.encodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML5', {
          enumerable: !0,
          get: s(function () {
            return a.encodeHTML;
          }, 'get'),
        }));
      var l = _g();
      (Object.defineProperty(e, 'decodeXML', {
        enumerable: !0,
        get: s(function () {
          return l.decodeXML;
        }, 'get'),
      }),
        Object.defineProperty(e, 'decodeHTML', {
          enumerable: !0,
          get: s(function () {
            return l.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTMLStrict', {
          enumerable: !0,
          get: s(function () {
            return l.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4', {
          enumerable: !0,
          get: s(function () {
            return l.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5', {
          enumerable: !0,
          get: s(function () {
            return l.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4Strict', {
          enumerable: !0,
          get: s(function () {
            return l.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5Strict', {
          enumerable: !0,
          get: s(function () {
            return l.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeXMLStrict', {
          enumerable: !0,
          get: s(function () {
            return l.decodeXML;
          }, 'get'),
        }));
    },
  }),
  R1 = B({
    '../node_modules/ansi-to-html/lib/ansi_to_html.js'(e, t) {
      function r(P, D) {
        if (!(P instanceof D)) throw new TypeError('Cannot call a class as a function');
      }
      s(r, '_classCallCheck');
      function n(P, D) {
        for (var F = 0; F < D.length; F++) {
          var k = D[F];
          ((k.enumerable = k.enumerable || !1),
            (k.configurable = !0),
            'value' in k && (k.writable = !0),
            Object.defineProperty(P, k.key, k));
        }
      }
      s(n, '_defineProperties');
      function o(P, D, F) {
        return (D && n(P.prototype, D), F && n(P, F), P);
      }
      s(o, '_createClass');
      function i(P, D) {
        var F = (typeof Symbol < 'u' && P[Symbol.iterator]) || P['@@iterator'];
        if (!F) {
          if (Array.isArray(P) || (F = a(P)) || (D && P && typeof P.length == 'number')) {
            F && (P = F);
            var k = 0,
              K = s(function () {}, 'F');
            return {
              s: K,
              n: s(function () {
                return k >= P.length ? { done: !0 } : { done: !1, value: P[k++] };
              }, 'n'),
              e: s(function (ae) {
                throw ae;
              }, 'e'),
              f: K,
            };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var X = !0,
          se = !1,
          ie;
        return {
          s: s(function () {
            F = F.call(P);
          }, 's'),
          n: s(function () {
            var ae = F.next();
            return ((X = ae.done), ae);
          }, 'n'),
          e: s(function (ae) {
            ((se = !0), (ie = ae));
          }, 'e'),
          f: s(function () {
            try {
              !X && F.return != null && F.return();
            } finally {
              if (se) throw ie;
            }
          }, 'f'),
        };
      }
      s(i, '_createForOfIteratorHelper');
      function a(P, D) {
        if (P) {
          if (typeof P == 'string') return l(P, D);
          var F = Object.prototype.toString.call(P).slice(8, -1);
          if (
            (F === 'Object' && P.constructor && (F = P.constructor.name),
            F === 'Map' || F === 'Set')
          )
            return Array.from(P);
          if (F === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(F))
            return l(P, D);
        }
      }
      s(a, '_unsupportedIterableToArray');
      function l(P, D) {
        (D == null || D > P.length) && (D = P.length);
        for (var F = 0, k = new Array(D); F < D; F++) k[F] = P[F];
        return k;
      }
      s(l, '_arrayLikeToArray');
      var d = A1(),
        u = { fg: '#FFF', bg: '#000', newline: !1, escapeXML: !1, stream: !1, colors: p() };
      function p() {
        var P = {
          0: '#000',
          1: '#A00',
          2: '#0A0',
          3: '#A50',
          4: '#00A',
          5: '#A0A',
          6: '#0AA',
          7: '#AAA',
          8: '#555',
          9: '#F55',
          10: '#5F5',
          11: '#FF5',
          12: '#55F',
          13: '#F5F',
          14: '#5FF',
          15: '#FFF',
        };
        return (
          S(0, 5).forEach(function (D) {
            S(0, 5).forEach(function (F) {
              S(0, 5).forEach(function (k) {
                return f(D, F, k, P);
              });
            });
          }),
          S(0, 23).forEach(function (D) {
            var F = D + 232,
              k = m(D * 10 + 8);
            P[F] = '#' + k + k + k;
          }),
          P
        );
      }
      s(p, 'getDefaultColors');
      function f(P, D, F, k) {
        var K = 16 + P * 36 + D * 6 + F,
          X = P > 0 ? P * 40 + 55 : 0,
          se = D > 0 ? D * 40 + 55 : 0,
          ie = F > 0 ? F * 40 + 55 : 0;
        k[K] = h([X, se, ie]);
      }
      s(f, 'setStyleColor');
      function m(P) {
        for (var D = P.toString(16); D.length < 2; ) D = '0' + D;
        return D;
      }
      s(m, 'toHexString');
      function h(P) {
        var D = [],
          F = i(P),
          k;
        try {
          for (F.s(); !(k = F.n()).done; ) {
            var K = k.value;
            D.push(m(K));
          }
        } catch (X) {
          F.e(X);
        } finally {
          F.f();
        }
        return '#' + D.join('');
      }
      s(h, 'toColorHexString');
      function g(P, D, F, k) {
        var K;
        return (
          D === 'text'
            ? (K = $(F, k))
            : D === 'display'
              ? (K = E(P, F, k))
              : D === 'xterm256Foreground'
                ? (K = w(P, k.colors[F]))
                : D === 'xterm256Background'
                  ? (K = _(P, k.colors[F]))
                  : D === 'rgb' && (K = v(P, F)),
          K
        );
      }
      s(g, 'generateOutput');
      function v(P, D) {
        D = D.substring(2).slice(0, -1);
        var F = +D.substr(0, 2),
          k = D.substring(5).split(';'),
          K = k
            .map(function (X) {
              return ('0' + Number(X).toString(16)).substr(-2);
            })
            .join('');
        return A(P, (F === 38 ? 'color:#' : 'background-color:#') + K);
      }
      s(v, 'handleRgb');
      function E(P, D, F) {
        D = parseInt(D, 10);
        var k = {
            '-1': s(function () {
              return '<br/>';
            }, '_'),
            0: s(function () {
              return P.length && b(P);
            }, '_'),
            1: s(function () {
              return x(P, 'b');
            }, '_'),
            3: s(function () {
              return x(P, 'i');
            }, '_'),
            4: s(function () {
              return x(P, 'u');
            }, '_'),
            8: s(function () {
              return A(P, 'display:none');
            }, '_'),
            9: s(function () {
              return x(P, 'strike');
            }, '_'),
            22: s(function () {
              return A(P, 'font-weight:normal;text-decoration:none;font-style:normal');
            }, '_'),
            23: s(function () {
              return j(P, 'i');
            }, '_'),
            24: s(function () {
              return j(P, 'u');
            }, '_'),
            39: s(function () {
              return w(P, F.fg);
            }, '_'),
            49: s(function () {
              return _(P, F.bg);
            }, '_'),
            53: s(function () {
              return A(P, 'text-decoration:overline');
            }, '_'),
          },
          K;
        return (
          k[D]
            ? (K = k[D]())
            : 4 < D && D < 7
              ? (K = x(P, 'blink'))
              : 29 < D && D < 38
                ? (K = w(P, F.colors[D - 30]))
                : 39 < D && D < 48
                  ? (K = _(P, F.colors[D - 40]))
                  : 89 < D && D < 98
                    ? (K = w(P, F.colors[8 + (D - 90)]))
                    : 99 < D && D < 108 && (K = _(P, F.colors[8 + (D - 100)])),
          K
        );
      }
      s(E, 'handleDisplay');
      function b(P) {
        var D = P.slice(0);
        return (
          (P.length = 0),
          D.reverse()
            .map(function (F) {
              return '</' + F + '>';
            })
            .join('')
        );
      }
      s(b, 'resetStyles');
      function S(P, D) {
        for (var F = [], k = P; k <= D; k++) F.push(k);
        return F;
      }
      s(S, 'range');
      function R(P) {
        return function (D) {
          return (P === null || D.category !== P) && P !== 'all';
        };
      }
      s(R, 'notCategory');
      function I(P) {
        P = parseInt(P, 10);
        var D = null;
        return (
          P === 0
            ? (D = 'all')
            : P === 1
              ? (D = 'bold')
              : 2 < P && P < 5
                ? (D = 'underline')
                : 4 < P && P < 7
                  ? (D = 'blink')
                  : P === 8
                    ? (D = 'hide')
                    : P === 9
                      ? (D = 'strike')
                      : (29 < P && P < 38) || P === 39 || (89 < P && P < 98)
                        ? (D = 'foreground-color')
                        : ((39 < P && P < 48) || P === 49 || (99 < P && P < 108)) &&
                          (D = 'background-color'),
          D
        );
      }
      s(I, 'categoryForCode');
      function $(P, D) {
        return D.escapeXML ? d.encodeXML(P) : P;
      }
      s($, 'pushText');
      function x(P, D, F) {
        return (
          F || (F = ''),
          P.push(D),
          '<'.concat(D).concat(F ? ' style="'.concat(F, '"') : '', '>')
        );
      }
      s(x, 'pushTag');
      function A(P, D) {
        return x(P, 'span', D);
      }
      s(A, 'pushStyle');
      function w(P, D) {
        return x(P, 'span', 'color:' + D);
      }
      s(w, 'pushForegroundColor');
      function _(P, D) {
        return x(P, 'span', 'background-color:' + D);
      }
      s(_, 'pushBackgroundColor');
      function j(P, D) {
        var F;
        if ((P.slice(-1)[0] === D && (F = P.pop()), F)) return '</' + D + '>';
      }
      s(j, 'closeTag');
      function N(P, D, F) {
        var k = !1,
          K = 3;
        function X() {
          return '';
        }
        s(X, 'remove');
        function se(ne, de) {
          return (F('xterm256Foreground', de), '');
        }
        s(se, 'removeXterm256Foreground');
        function ie(ne, de) {
          return (F('xterm256Background', de), '');
        }
        s(ie, 'removeXterm256Background');
        function W(ne) {
          return (D.newline ? F('display', -1) : F('text', ne), '');
        }
        s(W, 'newline');
        function ae(ne, de) {
          ((k = !0), de.trim().length === 0 && (de = '0'), (de = de.trimRight(';').split(';')));
          var ye = i(de),
            pe;
          try {
            for (ye.s(); !(pe = ye.n()).done; ) {
              var Fe = pe.value;
              F('display', Fe);
            }
          } catch (it) {
            ye.e(it);
          } finally {
            ye.f();
          }
          return '';
        }
        s(ae, 'ansiMess');
        function be(ne) {
          return (F('text', ne), '');
        }
        s(be, 'realText');
        function ue(ne) {
          return (F('rgb', ne), '');
        }
        s(ue, 'rgb');
        var ee = [
          { pattern: /^\x08+/, sub: X },
          { pattern: /^\x1b\[[012]?K/, sub: X },
          { pattern: /^\x1b\[\(B/, sub: X },
          { pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/, sub: ue },
          { pattern: /^\x1b\[38;5;(\d+)m/, sub: se },
          { pattern: /^\x1b\[48;5;(\d+)m/, sub: ie },
          { pattern: /^\n/, sub: W },
          { pattern: /^\r+\n/, sub: W },
          { pattern: /^\r/, sub: W },
          { pattern: /^\x1b\[((?:\d{1,3};?)+|)m/, sub: ae },
          { pattern: /^\x1b\[\d?J/, sub: X },
          { pattern: /^\x1b\[\d{0,3};\d{0,3}f/, sub: X },
          { pattern: /^\x1b\[?[\d;]{0,3}/, sub: X },
          { pattern: /^(([^\x1b\x08\r\n])+)/, sub: be },
        ];
        function Pe(ne, de) {
          (de > K && k) || ((k = !1), (P = P.replace(ne.pattern, ne.sub)));
        }
        s(Pe, 'process');
        var xe = [],
          He = P,
          Xe = He.length;
        e: for (; Xe > 0; ) {
          for (var J = 0, Q = 0, re = ee.length; Q < re; J = ++Q) {
            var oe = ee[J];
            if ((Pe(oe, J), P.length !== Xe)) {
              Xe = P.length;
              continue e;
            }
          }
          if (P.length === Xe) break;
          (xe.push(0), (Xe = P.length));
        }
        return xe;
      }
      s(N, 'tokenize');
      function V(P, D, F) {
        return (
          D !== 'text' && ((P = P.filter(R(I(F)))), P.push({ token: D, data: F, category: I(F) })),
          P
        );
      }
      s(V, 'updateStickyStack');
      var H = (function () {
        function P(D) {
          (r(this, P),
            (D = D || {}),
            D.colors && (D.colors = Object.assign({}, u.colors, D.colors)),
            (this.options = Object.assign({}, u, D)),
            (this.stack = []),
            (this.stickyStack = []));
        }
        return (
          s(P, 'Filter'),
          o(P, [
            {
              key: 'toHtml',
              value: s(function (F) {
                var k = this;
                F = typeof F == 'string' ? [F] : F;
                var K = this.stack,
                  X = this.options,
                  se = [];
                return (
                  this.stickyStack.forEach(function (ie) {
                    var W = g(K, ie.token, ie.data, X);
                    W && se.push(W);
                  }),
                  N(F.join(''), X, function (ie, W) {
                    var ae = g(K, ie, W, X);
                    (ae && se.push(ae), X.stream && (k.stickyStack = V(k.stickyStack, ie, W)));
                  }),
                  K.length && se.push(b(K)),
                  se.join('')
                );
              }, 'toHtml'),
            },
          ]),
          P
        );
      })();
      t.exports = H;
    },
  }),
  P1 = B({
    '../node_modules/jsdoc-type-pratt-parser/dist/index.js'(e, t) {
      (function (r, n) {
        typeof e == 'object' && typeof t < 'u'
          ? n(e)
          : typeof define == 'function' && define.amd
            ? define(['exports'], n)
            : ((r = typeof globalThis < 'u' ? globalThis : r || self), n((r.jtpp = {})));
      })(e, function (r) {
        function n(c) {
          return c.text !== void 0 && c.text !== ''
            ? `'${c.type}' with value '${c.text}'`
            : `'${c.type}'`;
        }
        s(n, 'tokenToString');
        const o = class Xv extends Error {
          constructor(y) {
            (super(`No parslet found for token: ${n(y)}`),
              (this.token = y),
              Object.setPrototypeOf(this, Xv.prototype));
          }
          getToken() {
            return this.token;
          }
        };
        s(o, 'NoParsletFoundError');
        let i = o;
        const a = class Qv extends Error {
          constructor(y) {
            (super(`The parsing ended early. The next token was: ${n(y)}`),
              (this.token = y),
              Object.setPrototypeOf(this, Qv.prototype));
          }
          getToken() {
            return this.token;
          }
        };
        s(a, 'EarlyEndOfParseError');
        let l = a;
        const d = class Zv extends Error {
          constructor(y, T) {
            let C = `Unexpected type: '${y.type}'.`;
            (T !== void 0 && (C += ` Message: ${T}`),
              super(C),
              Object.setPrototypeOf(this, Zv.prototype));
          }
        };
        s(d, 'UnexpectedTypeError');
        let u = d;
        function p(c) {
          return (y) => (y.startsWith(c) ? { type: c, text: c } : null);
        }
        s(p, 'makePunctuationRule');
        function f(c) {
          let y = 0,
            T;
          const C = c[0];
          let L = !1;
          if (C !== "'" && C !== '"') return null;
          for (; y < c.length; ) {
            if ((y++, (T = c[y]), !L && T === C)) {
              y++;
              break;
            }
            L = !L && T === '\\';
          }
          if (T !== C) throw new Error('Unterminated String');
          return c.slice(0, y);
        }
        s(f, 'getQuoted');
        const m = new RegExp(
            '[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
            'u',
          ),
          h = new RegExp(
            '[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
            'u',
          );
        function g(c) {
          let y = c[0];
          if (!m.test(y)) return null;
          let T = 1;
          do {
            if (((y = c[T]), !h.test(y))) break;
            T++;
          } while (T < c.length);
          return c.slice(0, T);
        }
        s(g, 'getIdentifier');
        const v = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
        function E(c) {
          var y, T;
          return (T = (y = v.exec(c)) === null || y === void 0 ? void 0 : y[0]) !== null &&
            T !== void 0
            ? T
            : null;
        }
        s(E, 'getNumber');
        const b = s((c) => {
          const y = g(c);
          return y == null ? null : { type: 'Identifier', text: y };
        }, 'identifierRule');
        function S(c) {
          return (y) => {
            if (!y.startsWith(c)) return null;
            const T = y[c.length];
            return T !== void 0 && h.test(T) ? null : { type: c, text: c };
          };
        }
        s(S, 'makeKeyWordRule');
        const R = s((c) => {
            const y = f(c);
            return y == null ? null : { type: 'StringValue', text: y };
          }, 'stringValueRule'),
          I = s((c) => (c.length > 0 ? null : { type: 'EOF', text: '' }), 'eofRule'),
          $ = s((c) => {
            const y = E(c);
            return y === null ? null : { type: 'Number', text: y };
          }, 'numberRule'),
          x = [
            I,
            p('=>'),
            p('('),
            p(')'),
            p('{'),
            p('}'),
            p('['),
            p(']'),
            p('|'),
            p('&'),
            p('<'),
            p('>'),
            p(','),
            p(';'),
            p('*'),
            p('?'),
            p('!'),
            p('='),
            p(':'),
            p('...'),
            p('.'),
            p('#'),
            p('~'),
            p('/'),
            p('@'),
            S('undefined'),
            S('null'),
            S('function'),
            S('this'),
            S('new'),
            S('module'),
            S('event'),
            S('extends'),
            S('external'),
            S('infer'),
            S('typeof'),
            S('keyof'),
            S('readonly'),
            S('import'),
            S('is'),
            S('in'),
            S('asserts'),
            $,
            b,
            R,
          ],
          A = /^\s*\n\s*/,
          w = class ea {
            static create(y) {
              const T = this.read(y);
              y = T.text;
              const C = this.read(y);
              return ((y = C.text), new ea(y, void 0, T.token, C.token));
            }
            constructor(y, T, C, L) {
              ((this.text = ''),
                (this.text = y),
                (this.previous = T),
                (this.current = C),
                (this.next = L));
            }
            static read(y, T = !1) {
              ((T = T || A.test(y)), (y = y.trim()));
              for (const C of x) {
                const L = C(y);
                if (L !== null) {
                  const G = Object.assign(Object.assign({}, L), { startOfLine: T });
                  return ((y = y.slice(G.text.length)), { text: y, token: G });
                }
              }
              throw new Error('Unexpected Token ' + y);
            }
            advance() {
              const y = ea.read(this.text);
              return new ea(y.text, this.current, this.next, y.token);
            }
          };
        s(w, 'Lexer');
        let _ = w;
        function j(c) {
          if (c === void 0) throw new Error('Unexpected undefined');
          if (
            c.type === 'JsdocTypeKeyValue' ||
            c.type === 'JsdocTypeParameterList' ||
            c.type === 'JsdocTypeProperty' ||
            c.type === 'JsdocTypeReadonlyProperty' ||
            c.type === 'JsdocTypeObjectField' ||
            c.type === 'JsdocTypeJsdocObjectField' ||
            c.type === 'JsdocTypeIndexSignature' ||
            c.type === 'JsdocTypeMappedType' ||
            c.type === 'JsdocTypeTypeParameter'
          )
            throw new u(c);
          return c;
        }
        s(j, 'assertRootResult');
        function N(c) {
          return c.type === 'JsdocTypeKeyValue' ? H(c) : j(c);
        }
        s(N, 'assertPlainKeyValueOrRootResult');
        function V(c) {
          return c.type === 'JsdocTypeName' ? c : H(c);
        }
        s(V, 'assertPlainKeyValueOrNameResult');
        function H(c) {
          if (c.type !== 'JsdocTypeKeyValue') throw new u(c);
          return c;
        }
        s(H, 'assertPlainKeyValueResult');
        function P(c) {
          var y;
          if (c.type === 'JsdocTypeVariadic') {
            if (((y = c.element) === null || y === void 0 ? void 0 : y.type) === 'JsdocTypeName')
              return c;
            throw new u(c);
          }
          if (c.type !== 'JsdocTypeNumber' && c.type !== 'JsdocTypeName') throw new u(c);
          return c;
        }
        s(P, 'assertNumberOrVariadicNameResult');
        function D(c) {
          if (
            c.type === 'JsdocTypeTuple' ||
            (c.type === 'JsdocTypeGeneric' && c.meta.brackets === 'square')
          )
            return c;
          throw new u(c);
        }
        s(D, 'assertArrayOrTupleResult');
        function F(c) {
          return c.type === 'JsdocTypeIndexSignature' || c.type === 'JsdocTypeMappedType';
        }
        s(F, 'isSquaredProperty');
        var k;
        (function (c) {
          ((c[(c.ALL = 0)] = 'ALL'),
            (c[(c.PARAMETER_LIST = 1)] = 'PARAMETER_LIST'),
            (c[(c.OBJECT = 2)] = 'OBJECT'),
            (c[(c.KEY_VALUE = 3)] = 'KEY_VALUE'),
            (c[(c.INDEX_BRACKETS = 4)] = 'INDEX_BRACKETS'),
            (c[(c.UNION = 5)] = 'UNION'),
            (c[(c.INTERSECTION = 6)] = 'INTERSECTION'),
            (c[(c.PREFIX = 7)] = 'PREFIX'),
            (c[(c.INFIX = 8)] = 'INFIX'),
            (c[(c.TUPLE = 9)] = 'TUPLE'),
            (c[(c.SYMBOL = 10)] = 'SYMBOL'),
            (c[(c.OPTIONAL = 11)] = 'OPTIONAL'),
            (c[(c.NULLABLE = 12)] = 'NULLABLE'),
            (c[(c.KEY_OF_TYPE_OF = 13)] = 'KEY_OF_TYPE_OF'),
            (c[(c.FUNCTION = 14)] = 'FUNCTION'),
            (c[(c.ARROW = 15)] = 'ARROW'),
            (c[(c.ARRAY_BRACKETS = 16)] = 'ARRAY_BRACKETS'),
            (c[(c.GENERIC = 17)] = 'GENERIC'),
            (c[(c.NAME_PATH = 18)] = 'NAME_PATH'),
            (c[(c.PARENTHESIS = 19)] = 'PARENTHESIS'),
            (c[(c.SPECIAL_TYPES = 20)] = 'SPECIAL_TYPES'));
        })(k || (k = {}));
        const K = class {
          constructor(y, T, C) {
            ((this.grammar = y),
              typeof T == 'string' ? (this._lexer = _.create(T)) : (this._lexer = T),
              (this.baseParser = C));
          }
          get lexer() {
            return this._lexer;
          }
          parse() {
            const y = this.parseType(k.ALL);
            if (this.lexer.current.type !== 'EOF') throw new l(this.lexer.current);
            return y;
          }
          parseType(y) {
            return j(this.parseIntermediateType(y));
          }
          parseIntermediateType(y) {
            const T = this.tryParslets(null, y);
            if (T === null) throw new i(this.lexer.current);
            return this.parseInfixIntermediateType(T, y);
          }
          parseInfixIntermediateType(y, T) {
            let C = this.tryParslets(y, T);
            for (; C !== null; ) ((y = C), (C = this.tryParslets(y, T)));
            return y;
          }
          tryParslets(y, T) {
            for (const C of this.grammar) {
              const L = C(this, T, y);
              if (L !== null) return L;
            }
            return null;
          }
          consume(y) {
            return (
              Array.isArray(y) || (y = [y]),
              y.includes(this.lexer.current.type) ? ((this._lexer = this.lexer.advance()), !0) : !1
            );
          }
          acceptLexerState(y) {
            this._lexer = y.lexer;
          }
        };
        s(K, 'Parser');
        let X = K;
        function se(c) {
          return c === '}' || c === 'EOF' || c === '|' || c === ',' || c === ')' || c === '>';
        }
        s(se, 'isQuestionMarkUnknownType');
        const ie = s((c, y, T) => {
          const C = c.lexer.current.type,
            L = c.lexer.next.type;
          return (T == null && C === '?' && !se(L)) || (T != null && C === '?')
            ? (c.consume('?'),
              T == null
                ? {
                    type: 'JsdocTypeNullable',
                    element: c.parseType(k.NULLABLE),
                    meta: { position: 'prefix' },
                  }
                : { type: 'JsdocTypeNullable', element: j(T), meta: { position: 'suffix' } })
            : null;
        }, 'nullableParslet');
        function W(c) {
          const y = s((T, C, L) => {
            const G = T.lexer.current.type,
              Z = T.lexer.next.type;
            if (L === null) {
              if ('parsePrefix' in c && c.accept(G, Z)) return c.parsePrefix(T);
            } else if ('parseInfix' in c && c.precedence > C && c.accept(G, Z))
              return c.parseInfix(T, L);
            return null;
          }, 'parslet');
          return (Object.defineProperty(y, 'name', { value: c.name }), y);
        }
        s(W, 'composeParslet');
        const ae = W({
            name: 'optionalParslet',
            accept: s((c) => c === '=', 'accept'),
            precedence: k.OPTIONAL,
            parsePrefix: s(
              (c) => (
                c.consume('='),
                {
                  type: 'JsdocTypeOptional',
                  element: c.parseType(k.OPTIONAL),
                  meta: { position: 'prefix' },
                }
              ),
              'parsePrefix',
            ),
            parseInfix: s(
              (c, y) => (
                c.consume('='),
                { type: 'JsdocTypeOptional', element: j(y), meta: { position: 'suffix' } }
              ),
              'parseInfix',
            ),
          }),
          be = W({
            name: 'numberParslet',
            accept: s((c) => c === 'Number', 'accept'),
            parsePrefix: s((c) => {
              const y = parseFloat(c.lexer.current.text);
              return (c.consume('Number'), { type: 'JsdocTypeNumber', value: y });
            }, 'parsePrefix'),
          }),
          ue = W({
            name: 'parenthesisParslet',
            accept: s((c) => c === '(', 'accept'),
            parsePrefix: s((c) => {
              if ((c.consume('('), c.consume(')')))
                return { type: 'JsdocTypeParameterList', elements: [] };
              const y = c.parseIntermediateType(k.ALL);
              if (!c.consume(')')) throw new Error('Unterminated parenthesis');
              return y.type === 'JsdocTypeParameterList'
                ? y
                : y.type === 'JsdocTypeKeyValue'
                  ? { type: 'JsdocTypeParameterList', elements: [y] }
                  : { type: 'JsdocTypeParenthesis', element: j(y) };
            }, 'parsePrefix'),
          }),
          ee = W({
            name: 'specialTypesParslet',
            accept: s(
              (c, y) => (c === '?' && se(y)) || c === 'null' || c === 'undefined' || c === '*',
              'accept',
            ),
            parsePrefix: s((c) => {
              if (c.consume('null')) return { type: 'JsdocTypeNull' };
              if (c.consume('undefined')) return { type: 'JsdocTypeUndefined' };
              if (c.consume('*')) return { type: 'JsdocTypeAny' };
              if (c.consume('?')) return { type: 'JsdocTypeUnknown' };
              throw new Error('Unacceptable token: ' + c.lexer.current.text);
            }, 'parsePrefix'),
          }),
          Pe = W({
            name: 'notNullableParslet',
            accept: s((c) => c === '!', 'accept'),
            precedence: k.NULLABLE,
            parsePrefix: s(
              (c) => (
                c.consume('!'),
                {
                  type: 'JsdocTypeNotNullable',
                  element: c.parseType(k.NULLABLE),
                  meta: { position: 'prefix' },
                }
              ),
              'parsePrefix',
            ),
            parseInfix: s(
              (c, y) => (
                c.consume('!'),
                { type: 'JsdocTypeNotNullable', element: j(y), meta: { position: 'suffix' } }
              ),
              'parseInfix',
            ),
          });
        function xe({ allowTrailingComma: c }) {
          return W({
            name: 'parameterListParslet',
            accept: s((y) => y === ',', 'accept'),
            precedence: k.PARAMETER_LIST,
            parseInfix: s((y, T) => {
              const C = [N(T)];
              y.consume(',');
              do
                try {
                  const L = y.parseIntermediateType(k.PARAMETER_LIST);
                  C.push(N(L));
                } catch (L) {
                  if (L instanceof i) break;
                  throw L;
                }
              while (y.consume(','));
              if (C.length > 0 && C.slice(0, -1).some((L) => L.type === 'JsdocTypeVariadic'))
                throw new Error('Only the last parameter may be a rest parameter');
              return { type: 'JsdocTypeParameterList', elements: C };
            }, 'parseInfix'),
          });
        }
        s(xe, 'createParameterListParslet');
        const He = W({
            name: 'genericParslet',
            accept: s((c, y) => c === '<' || (c === '.' && y === '<'), 'accept'),
            precedence: k.GENERIC,
            parseInfix: s((c, y) => {
              const T = c.consume('.');
              c.consume('<');
              const C = [];
              let L = !1;
              if (c.consume('infer')) {
                L = !0;
                const G = c.parseIntermediateType(k.SYMBOL);
                if (G.type !== 'JsdocTypeName')
                  throw new u(
                    G,
                    'A typescript asserts always has to have a name on the left side.',
                  );
                C.push(G);
              } else
                do C.push(c.parseType(k.PARAMETER_LIST));
                while (c.consume(','));
              if (!c.consume('>')) throw new Error('Unterminated generic parameter list');
              return Object.assign(
                Object.assign(
                  { type: 'JsdocTypeGeneric', left: j(y), elements: C },
                  L ? { infer: !0 } : {},
                ),
                { meta: { brackets: 'angle', dot: T } },
              );
            }, 'parseInfix'),
          }),
          Xe = W({
            name: 'unionParslet',
            accept: s((c) => c === '|', 'accept'),
            precedence: k.UNION,
            parseInfix: s((c, y) => {
              c.consume('|');
              const T = [];
              do T.push(c.parseType(k.UNION));
              while (c.consume('|'));
              return { type: 'JsdocTypeUnion', elements: [j(y), ...T] };
            }, 'parseInfix'),
          }),
          J = [ie, ae, be, ue, ee, Pe, xe({ allowTrailingComma: !0 }), He, Xe, ae];
        function Q({ allowSquareBracketsOnAnyType: c, allowJsdocNamePaths: y, pathGrammar: T }) {
          return s(function (L, G, Z) {
            if (Z == null || G >= k.NAME_PATH) return null;
            const ce = L.lexer.current.type,
              _e = L.lexer.next.type;
            if (
              !(
                (ce === '.' && _e !== '<') ||
                (ce === '[' && (c || Z.type === 'JsdocTypeName')) ||
                (y && (ce === '~' || ce === '#'))
              )
            )
              return null;
            let $e,
              br = !1;
            L.consume('.')
              ? ($e = 'property')
              : L.consume('[')
                ? (($e = 'property-brackets'), (br = !0))
                : L.consume('~')
                  ? ($e = 'inner')
                  : (L.consume('#'), ($e = 'instance'));
            const Es = T !== null ? new X(T, L.lexer, L) : L,
              et = Es.parseIntermediateType(k.NAME_PATH);
            L.acceptLexerState(Es);
            let Gt;
            switch (et.type) {
              case 'JsdocTypeName':
                Gt = { type: 'JsdocTypeProperty', value: et.value, meta: { quote: void 0 } };
                break;
              case 'JsdocTypeNumber':
                Gt = {
                  type: 'JsdocTypeProperty',
                  value: et.value.toString(10),
                  meta: { quote: void 0 },
                };
                break;
              case 'JsdocTypeStringValue':
                Gt = { type: 'JsdocTypeProperty', value: et.value, meta: { quote: et.meta.quote } };
                break;
              case 'JsdocTypeSpecialNamePath':
                if (et.specialType === 'event') Gt = et;
                else
                  throw new u(
                    et,
                    "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'",
                  );
                break;
              default:
                throw new u(
                  et,
                  "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'",
                );
            }
            if (br && !L.consume(']')) {
              const ws = L.lexer.current;
              throw new Error(
                `Unterminated square brackets. Next token is '${ws.type}' with text '${ws.text}'`,
              );
            }
            return { type: 'JsdocTypeNamePath', left: j(Z), right: Gt, pathType: $e };
          }, 'namePathParslet');
        }
        s(Q, 'createNamePathParslet');
        function re({ allowedAdditionalTokens: c }) {
          return W({
            name: 'nameParslet',
            accept: s(
              (y) => y === 'Identifier' || y === 'this' || y === 'new' || c.includes(y),
              'accept',
            ),
            parsePrefix: s((y) => {
              const { type: T, text: C } = y.lexer.current;
              return (y.consume(T), { type: 'JsdocTypeName', value: C });
            }, 'parsePrefix'),
          });
        }
        s(re, 'createNameParslet');
        const oe = W({
          name: 'stringValueParslet',
          accept: s((c) => c === 'StringValue', 'accept'),
          parsePrefix: s((c) => {
            const y = c.lexer.current.text;
            return (
              c.consume('StringValue'),
              {
                type: 'JsdocTypeStringValue',
                value: y.slice(1, -1),
                meta: { quote: y[0] === "'" ? 'single' : 'double' },
              }
            );
          }, 'parsePrefix'),
        });
        function ne({ pathGrammar: c, allowedTypes: y }) {
          return W({
            name: 'specialNamePathParslet',
            accept: s((T) => y.includes(T), 'accept'),
            parsePrefix: s((T) => {
              const C = T.lexer.current.type;
              if ((T.consume(C), !T.consume(':'))) return { type: 'JsdocTypeName', value: C };
              let L,
                G = T.lexer.current;
              if (T.consume('StringValue'))
                L = {
                  type: 'JsdocTypeSpecialNamePath',
                  value: G.text.slice(1, -1),
                  specialType: C,
                  meta: { quote: G.text[0] === "'" ? 'single' : 'double' },
                };
              else {
                let _e = '';
                const Te = ['Identifier', '@', '/'];
                for (; Te.some(($e) => T.consume($e)); ) ((_e += G.text), (G = T.lexer.current));
                L = {
                  type: 'JsdocTypeSpecialNamePath',
                  value: _e,
                  specialType: C,
                  meta: { quote: void 0 },
                };
              }
              const Z = new X(c, T.lexer, T),
                ce = Z.parseInfixIntermediateType(L, k.ALL);
              return (T.acceptLexerState(Z), j(ce));
            }, 'parsePrefix'),
          });
        }
        s(ne, 'createSpecialNamePathParslet');
        const de = [
            re({ allowedAdditionalTokens: ['external', 'module'] }),
            oe,
            be,
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: null }),
          ],
          ye = [...de, ne({ allowedTypes: ['event'], pathGrammar: de })];
        function pe(c) {
          let y;
          if (c.type === 'JsdocTypeParameterList') y = c.elements;
          else if (c.type === 'JsdocTypeParenthesis') y = [c.element];
          else throw new u(c);
          return y.map((T) => N(T));
        }
        s(pe, 'getParameters');
        function Fe(c) {
          const y = pe(c);
          if (y.some((T) => T.type === 'JsdocTypeKeyValue'))
            throw new Error('No parameter should be named');
          return y;
        }
        s(Fe, 'getUnnamedParameters');
        function it({
          allowNamedParameters: c,
          allowNoReturnType: y,
          allowWithoutParenthesis: T,
          allowNewAsFunctionKeyword: C,
        }) {
          return W({
            name: 'functionParslet',
            accept: s((L, G) => L === 'function' || (C && L === 'new' && G === '('), 'accept'),
            parsePrefix: s((L) => {
              const G = L.consume('new');
              L.consume('function');
              const Z = L.lexer.current.type === '(';
              if (!Z) {
                if (!T) throw new Error('function is missing parameter list');
                return { type: 'JsdocTypeName', value: 'function' };
              }
              let ce = {
                type: 'JsdocTypeFunction',
                parameters: [],
                arrow: !1,
                constructor: G,
                parenthesis: Z,
              };
              const _e = L.parseIntermediateType(k.FUNCTION);
              if (c === void 0) ce.parameters = Fe(_e);
              else {
                if (G && _e.type === 'JsdocTypeFunction' && _e.arrow)
                  return ((ce = _e), (ce.constructor = !0), ce);
                ce.parameters = pe(_e);
                for (const Te of ce.parameters)
                  if (Te.type === 'JsdocTypeKeyValue' && !c.includes(Te.key))
                    throw new Error(
                      `only allowed named parameters are ${c.join(', ')} but got ${Te.type}`,
                    );
              }
              if (L.consume(':')) ce.returnType = L.parseType(k.PREFIX);
              else if (!y) throw new Error('function is missing return type');
              return ce;
            }, 'parsePrefix'),
          });
        }
        s(it, 'createFunctionParslet');
        function yt({ allowPostfix: c, allowEnclosingBrackets: y }) {
          return W({
            name: 'variadicParslet',
            accept: s((T) => T === '...', 'accept'),
            precedence: k.PREFIX,
            parsePrefix: s((T) => {
              T.consume('...');
              const C = y && T.consume('[');
              try {
                const L = T.parseType(k.PREFIX);
                if (C && !T.consume(']'))
                  throw new Error("Unterminated variadic type. Missing ']'");
                return {
                  type: 'JsdocTypeVariadic',
                  element: j(L),
                  meta: { position: 'prefix', squareBrackets: C },
                };
              } catch (L) {
                if (L instanceof i) {
                  if (C) throw new Error('Empty square brackets for variadic are not allowed.');
                  return {
                    type: 'JsdocTypeVariadic',
                    meta: { position: void 0, squareBrackets: !1 },
                  };
                } else throw L;
              }
            }, 'parsePrefix'),
            parseInfix: c
              ? (T, C) => (
                  T.consume('...'),
                  {
                    type: 'JsdocTypeVariadic',
                    element: j(C),
                    meta: { position: 'suffix', squareBrackets: !1 },
                  }
                )
              : void 0,
          });
        }
        s(yt, 'createVariadicParslet');
        const Pt = W({
            name: 'symbolParslet',
            accept: s((c) => c === '(', 'accept'),
            precedence: k.SYMBOL,
            parseInfix: s((c, y) => {
              if (y.type !== 'JsdocTypeName')
                throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
              c.consume('(');
              const T = { type: 'JsdocTypeSymbol', value: y.value };
              if (!c.consume(')')) {
                const C = c.parseIntermediateType(k.SYMBOL);
                if (((T.element = P(C)), !c.consume(')')))
                  throw new Error('Symbol does not end after value');
              }
              return T;
            }, 'parseInfix'),
          }),
          at = W({
            name: 'arrayBracketsParslet',
            precedence: k.ARRAY_BRACKETS,
            accept: s((c, y) => c === '[' && y === ']', 'accept'),
            parseInfix: s(
              (c, y) => (
                c.consume('['),
                c.consume(']'),
                {
                  type: 'JsdocTypeGeneric',
                  left: { type: 'JsdocTypeName', value: 'Array' },
                  elements: [j(y)],
                  meta: { brackets: 'square', dot: !1 },
                }
              ),
              'parseInfix',
            ),
          });
        function ht({ objectFieldGrammar: c, allowKeyTypes: y }) {
          return W({
            name: 'objectParslet',
            accept: s((T) => T === '{', 'accept'),
            parsePrefix: s((T) => {
              T.consume('{');
              const C = { type: 'JsdocTypeObject', meta: { separator: 'comma' }, elements: [] };
              if (!T.consume('}')) {
                let L;
                const G = new X(c, T.lexer, T);
                for (;;) {
                  G.acceptLexerState(T);
                  let Z = G.parseIntermediateType(k.OBJECT);
                  (T.acceptLexerState(G),
                    Z === void 0 && y && (Z = T.parseIntermediateType(k.OBJECT)));
                  let ce = !1;
                  if (
                    (Z.type === 'JsdocTypeNullable' && ((ce = !0), (Z = Z.element)),
                    Z.type === 'JsdocTypeNumber' ||
                      Z.type === 'JsdocTypeName' ||
                      Z.type === 'JsdocTypeStringValue')
                  ) {
                    let Te;
                    (Z.type === 'JsdocTypeStringValue' && (Te = Z.meta.quote),
                      C.elements.push({
                        type: 'JsdocTypeObjectField',
                        key: Z.value.toString(),
                        right: void 0,
                        optional: ce,
                        readonly: !1,
                        meta: { quote: Te },
                      }));
                  } else if (
                    Z.type === 'JsdocTypeObjectField' ||
                    Z.type === 'JsdocTypeJsdocObjectField'
                  )
                    C.elements.push(Z);
                  else throw new u(Z);
                  if (T.lexer.current.startOfLine)
                    ((L = 'linebreak'), T.consume(',') || T.consume(';'));
                  else if (T.consume(',')) L = 'comma';
                  else if (T.consume(';')) L = 'semicolon';
                  else break;
                  if (T.lexer.current.type === '}') break;
                }
                if (
                  ((C.meta.separator = L ?? 'comma'),
                  L === 'linebreak' && (C.meta.propertyIndent = '  '),
                  !T.consume('}'))
                )
                  throw new Error("Unterminated record type. Missing '}'");
              }
              return C;
            }, 'parsePrefix'),
          });
        }
        s(ht, 'createObjectParslet');
        function gt({
          allowSquaredProperties: c,
          allowKeyTypes: y,
          allowReadonly: T,
          allowOptional: C,
        }) {
          return W({
            name: 'objectFieldParslet',
            precedence: k.KEY_VALUE,
            accept: s((L) => L === ':', 'accept'),
            parseInfix: s((L, G) => {
              var Z;
              let ce = !1,
                _e = !1;
              (C && G.type === 'JsdocTypeNullable' && ((ce = !0), (G = G.element)),
                T && G.type === 'JsdocTypeReadonlyProperty' && ((_e = !0), (G = G.element)));
              const Te = (Z = L.baseParser) !== null && Z !== void 0 ? Z : L;
              if (
                (Te.acceptLexerState(L),
                G.type === 'JsdocTypeNumber' ||
                  G.type === 'JsdocTypeName' ||
                  G.type === 'JsdocTypeStringValue' ||
                  F(G))
              ) {
                if (F(G) && !c) throw new u(G);
                Te.consume(':');
                let $e;
                G.type === 'JsdocTypeStringValue' && ($e = G.meta.quote);
                const br = Te.parseType(k.KEY_VALUE);
                return (
                  L.acceptLexerState(Te),
                  {
                    type: 'JsdocTypeObjectField',
                    key: F(G) ? G : G.value.toString(),
                    right: br,
                    optional: ce,
                    readonly: _e,
                    meta: { quote: $e },
                  }
                );
              } else {
                if (!y) throw new u(G);
                Te.consume(':');
                const $e = Te.parseType(k.KEY_VALUE);
                return (
                  L.acceptLexerState(Te),
                  { type: 'JsdocTypeJsdocObjectField', left: j(G), right: $e }
                );
              }
            }, 'parseInfix'),
          });
        }
        s(gt, 'createObjectFieldParslet');
        function bt({ allowOptional: c, allowVariadic: y }) {
          return W({
            name: 'keyValueParslet',
            precedence: k.KEY_VALUE,
            accept: s((T) => T === ':', 'accept'),
            parseInfix: s((T, C) => {
              let L = !1,
                G = !1;
              if (
                (c && C.type === 'JsdocTypeNullable' && ((L = !0), (C = C.element)),
                y &&
                  C.type === 'JsdocTypeVariadic' &&
                  C.element !== void 0 &&
                  ((G = !0), (C = C.element)),
                C.type !== 'JsdocTypeName')
              )
                throw new u(C);
              T.consume(':');
              const Z = T.parseType(k.KEY_VALUE);
              return {
                type: 'JsdocTypeKeyValue',
                key: C.value,
                right: Z,
                optional: L,
                variadic: G,
              };
            }, 'parseInfix'),
          });
        }
        s(bt, 'createKeyValueParslet');
        const un = [
            ...J,
            it({
              allowWithoutParenthesis: !0,
              allowNamedParameters: ['this', 'new'],
              allowNoReturnType: !0,
              allowNewAsFunctionKeyword: !1,
            }),
            oe,
            ne({ allowedTypes: ['module', 'external', 'event'], pathGrammar: ye }),
            yt({ allowEnclosingBrackets: !0, allowPostfix: !0 }),
            re({ allowedAdditionalTokens: ['keyof'] }),
            Pt,
            at,
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
          ],
          Qo = [
            ...un,
            ht({
              objectFieldGrammar: [
                re({ allowedAdditionalTokens: ['typeof', 'module', 'in'] }),
                gt({
                  allowSquaredProperties: !1,
                  allowKeyTypes: !0,
                  allowOptional: !1,
                  allowReadonly: !1,
                }),
                ...un,
              ],
              allowKeyTypes: !0,
            }),
            bt({ allowOptional: !0, allowVariadic: !0 }),
          ],
          dn = W({
            name: 'typeOfParslet',
            accept: s((c) => c === 'typeof', 'accept'),
            parsePrefix: s(
              (c) => (
                c.consume('typeof'),
                { type: 'JsdocTypeTypeof', element: c.parseType(k.KEY_OF_TYPE_OF) }
              ),
              'parsePrefix',
            ),
          }),
          Zo = [
            re({
              allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'],
            }),
            ie,
            ae,
            oe,
            be,
            gt({
              allowSquaredProperties: !1,
              allowKeyTypes: !1,
              allowOptional: !1,
              allowReadonly: !1,
            }),
          ],
          es = [
            ...J,
            ht({ allowKeyTypes: !1, objectFieldGrammar: Zo }),
            re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
            dn,
            it({
              allowWithoutParenthesis: !1,
              allowNamedParameters: ['this', 'new'],
              allowNoReturnType: !0,
              allowNewAsFunctionKeyword: !1,
            }),
            yt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
            re({ allowedAdditionalTokens: ['keyof'] }),
            ne({ allowedTypes: ['module'], pathGrammar: ye }),
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
            bt({ allowOptional: !1, allowVariadic: !1 }),
            Pt,
          ],
          ts = W({
            name: 'assertsParslet',
            accept: s((c) => c === 'asserts', 'accept'),
            parsePrefix: s((c) => {
              c.consume('asserts');
              const y = c.parseIntermediateType(k.SYMBOL);
              if (y.type !== 'JsdocTypeName')
                throw new u(y, 'A typescript asserts always has to have a name on the left side.');
              return c.consume('is')
                ? { type: 'JsdocTypeAsserts', left: y, right: j(c.parseIntermediateType(k.INFIX)) }
                : { type: 'JsdocTypeAssertsPlain', element: y };
            }, 'parsePrefix'),
          });
        function pn({ allowQuestionMark: c }) {
          return W({
            name: 'tupleParslet',
            accept: s((y) => y === '[', 'accept'),
            parsePrefix: s((y) => {
              y.consume('[');
              const T = { type: 'JsdocTypeTuple', elements: [] };
              if (y.consume(']')) return T;
              const C = y.parseIntermediateType(k.ALL);
              if (
                (C.type === 'JsdocTypeParameterList'
                  ? C.elements[0].type === 'JsdocTypeKeyValue'
                    ? (T.elements = C.elements.map(H))
                    : (T.elements = C.elements.map(j))
                  : C.type === 'JsdocTypeKeyValue'
                    ? (T.elements = [H(C)])
                    : (T.elements = [j(C)]),
                !y.consume(']'))
              )
                throw new Error("Unterminated '['");
              if (T.elements.some((L) => L.type === 'JsdocTypeUnknown'))
                throw new Error('Question mark in tuple not allowed');
              return T;
            }, 'parsePrefix'),
          });
        }
        s(pn, 'createTupleParslet');
        const rs = W({
            name: 'keyOfParslet',
            accept: s((c) => c === 'keyof', 'accept'),
            parsePrefix: s(
              (c) => (
                c.consume('keyof'),
                { type: 'JsdocTypeKeyof', element: j(c.parseType(k.KEY_OF_TYPE_OF)) }
              ),
              'parsePrefix',
            ),
          }),
          ns = W({
            name: 'importParslet',
            accept: s((c) => c === 'import', 'accept'),
            parsePrefix: s((c) => {
              if ((c.consume('import'), !c.consume('(')))
                throw new Error('Missing parenthesis after import keyword');
              const y = c.parseType(k.PREFIX);
              if (y.type !== 'JsdocTypeStringValue')
                throw new Error('Only string values are allowed as paths for imports');
              if (!c.consume(')'))
                throw new Error('Missing closing parenthesis after import keyword');
              return { type: 'JsdocTypeImport', element: y };
            }, 'parsePrefix'),
          }),
          os = W({
            name: 'readonlyPropertyParslet',
            accept: s((c) => c === 'readonly', 'accept'),
            parsePrefix: s(
              (c) => (
                c.consume('readonly'),
                { type: 'JsdocTypeReadonlyProperty', element: c.parseIntermediateType(k.KEY_VALUE) }
              ),
              'parsePrefix',
            ),
          }),
          ss = W({
            name: 'arrowFunctionParslet',
            precedence: k.ARROW,
            accept: s((c) => c === '=>', 'accept'),
            parseInfix: s(
              (c, y) => (
                c.consume('=>'),
                {
                  type: 'JsdocTypeFunction',
                  parameters: pe(y).map(V),
                  arrow: !0,
                  constructor: !1,
                  parenthesis: !0,
                  returnType: c.parseType(k.OBJECT),
                }
              ),
              'parseInfix',
            ),
          }),
          is = W({
            name: 'genericArrowFunctionParslet',
            accept: s((c) => c === '<', 'accept'),
            parsePrefix: s((c) => {
              const y = [];
              c.consume('<');
              do {
                let C,
                  L = c.parseIntermediateType(k.SYMBOL);
                if (
                  (L.type === 'JsdocTypeOptional' && ((L = L.element), (C = c.parseType(k.SYMBOL))),
                  L.type !== 'JsdocTypeName')
                )
                  throw new u(L);
                let G;
                c.consume('extends') &&
                  ((G = c.parseType(k.SYMBOL)),
                  G.type === 'JsdocTypeOptional' && ((G = G.element), (C = c.parseType(k.SYMBOL))));
                const Z = { type: 'JsdocTypeTypeParameter', name: L };
                if (
                  (G !== void 0 && (Z.constraint = G),
                  C !== void 0 && (Z.defaultValue = C),
                  y.push(Z),
                  c.consume('>'))
                )
                  break;
              } while (c.consume(','));
              const T = c.parseIntermediateType(k.SYMBOL);
              return ((T.typeParameters = y), T);
            }, 'parsePrefix'),
          }),
          as = W({
            name: 'intersectionParslet',
            accept: s((c) => c === '&', 'accept'),
            precedence: k.INTERSECTION,
            parseInfix: s((c, y) => {
              c.consume('&');
              const T = [];
              do T.push(c.parseType(k.INTERSECTION));
              while (c.consume('&'));
              return { type: 'JsdocTypeIntersection', elements: [j(y), ...T] };
            }, 'parseInfix'),
          }),
          ls = W({
            name: 'predicateParslet',
            precedence: k.INFIX,
            accept: s((c) => c === 'is', 'accept'),
            parseInfix: s((c, y) => {
              if (y.type !== 'JsdocTypeName')
                throw new u(
                  y,
                  'A typescript predicate always has to have a name on the left side.',
                );
              return (
                c.consume('is'),
                { type: 'JsdocTypePredicate', left: y, right: j(c.parseIntermediateType(k.INFIX)) }
              );
            }, 'parseInfix'),
          }),
          cs = W({
            name: 'objectSquareBracketPropertyParslet',
            accept: s((c) => c === '[', 'accept'),
            parsePrefix: s((c) => {
              if (c.baseParser === void 0) throw new Error('Only allowed inside object grammar');
              c.consume('[');
              const y = c.lexer.current.text;
              c.consume('Identifier');
              let T;
              if (c.consume(':')) {
                const C = c.baseParser;
                (C.acceptLexerState(c),
                  (T = {
                    type: 'JsdocTypeIndexSignature',
                    key: y,
                    right: C.parseType(k.INDEX_BRACKETS),
                  }),
                  c.acceptLexerState(C));
              } else if (c.consume('in')) {
                const C = c.baseParser;
                (C.acceptLexerState(c),
                  (T = {
                    type: 'JsdocTypeMappedType',
                    key: y,
                    right: C.parseType(k.ARRAY_BRACKETS),
                  }),
                  c.acceptLexerState(C));
              } else throw new Error("Missing ':' or 'in' inside square bracketed property.");
              if (!c.consume(']')) throw new Error('Unterminated square brackets');
              return T;
            }, 'parsePrefix'),
          }),
          us = W({
            name: 'readonlyArrayParslet',
            accept: s((c) => c === 'readonly', 'accept'),
            parsePrefix: s(
              (c) => (
                c.consume('readonly'),
                { type: 'JsdocTypeReadonlyArray', element: D(c.parseIntermediateType(k.ALL)) }
              ),
              'parsePrefix',
            ),
          }),
          ds = W({
            name: 'conditionalParslet',
            precedence: k.INFIX,
            accept: s((c) => c === 'extends', 'accept'),
            parseInfix: s((c, y) => {
              c.consume('extends');
              const T = c.parseType(k.KEY_OF_TYPE_OF).element,
                C = c.parseType(k.INFIX);
              return (
                c.consume(':'),
                {
                  type: 'JsdocTypeConditional',
                  checksType: j(y),
                  extendsType: T,
                  trueType: C,
                  falseType: c.parseType(k.INFIX),
                }
              );
            }, 'parseInfix'),
          }),
          ps = [
            os,
            re({
              allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'],
            }),
            ie,
            ae,
            oe,
            be,
            gt({
              allowSquaredProperties: !0,
              allowKeyTypes: !1,
              allowOptional: !0,
              allowReadonly: !0,
            }),
            cs,
          ],
          fs = [
            ...J,
            ht({ allowKeyTypes: !1, objectFieldGrammar: ps }),
            us,
            dn,
            rs,
            ns,
            oe,
            it({
              allowWithoutParenthesis: !0,
              allowNoReturnType: !1,
              allowNamedParameters: ['this', 'new', 'args'],
              allowNewAsFunctionKeyword: !0,
            }),
            pn({ allowQuestionMark: !1 }),
            yt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
            ts,
            ds,
            re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
            ne({ allowedTypes: ['module'], pathGrammar: ye }),
            at,
            ss,
            is,
            Q({ allowSquareBracketsOnAnyType: !0, allowJsdocNamePaths: !1, pathGrammar: ye }),
            as,
            ls,
            bt({ allowVariadic: !0, allowOptional: !0 }),
          ];
        function yr(c, y) {
          switch (y) {
            case 'closure':
              return new X(es, c).parse();
            case 'jsdoc':
              return new X(Qo, c).parse();
            case 'typescript':
              return new X(fs, c).parse();
          }
        }
        s(yr, 'parse');
        function fn(c, y = ['typescript', 'closure', 'jsdoc']) {
          let T;
          for (const C of y)
            try {
              return yr(c, C);
            } catch (L) {
              T = L;
            }
          throw T;
        }
        s(fn, 'tryParse');
        function Y(c, y) {
          const T = c[y.type];
          if (T === void 0)
            throw new Error(`In this set of transform rules exists no rule for type ${y.type}.`);
          return T(y, (C) => Y(c, C));
        }
        s(Y, 'transform');
        function le(c) {
          throw new Error(
            'This transform is not available. Are you trying the correct parsing mode?',
          );
        }
        s(le, 'notAvailableTransform');
        function kt(c) {
          const y = { params: [] };
          for (const T of c.parameters)
            T.type === 'JsdocTypeKeyValue'
              ? T.key === 'this'
                ? (y.this = T.right)
                : T.key === 'new'
                  ? (y.new = T.right)
                  : y.params.push(T)
              : y.params.push(T);
          return y;
        }
        s(kt, 'extractSpecialParams');
        function zt(c, y, T) {
          return c === 'prefix' ? T + y : y + T;
        }
        s(zt, 'applyPosition');
        function Qe(c, y) {
          switch (y) {
            case 'double':
              return `"${c}"`;
            case 'single':
              return `'${c}'`;
            case void 0:
              return c;
          }
        }
        s(Qe, 'quote');
        function mn() {
          return {
            JsdocTypeParenthesis: s(
              (c, y) => `(${c.element !== void 0 ? y(c.element) : ''})`,
              'JsdocTypeParenthesis',
            ),
            JsdocTypeKeyof: s((c, y) => `keyof ${y(c.element)}`, 'JsdocTypeKeyof'),
            JsdocTypeFunction: s((c, y) => {
              var T;
              if (c.arrow) {
                if (c.returnType === void 0) throw new Error('Arrow function needs a return type.');
                let C = `${c.typeParameters !== void 0 ? `<${(T = c.typeParameters.map(y).join(', ')) !== null && T !== void 0 ? T : ''}>` : ''}(${c.parameters.map(y).join(', ')}) => ${y(c.returnType)}`;
                return (c.constructor && (C = 'new ' + C), C);
              } else {
                let C = c.constructor ? 'new' : 'function';
                return (
                  c.parenthesis &&
                    ((C += `(${c.parameters.map(y).join(', ')})`),
                    c.returnType !== void 0 && (C += `: ${y(c.returnType)}`)),
                  C
                );
              }
            }, 'JsdocTypeFunction'),
            JsdocTypeName: s((c) => c.value, 'JsdocTypeName'),
            JsdocTypeTuple: s((c, y) => `[${c.elements.map(y).join(', ')}]`, 'JsdocTypeTuple'),
            JsdocTypeVariadic: s(
              (c, y) =>
                c.meta.position === void 0 ? '...' : zt(c.meta.position, y(c.element), '...'),
              'JsdocTypeVariadic',
            ),
            JsdocTypeNamePath: s((c, y) => {
              const T = y(c.left),
                C = y(c.right);
              switch (c.pathType) {
                case 'inner':
                  return `${T}~${C}`;
                case 'instance':
                  return `${T}#${C}`;
                case 'property':
                  return `${T}.${C}`;
                case 'property-brackets':
                  return `${T}[${C}]`;
              }
            }, 'JsdocTypeNamePath'),
            JsdocTypeStringValue: s((c) => Qe(c.value, c.meta.quote), 'JsdocTypeStringValue'),
            JsdocTypeAny: s(() => '*', 'JsdocTypeAny'),
            JsdocTypeGeneric: s((c, y) => {
              if (c.meta.brackets === 'square') {
                const T = c.elements[0],
                  C = y(T);
                return T.type === 'JsdocTypeUnion' || T.type === 'JsdocTypeIntersection'
                  ? `(${C})[]`
                  : `${C}[]`;
              } else
                return `${y(c.left)}${c.meta.dot ? '.' : ''}<${c.infer === !0 ? 'infer ' : ''}${c.elements.map(y).join(', ')}>`;
            }, 'JsdocTypeGeneric'),
            JsdocTypeImport: s((c, y) => `import(${y(c.element)})`, 'JsdocTypeImport'),
            JsdocTypeObjectField: s((c, y) => {
              let T = '';
              return (
                c.readonly && (T += 'readonly '),
                typeof c.key == 'string' ? (T += Qe(c.key, c.meta.quote)) : (T += y(c.key)),
                c.optional && (T += '?'),
                c.right === void 0 ? T : T + `: ${y(c.right)}`
              );
            }, 'JsdocTypeObjectField'),
            JsdocTypeJsdocObjectField: s(
              (c, y) => `${y(c.left)}: ${y(c.right)}`,
              'JsdocTypeJsdocObjectField',
            ),
            JsdocTypeKeyValue: s((c, y) => {
              let T = c.key;
              return (
                c.optional && (T += '?'),
                c.variadic && (T = '...' + T),
                c.right === void 0 ? T : T + `: ${y(c.right)}`
              );
            }, 'JsdocTypeKeyValue'),
            JsdocTypeSpecialNamePath: s(
              (c) => `${c.specialType}:${Qe(c.value, c.meta.quote)}`,
              'JsdocTypeSpecialNamePath',
            ),
            JsdocTypeNotNullable: s(
              (c, y) => zt(c.meta.position, y(c.element), '!'),
              'JsdocTypeNotNullable',
            ),
            JsdocTypeNull: s(() => 'null', 'JsdocTypeNull'),
            JsdocTypeNullable: s(
              (c, y) => zt(c.meta.position, y(c.element), '?'),
              'JsdocTypeNullable',
            ),
            JsdocTypeNumber: s((c) => c.value.toString(), 'JsdocTypeNumber'),
            JsdocTypeObject: s((c, y) => {
              var T, C;
              return `{${
                (c.meta.separator === 'linebreak' && c.elements.length > 1
                  ? `
` + ((T = c.meta.propertyIndent) !== null && T !== void 0 ? T : '')
                  : '') +
                c.elements.map(y).join(
                  c.meta.separator === 'comma'
                    ? ', '
                    : c.meta.separator === 'linebreak'
                      ? `
` + ((C = c.meta.propertyIndent) !== null && C !== void 0 ? C : '')
                      : '; ',
                ) +
                (c.meta.separator === 'linebreak' && c.elements.length > 1
                  ? `
`
                  : '')
              }}`;
            }, 'JsdocTypeObject'),
            JsdocTypeOptional: s(
              (c, y) => zt(c.meta.position, y(c.element), '='),
              'JsdocTypeOptional',
            ),
            JsdocTypeSymbol: s(
              (c, y) => `${c.value}(${c.element !== void 0 ? y(c.element) : ''})`,
              'JsdocTypeSymbol',
            ),
            JsdocTypeTypeof: s((c, y) => `typeof ${y(c.element)}`, 'JsdocTypeTypeof'),
            JsdocTypeUndefined: s(() => 'undefined', 'JsdocTypeUndefined'),
            JsdocTypeUnion: s((c, y) => c.elements.map(y).join(' | '), 'JsdocTypeUnion'),
            JsdocTypeUnknown: s(() => '?', 'JsdocTypeUnknown'),
            JsdocTypeIntersection: s(
              (c, y) => c.elements.map(y).join(' & '),
              'JsdocTypeIntersection',
            ),
            JsdocTypeProperty: s((c) => Qe(c.value, c.meta.quote), 'JsdocTypeProperty'),
            JsdocTypePredicate: s((c, y) => `${y(c.left)} is ${y(c.right)}`, 'JsdocTypePredicate'),
            JsdocTypeIndexSignature: s(
              (c, y) => `[${c.key}: ${y(c.right)}]`,
              'JsdocTypeIndexSignature',
            ),
            JsdocTypeMappedType: s((c, y) => `[${c.key} in ${y(c.right)}]`, 'JsdocTypeMappedType'),
            JsdocTypeAsserts: s(
              (c, y) => `asserts ${y(c.left)} is ${y(c.right)}`,
              'JsdocTypeAsserts',
            ),
            JsdocTypeReadonlyArray: s(
              (c, y) => `readonly ${y(c.element)}`,
              'JsdocTypeReadonlyArray',
            ),
            JsdocTypeAssertsPlain: s((c, y) => `asserts ${y(c.element)}`, 'JsdocTypeAssertsPlain'),
            JsdocTypeConditional: s(
              (c, y) =>
                `${y(c.checksType)} extends ${y(c.extendsType)} ? ${y(c.trueType)} : ${y(c.falseType)}`,
              'JsdocTypeConditional',
            ),
            JsdocTypeTypeParameter: s(
              (c, y) =>
                `${y(c.name)}${c.constraint !== void 0 ? ` extends ${y(c.constraint)}` : ''}${c.defaultValue !== void 0 ? ` = ${y(c.defaultValue)}` : ''}`,
              'JsdocTypeTypeParameter',
            ),
          };
        }
        s(mn, 'stringifyRules');
        const Kc = mn();
        function ms(c) {
          return Y(Kc, c);
        }
        s(ms, 'stringify');
        const Yc = [
          'null',
          'true',
          'false',
          'break',
          'case',
          'catch',
          'class',
          'const',
          'continue',
          'debugger',
          'default',
          'delete',
          'do',
          'else',
          'export',
          'extends',
          'finally',
          'for',
          'function',
          'if',
          'import',
          'in',
          'instanceof',
          'new',
          'return',
          'super',
          'switch',
          'this',
          'throw',
          'try',
          'typeof',
          'var',
          'void',
          'while',
          'with',
          'yield',
        ];
        function Ze(c) {
          const y = { type: 'NameExpression', name: c };
          return (Yc.includes(c) && (y.reservedWord = !0), y);
        }
        s(Ze, 'makeName');
        const Xc = {
          JsdocTypeOptional: s((c, y) => {
            const T = y(c.element);
            return ((T.optional = !0), T);
          }, 'JsdocTypeOptional'),
          JsdocTypeNullable: s((c, y) => {
            const T = y(c.element);
            return ((T.nullable = !0), T);
          }, 'JsdocTypeNullable'),
          JsdocTypeNotNullable: s((c, y) => {
            const T = y(c.element);
            return ((T.nullable = !1), T);
          }, 'JsdocTypeNotNullable'),
          JsdocTypeVariadic: s((c, y) => {
            if (c.element === void 0)
              throw new Error('dots without value are not allowed in catharsis mode');
            const T = y(c.element);
            return ((T.repeatable = !0), T);
          }, 'JsdocTypeVariadic'),
          JsdocTypeAny: s(() => ({ type: 'AllLiteral' }), 'JsdocTypeAny'),
          JsdocTypeNull: s(() => ({ type: 'NullLiteral' }), 'JsdocTypeNull'),
          JsdocTypeStringValue: s((c) => Ze(Qe(c.value, c.meta.quote)), 'JsdocTypeStringValue'),
          JsdocTypeUndefined: s(() => ({ type: 'UndefinedLiteral' }), 'JsdocTypeUndefined'),
          JsdocTypeUnknown: s(() => ({ type: 'UnknownLiteral' }), 'JsdocTypeUnknown'),
          JsdocTypeFunction: s((c, y) => {
            const T = kt(c),
              C = { type: 'FunctionType', params: T.params.map(y) };
            return (
              T.this !== void 0 && (C.this = y(T.this)),
              T.new !== void 0 && (C.new = y(T.new)),
              c.returnType !== void 0 && (C.result = y(c.returnType)),
              C
            );
          }, 'JsdocTypeFunction'),
          JsdocTypeGeneric: s(
            (c, y) => ({
              type: 'TypeApplication',
              applications: c.elements.map((T) => y(T)),
              expression: y(c.left),
            }),
            'JsdocTypeGeneric',
          ),
          JsdocTypeSpecialNamePath: s(
            (c) => Ze(c.specialType + ':' + Qe(c.value, c.meta.quote)),
            'JsdocTypeSpecialNamePath',
          ),
          JsdocTypeName: s(
            (c) => (c.value !== 'function' ? Ze(c.value) : { type: 'FunctionType', params: [] }),
            'JsdocTypeName',
          ),
          JsdocTypeNumber: s((c) => Ze(c.value.toString()), 'JsdocTypeNumber'),
          JsdocTypeObject: s((c, y) => {
            const T = { type: 'RecordType', fields: [] };
            for (const C of c.elements)
              C.type !== 'JsdocTypeObjectField' && C.type !== 'JsdocTypeJsdocObjectField'
                ? T.fields.push({ type: 'FieldType', key: y(C), value: void 0 })
                : T.fields.push(y(C));
            return T;
          }, 'JsdocTypeObject'),
          JsdocTypeObjectField: s((c, y) => {
            if (typeof c.key != 'string')
              throw new Error('Index signatures and mapped types are not supported');
            return {
              type: 'FieldType',
              key: Ze(Qe(c.key, c.meta.quote)),
              value: c.right === void 0 ? void 0 : y(c.right),
            };
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: s(
            (c, y) => ({ type: 'FieldType', key: y(c.left), value: y(c.right) }),
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeUnion: s(
            (c, y) => ({ type: 'TypeUnion', elements: c.elements.map((T) => y(T)) }),
            'JsdocTypeUnion',
          ),
          JsdocTypeKeyValue: s(
            (c, y) => ({
              type: 'FieldType',
              key: Ze(c.key),
              value: c.right === void 0 ? void 0 : y(c.right),
            }),
            'JsdocTypeKeyValue',
          ),
          JsdocTypeNamePath: s((c, y) => {
            const T = y(c.left);
            let C;
            c.right.type === 'JsdocTypeSpecialNamePath'
              ? (C = y(c.right).name)
              : (C = Qe(c.right.value, c.right.meta.quote));
            const L = c.pathType === 'inner' ? '~' : c.pathType === 'instance' ? '#' : '.';
            return Ze(`${T.name}${L}${C}`);
          }, 'JsdocTypeNamePath'),
          JsdocTypeSymbol: s((c) => {
            let y = '',
              T = c.element,
              C = !1;
            return (
              T?.type === 'JsdocTypeVariadic' &&
                (T.meta.position === 'prefix' ? (y = '...') : (C = !0), (T = T.element)),
              T?.type === 'JsdocTypeName'
                ? (y += T.value)
                : T?.type === 'JsdocTypeNumber' && (y += T.value.toString()),
              C && (y += '...'),
              Ze(`${c.value}(${y})`)
            );
          }, 'JsdocTypeSymbol'),
          JsdocTypeParenthesis: s((c, y) => y(j(c.element)), 'JsdocTypeParenthesis'),
          JsdocTypeMappedType: le,
          JsdocTypeIndexSignature: le,
          JsdocTypeImport: le,
          JsdocTypeKeyof: le,
          JsdocTypeTuple: le,
          JsdocTypeTypeof: le,
          JsdocTypeIntersection: le,
          JsdocTypeProperty: le,
          JsdocTypePredicate: le,
          JsdocTypeAsserts: le,
          JsdocTypeReadonlyArray: le,
          JsdocTypeAssertsPlain: le,
          JsdocTypeConditional: le,
          JsdocTypeTypeParameter: le,
        };
        function ys(c) {
          return Y(Xc, c);
        }
        s(ys, 'catharsisTransform');
        function lt(c) {
          switch (c) {
            case void 0:
              return 'none';
            case 'single':
              return 'single';
            case 'double':
              return 'double';
          }
        }
        s(lt, 'getQuoteStyle');
        function hs(c) {
          switch (c) {
            case 'inner':
              return 'INNER_MEMBER';
            case 'instance':
              return 'INSTANCE_MEMBER';
            case 'property':
              return 'MEMBER';
            case 'property-brackets':
              return 'MEMBER';
          }
        }
        s(hs, 'getMemberType');
        function hr(c, y) {
          return y.length === 2
            ? { type: c, left: y[0], right: y[1] }
            : { type: c, left: y[0], right: hr(c, y.slice(1)) };
        }
        s(hr, 'nestResults');
        const Qc = {
          JsdocTypeOptional: s(
            (c, y) => ({
              type: 'OPTIONAL',
              value: y(c.element),
              meta: {
                syntax: c.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN',
              },
            }),
            'JsdocTypeOptional',
          ),
          JsdocTypeNullable: s(
            (c, y) => ({
              type: 'NULLABLE',
              value: y(c.element),
              meta: {
                syntax:
                  c.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK',
              },
            }),
            'JsdocTypeNullable',
          ),
          JsdocTypeNotNullable: s(
            (c, y) => ({
              type: 'NOT_NULLABLE',
              value: y(c.element),
              meta: { syntax: c.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG' },
            }),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeVariadic: s((c, y) => {
            const T = {
              type: 'VARIADIC',
              meta: {
                syntax:
                  c.meta.position === 'prefix'
                    ? 'PREFIX_DOTS'
                    : c.meta.position === 'suffix'
                      ? 'SUFFIX_DOTS'
                      : 'ONLY_DOTS',
              },
            };
            return (c.element !== void 0 && (T.value = y(c.element)), T);
          }, 'JsdocTypeVariadic'),
          JsdocTypeName: s((c) => ({ type: 'NAME', name: c.value }), 'JsdocTypeName'),
          JsdocTypeTypeof: s(
            (c, y) => ({ type: 'TYPE_QUERY', name: y(c.element) }),
            'JsdocTypeTypeof',
          ),
          JsdocTypeTuple: s(
            (c, y) => ({ type: 'TUPLE', entries: c.elements.map(y) }),
            'JsdocTypeTuple',
          ),
          JsdocTypeKeyof: s(
            (c, y) => ({ type: 'KEY_QUERY', value: y(c.element) }),
            'JsdocTypeKeyof',
          ),
          JsdocTypeImport: s(
            (c) => ({
              type: 'IMPORT',
              path: {
                type: 'STRING_VALUE',
                quoteStyle: lt(c.element.meta.quote),
                string: c.element.value,
              },
            }),
            'JsdocTypeImport',
          ),
          JsdocTypeUndefined: s(() => ({ type: 'NAME', name: 'undefined' }), 'JsdocTypeUndefined'),
          JsdocTypeAny: s(() => ({ type: 'ANY' }), 'JsdocTypeAny'),
          JsdocTypeFunction: s((c, y) => {
            const T = kt(c),
              C = {
                type: c.arrow ? 'ARROW' : 'FUNCTION',
                params: T.params.map((L) => {
                  if (L.type === 'JsdocTypeKeyValue') {
                    if (L.right === void 0)
                      throw new Error(
                        "Function parameter without ':' is not expected to be 'KEY_VALUE'",
                      );
                    return { type: 'NAMED_PARAMETER', name: L.key, typeName: y(L.right) };
                  } else return y(L);
                }),
                new: null,
                returns: null,
              };
            return (
              T.this !== void 0 ? (C.this = y(T.this)) : c.arrow || (C.this = null),
              T.new !== void 0 && (C.new = y(T.new)),
              c.returnType !== void 0 && (C.returns = y(c.returnType)),
              C
            );
          }, 'JsdocTypeFunction'),
          JsdocTypeGeneric: s((c, y) => {
            const T = {
              type: 'GENERIC',
              subject: y(c.left),
              objects: c.elements.map(y),
              meta: {
                syntax:
                  c.meta.brackets === 'square'
                    ? 'SQUARE_BRACKET'
                    : c.meta.dot
                      ? 'ANGLE_BRACKET_WITH_DOT'
                      : 'ANGLE_BRACKET',
              },
            };
            return (
              c.meta.brackets === 'square' &&
                c.elements[0].type === 'JsdocTypeFunction' &&
                !c.elements[0].parenthesis &&
                (T.objects[0] = { type: 'NAME', name: 'function' }),
              T
            );
          }, 'JsdocTypeGeneric'),
          JsdocTypeObjectField: s((c, y) => {
            if (typeof c.key != 'string')
              throw new Error('Index signatures and mapped types are not supported');
            if (c.right === void 0)
              return {
                type: 'RECORD_ENTRY',
                key: c.key,
                quoteStyle: lt(c.meta.quote),
                value: null,
                readonly: !1,
              };
            let T = y(c.right);
            return (
              c.optional &&
                (T = { type: 'OPTIONAL', value: T, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
              {
                type: 'RECORD_ENTRY',
                key: c.key.toString(),
                quoteStyle: lt(c.meta.quote),
                value: T,
                readonly: !1,
              }
            );
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: s(() => {
            throw new Error('Keys may not be typed in jsdoctypeparser.');
          }, 'JsdocTypeJsdocObjectField'),
          JsdocTypeKeyValue: s((c, y) => {
            if (c.right === void 0)
              return {
                type: 'RECORD_ENTRY',
                key: c.key,
                quoteStyle: 'none',
                value: null,
                readonly: !1,
              };
            let T = y(c.right);
            return (
              c.optional &&
                (T = { type: 'OPTIONAL', value: T, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
              { type: 'RECORD_ENTRY', key: c.key, quoteStyle: 'none', value: T, readonly: !1 }
            );
          }, 'JsdocTypeKeyValue'),
          JsdocTypeObject: s((c, y) => {
            const T = [];
            for (const C of c.elements)
              (C.type === 'JsdocTypeObjectField' || C.type === 'JsdocTypeJsdocObjectField') &&
                T.push(y(C));
            return { type: 'RECORD', entries: T };
          }, 'JsdocTypeObject'),
          JsdocTypeSpecialNamePath: s((c) => {
            if (c.specialType !== 'module')
              throw new Error(
                `jsdoctypeparser does not support type ${c.specialType} at this point.`,
              );
            return {
              type: 'MODULE',
              value: { type: 'FILE_PATH', quoteStyle: lt(c.meta.quote), path: c.value },
            };
          }, 'JsdocTypeSpecialNamePath'),
          JsdocTypeNamePath: s((c, y) => {
            let T = !1,
              C,
              L;
            c.right.type === 'JsdocTypeSpecialNamePath' && c.right.specialType === 'event'
              ? ((T = !0), (C = c.right.value), (L = lt(c.right.meta.quote)))
              : ((C = c.right.value), (L = lt(c.right.meta.quote)));
            const G = {
              type: hs(c.pathType),
              owner: y(c.left),
              name: C,
              quoteStyle: L,
              hasEventPrefix: T,
            };
            if (G.owner.type === 'MODULE') {
              const Z = G.owner;
              return ((G.owner = G.owner.value), (Z.value = G), Z);
            } else return G;
          }, 'JsdocTypeNamePath'),
          JsdocTypeUnion: s((c, y) => hr('UNION', c.elements.map(y)), 'JsdocTypeUnion'),
          JsdocTypeParenthesis: s(
            (c, y) => ({ type: 'PARENTHESIS', value: y(j(c.element)) }),
            'JsdocTypeParenthesis',
          ),
          JsdocTypeNull: s(() => ({ type: 'NAME', name: 'null' }), 'JsdocTypeNull'),
          JsdocTypeUnknown: s(() => ({ type: 'UNKNOWN' }), 'JsdocTypeUnknown'),
          JsdocTypeStringValue: s(
            (c) => ({ type: 'STRING_VALUE', quoteStyle: lt(c.meta.quote), string: c.value }),
            'JsdocTypeStringValue',
          ),
          JsdocTypeIntersection: s(
            (c, y) => hr('INTERSECTION', c.elements.map(y)),
            'JsdocTypeIntersection',
          ),
          JsdocTypeNumber: s(
            (c) => ({ type: 'NUMBER_VALUE', number: c.value.toString() }),
            'JsdocTypeNumber',
          ),
          JsdocTypeSymbol: le,
          JsdocTypeProperty: le,
          JsdocTypePredicate: le,
          JsdocTypeMappedType: le,
          JsdocTypeIndexSignature: le,
          JsdocTypeAsserts: le,
          JsdocTypeReadonlyArray: le,
          JsdocTypeAssertsPlain: le,
          JsdocTypeConditional: le,
          JsdocTypeTypeParameter: le,
        };
        function gs(c) {
          return Y(Qc, c);
        }
        s(gs, 'jtpTransform');
        function bs() {
          return {
            JsdocTypeIntersection: s(
              (c, y) => ({ type: 'JsdocTypeIntersection', elements: c.elements.map(y) }),
              'JsdocTypeIntersection',
            ),
            JsdocTypeGeneric: s(
              (c, y) => ({
                type: 'JsdocTypeGeneric',
                left: y(c.left),
                elements: c.elements.map(y),
                meta: { dot: c.meta.dot, brackets: c.meta.brackets },
              }),
              'JsdocTypeGeneric',
            ),
            JsdocTypeNullable: s((c) => c, 'JsdocTypeNullable'),
            JsdocTypeUnion: s(
              (c, y) => ({ type: 'JsdocTypeUnion', elements: c.elements.map(y) }),
              'JsdocTypeUnion',
            ),
            JsdocTypeUnknown: s((c) => c, 'JsdocTypeUnknown'),
            JsdocTypeUndefined: s((c) => c, 'JsdocTypeUndefined'),
            JsdocTypeTypeof: s(
              (c, y) => ({ type: 'JsdocTypeTypeof', element: y(c.element) }),
              'JsdocTypeTypeof',
            ),
            JsdocTypeSymbol: s((c, y) => {
              const T = { type: 'JsdocTypeSymbol', value: c.value };
              return (c.element !== void 0 && (T.element = y(c.element)), T);
            }, 'JsdocTypeSymbol'),
            JsdocTypeOptional: s(
              (c, y) => ({
                type: 'JsdocTypeOptional',
                element: y(c.element),
                meta: { position: c.meta.position },
              }),
              'JsdocTypeOptional',
            ),
            JsdocTypeObject: s(
              (c, y) => ({
                type: 'JsdocTypeObject',
                meta: { separator: 'comma' },
                elements: c.elements.map(y),
              }),
              'JsdocTypeObject',
            ),
            JsdocTypeNumber: s((c) => c, 'JsdocTypeNumber'),
            JsdocTypeNull: s((c) => c, 'JsdocTypeNull'),
            JsdocTypeNotNullable: s(
              (c, y) => ({
                type: 'JsdocTypeNotNullable',
                element: y(c.element),
                meta: { position: c.meta.position },
              }),
              'JsdocTypeNotNullable',
            ),
            JsdocTypeSpecialNamePath: s((c) => c, 'JsdocTypeSpecialNamePath'),
            JsdocTypeObjectField: s(
              (c, y) => ({
                type: 'JsdocTypeObjectField',
                key: c.key,
                right: c.right === void 0 ? void 0 : y(c.right),
                optional: c.optional,
                readonly: c.readonly,
                meta: c.meta,
              }),
              'JsdocTypeObjectField',
            ),
            JsdocTypeJsdocObjectField: s(
              (c, y) => ({ type: 'JsdocTypeJsdocObjectField', left: y(c.left), right: y(c.right) }),
              'JsdocTypeJsdocObjectField',
            ),
            JsdocTypeKeyValue: s(
              (c, y) => ({
                type: 'JsdocTypeKeyValue',
                key: c.key,
                right: c.right === void 0 ? void 0 : y(c.right),
                optional: c.optional,
                variadic: c.variadic,
              }),
              'JsdocTypeKeyValue',
            ),
            JsdocTypeImport: s(
              (c, y) => ({ type: 'JsdocTypeImport', element: y(c.element) }),
              'JsdocTypeImport',
            ),
            JsdocTypeAny: s((c) => c, 'JsdocTypeAny'),
            JsdocTypeStringValue: s((c) => c, 'JsdocTypeStringValue'),
            JsdocTypeNamePath: s((c) => c, 'JsdocTypeNamePath'),
            JsdocTypeVariadic: s((c, y) => {
              const T = {
                type: 'JsdocTypeVariadic',
                meta: { position: c.meta.position, squareBrackets: c.meta.squareBrackets },
              };
              return (c.element !== void 0 && (T.element = y(c.element)), T);
            }, 'JsdocTypeVariadic'),
            JsdocTypeTuple: s(
              (c, y) => ({ type: 'JsdocTypeTuple', elements: c.elements.map(y) }),
              'JsdocTypeTuple',
            ),
            JsdocTypeName: s((c) => c, 'JsdocTypeName'),
            JsdocTypeFunction: s((c, y) => {
              const T = {
                type: 'JsdocTypeFunction',
                arrow: c.arrow,
                parameters: c.parameters.map(y),
                constructor: c.constructor,
                parenthesis: c.parenthesis,
              };
              return (c.returnType !== void 0 && (T.returnType = y(c.returnType)), T);
            }, 'JsdocTypeFunction'),
            JsdocTypeKeyof: s(
              (c, y) => ({ type: 'JsdocTypeKeyof', element: y(c.element) }),
              'JsdocTypeKeyof',
            ),
            JsdocTypeParenthesis: s(
              (c, y) => ({ type: 'JsdocTypeParenthesis', element: y(c.element) }),
              'JsdocTypeParenthesis',
            ),
            JsdocTypeProperty: s((c) => c, 'JsdocTypeProperty'),
            JsdocTypePredicate: s(
              (c, y) => ({ type: 'JsdocTypePredicate', left: y(c.left), right: y(c.right) }),
              'JsdocTypePredicate',
            ),
            JsdocTypeIndexSignature: s(
              (c, y) => ({ type: 'JsdocTypeIndexSignature', key: c.key, right: y(c.right) }),
              'JsdocTypeIndexSignature',
            ),
            JsdocTypeMappedType: s(
              (c, y) => ({ type: 'JsdocTypeMappedType', key: c.key, right: y(c.right) }),
              'JsdocTypeMappedType',
            ),
            JsdocTypeAsserts: s(
              (c, y) => ({ type: 'JsdocTypeAsserts', left: y(c.left), right: y(c.right) }),
              'JsdocTypeAsserts',
            ),
            JsdocTypeReadonlyArray: s(
              (c, y) => ({ type: 'JsdocTypeReadonlyArray', element: y(c.element) }),
              'JsdocTypeReadonlyArray',
            ),
            JsdocTypeAssertsPlain: s(
              (c, y) => ({ type: 'JsdocTypeAssertsPlain', element: y(c.element) }),
              'JsdocTypeAssertsPlain',
            ),
            JsdocTypeConditional: s(
              (c, y) => ({
                type: 'JsdocTypeConditional',
                checksType: y(c.checksType),
                extendsType: y(c.extendsType),
                trueType: y(c.trueType),
                falseType: y(c.falseType),
              }),
              'JsdocTypeConditional',
            ),
            JsdocTypeTypeParameter: s(
              (c, y) => ({
                type: 'JsdocTypeTypeParameter',
                name: y(c.name),
                constraint: c.constraint !== void 0 ? y(c.constraint) : void 0,
                defaultValue: c.defaultValue !== void 0 ? y(c.defaultValue) : void 0,
              }),
              'JsdocTypeTypeParameter',
            ),
          };
        }
        s(bs, 'identityTransformRules');
        const vs = {
          JsdocTypeAny: [],
          JsdocTypeFunction: ['parameters', 'returnType'],
          JsdocTypeGeneric: ['left', 'elements'],
          JsdocTypeImport: [],
          JsdocTypeIndexSignature: ['right'],
          JsdocTypeIntersection: ['elements'],
          JsdocTypeKeyof: ['element'],
          JsdocTypeKeyValue: ['right'],
          JsdocTypeMappedType: ['right'],
          JsdocTypeName: [],
          JsdocTypeNamePath: ['left', 'right'],
          JsdocTypeNotNullable: ['element'],
          JsdocTypeNull: [],
          JsdocTypeNullable: ['element'],
          JsdocTypeNumber: [],
          JsdocTypeObject: ['elements'],
          JsdocTypeObjectField: ['right'],
          JsdocTypeJsdocObjectField: ['left', 'right'],
          JsdocTypeOptional: ['element'],
          JsdocTypeParenthesis: ['element'],
          JsdocTypeSpecialNamePath: [],
          JsdocTypeStringValue: [],
          JsdocTypeSymbol: ['element'],
          JsdocTypeTuple: ['elements'],
          JsdocTypeTypeof: ['element'],
          JsdocTypeUndefined: [],
          JsdocTypeUnion: ['elements'],
          JsdocTypeUnknown: [],
          JsdocTypeVariadic: ['element'],
          JsdocTypeProperty: [],
          JsdocTypePredicate: ['left', 'right'],
          JsdocTypeAsserts: ['left', 'right'],
          JsdocTypeReadonlyArray: ['element'],
          JsdocTypeAssertsPlain: ['element'],
          JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],
          JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue'],
        };
        function gr(c, y, T, C, L) {
          C?.(c, y, T);
          const G = vs[c.type];
          for (const Z of G) {
            const ce = c[Z];
            if (ce !== void 0)
              if (Array.isArray(ce)) for (const _e of ce) gr(_e, c, Z, C, L);
              else gr(ce, c, Z, C, L);
          }
          L?.(c, y, T);
        }
        s(gr, '_traverse');
        function Ts(c, y, T) {
          gr(c, void 0, void 0, y, T);
        }
        (s(Ts, 'traverse'),
          (r.catharsisTransform = ys),
          (r.identityTransformRules = bs),
          (r.jtpTransform = gs),
          (r.parse = yr),
          (r.stringify = ms),
          (r.stringifyRules = mn),
          (r.transform = Y),
          (r.traverse = Ts),
          (r.tryParse = fn),
          (r.visitorKeys = vs));
      });
    },
  }),
  x1 = B({
    '../node_modules/browser-dtector/browser-dtector.umd.min.js'(e, t) {
      (function (r, n) {
        typeof e == 'object' && typeof t < 'u'
          ? (t.exports = n())
          : typeof define == 'function' && define.amd
            ? define(n)
            : ((r = typeof globalThis < 'u' ? globalThis : r || self).BrowserDetector = n());
      })(e, function () {
        function r(d, u) {
          for (var p = 0; p < u.length; p++) {
            var f = u[p];
            ((f.enumerable = f.enumerable || !1),
              (f.configurable = !0),
              'value' in f && (f.writable = !0),
              Object.defineProperty(
                d,
                ((m = f.key),
                (h = void 0),
                typeof (h = (function (g, v) {
                  if (typeof g != 'object' || g === null) return g;
                  var E = g[Symbol.toPrimitive];
                  if (E !== void 0) {
                    var b = E.call(g, v);
                    if (typeof b != 'object') return b;
                    throw new TypeError('@@toPrimitive must return a primitive value.');
                  }
                  return (v === 'string' ? String : Number)(g);
                })(m, 'string')) == 'symbol'
                  ? h
                  : String(h)),
                f,
              ));
          }
          var m, h;
        }
        s(r, 'e');
        var n = {
            chrome: 'Google Chrome',
            brave: 'Brave',
            crios: 'Google Chrome',
            edge: 'Microsoft Edge',
            edg: 'Microsoft Edge',
            edgios: 'Microsoft Edge',
            fennec: 'Mozilla Firefox',
            jsdom: 'JsDOM',
            mozilla: 'Mozilla Firefox',
            fxios: 'Mozilla Firefox',
            msie: 'Microsoft Internet Explorer',
            opera: 'Opera',
            opios: 'Opera',
            opr: 'Opera',
            opt: 'Opera',
            rv: 'Microsoft Internet Explorer',
            safari: 'Safari',
            samsungbrowser: 'Samsung Browser',
            electron: 'Electron',
          },
          o = {
            android: 'Android',
            androidTablet: 'Android Tablet',
            cros: 'Chrome OS',
            fennec: 'Android Tablet',
            ipad: 'IPad',
            iphone: 'IPhone',
            jsdom: 'JsDOM',
            linux: 'Linux',
            mac: 'Macintosh',
            tablet: 'Android Tablet',
            win: 'Windows',
            'windows phone': 'Windows Phone',
            xbox: 'Microsoft Xbox',
          },
          i = s(function (d) {
            var u = new RegExp(
                '^-?\\d+(?:.\\d{0,'.concat(
                  arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1,
                  '})?',
                ),
              ),
              p = Number(d).toString().match(u);
            return p ? p[0] : null;
          }, 'n'),
          a = s(function () {
            return typeof window < 'u' ? window.navigator : null;
          }, 'i'),
          l = (function () {
            function d(m) {
              var h;
              ((function (g, v) {
                if (!(g instanceof v)) throw new TypeError('Cannot call a class as a function');
              })(this, d),
                (this.userAgent =
                  m || ((h = a()) === null || h === void 0 ? void 0 : h.userAgent) || null));
            }
            s(d, 't');
            var u, p, f;
            return (
              (u = d),
              (p = [
                {
                  key: 'parseUserAgent',
                  value: s(function (m) {
                    var h,
                      g,
                      v,
                      E = {},
                      b = m || this.userAgent || '',
                      S = b.toLowerCase().replace(/\s\s+/g, ' '),
                      R =
                        /(edge)\/([\w.]+)/.exec(S) ||
                        /(edg)[/]([\w.]+)/.exec(S) ||
                        /(opr)[/]([\w.]+)/.exec(S) ||
                        /(opt)[/]([\w.]+)/.exec(S) ||
                        /(fxios)[/]([\w.]+)/.exec(S) ||
                        /(edgios)[/]([\w.]+)/.exec(S) ||
                        /(jsdom)[/]([\w.]+)/.exec(S) ||
                        /(samsungbrowser)[/]([\w.]+)/.exec(S) ||
                        /(electron)[/]([\w.]+)/.exec(S) ||
                        /(chrome)[/]([\w.]+)/.exec(S) ||
                        /(crios)[/]([\w.]+)/.exec(S) ||
                        /(opios)[/]([\w.]+)/.exec(S) ||
                        /(version)(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(webkit)[/]([\w.]+).*(version)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(webkit)[/]([\w.]+)/.exec(S) ||
                        /(opera)(?:.*version|)[/]([\w.]+)/.exec(S) ||
                        /(msie) ([\w.]+)/.exec(S) ||
                        /(fennec)[/]([\w.]+)/.exec(S) ||
                        (S.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(S)) ||
                        (S.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(S)) ||
                        [],
                      I =
                        /(ipad)/.exec(S) ||
                        /(ipod)/.exec(S) ||
                        /(iphone)/.exec(S) ||
                        /(jsdom)/.exec(S) ||
                        /(windows phone)/.exec(S) ||
                        /(xbox)/.exec(S) ||
                        /(win)/.exec(S) ||
                        /(tablet)/.exec(S) ||
                        (/(android)/.test(S) && /(mobile)/.test(S) === !1 && ['androidTablet']) ||
                        /(android)/.exec(S) ||
                        /(mac)/.exec(S) ||
                        /(linux)/.exec(S) ||
                        /(cros)/.exec(S) ||
                        [],
                      $ = R[5] || R[3] || R[1] || null,
                      x = I[0] || null,
                      A = R[4] || R[2] || null,
                      w = a();
                    ($ === 'chrome' &&
                      typeof (w == null || (h = w.brave) === null || h === void 0
                        ? void 0
                        : h.isBrave) == 'function' &&
                      ($ = 'brave'),
                      $ && (E[$] = !0),
                      x && (E[x] = !0));
                    var _ = !!(E.tablet || E.android || E.androidTablet),
                      j = !!(E.ipad || E.tablet || E.androidTablet),
                      N = !!(
                        E.android ||
                        E.androidTablet ||
                        E.tablet ||
                        E.ipad ||
                        E.ipod ||
                        E.iphone ||
                        E['windows phone']
                      ),
                      V = !!(E.cros || E.mac || E.linux || E.win),
                      H = !!(
                        E.brave ||
                        E.chrome ||
                        E.crios ||
                        E.opr ||
                        E.safari ||
                        E.edg ||
                        E.electron
                      ),
                      P = !!(E.msie || E.rv);
                    return {
                      name: (g = n[$]) !== null && g !== void 0 ? g : null,
                      platform: (v = o[x]) !== null && v !== void 0 ? v : null,
                      userAgent: b,
                      version: A,
                      shortVersion: A ? i(parseFloat(A), 2) : null,
                      isAndroid: _,
                      isTablet: j,
                      isMobile: N,
                      isDesktop: V,
                      isWebkit: H,
                      isIE: P,
                    };
                  }, 'value'),
                },
                {
                  key: 'getBrowserInfo',
                  value: s(function () {
                    var m = this.parseUserAgent();
                    return {
                      name: m.name,
                      platform: m.platform,
                      userAgent: m.userAgent,
                      version: m.version,
                      shortVersion: m.shortVersion,
                    };
                  }, 'value'),
                },
              ]),
              (f = [
                {
                  key: 'VERSION',
                  get: s(function () {
                    return '3.4.0';
                  }, 'get'),
                },
              ]),
              p && r(u.prototype, p),
              f && r(u, f),
              Object.defineProperty(u, 'prototype', { writable: !1 }),
              d
            );
          })();
        return l;
      });
    },
  }),
  Vp = {};
Rt(Vp, {
  ARGTYPES_INFO_REQUEST: () => TT,
  ARGTYPES_INFO_RESPONSE: () => Iu,
  CHANNEL_CREATED: () => C1,
  CHANNEL_WS_DISCONNECT: () => eT,
  CONFIG_ERROR: () => tT,
  CREATE_NEW_STORYFILE_REQUEST: () => I1,
  CREATE_NEW_STORYFILE_RESPONSE: () => N1,
  CURRENT_STORY_WAS_SET: () => xu,
  DOCS_PREPARED: () => rT,
  DOCS_RENDERED: () => zp,
  FILE_COMPONENT_SEARCH_REQUEST: () => $1,
  FILE_COMPONENT_SEARCH_RESPONSE: () => q1,
  FORCE_REMOUNT: () => va,
  FORCE_RE_RENDER: () => Gp,
  GLOBALS_UPDATED: () => Xs,
  NAVIGATE_URL: () => M1,
  OPEN_IN_EDITOR_REQUEST: () => Z1,
  OPEN_IN_EDITOR_RESPONSE: () => ek,
  PLAY_FUNCTION_THREW_EXCEPTION: () => nT,
  PRELOAD_ENTRIES: () => sT,
  PREVIEW_BUILDER_PROGRESS: () => j1,
  PREVIEW_INITIALIZED: () => iT,
  PREVIEW_KEYDOWN: () => aT,
  REGISTER_SUBSCRIPTION: () => k1,
  REQUEST_WHATS_NEW_DATA: () => G1,
  RESET_STORY_ARGS: () => Wp,
  RESULT_WHATS_NEW_DATA: () => W1,
  SAVE_STORY_REQUEST: () => X1,
  SAVE_STORY_RESPONSE: () => Q1,
  SELECT_STORY: () => D1,
  SET_CONFIG: () => L1,
  SET_CURRENT_STORY: () => Kp,
  SET_FILTER: () => F1,
  SET_GLOBALS: () => lT,
  SET_INDEX: () => B1,
  SET_STORIES: () => J1,
  SET_WHATS_NEW_CACHE: () => K1,
  SHARED_STATE_CHANGED: () => U1,
  SHARED_STATE_SET: () => V1,
  STORIES_COLLAPSE_ALL: () => H1,
  STORIES_EXPAND_ALL: () => z1,
  STORY_ARGS_UPDATED: () => cT,
  STORY_CHANGED: () => uT,
  STORY_ERRORED: () => dT,
  STORY_FINISHED: () => Cu,
  STORY_HOT_UPDATED: () => gT,
  STORY_INDEX_INVALIDATED: () => pT,
  STORY_MISSING: () => Ou,
  STORY_PREPARED: () => fT,
  STORY_RENDERED: () => Ta,
  STORY_RENDER_PHASE_CHANGED: () => On,
  STORY_SPECIFIED: () => mT,
  STORY_THREW_EXCEPTION: () => yT,
  STORY_UNCHANGED: () => hT,
  TELEMETRY_ERROR: () => vT,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => Y1,
  UNHANDLED_ERRORS_WHILE_PLAYING: () => oT,
  UPDATE_GLOBALS: () => Yp,
  UPDATE_QUERY_PARAMS: () => bT,
  UPDATE_STORY_ARGS: () => Xp,
  default: () => O1,
});
var Hp = ((e) => (
    (e.CHANNEL_WS_DISCONNECT = 'channelWSDisconnect'),
    (e.CHANNEL_CREATED = 'channelCreated'),
    (e.CONFIG_ERROR = 'configError'),
    (e.STORY_INDEX_INVALIDATED = 'storyIndexInvalidated'),
    (e.STORY_SPECIFIED = 'storySpecified'),
    (e.SET_CONFIG = 'setConfig'),
    (e.SET_STORIES = 'setStories'),
    (e.SET_INDEX = 'setIndex'),
    (e.SET_CURRENT_STORY = 'setCurrentStory'),
    (e.CURRENT_STORY_WAS_SET = 'currentStoryWasSet'),
    (e.FORCE_RE_RENDER = 'forceReRender'),
    (e.FORCE_REMOUNT = 'forceRemount'),
    (e.PRELOAD_ENTRIES = 'preloadStories'),
    (e.STORY_PREPARED = 'storyPrepared'),
    (e.DOCS_PREPARED = 'docsPrepared'),
    (e.STORY_CHANGED = 'storyChanged'),
    (e.STORY_UNCHANGED = 'storyUnchanged'),
    (e.STORY_RENDERED = 'storyRendered'),
    (e.STORY_FINISHED = 'storyFinished'),
    (e.STORY_MISSING = 'storyMissing'),
    (e.STORY_ERRORED = 'storyErrored'),
    (e.STORY_THREW_EXCEPTION = 'storyThrewException'),
    (e.STORY_RENDER_PHASE_CHANGED = 'storyRenderPhaseChanged'),
    (e.STORY_HOT_UPDATED = 'storyHotUpdated'),
    (e.PLAY_FUNCTION_THREW_EXCEPTION = 'playFunctionThrewException'),
    (e.UNHANDLED_ERRORS_WHILE_PLAYING = 'unhandledErrorsWhilePlaying'),
    (e.UPDATE_STORY_ARGS = 'updateStoryArgs'),
    (e.STORY_ARGS_UPDATED = 'storyArgsUpdated'),
    (e.RESET_STORY_ARGS = 'resetStoryArgs'),
    (e.SET_FILTER = 'setFilter'),
    (e.SET_GLOBALS = 'setGlobals'),
    (e.UPDATE_GLOBALS = 'updateGlobals'),
    (e.GLOBALS_UPDATED = 'globalsUpdated'),
    (e.REGISTER_SUBSCRIPTION = 'registerSubscription'),
    (e.PREVIEW_INITIALIZED = 'previewInitialized'),
    (e.PREVIEW_KEYDOWN = 'previewKeydown'),
    (e.PREVIEW_BUILDER_PROGRESS = 'preview_builder_progress'),
    (e.SELECT_STORY = 'selectStory'),
    (e.STORIES_COLLAPSE_ALL = 'storiesCollapseAll'),
    (e.STORIES_EXPAND_ALL = 'storiesExpandAll'),
    (e.DOCS_RENDERED = 'docsRendered'),
    (e.SHARED_STATE_CHANGED = 'sharedStateChanged'),
    (e.SHARED_STATE_SET = 'sharedStateSet'),
    (e.NAVIGATE_URL = 'navigateUrl'),
    (e.UPDATE_QUERY_PARAMS = 'updateQueryParams'),
    (e.REQUEST_WHATS_NEW_DATA = 'requestWhatsNewData'),
    (e.RESULT_WHATS_NEW_DATA = 'resultWhatsNewData'),
    (e.SET_WHATS_NEW_CACHE = 'setWhatsNewCache'),
    (e.TOGGLE_WHATS_NEW_NOTIFICATIONS = 'toggleWhatsNewNotifications'),
    (e.TELEMETRY_ERROR = 'telemetryError'),
    (e.FILE_COMPONENT_SEARCH_REQUEST = 'fileComponentSearchRequest'),
    (e.FILE_COMPONENT_SEARCH_RESPONSE = 'fileComponentSearchResponse'),
    (e.SAVE_STORY_REQUEST = 'saveStoryRequest'),
    (e.SAVE_STORY_RESPONSE = 'saveStoryResponse'),
    (e.ARGTYPES_INFO_REQUEST = 'argtypesInfoRequest'),
    (e.ARGTYPES_INFO_RESPONSE = 'argtypesInfoResponse'),
    (e.CREATE_NEW_STORYFILE_REQUEST = 'createNewStoryfileRequest'),
    (e.CREATE_NEW_STORYFILE_RESPONSE = 'createNewStoryfileResponse'),
    (e.OPEN_IN_EDITOR_REQUEST = 'openInEditorRequest'),
    (e.OPEN_IN_EDITOR_RESPONSE = 'openInEditorResponse'),
    e
  ))(Hp || {}),
  O1 = Hp,
  {
    CHANNEL_WS_DISCONNECT: eT,
    CHANNEL_CREATED: C1,
    CONFIG_ERROR: tT,
    CREATE_NEW_STORYFILE_REQUEST: I1,
    CREATE_NEW_STORYFILE_RESPONSE: N1,
    CURRENT_STORY_WAS_SET: xu,
    DOCS_PREPARED: rT,
    DOCS_RENDERED: zp,
    FILE_COMPONENT_SEARCH_REQUEST: $1,
    FILE_COMPONENT_SEARCH_RESPONSE: q1,
    FORCE_RE_RENDER: Gp,
    FORCE_REMOUNT: va,
    GLOBALS_UPDATED: Xs,
    NAVIGATE_URL: M1,
    PLAY_FUNCTION_THREW_EXCEPTION: nT,
    UNHANDLED_ERRORS_WHILE_PLAYING: oT,
    PRELOAD_ENTRIES: sT,
    PREVIEW_INITIALIZED: iT,
    PREVIEW_BUILDER_PROGRESS: j1,
    PREVIEW_KEYDOWN: aT,
    REGISTER_SUBSCRIPTION: k1,
    RESET_STORY_ARGS: Wp,
    SELECT_STORY: D1,
    SET_CONFIG: L1,
    SET_CURRENT_STORY: Kp,
    SET_FILTER: F1,
    SET_GLOBALS: lT,
    SET_INDEX: B1,
    SET_STORIES: J1,
    SHARED_STATE_CHANGED: U1,
    SHARED_STATE_SET: V1,
    STORIES_COLLAPSE_ALL: H1,
    STORIES_EXPAND_ALL: z1,
    STORY_ARGS_UPDATED: cT,
    STORY_CHANGED: uT,
    STORY_ERRORED: dT,
    STORY_INDEX_INVALIDATED: pT,
    STORY_MISSING: Ou,
    STORY_PREPARED: fT,
    STORY_RENDER_PHASE_CHANGED: On,
    STORY_RENDERED: Ta,
    STORY_FINISHED: Cu,
    STORY_SPECIFIED: mT,
    STORY_THREW_EXCEPTION: yT,
    STORY_UNCHANGED: hT,
    STORY_HOT_UPDATED: gT,
    UPDATE_GLOBALS: Yp,
    UPDATE_QUERY_PARAMS: bT,
    UPDATE_STORY_ARGS: Xp,
    REQUEST_WHATS_NEW_DATA: G1,
    RESULT_WHATS_NEW_DATA: W1,
    SET_WHATS_NEW_CACHE: K1,
    TOGGLE_WHATS_NEW_NOTIFICATIONS: Y1,
    TELEMETRY_ERROR: vT,
    SAVE_STORY_REQUEST: X1,
    SAVE_STORY_RESPONSE: Q1,
    ARGTYPES_INFO_REQUEST: TT,
    ARGTYPES_INFO_RESPONSE: Iu,
    OPEN_IN_EDITOR_REQUEST: Z1,
    OPEN_IN_EDITOR_RESPONSE: ek,
  } = Hp,
  ET = {};
Rt(ET, { global: () => te });
var te = (() => {
    let e;
    return (
      typeof window < 'u'
        ? (e = window)
        : typeof globalThis < 'u'
          ? (e = globalThis)
          : typeof global < 'u'
            ? (e = global)
            : typeof self < 'u'
              ? (e = self)
              : (e = {}),
      e
    );
  })(),
  wT = {
    '@storybook/global': '__STORYBOOK_MODULE_GLOBAL__',
    'storybook/test': '__STORYBOOK_MODULE_TEST__',
    'storybook/actions': '__STORYBOOK_MODULE_ACTIONS__',
    'storybook/preview-api': '__STORYBOOK_MODULE_PREVIEW_API__',
    'storybook/internal/channels': '__STORYBOOK_MODULE_CHANNELS__',
    'storybook/internal/client-logger': '__STORYBOOK_MODULE_CLIENT_LOGGER__',
    'storybook/internal/core-events': '__STORYBOOK_MODULE_CORE_EVENTS__',
    'storybook/internal/preview-errors': '__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__',
    'storybook/internal/types': '__STORYBOOK_MODULE_TYPES__',
    'storybook/internal/preview-api': '__STORYBOOK_MODULE_PREVIEW_API__',
  },
  tk = Object.keys(wT),
  ST = {};
Rt(ST, {
  Channel: () => _l,
  HEARTBEAT_INTERVAL: () => qE,
  HEARTBEAT_MAX_LATENCY: () => ME,
  PostMessageTransport: () => $E,
  WebsocketTransport: () => kE,
  createBrowserChannel: () => DE,
  default: () => RL,
});
function ve(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = Array.from(typeof e == 'string' ? [e] : e);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '');
  var o = n.reduce(function (l, d) {
    var u = d.match(/\n([\t ]+|(?!\s).)/g);
    return u
      ? l.concat(
          u.map(function (p) {
            var f, m;
            return (m = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !==
              null && m !== void 0
              ? m
              : 0;
          }),
        )
      : l;
  }, []);
  if (o.length) {
    var i = new RegExp(
      `
[	 ]{` +
        Math.min.apply(Math, o) +
        '}',
      'g',
    );
    n = n.map(function (l) {
      return l.replace(
        i,
        `
`,
      );
    });
  }
  n[0] = n[0].replace(/^\r?\n/, '');
  var a = n[0];
  return (
    t.forEach(function (l, d) {
      var u = a.match(/(?:^|\n)( *)$/),
        p = u ? u[1] : '',
        f = l;
      (typeof l == 'string' &&
        l.includes(`
`) &&
        (f = String(l)
          .split(
            `
`,
          )
          .map(function (m, h) {
            return h === 0 ? m : '' + p + m;
          }).join(`
`)),
        (a += f + n[d + 1]));
    }),
    a
  );
}
s(ve, 'dedent');
var Rg = new Map(),
  rk = 'UNIVERSAL_STORE:',
  Dt = { PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED' },
  on = class fe {
    constructor(t, r) {
      if (
        ((this.debugging = !1),
        (this.listeners = new Map([['*', new Set()]])),
        (this.getState = s(
          () => (this.debug('getState', { state: this.state }), this.state),
          'getState',
        )),
        (this.subscribe = s((n, o) => {
          const i = typeof n == 'function',
            a = i ? '*' : n,
            l = i ? n : o;
          if ((this.debug('subscribe', { eventType: a, listener: l }), !l))
            throw new TypeError(
              `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`,
            );
          return (
            this.listeners.has(a) || this.listeners.set(a, new Set()),
            this.listeners.get(a).add(l),
            () => {
              (this.debug('unsubscribe', { eventType: a, listener: l }),
                this.listeners.has(a) &&
                  (this.listeners.get(a).delete(l),
                  this.listeners.get(a)?.size === 0 && this.listeners.delete(a)));
            }
          );
        }, 'subscribe')),
        (this.send = s((n) => {
          if ((this.debug('send', { event: n }), this.status !== fe.Status.READY))
            throw new TypeError(ve`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify({ event: n, id: this.id, actor: this.actor, environment: this.environment }, null, 2)}`);
          (this.emitToListeners(n, { actor: this.actor }),
            this.emitToChannel(n, { actor: this.actor }));
        }, 'send')),
        (this.debugging = t.debug ?? !1),
        !fe.isInternalConstructing)
      )
        throw new TypeError(
          'UniversalStore is not constructable - use UniversalStore.create() instead',
        );
      if (
        ((fe.isInternalConstructing = !1),
        (this.id = t.id),
        (this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2)),
        (this.actorType = t.leader ? fe.ActorType.LEADER : fe.ActorType.FOLLOWER),
        (this.state = t.initialState),
        (this.channelEventName = `${rk}${this.id}`),
        this.debug('constructor', {
          options: t,
          environmentOverrides: r,
          channelEventName: this.channelEventName,
        }),
        this.actor.type === fe.ActorType.LEADER)
      )
        this.syncing = { state: Dt.RESOLVED, promise: Promise.resolve() };
      else {
        let n, o;
        const i = new Promise((a, l) => {
          ((n = s(() => {
            this.syncing.state === Dt.PENDING && ((this.syncing.state = Dt.RESOLVED), a());
          }, 'syncingResolve')),
            (o = s((d) => {
              this.syncing.state === Dt.PENDING && ((this.syncing.state = Dt.REJECTED), l(d));
            }, 'syncingReject')));
        });
        this.syncing = { state: Dt.PENDING, promise: i, resolve: n, reject: o };
      }
      ((this.getState = this.getState.bind(this)),
        (this.setState = this.setState.bind(this)),
        (this.subscribe = this.subscribe.bind(this)),
        (this.onStateChange = this.onStateChange.bind(this)),
        (this.send = this.send.bind(this)),
        (this.emitToChannel = this.emitToChannel.bind(this)),
        (this.prepareThis = this.prepareThis.bind(this)),
        (this.emitToListeners = this.emitToListeners.bind(this)),
        (this.handleChannelEvents = this.handleChannelEvents.bind(this)),
        (this.debug = this.debug.bind(this)),
        (this.channel = r?.channel ?? fe.preparation.channel),
        (this.environment = r?.environment ?? fe.preparation.environment),
        this.channel && this.environment
          ? (fe.preparation.resolve({ channel: this.channel, environment: this.environment }),
            this.prepareThis({ channel: this.channel, environment: this.environment }))
          : fe.preparation.promise.then(this.prepareThis));
    }
    static setupPreparationPromise() {
      let t, r;
      const n = new Promise((o, i) => {
        ((t = s((a) => {
          o(a);
        }, 'resolveRef')),
          (r = s((...a) => {
            i(a);
          }, 'rejectRef')));
      });
      fe.preparation = { resolve: t, reject: r, promise: n };
    }
    get actor() {
      return Object.freeze({
        id: this.actorId,
        type: this.actorType,
        environment: this.environment ?? fe.Environment.UNKNOWN,
      });
    }
    get status() {
      if (!this.channel || !this.environment) return fe.Status.UNPREPARED;
      switch (this.syncing?.state) {
        case Dt.PENDING:
        case void 0:
          return fe.Status.SYNCING;
        case Dt.REJECTED:
          return fe.Status.ERROR;
        case Dt.RESOLVED:
        default:
          return fe.Status.READY;
      }
    }
    untilReady() {
      return Promise.all([fe.preparation.promise, this.syncing?.promise]);
    }
    static create(t) {
      if (!t || typeof t?.id != 'string')
        throw new TypeError('id is required and must be a string, when creating a UniversalStore');
      t.debug &&
        console.debug(
          ve`[UniversalStore]
        create`,
          { options: t },
        );
      const r = Rg.get(t.id);
      if (r)
        return (
          console.warn(ve`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`),
          r
        );
      fe.isInternalConstructing = !0;
      const n = new fe(t);
      return (Rg.set(t.id, n), n);
    }
    static __prepare(t, r) {
      ((fe.preparation.channel = t),
        (fe.preparation.environment = r),
        fe.preparation.resolve({ channel: t, environment: r }));
    }
    setState(t) {
      const r = this.state,
        n = typeof t == 'function' ? t(r) : t;
      if (
        (this.debug('setState', { newState: n, previousState: r, updater: t }),
        this.status !== fe.Status.READY)
      )
        throw new TypeError(ve`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify({ newState: n, id: this.id, actor: this.actor, environment: this.environment }, null, 2)}`);
      this.state = n;
      const o = { type: fe.InternalEventType.SET_STATE, payload: { state: n, previousState: r } };
      (this.emitToChannel(o, { actor: this.actor }),
        this.emitToListeners(o, { actor: this.actor }));
    }
    onStateChange(t) {
      return (
        this.debug('onStateChange', { listener: t }),
        this.subscribe(fe.InternalEventType.SET_STATE, ({ payload: r }, n) => {
          t(r.state, r.previousState, n);
        })
      );
    }
    emitToChannel(t, r) {
      (this.debug('emitToChannel', { event: t, eventInfo: r, channel: !!this.channel }),
        this.channel?.emit(this.channelEventName, { event: t, eventInfo: r }));
    }
    prepareThis({ channel: t, environment: r }) {
      ((this.channel = t),
        (this.environment = r),
        this.debug('prepared', { channel: !!t, environment: r }),
        this.channel.on(this.channelEventName, this.handleChannelEvents),
        this.actor.type === fe.ActorType.LEADER
          ? this.emitToChannel({ type: fe.InternalEventType.LEADER_CREATED }, { actor: this.actor })
          : (this.emitToChannel(
              { type: fe.InternalEventType.FOLLOWER_CREATED },
              { actor: this.actor },
            ),
            this.emitToChannel(
              { type: fe.InternalEventType.EXISTING_STATE_REQUEST },
              { actor: this.actor },
            ),
            setTimeout(() => {
              this.syncing.reject(
                new TypeError(
                  `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`,
                ),
              );
            }, 1e3)));
    }
    emitToListeners(t, r) {
      const n = this.listeners.get(t.type),
        o = this.listeners.get('*');
      (this.debug('emitToListeners', {
        event: t,
        eventInfo: r,
        eventTypeListeners: n,
        everythingListeners: o,
      }),
        [...(n ?? []), ...(o ?? [])].forEach((i) => i(t, r)));
    }
    handleChannelEvents(t) {
      const { event: r, eventInfo: n } = t;
      if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
        this.debug('handleChannelEvents: Ignoring event from self', { channelEvent: t });
        return;
      } else if (
        this.syncing?.state === Dt.PENDING &&
        r.type !== fe.InternalEventType.EXISTING_STATE_RESPONSE
      ) {
        this.debug('handleChannelEvents: Ignoring event while syncing', { channelEvent: t });
        return;
      }
      if (
        (this.debug('handleChannelEvents', { channelEvent: t }),
        this.actor.type === fe.ActorType.LEADER)
      ) {
        let o = !0;
        switch (r.type) {
          case fe.InternalEventType.EXISTING_STATE_REQUEST:
            o = !1;
            const i = { type: fe.InternalEventType.EXISTING_STATE_RESPONSE, payload: this.state };
            (this.debug('handleChannelEvents: responding to existing state request', {
              responseEvent: i,
            }),
              this.emitToChannel(i, { actor: this.actor }),
              this.emitToListeners(i, { actor: this.actor }));
            break;
          case fe.InternalEventType.LEADER_CREATED:
            ((o = !1),
              (this.syncing.state = Dt.REJECTED),
              this.debug('handleChannelEvents: erroring due to second leader being created', {
                event: r,
              }),
              console.error(ve`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`));
            break;
        }
        o &&
          (this.debug('handleChannelEvents: forwarding event', { channelEvent: t }),
          this.emitToChannel(r, { actor: n.actor, forwardingActor: this.actor }));
      }
      if (this.actor.type === fe.ActorType.FOLLOWER)
        switch (r.type) {
          case fe.InternalEventType.EXISTING_STATE_RESPONSE:
            if (
              (this.debug(
                "handleChannelEvents: Setting state from leader's existing state response",
                { event: r },
              ),
              this.syncing?.state !== Dt.PENDING)
            )
              break;
            this.syncing.resolve?.();
            const o = {
              type: fe.InternalEventType.SET_STATE,
              payload: { state: r.payload, previousState: this.state },
            };
            ((this.state = r.payload), this.emitToListeners(o, n));
            break;
        }
      switch (r.type) {
        case fe.InternalEventType.SET_STATE:
          (this.debug('handleChannelEvents: Setting state', { event: r }),
            (this.state = r.payload.state));
          break;
      }
      this.emitToListeners(r, { actor: n.actor });
    }
    debug(t, r) {
      this.debugging &&
        console.debug(
          ve`[UniversalStore::${this.id}::${this.environment ?? fe.Environment.UNKNOWN}]
        ${t}`,
          JSON.stringify(
            { data: r, actor: this.actor, state: this.state, status: this.status },
            null,
            2,
          ),
        );
    }
    static __reset() {
      (fe.preparation.reject(new Error('reset')),
        fe.setupPreparationPromise(),
        (fe.isInternalConstructing = !1));
    }
  };
s(on, 'UniversalStore');
on.ActorType = { LEADER: 'LEADER', FOLLOWER: 'FOLLOWER' };
on.Environment = {
  SERVER: 'SERVER',
  MANAGER: 'MANAGER',
  PREVIEW: 'PREVIEW',
  UNKNOWN: 'UNKNOWN',
  MOCK: 'MOCK',
};
on.InternalEventType = {
  EXISTING_STATE_REQUEST: '__EXISTING_STATE_REQUEST',
  EXISTING_STATE_RESPONSE: '__EXISTING_STATE_RESPONSE',
  SET_STATE: '__SET_STATE',
  LEADER_CREATED: '__LEADER_CREATED',
  FOLLOWER_CREATED: '__FOLLOWER_CREATED',
};
on.Status = { UNPREPARED: 'UNPREPARED', SYNCING: 'SYNCING', READY: 'READY', ERROR: 'ERROR' };
on.isInternalConstructing = !1;
on.setupPreparationPromise();
var Zc = on,
  nk = s((e) => e.transports !== void 0, 'isMulti'),
  ok = s(() => Math.random().toString(16).slice(2), 'generateRandomId'),
  _T = class {
    constructor(t = {}) {
      ((this.sender = ok()),
        (this.events = {}),
        (this.data = {}),
        (this.transports = []),
        (this.isAsync = t.async || !1),
        nk(t)
          ? ((this.transports = t.transports || []),
            this.transports.forEach((r) => {
              r.setHandler((n) => this.handleEvent(n));
            }))
          : (this.transports = t.transport ? [t.transport] : []),
        this.transports.forEach((r) => {
          r.setHandler((n) => this.handleEvent(n));
        }));
    }
    get hasTransport() {
      return this.transports.length > 0;
    }
    addListener(t, r) {
      ((this.events[t] = this.events[t] || []), this.events[t].push(r));
    }
    emit(t, ...r) {
      const n = { type: t, args: r, from: this.sender };
      let o = {};
      r.length >= 1 && r[0] && r[0].options && (o = r[0].options);
      const i = s(() => {
        (this.transports.forEach((a) => {
          a.send(n, o);
        }),
          this.handleEvent(n));
      }, 'handler');
      this.isAsync ? setImmediate(i) : i();
    }
    last(t) {
      return this.data[t];
    }
    eventNames() {
      return Object.keys(this.events);
    }
    listenerCount(t) {
      const r = this.listeners(t);
      return r ? r.length : 0;
    }
    listeners(t) {
      return this.events[t] || void 0;
    }
    once(t, r) {
      const n = this.onceListener(t, r);
      this.addListener(t, n);
    }
    removeAllListeners(t) {
      t ? this.events[t] && delete this.events[t] : (this.events = {});
    }
    removeListener(t, r) {
      const n = this.listeners(t);
      n && (this.events[t] = n.filter((o) => o !== r));
    }
    on(t, r) {
      this.addListener(t, r);
    }
    off(t, r) {
      this.removeListener(t, r);
    }
    handleEvent(t) {
      const r = this.listeners(t.type);
      (r &&
        r.length &&
        r.forEach((n) => {
          n.apply(t, t.args);
        }),
        (this.data[t.type] = t.args));
    }
    onceListener(t, r) {
      const n = s((...o) => (this.removeListener(t, n), r(...o)), 'onceListener');
      return n;
    }
  };
s(_T, 'Channel');
var _l = _T,
  AT = {};
Rt(AT, { deprecate: () => Qp, logger: () => ke, once: () => Ve, pretty: () => qt });
var { LOGLEVEL: sk } = te,
  Br = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 },
  ik = sk,
  Yn = Br[ik] || Br.info,
  ke = {
    trace: s((e, ...t) => {
      Yn <= Br.trace && console.trace(e, ...t);
    }, 'trace'),
    debug: s((e, ...t) => {
      Yn <= Br.debug && console.debug(e, ...t);
    }, 'debug'),
    info: s((e, ...t) => {
      Yn <= Br.info && console.info(e, ...t);
    }, 'info'),
    warn: s((e, ...t) => {
      Yn <= Br.warn && console.warn(e, ...t);
    }, 'warn'),
    error: s((e, ...t) => {
      Yn <= Br.error && console.error(e, ...t);
    }, 'error'),
    log: s((e, ...t) => {
      Yn < Br.silent && console.log(e, ...t);
    }, 'log'),
  },
  Nu = new Set(),
  Ve = s(
    (e) =>
      (t, ...r) => {
        if (!Nu.has(t)) return (Nu.add(t), ke[e](t, ...r));
      },
    'once',
  );
Ve.clear = () => Nu.clear();
Ve.trace = Ve('trace');
Ve.debug = Ve('debug');
Ve.info = Ve('info');
Ve.warn = Ve('warn');
Ve.error = Ve('error');
Ve.log = Ve('log');
var Qp = Ve('warn'),
  qt = s(
    (e) =>
      (...t) => {
        const r = [];
        if (t.length) {
          const n = /<span\s+style=(['"])([^'"]*)\1\s*>/gi,
            o = /<\/span>/gi;
          let i;
          for (r.push(t[0].replace(n, '%c').replace(o, '%c')); (i = n.exec(t[0])); )
            (r.push(i[2]), r.push(''));
          for (let a = 1; a < t.length; a++) r.push(t[a]);
        }
        ke[e].apply(ke, r);
      },
    'pretty',
  );
qt.trace = qt('trace');
qt.debug = qt('debug');
qt.info = qt('info');
qt.warn = qt('warn');
qt.error = qt('error');
var ak = Object.create,
  RT = Object.defineProperty,
  lk = Object.getOwnPropertyDescriptor,
  PT = Object.getOwnPropertyNames,
  ck = Object.getPrototypeOf,
  uk = Object.prototype.hasOwnProperty,
  ge = s(
    (e, t) =>
      s(function () {
        return (t || (0, e[PT(e)[0]])((t = { exports: {} }).exports, t), t.exports);
      }, '__require'),
    '__commonJS',
  ),
  dk = s((e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let o of PT(t))
        !uk.call(e, o) &&
          o !== r &&
          RT(e, o, { get: s(() => t[o], 'get'), enumerable: !(n = lk(t, o)) || n.enumerable });
    return e;
  }, '__copyProps'),
  Zp = s(
    (e, t, r) => (
      (r = e != null ? ak(ck(e)) : {}),
      dk(t || !e || !e.__esModule ? RT(r, 'default', { value: e, enumerable: !0 }) : r, e)
    ),
    '__toESM',
  ),
  pk = [
    'bubbles',
    'cancelBubble',
    'cancelable',
    'composed',
    'currentTarget',
    'defaultPrevented',
    'eventPhase',
    'isTrusted',
    'returnValue',
    'srcElement',
    'target',
    'timeStamp',
    'type',
  ],
  fk = ['detail'];
function xT(e) {
  const t = pk.filter((r) => e[r] !== void 0).reduce((r, n) => ((r[n] = e[n]), r), {});
  if (e instanceof CustomEvent) for (const r of fk.filter((n) => e[n] !== void 0)) t[r] = e[r];
  return t;
}
s(xT, 'extractEventHiddenProperties');
var OT = ge({
    'node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js'(e, t) {
      t.exports = Object;
    },
  }),
  mk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js'(e, t) {
      t.exports = Error;
    },
  }),
  yk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js'(e, t) {
      t.exports = EvalError;
    },
  }),
  hk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js'(e, t) {
      t.exports = RangeError;
    },
  }),
  gk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js'(e, t) {
      t.exports = ReferenceError;
    },
  }),
  bk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js'(e, t) {
      t.exports = SyntaxError;
    },
  }),
  ef = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js'(e, t) {
      t.exports = TypeError;
    },
  }),
  vk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js'(e, t) {
      t.exports = URIError;
    },
  }),
  Tk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js'(e, t) {
      t.exports = Math.abs;
    },
  }),
  Ek = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js'(e, t) {
      t.exports = Math.floor;
    },
  }),
  wk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js'(e, t) {
      t.exports = Math.max;
    },
  }),
  Sk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js'(e, t) {
      t.exports = Math.min;
    },
  }),
  _k = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js'(e, t) {
      t.exports = Math.pow;
    },
  }),
  Ak = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js'(e, t) {
      t.exports = Math.round;
    },
  }),
  Rk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js'(e, t) {
      t.exports =
        Number.isNaN ||
        s(function (n) {
          return n !== n;
        }, 'isNaN2');
    },
  }),
  Pk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js'(e, t) {
      var r = Rk();
      t.exports = s(function (o) {
        return r(o) || o === 0 ? o : o < 0 ? -1 : 1;
      }, 'sign');
    },
  }),
  xk = ge({
    'node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js'(e, t) {
      t.exports = Object.getOwnPropertyDescriptor;
    },
  }),
  tf = ge({
    'node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js'(e, t) {
      var r = xk();
      if (r)
        try {
          r([], 'length');
        } catch {
          r = null;
        }
      t.exports = r;
    },
  }),
  Ok = ge({
    'node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js'(e, t) {
      var r = Object.defineProperty || !1;
      if (r)
        try {
          r({}, 'a', { value: 1 });
        } catch {
          r = !1;
        }
      t.exports = r;
    },
  }),
  CT = ge({
    'node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js'(e, t) {
      t.exports = s(function () {
        if (typeof Symbol != 'function' || typeof Object.getOwnPropertySymbols != 'function')
          return !1;
        if (typeof Symbol.iterator == 'symbol') return !0;
        var n = {},
          o = Symbol('test'),
          i = Object(o);
        if (
          typeof o == 'string' ||
          Object.prototype.toString.call(o) !== '[object Symbol]' ||
          Object.prototype.toString.call(i) !== '[object Symbol]'
        )
          return !1;
        var a = 42;
        n[o] = a;
        for (var l in n) return !1;
        if (
          (typeof Object.keys == 'function' && Object.keys(n).length !== 0) ||
          (typeof Object.getOwnPropertyNames == 'function' &&
            Object.getOwnPropertyNames(n).length !== 0)
        )
          return !1;
        var d = Object.getOwnPropertySymbols(n);
        if (d.length !== 1 || d[0] !== o || !Object.prototype.propertyIsEnumerable.call(n, o))
          return !1;
        if (typeof Object.getOwnPropertyDescriptor == 'function') {
          var u = Object.getOwnPropertyDescriptor(n, o);
          if (u.value !== a || u.enumerable !== !0) return !1;
        }
        return !0;
      }, 'hasSymbols');
    },
  }),
  IT = ge({
    'node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js'(e, t) {
      var r = typeof Symbol < 'u' && Symbol,
        n = CT();
      t.exports = s(function () {
        return typeof r != 'function' ||
          typeof Symbol != 'function' ||
          typeof r('foo') != 'symbol' ||
          typeof Symbol('bar') != 'symbol'
          ? !1
          : n();
      }, 'hasNativeSymbols');
    },
  }),
  NT = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js'(e, t) {
      t.exports = (typeof Reflect < 'u' && Reflect.getPrototypeOf) || null;
    },
  }),
  $T = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js'(e, t) {
      var r = OT();
      t.exports = r.getPrototypeOf || null;
    },
  }),
  Ck = ge({
    'node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js'(e, t) {
      var r = 'Function.prototype.bind called on incompatible ',
        n = Object.prototype.toString,
        o = Math.max,
        i = '[object Function]',
        a = s(function (p, f) {
          for (var m = [], h = 0; h < p.length; h += 1) m[h] = p[h];
          for (var g = 0; g < f.length; g += 1) m[g + p.length] = f[g];
          return m;
        }, 'concatty2'),
        l = s(function (p, f) {
          for (var m = [], h = f || 0, g = 0; h < p.length; h += 1, g += 1) m[g] = p[h];
          return m;
        }, 'slicy2'),
        d = s(function (u, p) {
          for (var f = '', m = 0; m < u.length; m += 1) ((f += u[m]), m + 1 < u.length && (f += p));
          return f;
        }, 'joiny');
      t.exports = s(function (p) {
        var f = this;
        if (typeof f != 'function' || n.apply(f) !== i) throw new TypeError(r + f);
        for (
          var m = l(arguments, 1),
            h,
            g = s(function () {
              if (this instanceof h) {
                var R = f.apply(this, a(m, arguments));
                return Object(R) === R ? R : this;
              }
              return f.apply(p, a(m, arguments));
            }, 'binder'),
            v = o(0, f.length - m.length),
            E = [],
            b = 0;
          b < v;
          b++
        )
          E[b] = '$' + b;
        if (
          ((h = Function(
            'binder',
            'return function (' + d(E, ',') + '){ return binder.apply(this,arguments); }',
          )(g)),
          f.prototype)
        ) {
          var S = s(function () {}, 'Empty2');
          ((S.prototype = f.prototype), (h.prototype = new S()), (S.prototype = null));
        }
        return h;
      }, 'bind');
    },
  }),
  Al = ge({
    'node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js'(e, t) {
      var r = Ck();
      t.exports = Function.prototype.bind || r;
    },
  }),
  rf = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js'(
      e,
      t,
    ) {
      t.exports = Function.prototype.call;
    },
  }),
  qT = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js'(
      e,
      t,
    ) {
      t.exports = Function.prototype.apply;
    },
  }),
  Ik = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js'(
      e,
      t,
    ) {
      t.exports = typeof Reflect < 'u' && Reflect && Reflect.apply;
    },
  }),
  Nk = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js'(
      e,
      t,
    ) {
      var r = Al(),
        n = qT(),
        o = rf(),
        i = Ik();
      t.exports = i || r.call(o, n);
    },
  }),
  MT = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js'(
      e,
      t,
    ) {
      var r = Al(),
        n = ef(),
        o = rf(),
        i = Nk();
      t.exports = s(function (l) {
        if (l.length < 1 || typeof l[0] != 'function') throw new n('a function is required');
        return i(r, o, l);
      }, 'callBindBasic');
    },
  }),
  $k = ge({
    'node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js'(e, t) {
      var r = MT(),
        n = tf(),
        o;
      try {
        o = [].__proto__ === Array.prototype;
      } catch (d) {
        if (!d || typeof d != 'object' || !('code' in d) || d.code !== 'ERR_PROTO_ACCESS') throw d;
      }
      var i = !!o && n && n(Object.prototype, '__proto__'),
        a = Object,
        l = a.getPrototypeOf;
      t.exports =
        i && typeof i.get == 'function'
          ? r([i.get])
          : typeof l == 'function'
            ? s(function (u) {
                return l(u == null ? u : a(u));
              }, 'getDunder')
            : !1;
    },
  }),
  qk = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js'(e, t) {
      var r = NT(),
        n = $T(),
        o = $k();
      t.exports = r
        ? s(function (a) {
            return r(a);
          }, 'getProto')
        : n
          ? s(function (a) {
              if (!a || (typeof a != 'object' && typeof a != 'function'))
                throw new TypeError('getProto: not an object');
              return n(a);
            }, 'getProto')
          : o
            ? s(function (a) {
                return o(a);
              }, 'getProto')
            : null;
    },
  }),
  jT = ge({
    'node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js'(e, t) {
      var r = Function.prototype.call,
        n = Object.prototype.hasOwnProperty,
        o = Al();
      t.exports = o.call(r, n);
    },
  }),
  Mk = ge({
    'node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js'(e, t) {
      var r,
        n = OT(),
        o = mk(),
        i = yk(),
        a = hk(),
        l = gk(),
        d = bk(),
        u = ef(),
        p = vk(),
        f = Tk(),
        m = Ek(),
        h = wk(),
        g = Sk(),
        v = _k(),
        E = Ak(),
        b = Pk(),
        S = Function,
        R = s(function (J) {
          try {
            return S('"use strict"; return (' + J + ').constructor;')();
          } catch {}
        }, 'getEvalledConstructor'),
        I = tf(),
        $ = Ok(),
        x = s(function () {
          throw new u();
        }, 'throwTypeError'),
        A = I
          ? (function () {
              try {
                return (arguments.callee, x);
              } catch {
                try {
                  return I(arguments, 'callee').get;
                } catch {
                  return x;
                }
              }
            })()
          : x,
        w = IT()(),
        _ = qk(),
        j = $T(),
        N = NT(),
        V = qT(),
        H = rf(),
        P = {},
        D = typeof Uint8Array > 'u' || !_ ? r : _(Uint8Array),
        F = {
          __proto__: null,
          '%AggregateError%': typeof AggregateError > 'u' ? r : AggregateError,
          '%Array%': Array,
          '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? r : ArrayBuffer,
          '%ArrayIteratorPrototype%': w && _ ? _([][Symbol.iterator]()) : r,
          '%AsyncFromSyncIteratorPrototype%': r,
          '%AsyncFunction%': P,
          '%AsyncGenerator%': P,
          '%AsyncGeneratorFunction%': P,
          '%AsyncIteratorPrototype%': P,
          '%Atomics%': typeof Atomics > 'u' ? r : Atomics,
          '%BigInt%': typeof BigInt > 'u' ? r : BigInt,
          '%BigInt64Array%': typeof BigInt64Array > 'u' ? r : BigInt64Array,
          '%BigUint64Array%': typeof BigUint64Array > 'u' ? r : BigUint64Array,
          '%Boolean%': Boolean,
          '%DataView%': typeof DataView > 'u' ? r : DataView,
          '%Date%': Date,
          '%decodeURI%': decodeURI,
          '%decodeURIComponent%': decodeURIComponent,
          '%encodeURI%': encodeURI,
          '%encodeURIComponent%': encodeURIComponent,
          '%Error%': o,
          '%eval%': eval,
          '%EvalError%': i,
          '%Float16Array%': typeof Float16Array > 'u' ? r : Float16Array,
          '%Float32Array%': typeof Float32Array > 'u' ? r : Float32Array,
          '%Float64Array%': typeof Float64Array > 'u' ? r : Float64Array,
          '%FinalizationRegistry%': typeof FinalizationRegistry > 'u' ? r : FinalizationRegistry,
          '%Function%': S,
          '%GeneratorFunction%': P,
          '%Int8Array%': typeof Int8Array > 'u' ? r : Int8Array,
          '%Int16Array%': typeof Int16Array > 'u' ? r : Int16Array,
          '%Int32Array%': typeof Int32Array > 'u' ? r : Int32Array,
          '%isFinite%': isFinite,
          '%isNaN%': isNaN,
          '%IteratorPrototype%': w && _ ? _(_([][Symbol.iterator]())) : r,
          '%JSON%': typeof JSON == 'object' ? JSON : r,
          '%Map%': typeof Map > 'u' ? r : Map,
          '%MapIteratorPrototype%':
            typeof Map > 'u' || !w || !_ ? r : _(new Map()[Symbol.iterator]()),
          '%Math%': Math,
          '%Number%': Number,
          '%Object%': n,
          '%Object.getOwnPropertyDescriptor%': I,
          '%parseFloat%': parseFloat,
          '%parseInt%': parseInt,
          '%Promise%': typeof Promise > 'u' ? r : Promise,
          '%Proxy%': typeof Proxy > 'u' ? r : Proxy,
          '%RangeError%': a,
          '%ReferenceError%': l,
          '%Reflect%': typeof Reflect > 'u' ? r : Reflect,
          '%RegExp%': RegExp,
          '%Set%': typeof Set > 'u' ? r : Set,
          '%SetIteratorPrototype%':
            typeof Set > 'u' || !w || !_ ? r : _(new Set()[Symbol.iterator]()),
          '%SharedArrayBuffer%': typeof SharedArrayBuffer > 'u' ? r : SharedArrayBuffer,
          '%String%': String,
          '%StringIteratorPrototype%': w && _ ? _(''[Symbol.iterator]()) : r,
          '%Symbol%': w ? Symbol : r,
          '%SyntaxError%': d,
          '%ThrowTypeError%': A,
          '%TypedArray%': D,
          '%TypeError%': u,
          '%Uint8Array%': typeof Uint8Array > 'u' ? r : Uint8Array,
          '%Uint8ClampedArray%': typeof Uint8ClampedArray > 'u' ? r : Uint8ClampedArray,
          '%Uint16Array%': typeof Uint16Array > 'u' ? r : Uint16Array,
          '%Uint32Array%': typeof Uint32Array > 'u' ? r : Uint32Array,
          '%URIError%': p,
          '%WeakMap%': typeof WeakMap > 'u' ? r : WeakMap,
          '%WeakRef%': typeof WeakRef > 'u' ? r : WeakRef,
          '%WeakSet%': typeof WeakSet > 'u' ? r : WeakSet,
          '%Function.prototype.call%': H,
          '%Function.prototype.apply%': V,
          '%Object.defineProperty%': $,
          '%Object.getPrototypeOf%': j,
          '%Math.abs%': f,
          '%Math.floor%': m,
          '%Math.max%': h,
          '%Math.min%': g,
          '%Math.pow%': v,
          '%Math.round%': E,
          '%Math.sign%': b,
          '%Reflect.getPrototypeOf%': N,
        };
      if (_)
        try {
          null.error;
        } catch (J) {
          ((k = _(_(J))), (F['%Error.prototype%'] = k));
        }
      var k,
        K = s(function J(Q) {
          var re;
          if (Q === '%AsyncFunction%') re = R('async function () {}');
          else if (Q === '%GeneratorFunction%') re = R('function* () {}');
          else if (Q === '%AsyncGeneratorFunction%') re = R('async function* () {}');
          else if (Q === '%AsyncGenerator%') {
            var oe = J('%AsyncGeneratorFunction%');
            oe && (re = oe.prototype);
          } else if (Q === '%AsyncIteratorPrototype%') {
            var ne = J('%AsyncGenerator%');
            ne && _ && (re = _(ne.prototype));
          }
          return ((F[Q] = re), re);
        }, 'doEval2'),
        X = {
          __proto__: null,
          '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
          '%ArrayPrototype%': ['Array', 'prototype'],
          '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
          '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
          '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
          '%ArrayProto_values%': ['Array', 'prototype', 'values'],
          '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
          '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
          '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
          '%BooleanPrototype%': ['Boolean', 'prototype'],
          '%DataViewPrototype%': ['DataView', 'prototype'],
          '%DatePrototype%': ['Date', 'prototype'],
          '%ErrorPrototype%': ['Error', 'prototype'],
          '%EvalErrorPrototype%': ['EvalError', 'prototype'],
          '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
          '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
          '%FunctionPrototype%': ['Function', 'prototype'],
          '%Generator%': ['GeneratorFunction', 'prototype'],
          '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
          '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
          '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
          '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
          '%JSONParse%': ['JSON', 'parse'],
          '%JSONStringify%': ['JSON', 'stringify'],
          '%MapPrototype%': ['Map', 'prototype'],
          '%NumberPrototype%': ['Number', 'prototype'],
          '%ObjectPrototype%': ['Object', 'prototype'],
          '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
          '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
          '%PromisePrototype%': ['Promise', 'prototype'],
          '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
          '%Promise_all%': ['Promise', 'all'],
          '%Promise_reject%': ['Promise', 'reject'],
          '%Promise_resolve%': ['Promise', 'resolve'],
          '%RangeErrorPrototype%': ['RangeError', 'prototype'],
          '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
          '%RegExpPrototype%': ['RegExp', 'prototype'],
          '%SetPrototype%': ['Set', 'prototype'],
          '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
          '%StringPrototype%': ['String', 'prototype'],
          '%SymbolPrototype%': ['Symbol', 'prototype'],
          '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
          '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
          '%TypeErrorPrototype%': ['TypeError', 'prototype'],
          '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
          '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
          '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
          '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
          '%URIErrorPrototype%': ['URIError', 'prototype'],
          '%WeakMapPrototype%': ['WeakMap', 'prototype'],
          '%WeakSetPrototype%': ['WeakSet', 'prototype'],
        },
        se = Al(),
        ie = jT(),
        W = se.call(H, Array.prototype.concat),
        ae = se.call(V, Array.prototype.splice),
        be = se.call(H, String.prototype.replace),
        ue = se.call(H, String.prototype.slice),
        ee = se.call(H, RegExp.prototype.exec),
        Pe =
          /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        xe = /\\(\\)?/g,
        He = s(function (Q) {
          var re = ue(Q, 0, 1),
            oe = ue(Q, -1);
          if (re === '%' && oe !== '%')
            throw new d('invalid intrinsic syntax, expected closing `%`');
          if (oe === '%' && re !== '%')
            throw new d('invalid intrinsic syntax, expected opening `%`');
          var ne = [];
          return (
            be(Q, Pe, function (de, ye, pe, Fe) {
              ne[ne.length] = pe ? be(Fe, xe, '$1') : ye || de;
            }),
            ne
          );
        }, 'stringToPath3'),
        Xe = s(function (Q, re) {
          var oe = Q,
            ne;
          if ((ie(X, oe) && ((ne = X[oe]), (oe = '%' + ne[0] + '%')), ie(F, oe))) {
            var de = F[oe];
            if ((de === P && (de = K(oe)), typeof de > 'u' && !re))
              throw new u(
                'intrinsic ' + Q + ' exists, but is not available. Please file an issue!',
              );
            return { alias: ne, name: oe, value: de };
          }
          throw new d('intrinsic ' + Q + ' does not exist!');
        }, 'getBaseIntrinsic2');
      t.exports = s(function (Q, re) {
        if (typeof Q != 'string' || Q.length === 0)
          throw new u('intrinsic name must be a non-empty string');
        if (arguments.length > 1 && typeof re != 'boolean')
          throw new u('"allowMissing" argument must be a boolean');
        if (ee(/^%?[^%]*%?$/, Q) === null)
          throw new d(
            '`%` may not be present anywhere but at the beginning and end of the intrinsic name',
          );
        var oe = He(Q),
          ne = oe.length > 0 ? oe[0] : '',
          de = Xe('%' + ne + '%', re),
          ye = de.name,
          pe = de.value,
          Fe = !1,
          it = de.alias;
        it && ((ne = it[0]), ae(oe, W([0, 1], it)));
        for (var yt = 1, Pt = !0; yt < oe.length; yt += 1) {
          var at = oe[yt],
            ht = ue(at, 0, 1),
            gt = ue(at, -1);
          if (
            (ht === '"' || ht === "'" || ht === '`' || gt === '"' || gt === "'" || gt === '`') &&
            ht !== gt
          )
            throw new d('property names with quotes must have matching quotes');
          if (
            ((at === 'constructor' || !Pt) && (Fe = !0),
            (ne += '.' + at),
            (ye = '%' + ne + '%'),
            ie(F, ye))
          )
            pe = F[ye];
          else if (pe != null) {
            if (!(at in pe)) {
              if (!re)
                throw new u(
                  'base intrinsic for ' + Q + ' exists, but the property is not available.',
                );
              return;
            }
            if (I && yt + 1 >= oe.length) {
              var bt = I(pe, at);
              ((Pt = !!bt),
                Pt && 'get' in bt && !('originalValue' in bt.get) ? (pe = bt.get) : (pe = pe[at]));
            } else ((Pt = ie(pe, at)), (pe = pe[at]));
            Pt && !Fe && (F[ye] = pe);
          }
        }
        return pe;
      }, 'GetIntrinsic');
    },
  }),
  nf = ge({
    'node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js'(e, t) {
      var r = Mk(),
        n = MT(),
        o = n([r('%String.prototype.indexOf%')]);
      t.exports = s(function (a, l) {
        var d = r(a, !!l);
        return typeof d == 'function' && o(a, '.prototype.') > -1 ? n([d]) : d;
      }, 'callBoundIntrinsic');
    },
  }),
  jk = ge({
    'node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js'(e, t) {
      var r = CT();
      t.exports = s(function () {
        return r() && !!Symbol.toStringTag;
      }, 'hasToStringTagShams');
    },
  }),
  kT = ge({
    'node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js'(e, t) {
      var r = nf(),
        n = jk()(),
        o = jT(),
        i = tf(),
        a;
      n
        ? ((l = r('RegExp.prototype.exec')),
          (d = {}),
          (u = s(function () {
            throw d;
          }, 'throwRegexMarker')),
          (p = { toString: u, valueOf: u }),
          typeof Symbol.toPrimitive == 'symbol' && (p[Symbol.toPrimitive] = u),
          (a = s(function (g) {
            if (!g || typeof g != 'object') return !1;
            var v = i(g, 'lastIndex'),
              E = v && o(v, 'value');
            if (!E) return !1;
            try {
              l(g, p);
            } catch (b) {
              return b === d;
            }
          }, 'isRegex')))
        : ((f = r('Object.prototype.toString')),
          (m = '[object RegExp]'),
          (a = s(function (g) {
            return !g || (typeof g != 'object' && typeof g != 'function') ? !1 : f(g) === m;
          }, 'isRegex')));
      var l, d, u, p, f, m;
      t.exports = a;
    },
  }),
  kk = ge({
    'node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js'(e, t) {
      t.exports = n;
      var r = Object.prototype.toString;
      function n(o) {
        if (!o) return !1;
        var i = r.call(o);
        return (
          i === '[object Function]' ||
          (typeof o == 'function' && i !== '[object RegExp]') ||
          (typeof window < 'u' &&
            (o === window.setTimeout ||
              o === window.alert ||
              o === window.confirm ||
              o === window.prompt))
        );
      }
      s(n, 'isFunction3');
    },
  }),
  Dk = ge({
    'node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js'(e, t) {
      var r = nf(),
        n = kT(),
        o = r('RegExp.prototype.exec'),
        i = ef();
      t.exports = s(function (l) {
        if (!n(l)) throw new i('`regex` must be a RegExp');
        return s(function (u) {
          return o(l, u) !== null;
        }, 'test');
      }, 'regexTester');
    },
  }),
  Lk = ge({
    'node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js'(e, t) {
      var r = nf(),
        n = r('Object.prototype.toString'),
        o = IT()(),
        i = Dk();
      o
        ? ((a = r('Symbol.prototype.toString')),
          (l = i(/^Symbol\(.*\)$/)),
          (d = s(function (p) {
            return typeof p.valueOf() != 'symbol' ? !1 : l(a(p));
          }, 'isRealSymbolObject')),
          (t.exports = s(function (p) {
            if (typeof p == 'symbol') return !0;
            if (!p || typeof p != 'object' || n(p) !== '[object Symbol]') return !1;
            try {
              return d(p);
            } catch {
              return !1;
            }
          }, 'isSymbol3')))
        : (t.exports = s(function (p) {
            return !1;
          }, 'isSymbol3'));
      var a, l, d;
    },
  }),
  Fk = Zp(kT()),
  Bk = Zp(kk()),
  Jk = Zp(Lk());
function DT(e) {
  return e != null && typeof e == 'object' && Array.isArray(e) === !1;
}
s(DT, 'isObject');
var Uk = typeof global == 'object' && global && global.Object === Object && global,
  Vk = Uk,
  Hk = typeof self == 'object' && self && self.Object === Object && self,
  zk = Vk || Hk || Function('return this')(),
  of = zk,
  Gk = of.Symbol,
  To = Gk,
  LT = Object.prototype,
  Wk = LT.hasOwnProperty,
  Kk = LT.toString,
  Ss = To ? To.toStringTag : void 0;
function FT(e) {
  var t = Wk.call(e, Ss),
    r = e[Ss];
  try {
    e[Ss] = void 0;
    var n = !0;
  } catch {}
  var o = Kk.call(e);
  return (n && (t ? (e[Ss] = r) : delete e[Ss]), o);
}
s(FT, 'getRawTag');
var Yk = FT,
  Xk = Object.prototype,
  Qk = Xk.toString;
function BT(e) {
  return Qk.call(e);
}
s(BT, 'objectToString');
var Zk = BT,
  eD = '[object Null]',
  tD = '[object Undefined]',
  Pg = To ? To.toStringTag : void 0;
function JT(e) {
  return e == null ? (e === void 0 ? tD : eD) : Pg && Pg in Object(e) ? Yk(e) : Zk(e);
}
s(JT, 'baseGetTag');
var UT = JT;
function VT(e) {
  return e != null && typeof e == 'object';
}
s(VT, 'isObjectLike');
var rD = VT,
  nD = '[object Symbol]';
function HT(e) {
  return typeof e == 'symbol' || (rD(e) && UT(e) == nD);
}
s(HT, 'isSymbol');
var sf = HT;
function zT(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, o = Array(n); ++r < n; ) o[r] = t(e[r], r, e);
  return o;
}
s(zT, 'arrayMap');
var oD = zT,
  sD = Array.isArray,
  af = sD,
  xg = To ? To.prototype : void 0,
  Og = xg ? xg.toString : void 0;
function lf(e) {
  if (typeof e == 'string') return e;
  if (af(e)) return oD(e, lf) + '';
  if (sf(e)) return Og ? Og.call(e) : '';
  var t = e + '';
  return t == '0' && 1 / e == -1 / 0 ? '-0' : t;
}
s(lf, 'baseToString');
var iD = lf;
function GT(e) {
  var t = typeof e;
  return e != null && (t == 'object' || t == 'function');
}
s(GT, 'isObject2');
var WT = GT,
  aD = '[object AsyncFunction]',
  lD = '[object Function]',
  cD = '[object GeneratorFunction]',
  uD = '[object Proxy]';
function KT(e) {
  if (!WT(e)) return !1;
  var t = UT(e);
  return t == lD || t == cD || t == aD || t == uD;
}
s(KT, 'isFunction');
var dD = KT,
  pD = of['__core-js_shared__'],
  eu = pD,
  Cg = (function () {
    var e = /[^.]+$/.exec((eu && eu.keys && eu.keys.IE_PROTO) || '');
    return e ? 'Symbol(src)_1.' + e : '';
  })();
function YT(e) {
  return !!Cg && Cg in e;
}
s(YT, 'isMasked');
var fD = YT,
  mD = Function.prototype,
  yD = mD.toString;
function XT(e) {
  if (e != null) {
    try {
      return yD.call(e);
    } catch {}
    try {
      return e + '';
    } catch {}
  }
  return '';
}
s(XT, 'toSource');
var hD = XT,
  gD = /[\\^$.*+?()[\]{}|]/g,
  bD = /^\[object .+?Constructor\]$/,
  vD = Function.prototype,
  TD = Object.prototype,
  ED = vD.toString,
  wD = TD.hasOwnProperty,
  SD = RegExp(
    '^' +
      ED.call(wD)
        .replace(gD, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
      '$',
  );
function QT(e) {
  if (!WT(e) || fD(e)) return !1;
  var t = dD(e) ? SD : bD;
  return t.test(hD(e));
}
s(QT, 'baseIsNative');
var _D = QT;
function ZT(e, t) {
  return e?.[t];
}
s(ZT, 'getValue');
var AD = ZT;
function eE(e, t) {
  var r = AD(e, t);
  return _D(r) ? r : void 0;
}
s(eE, 'getNative');
var tE = eE;
function rE(e, t) {
  return e === t || (e !== e && t !== t);
}
s(rE, 'eq');
var RD = rE,
  PD = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  xD = /^\w*$/;
function nE(e, t) {
  if (af(e)) return !1;
  var r = typeof e;
  return r == 'number' || r == 'symbol' || r == 'boolean' || e == null || sf(e)
    ? !0
    : xD.test(e) || !PD.test(e) || (t != null && e in Object(t));
}
s(nE, 'isKey');
var OD = nE,
  CD = tE(Object, 'create'),
  Qs = CD;
function oE() {
  ((this.__data__ = Qs ? Qs(null) : {}), (this.size = 0));
}
s(oE, 'hashClear');
var ID = oE;
function sE(e) {
  var t = this.has(e) && delete this.__data__[e];
  return ((this.size -= t ? 1 : 0), t);
}
s(sE, 'hashDelete');
var ND = sE,
  $D = '__lodash_hash_undefined__',
  qD = Object.prototype,
  MD = qD.hasOwnProperty;
function iE(e) {
  var t = this.__data__;
  if (Qs) {
    var r = t[e];
    return r === $D ? void 0 : r;
  }
  return MD.call(t, e) ? t[e] : void 0;
}
s(iE, 'hashGet');
var jD = iE,
  kD = Object.prototype,
  DD = kD.hasOwnProperty;
function aE(e) {
  var t = this.__data__;
  return Qs ? t[e] !== void 0 : DD.call(t, e);
}
s(aE, 'hashHas');
var LD = aE,
  FD = '__lodash_hash_undefined__';
function lE(e, t) {
  var r = this.__data__;
  return ((this.size += this.has(e) ? 0 : 1), (r[e] = Qs && t === void 0 ? FD : t), this);
}
s(lE, 'hashSet');
var BD = lE;
function Jn(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
s(Jn, 'Hash');
Jn.prototype.clear = ID;
Jn.prototype.delete = ND;
Jn.prototype.get = jD;
Jn.prototype.has = LD;
Jn.prototype.set = BD;
var Ig = Jn;
function cE() {
  ((this.__data__ = []), (this.size = 0));
}
s(cE, 'listCacheClear');
var JD = cE;
function uE(e, t) {
  for (var r = e.length; r--; ) if (RD(e[r][0], t)) return r;
  return -1;
}
s(uE, 'assocIndexOf');
var Rl = uE,
  UD = Array.prototype,
  VD = UD.splice;
function dE(e) {
  var t = this.__data__,
    r = Rl(t, e);
  if (r < 0) return !1;
  var n = t.length - 1;
  return (r == n ? t.pop() : VD.call(t, r, 1), --this.size, !0);
}
s(dE, 'listCacheDelete');
var HD = dE;
function pE(e) {
  var t = this.__data__,
    r = Rl(t, e);
  return r < 0 ? void 0 : t[r][1];
}
s(pE, 'listCacheGet');
var zD = pE;
function fE(e) {
  return Rl(this.__data__, e) > -1;
}
s(fE, 'listCacheHas');
var GD = fE;
function mE(e, t) {
  var r = this.__data__,
    n = Rl(r, e);
  return (n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this);
}
s(mE, 'listCacheSet');
var WD = mE;
function Un(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
s(Un, 'ListCache');
Un.prototype.clear = JD;
Un.prototype.delete = HD;
Un.prototype.get = zD;
Un.prototype.has = GD;
Un.prototype.set = WD;
var KD = Un,
  YD = tE(of, 'Map'),
  XD = YD;
function yE() {
  ((this.size = 0), (this.__data__ = { hash: new Ig(), map: new (XD || KD)(), string: new Ig() }));
}
s(yE, 'mapCacheClear');
var QD = yE;
function hE(e) {
  var t = typeof e;
  return t == 'string' || t == 'number' || t == 'symbol' || t == 'boolean'
    ? e !== '__proto__'
    : e === null;
}
s(hE, 'isKeyable');
var ZD = hE;
function gE(e, t) {
  var r = e.__data__;
  return ZD(t) ? r[typeof t == 'string' ? 'string' : 'hash'] : r.map;
}
s(gE, 'getMapData');
var Pl = gE;
function bE(e) {
  var t = Pl(this, e).delete(e);
  return ((this.size -= t ? 1 : 0), t);
}
s(bE, 'mapCacheDelete');
var eL = bE;
function vE(e) {
  return Pl(this, e).get(e);
}
s(vE, 'mapCacheGet');
var tL = vE;
function TE(e) {
  return Pl(this, e).has(e);
}
s(TE, 'mapCacheHas');
var rL = TE;
function EE(e, t) {
  var r = Pl(this, e),
    n = r.size;
  return (r.set(e, t), (this.size += r.size == n ? 0 : 1), this);
}
s(EE, 'mapCacheSet');
var nL = EE;
function Vn(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
s(Vn, 'MapCache');
Vn.prototype.clear = QD;
Vn.prototype.delete = eL;
Vn.prototype.get = tL;
Vn.prototype.has = rL;
Vn.prototype.set = nL;
var wE = Vn,
  oL = 'Expected a function';
function xl(e, t) {
  if (typeof e != 'function' || (t != null && typeof t != 'function')) throw new TypeError(oL);
  var r = s(function () {
    var n = arguments,
      o = t ? t.apply(this, n) : n[0],
      i = r.cache;
    if (i.has(o)) return i.get(o);
    var a = e.apply(this, n);
    return ((r.cache = i.set(o, a) || i), a);
  }, 'memoized');
  return ((r.cache = new (xl.Cache || wE)()), r);
}
s(xl, 'memoize');
xl.Cache = wE;
var sL = xl,
  iL = 500;
function SE(e) {
  var t = sL(e, function (n) {
      return (r.size === iL && r.clear(), n);
    }),
    r = t.cache;
  return t;
}
s(SE, 'memoizeCapped');
var aL = SE,
  lL =
    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
  cL = /\\(\\)?/g,
  uL = aL(function (e) {
    var t = [];
    return (
      e.charCodeAt(0) === 46 && t.push(''),
      e.replace(lL, function (r, n, o, i) {
        t.push(o ? i.replace(cL, '$1') : n || r);
      }),
      t
    );
  }),
  dL = uL;
function _E(e) {
  return e == null ? '' : iD(e);
}
s(_E, 'toString');
var pL = _E;
function AE(e, t) {
  return af(e) ? e : OD(e, t) ? [e] : dL(pL(e));
}
s(AE, 'castPath');
var fL = AE;
function RE(e) {
  if (typeof e == 'string' || sf(e)) return e;
  var t = e + '';
  return t == '0' && 1 / e == -1 / 0 ? '-0' : t;
}
s(RE, 'toKey');
var mL = RE;
function PE(e, t) {
  t = fL(t, e);
  for (var r = 0, n = t.length; e != null && r < n; ) e = e[mL(t[r++])];
  return r && r == n ? e : void 0;
}
s(PE, 'baseGet');
var yL = PE;
function xE(e, t, r) {
  var n = e == null ? void 0 : yL(e, t);
  return n === void 0 ? r : n;
}
s(xE, 'get');
var hL = xE,
  cf = DT,
  gL = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/,
  uf = s((e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/), 'isJSON');
function df(e) {
  if (!cf(e)) return e;
  let t = e,
    r = !1;
  return (
    typeof Event < 'u' && e instanceof Event && ((t = xT(t)), (r = !0)),
    (t = Object.keys(t).reduce((n, o) => {
      try {
        (t[o] && t[o].toJSON, (n[o] = t[o]));
      } catch {
        r = !0;
      }
      return n;
    }, {})),
    r ? t : e
  );
}
s(df, 'convertUnconventionalData');
var bL = s(function (t) {
    let r, n, o, i;
    return s(function (l, d) {
      try {
        if (l === '') return ((i = []), (r = new Map([[d, '[]']])), (n = new Map()), (o = []), d);
        const u = n.get(this) || this;
        for (; o.length && u !== o[0]; ) (o.shift(), i.pop());
        if (typeof d == 'boolean') return d;
        if (d === void 0) return t.allowUndefined ? '_undefined_' : void 0;
        if (d === null) return null;
        if (typeof d == 'number')
          return d === Number.NEGATIVE_INFINITY
            ? '_-Infinity_'
            : d === Number.POSITIVE_INFINITY
              ? '_Infinity_'
              : Number.isNaN(d)
                ? '_NaN_'
                : d;
        if (typeof d == 'bigint') return `_bigint_${d.toString()}`;
        if (typeof d == 'string') return gL.test(d) ? (t.allowDate ? `_date_${d}` : void 0) : d;
        if ((0, Fk.default)(d)) return t.allowRegExp ? `_regexp_${d.flags}|${d.source}` : void 0;
        if ((0, Bk.default)(d)) return;
        if ((0, Jk.default)(d)) {
          if (!t.allowSymbol) return;
          const f = Symbol.keyFor(d);
          return f !== void 0 ? `_gsymbol_${f}` : `_symbol_${d.toString().slice(7, -1)}`;
        }
        if (o.length >= t.maxDepth) return Array.isArray(d) ? `[Array(${d.length})]` : '[Object]';
        if (d === this) return `_duplicate_${JSON.stringify(i)}`;
        if (d instanceof Error && t.allowError)
          return {
            __isConvertedError__: !0,
            errorProperties: {
              ...(d.cause ? { cause: d.cause } : {}),
              ...d,
              name: d.name,
              message: d.message,
              stack: d.stack,
              '_constructor-name_': d.constructor.name,
            },
          };
        if (d?.constructor?.name && d.constructor.name !== 'Object' && !Array.isArray(d)) {
          const f = r.get(d);
          if (!f) {
            const m = {
              __isClassInstance__: !0,
              __className__: d.constructor.name,
              ...Object.getOwnPropertyNames(d).reduce((h, g) => {
                try {
                  h[g] = d[g];
                } catch {}
                return h;
              }, {}),
            };
            return (
              i.push(l),
              o.unshift(m),
              r.set(d, JSON.stringify(i)),
              d !== m && n.set(d, m),
              m
            );
          }
          return `_duplicate_${f}`;
        }
        const p = r.get(d);
        if (!p) {
          const f = Array.isArray(d) ? d : df(d);
          return (i.push(l), o.unshift(f), r.set(d, JSON.stringify(i)), d !== f && n.set(d, f), f);
        }
        return `_duplicate_${p}`;
      } catch {
        return;
      }
    }, 'replace');
  }, 'replacer2'),
  vL = s(function (t) {
    const r = [];
    let n;
    return s(function (i, a) {
      if (
        (i === '' &&
          ((n = a),
          r.forEach(({ target: l, container: d, replacement: u }) => {
            const p = uf(u) ? JSON.parse(u) : u.split('.');
            p.length === 0 ? (d[l] = n) : (d[l] = hL(n, p));
          })),
        i === '_constructor-name_')
      )
        return a;
      if (cf(a) && a.__isConvertedError__) {
        const { message: l, ...d } = a.errorProperties,
          u = new Error(l);
        return (Object.assign(u, d), u);
      }
      if (typeof a == 'string' && a.startsWith('_regexp_') && t.allowRegExp) {
        const [, l, d] = a.match(/_regexp_([^|]*)\|(.*)/) || [];
        return new RegExp(d, l);
      }
      return typeof a == 'string' && a.startsWith('_date_') && t.allowDate
        ? new Date(a.replace('_date_', ''))
        : typeof a == 'string' && a.startsWith('_duplicate_')
          ? (r.push({ target: i, container: this, replacement: a.replace(/^_duplicate_/, '') }),
            null)
          : typeof a == 'string' && a.startsWith('_symbol_') && t.allowSymbol
            ? Symbol(a.replace('_symbol_', ''))
            : typeof a == 'string' && a.startsWith('_gsymbol_') && t.allowSymbol
              ? Symbol.for(a.replace('_gsymbol_', ''))
              : typeof a == 'string' && a === '_-Infinity_'
                ? Number.NEGATIVE_INFINITY
                : typeof a == 'string' && a === '_Infinity_'
                  ? Number.POSITIVE_INFINITY
                  : typeof a == 'string' && a === '_NaN_'
                    ? Number.NaN
                    : typeof a == 'string' &&
                        a.startsWith('_bigint_') &&
                        typeof BigInt == 'function'
                      ? BigInt(a.replace('_bigint_', ''))
                      : a;
    }, 'revive');
  }, 'reviver2'),
  OE = {
    maxDepth: 10,
    space: void 0,
    allowRegExp: !0,
    allowDate: !0,
    allowError: !0,
    allowUndefined: !0,
    allowSymbol: !0,
  },
  CE = s((e, t = {}) => {
    const r = { ...OE, ...t };
    return JSON.stringify(df(e), bL(r), t.space);
  }, 'stringify'),
  TL = s(() => {
    const e = new Map();
    return s(function t(r) {
      (cf(r) &&
        Object.entries(r).forEach(([n, o]) => {
          o === '_undefined_' ? (r[n] = void 0) : e.get(o) || (e.set(o, !0), t(o));
        }),
        Array.isArray(r) &&
          r.forEach((n, o) => {
            n === '_undefined_'
              ? (e.set(n, !0), (r[o] = void 0))
              : e.get(n) || (e.set(n, !0), t(n));
          }));
    }, 'mutateUndefined');
  }, 'mutator'),
  IE = s((e, t = {}) => {
    const r = { ...OE, ...t },
      n = JSON.parse(e, vL(r));
    return (TL()(n), n);
  }, 'parse'),
  EL = 'Invariant failed';
function lr(e, t) {
  if (!e) throw new Error(EL);
}
s(lr, 'invariant');
var wL = s((e) => {
    const t = Array.from(document.querySelectorAll('iframe[data-is-storybook]')),
      [r, ...n] = t.filter((i) => {
        try {
          return (
            i.contentWindow?.location.origin === e.source.location.origin &&
            i.contentWindow?.location.pathname === e.source.location.pathname
          );
        } catch {}
        try {
          return i.contentWindow === e.source;
        } catch {}
        const a = i.getAttribute('src');
        let l;
        try {
          if (!a) return !1;
          ({ origin: l } = new URL(a, document.location.toString()));
        } catch {
          return !1;
        }
        return l === e.origin;
      }),
      o = r?.getAttribute('src');
    if (o && n.length === 0) {
      const { protocol: i, host: a, pathname: l } = new URL(o, document.location.toString());
      return `${i}//${a}${l}`;
    }
    return (n.length > 0 && ke.error('found multiple candidates for event source'), null);
  }, 'getEventSourceUrl'),
  { document: tu, location: ru } = te,
  Ng = 'storybook-channel',
  SL = { maxDepth: 25 },
  NE = class {
    constructor(t) {
      if (
        ((this.config = t),
        (this.connected = !1),
        (this.buffer = []),
        typeof te?.addEventListener == 'function' &&
          te.addEventListener('message', this.handleEvent.bind(this), !1),
        t.page !== 'manager' && t.page !== 'preview')
      )
        throw new Error(`postmsg-channel: "config.page" cannot be "${t.page}"`);
    }
    setHandler(t) {
      this.handler = (...r) => {
        (t.apply(this, r),
          !this.connected && this.getLocalFrame().length && (this.flush(), (this.connected = !0)));
      };
    }
    send(t, r) {
      const {
          target: n,
          allowRegExp: o,
          allowSymbol: i,
          allowDate: a,
          allowError: l,
          allowUndefined: d,
          maxDepth: u,
          space: p,
        } = r || {},
        f = Object.fromEntries(
          Object.entries({
            allowRegExp: o,
            allowSymbol: i,
            allowDate: a,
            allowError: l,
            allowUndefined: d,
            maxDepth: u,
            space: p,
          }).filter(([E, b]) => typeof b < 'u'),
        ),
        m = { ...SL, ...(te.CHANNEL_OPTIONS || {}), ...f },
        h = this.getFrames(n),
        g = new URLSearchParams(ru?.search || ''),
        v = CE({ key: Ng, event: t, refId: g.get('refId') }, m);
      return h.length
        ? (this.buffer.length && this.flush(),
          h.forEach((E) => {
            try {
              E.postMessage(v, '*');
            } catch {
              ke.error('sending over postmessage fail');
            }
          }),
          Promise.resolve(null))
        : new Promise((E, b) => {
            this.buffer.push({ event: t, resolve: E, reject: b });
          });
    }
    flush() {
      const { buffer: t } = this;
      ((this.buffer = []),
        t.forEach((r) => {
          this.send(r.event).then(r.resolve).catch(r.reject);
        }));
    }
    getFrames(t) {
      if (this.config.page === 'manager') {
        const n = Array.from(
          tu.querySelectorAll('iframe[data-is-storybook][data-is-loaded]'),
        ).flatMap((o) => {
          try {
            return o.contentWindow && o.dataset.isStorybook !== void 0 && o.id === t
              ? [o.contentWindow]
              : [];
          } catch {
            return [];
          }
        });
        return n?.length ? n : this.getCurrentFrames();
      }
      return te && te.parent && te.parent !== te.self ? [te.parent] : [];
    }
    getCurrentFrames() {
      return this.config.page === 'manager'
        ? Array.from(tu.querySelectorAll('[data-is-storybook="true"]')).flatMap((r) =>
            r.contentWindow ? [r.contentWindow] : [],
          )
        : te && te.parent
          ? [te.parent]
          : [];
    }
    getLocalFrame() {
      return this.config.page === 'manager'
        ? Array.from(tu.querySelectorAll('#storybook-preview-iframe')).flatMap((r) =>
            r.contentWindow ? [r.contentWindow] : [],
          )
        : te && te.parent
          ? [te.parent]
          : [];
    }
    handleEvent(t) {
      try {
        const { data: r } = t,
          {
            key: n,
            event: o,
            refId: i,
          } = typeof r == 'string' && uf(r) ? IE(r, te.CHANNEL_OPTIONS || {}) : r;
        if (n === Ng) {
          const a =
              this.config.page === 'manager'
                ? '<span style="color: #37D5D3; background: black"> manager </span>'
                : '<span style="color: #1EA7FD; background: black"> preview </span>',
            l = Object.values(Vp).includes(o.type)
              ? `<span style="color: #FF4785">${o.type}</span>`
              : `<span style="color: #FFAE00">${o.type}</span>`;
          if (
            (i && (o.refId = i),
            (o.source = this.config.page === 'preview' ? t.origin : wL(t)),
            !o.source)
          ) {
            qt.error(`${a} received ${l} but was unable to determine the source of the event`);
            return;
          }
          const d = `${a} received ${l} (${r.length})`;
          (qt.debug(
            ru.origin !== o.source
              ? d
              : `${d} <span style="color: gray">(on ${ru.origin} from ${o.source})</span>`,
            ...o.args,
          ),
            lr(this.handler, 'ChannelHandler should be set'),
            this.handler(o));
        }
      } catch (r) {
        ke.error(r);
      }
    }
  };
s(NE, 'PostMessageTransport');
var $E = NE,
  { WebSocket: _L } = te,
  qE = 15e3,
  ME = 5e3,
  jE = class {
    constructor({ url: t, onError: r, page: n }) {
      ((this.buffer = []),
        (this.isReady = !1),
        (this.isClosed = !1),
        (this.pingTimeout = 0),
        (this.socket = new _L(t)),
        (this.socket.onopen = () => {
          ((this.isReady = !0), this.heartbeat(), this.flush());
        }),
        (this.socket.onmessage = ({ data: o }) => {
          const i = typeof o == 'string' && uf(o) ? IE(o) : o;
          (lr(this.handler),
            this.handler(i),
            i.type === 'ping' && (this.heartbeat(), this.send({ type: 'pong' })));
        }),
        (this.socket.onerror = (o) => {
          r && r(o);
        }),
        (this.socket.onclose = (o) => {
          (lr(this.handler),
            this.handler({
              type: eT,
              args: [{ reason: o.reason, code: o.code }],
              from: n || 'preview',
            }),
            (this.isClosed = !0),
            clearTimeout(this.pingTimeout));
        }));
    }
    heartbeat() {
      (clearTimeout(this.pingTimeout),
        (this.pingTimeout = setTimeout(() => {
          this.socket.close(3008, 'timeout');
        }, qE + ME)));
    }
    setHandler(t) {
      this.handler = t;
    }
    send(t) {
      this.isClosed || (this.isReady ? this.sendNow(t) : this.sendLater(t));
    }
    sendLater(t) {
      this.buffer.push(t);
    }
    sendNow(t) {
      const r = CE(t, { maxDepth: 15, ...te.CHANNEL_OPTIONS });
      this.socket.send(r);
    }
    flush() {
      const { buffer: t } = this;
      ((this.buffer = []), t.forEach((r) => this.send(r)));
    }
  };
s(jE, 'WebsocketTransport');
var kE = jE,
  { CONFIG_TYPE: AL } = te,
  RL = _l;
function DE({ page: e, extraTransports: t = [] }) {
  const r = [new $E({ page: e }), ...t];
  if (AL === 'DEVELOPMENT') {
    const o = window.location.protocol === 'http:' ? 'ws' : 'wss',
      { hostname: i, port: a } = window.location,
      l = `${o}://${i}:${a}/storybook-server-channel`;
    r.push(new kE({ url: l, onError: s(() => {}, 'onError'), page: e }));
  }
  const n = new _l({ transports: r });
  return (Zc.__prepare(n, e === 'manager' ? Zc.Environment.MANAGER : Zc.Environment.PREVIEW), n);
}
s(DE, 'createBrowserChannel');
var LE = {};
Rt(LE, {
  CalledExtractOnStoreError: () => WE,
  CalledPreviewMethodBeforeInitializationError: () => It,
  Category: () => JE,
  ElementA11yParameterError: () => NL,
  EmptyIndexError: () => nw,
  ImplicitActionsDuringRendering: () => zE,
  MdxFileWithNoCsfReferencesError: () => tw,
  MissingRenderToCanvasError: () => YE,
  MissingStoryAfterHmrError: () => VE,
  MissingStoryFromCsfFileError: () => aw,
  MountMustBeDestructuredError: () => pf,
  NextJsSharpError: () => xL,
  NextjsRouterMocksNotAvailable: () => OL,
  NoRenderFunctionError: () => pw,
  NoStoryMatchError: () => sw,
  NoStoryMountedError: () => mw,
  StatusTypeIdMismatchError: () => PL,
  StoryIndexFetchError: () => ZE,
  StoryStoreAccessedBeforeInitializationError: () => cw,
  UnknownArgTypesError: () => CL,
  UnsupportedViewportDimensionError: () => IL,
});
function $u({ code: e, category: t }) {
  const r = String(e).padStart(4, '0');
  return `SB_${t}_${r}`;
}
s($u, 'parseErrorCode');
function qu(e) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e)) return e;
  try {
    const t = new URL(e);
    return (t.searchParams.set('ref', 'error'), t.toString());
  } catch {
    return e;
  }
}
s(qu, 'appendErrorRef');
var FE = class BE extends Error {
  constructor(t) {
    (super(BE.getFullMessage(t)),
      (this.data = {}),
      (this.fromStorybook = !0),
      (this.category = t.category),
      (this.documentation = t.documentation ?? !1),
      (this.code = t.code));
  }
  get fullErrorCode() {
    return $u({ code: this.code, category: this.category });
  }
  get name() {
    const t = this.constructor.name;
    return `${this.fullErrorCode} (${t})`;
  }
  static getFullMessage({ documentation: t, code: r, category: n, message: o }) {
    let i;
    return (
      t === !0
        ? (i = `https://storybook.js.org/error/${$u({ code: r, category: n })}?ref=error`)
        : typeof t == 'string'
          ? (i = qu(t))
          : Array.isArray(t) &&
            (i = `
${t.map((a) => `	- ${qu(a)}`).join(`
`)}`),
      `${o}${
        i != null
          ? `

More info: ${i}
`
          : ''
      }`
    );
  }
};
s(FE, 'StorybookError');
var Ye = FE,
  JE = ((e) => (
    (e.BLOCKS = 'BLOCKS'),
    (e.DOCS_TOOLS = 'DOCS-TOOLS'),
    (e.PREVIEW_CLIENT_LOGGER = 'PREVIEW_CLIENT-LOGGER'),
    (e.PREVIEW_CHANNELS = 'PREVIEW_CHANNELS'),
    (e.PREVIEW_CORE_EVENTS = 'PREVIEW_CORE-EVENTS'),
    (e.PREVIEW_INSTRUMENTER = 'PREVIEW_INSTRUMENTER'),
    (e.PREVIEW_API = 'PREVIEW_API'),
    (e.PREVIEW_REACT_DOM_SHIM = 'PREVIEW_REACT-DOM-SHIM'),
    (e.PREVIEW_ROUTER = 'PREVIEW_ROUTER'),
    (e.PREVIEW_THEMING = 'PREVIEW_THEMING'),
    (e.RENDERER_HTML = 'RENDERER_HTML'),
    (e.RENDERER_PREACT = 'RENDERER_PREACT'),
    (e.RENDERER_REACT = 'RENDERER_REACT'),
    (e.RENDERER_SERVER = 'RENDERER_SERVER'),
    (e.RENDERER_SVELTE = 'RENDERER_SVELTE'),
    (e.RENDERER_VUE = 'RENDERER_VUE'),
    (e.RENDERER_VUE3 = 'RENDERER_VUE3'),
    (e.RENDERER_WEB_COMPONENTS = 'RENDERER_WEB-COMPONENTS'),
    (e.FRAMEWORK_NEXTJS = 'FRAMEWORK_NEXTJS'),
    (e.ADDON_VITEST = 'ADDON_VITEST'),
    (e.ADDON_A11Y = 'ADDON_A11Y'),
    e
  ))(JE || {}),
  UE = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 1,
        message: ve`
        Couldn't find story matching id '${t.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${t.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`,
      }),
        (this.data = t));
    }
  };
s(UE, 'MissingStoryAfterHmrError');
var VE = UE,
  HE = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 2,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function',
        message: ve`
        We detected that you use an implicit action arg while ${t.phase} of your story.  
        ${
          t.deprecated
            ? `
This is deprecated and won't work in Storybook 8 anymore.
`
            : ''
        }
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${t.name}: fn()
          }`,
      }),
        (this.data = t));
    }
  };
s(HE, 'ImplicitActionsDuringRendering');
var zE = HE,
  GE = class extends Ye {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 3,
        message: ve`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`,
      });
    }
  };
s(GE, 'CalledExtractOnStoreError');
var WE = GE,
  KE = class extends Ye {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 4,
        message: ve`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field',
      });
    }
  };
s(KE, 'MissingRenderToCanvasError');
var YE = KE,
  XE = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 5,
        message: ve`
        Called \`Preview.${t.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${t.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`,
      }),
        (this.data = t));
    }
  };
s(XE, 'CalledPreviewMethodBeforeInitializationError');
var It = XE,
  QE = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 6,
        message: ve`
        Error fetching \`/index.json\`:
        
        ${t.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`,
      }),
        (this.data = t));
    }
  };
s(QE, 'StoryIndexFetchError');
var ZE = QE,
  ew = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 7,
        message: ve`
        Tried to render docs entry ${t.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`,
      }),
        (this.data = t));
    }
  };
s(ew, 'MdxFileWithNoCsfReferencesError');
var tw = ew,
  rw = class extends Ye {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 8,
        message: ve`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`,
      });
    }
  };
s(rw, 'EmptyIndexError');
var nw = rw,
  ow = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 9,
        message: ve`
        Couldn't find story matching '${t.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`,
      }),
        (this.data = t));
    }
  };
s(ow, 'NoStoryMatchError');
var sw = ow,
  iw = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 10,
        message: ve`
        Couldn't find story matching id '${t.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`,
      }),
        (this.data = t));
    }
  };
s(iw, 'MissingStoryFromCsfFileError');
var aw = iw,
  lw = class extends Ye {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 11,
        message: ve`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`,
      });
    }
  };
s(lw, 'StoryStoreAccessedBeforeInitializationError');
var cw = lw,
  uw = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 12,
        message: ve`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${t.playFunction}`,
      }),
        (this.data = t));
    }
  };
s(uw, 'MountMustBeDestructuredError');
var pf = uw,
  dw = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 14,
        message: ve`
        No render function available for storyId '${t.id}'
      `,
      }),
        (this.data = t));
    }
  };
s(dw, 'NoRenderFunctionError');
var pw = dw,
  fw = class extends Ye {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 15,
        message: ve`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `,
      });
    }
  };
s(fw, 'NoStoryMountedError');
var mw = fw,
  yw = class extends Ye {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 16,
        message: `Status has typeId "${t.status.typeId}" but was added to store with typeId "${t.typeId}". Full status: ${JSON.stringify(t.status, null, 2)}`,
      }),
        (this.data = t));
    }
  };
s(yw, 'StatusTypeIdMismatchError');
var PL = yw,
  hw = class extends Ye {
    constructor() {
      super({
        category: 'FRAMEWORK_NEXTJS',
        code: 1,
        documentation: 'https://storybook.js.org/docs/get-started/nextjs#faq',
        message: ve`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `,
      });
    }
  };
s(hw, 'NextJsSharpError');
var xL = hw,
  gw = class extends Ye {
    constructor(t) {
      (super({
        category: 'FRAMEWORK_NEXTJS',
        code: 2,
        message: ve`
        Tried to access router mocks from "${t.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `,
      }),
        (this.data = t));
    }
  };
s(gw, 'NextjsRouterMocksNotAvailable');
var OL = gw,
  bw = class extends Ye {
    constructor(t) {
      (super({
        category: 'DOCS-TOOLS',
        code: 1,
        documentation: 'https://github.com/storybookjs/storybook/issues/26606',
        message: ve`
        There was a failure when generating detailed ArgTypes in ${t.language} for:
        ${JSON.stringify(t.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `,
      }),
        (this.data = t));
    }
  };
s(bw, 'UnknownArgTypesError');
var CL = bw,
  vw = class extends Ye {
    constructor(t) {
      (super({
        category: 'ADDON_VITEST',
        code: 1,
        message: ve`
        Encountered an unsupported value "${t.value}" when setting the viewport ${t.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `,
      }),
        (this.data = t));
    }
  };
s(vw, 'UnsupportedViewportDimensionError');
var IL = vw,
  Tw = class extends Ye {
    constructor() {
      super({
        category: 'ADDON_A11Y',
        code: 1,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter',
        message:
          'The "element" parameter in parameters.a11y has been removed. Use "context" instead.',
      });
    }
  };
s(Tw, 'ElementA11yParameterError');
var NL = Tw,
  Ew = {};
Rt(Ew, { Addon_TypesEnum: () => ww });
var ww = ((e) => (
    (e.TAB = 'tab'),
    (e.PANEL = 'panel'),
    (e.TOOL = 'tool'),
    (e.TOOLEXTRA = 'toolextra'),
    (e.PREVIEW = 'preview'),
    (e.experimental_PAGE = 'page'),
    (e.experimental_TEST_PROVIDER = 'test-provider'),
    e
  ))(ww || {}),
  Sw = {};
Rt(Sw, {
  ADDON_ID: () => Ol,
  CLEAR_ID: () => ML,
  CYCLIC_KEY: () => jL,
  EVENT_ID: () => _w,
  PANEL_ID: () => qL,
  PARAM_KEY: () => $L,
  action: () => Yo,
  actions: () => yz,
  config: () => bi,
  configureActions: () => pz,
});
var $L = 'actions',
  Ol = 'storybook/actions',
  qL = `${Ol}/panel`,
  _w = `${Ol}/action-event`,
  ML = `${Ol}/action-clear`,
  jL = '$___storybook.isCyclic',
  Mu = {};
Rt(Mu, {
  DocsContext: () => Xh,
  HooksContext: () => mf,
  Preview: () => sN,
  PreviewWeb: () => oz,
  PreviewWithSelection: () => yN,
  ReporterAPI: () => Wh,
  StoryStore: () => eN,
  UrlStore: () => wN,
  WebView: () => AN,
  addons: () => Ut,
  applyHooks: () => xw,
  combineArgs: () => ll,
  combineParameters: () => Dn,
  composeConfigs: () => Ln,
  composeStepRunners: () => Hh,
  composeStories: () => YI,
  composeStory: () => Yh,
  createPlaywrightTest: () => XI,
  decorateStory: () => Dh,
  defaultDecorateStory: () => Fh,
  emitTransformCode: () => CN,
  filterArgTypes: () => VI,
  getCsfFactoryAnnotations: () => Kh,
  inferControls: () => Vh,
  makeDecorator: () => FL,
  mockChannel: () => ff,
  normalizeArrays: () => Ne,
  normalizeProjectAnnotations: () => gi,
  normalizeStory: () => bo,
  pauseAnimations: () => Vc,
  prepareMeta: () => Bh,
  prepareStory: () => Uc,
  sanitizeStoryContextUpdate: () => Lh,
  setDefaultProjectAnnotations: () => GI,
  setProjectAnnotations: () => KI,
  simulateDOMContentLoaded: () => pl,
  simulatePageLoad: () => xN,
  sortStoriesV7: () => H3,
  useArgs: () => jw,
  useCallback: () => Eo,
  useChannel: () => qw,
  useEffect: () => Zr,
  useGlobals: () => kw,
  useMemo: () => gf,
  useParameter: () => Mw,
  useReducer: () => $w,
  useRef: () => Cw,
  useState: () => Nw,
  useStoryContext: () => _i,
  userOrAutoTitle: () => J3,
  userOrAutoTitleFromSpecifier: () => rN,
  waitForAnimations: () => Hc,
});
function ff() {
  const e = { setHandler: s(() => {}, 'setHandler'), send: s(() => {}, 'send') };
  return new _l({ transport: e });
}
s(ff, 'mockChannel');
var Aw = class {
  constructor() {
    ((this.getChannel = s(() => {
      if (!this.channel) {
        const t = ff();
        return (this.setChannel(t), t);
      }
      return this.channel;
    }, 'getChannel')),
      (this.ready = s(() => this.promise, 'ready')),
      (this.hasChannel = s(() => !!this.channel, 'hasChannel')),
      (this.setChannel = s((t) => {
        ((this.channel = t), this.resolve());
      }, 'setChannel')),
      (this.promise = new Promise((t) => {
        this.resolve = () => t(this.getChannel());
      })));
  }
};
s(Aw, 'AddonStore');
var kL = Aw,
  nu = '__STORYBOOK_ADDONS_PREVIEW';
function Rw() {
  return (te[nu] || (te[nu] = new kL()), te[nu]);
}
s(Rw, 'getAddonsStore');
var Ut = Rw(),
  Pw = class {
    constructor() {
      ((this.hookListsMap = void 0),
        (this.mountedDecorators = void 0),
        (this.prevMountedDecorators = void 0),
        (this.currentHooks = void 0),
        (this.nextHookIndex = void 0),
        (this.currentPhase = void 0),
        (this.currentEffects = void 0),
        (this.prevEffects = void 0),
        (this.currentDecoratorName = void 0),
        (this.hasUpdates = void 0),
        (this.currentContext = void 0),
        (this.renderListener = s((t) => {
          t === this.currentContext?.id &&
            (this.triggerEffects(), (this.currentContext = null), this.removeRenderListeners());
        }, 'renderListener')),
        this.init());
    }
    init() {
      ((this.hookListsMap = new WeakMap()),
        (this.mountedDecorators = new Set()),
        (this.prevMountedDecorators = new Set()),
        (this.currentHooks = []),
        (this.nextHookIndex = 0),
        (this.currentPhase = 'NONE'),
        (this.currentEffects = []),
        (this.prevEffects = []),
        (this.currentDecoratorName = null),
        (this.hasUpdates = !1),
        (this.currentContext = null));
    }
    clean() {
      (this.prevEffects.forEach((t) => {
        t.destroy && t.destroy();
      }),
        this.init(),
        this.removeRenderListeners());
    }
    getNextHook() {
      const t = this.currentHooks[this.nextHookIndex];
      return ((this.nextHookIndex += 1), t);
    }
    triggerEffects() {
      (this.prevEffects.forEach((t) => {
        !this.currentEffects.includes(t) && t.destroy && t.destroy();
      }),
        this.currentEffects.forEach((t) => {
          this.prevEffects.includes(t) || (t.destroy = t.create());
        }),
        (this.prevEffects = this.currentEffects),
        (this.currentEffects = []));
    }
    addRenderListeners() {
      (this.removeRenderListeners(), Ut.getChannel().on(Ta, this.renderListener));
    }
    removeRenderListeners() {
      Ut.getChannel().removeListener(Ta, this.renderListener);
    }
  };
s(Pw, 'HooksContext');
var mf = Pw;
function ju(e) {
  const t = s((...r) => {
    const { hooks: n } = typeof r[0] == 'function' ? r[1] : r[0],
      o = n.currentPhase,
      i = n.currentHooks,
      a = n.nextHookIndex,
      l = n.currentDecoratorName;
    ((n.currentDecoratorName = e.name),
      n.prevMountedDecorators.has(e)
        ? ((n.currentPhase = 'UPDATE'), (n.currentHooks = n.hookListsMap.get(e) || []))
        : ((n.currentPhase = 'MOUNT'),
          (n.currentHooks = []),
          n.hookListsMap.set(e, n.currentHooks),
          n.prevMountedDecorators.add(e)),
      (n.nextHookIndex = 0));
    const d = te.STORYBOOK_HOOKS_CONTEXT;
    te.STORYBOOK_HOOKS_CONTEXT = n;
    const u = e(...r);
    if (((te.STORYBOOK_HOOKS_CONTEXT = d), n.currentPhase === 'UPDATE' && n.getNextHook() != null))
      throw new Error(
        'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.',
      );
    return (
      (n.currentPhase = o),
      (n.currentHooks = i),
      (n.nextHookIndex = a),
      (n.currentDecoratorName = l),
      u
    );
  }, 'hookified');
  return ((t.originalFn = e), t);
}
s(ju, 'hookify');
var ou = 0,
  DL = 25,
  xw = s(
    (e) => (t, r) => {
      const n = e(
        ju(t),
        r.map((o) => ju(o)),
      );
      return (o) => {
        const { hooks: i } = o;
        (i.prevMountedDecorators ?? (i.prevMountedDecorators = new Set()),
          (i.mountedDecorators = new Set([t, ...r])),
          (i.currentContext = o),
          (i.hasUpdates = !1));
        let a = n(o);
        for (ou = 1; i.hasUpdates; )
          if (((i.hasUpdates = !1), (i.currentEffects = []), (a = n(o)), (ou += 1), ou > DL))
            throw new Error(
              'Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.',
            );
        return (i.addRenderListeners(), a);
      };
    },
    'applyHooks',
  ),
  LL = s((e, t) => e.length === t.length && e.every((r, n) => r === t[n]), 'areDepsEqual'),
  yf = s(
    () =>
      new Error(
        'Storybook preview hooks can only be called inside decorators and story functions.',
      ),
    'invalidHooksError',
  );
function hf() {
  return te.STORYBOOK_HOOKS_CONTEXT || null;
}
s(hf, 'getHooksContextOrNull');
function Cl() {
  const e = hf();
  if (e == null) throw yf();
  return e;
}
s(Cl, 'getHooksContextOrThrow');
function Ow(e, t, r) {
  const n = Cl();
  if (n.currentPhase === 'MOUNT') {
    r != null &&
      !Array.isArray(r) &&
      ke.warn(
        `${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`,
      );
    const o = { name: e, deps: r };
    return (n.currentHooks.push(o), t(o), o);
  }
  if (n.currentPhase === 'UPDATE') {
    const o = n.getNextHook();
    if (o == null) throw new Error('Rendered more hooks than during the previous render.');
    return (
      o.name !== e &&
        ke.warn(
          `Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ''}. This will lead to bugs and errors if not fixed.`,
        ),
      r != null &&
        o.deps == null &&
        ke.warn(
          `${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`,
        ),
      r != null &&
        o.deps != null &&
        r.length !== o.deps.length &&
        ke.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${r}`),
      (r == null || o.deps == null || !LL(r, o.deps)) && (t(o), (o.deps = r)),
      o
    );
  }
  throw yf();
}
s(Ow, 'useHook');
function Si(e, t, r) {
  const { memoizedState: n } = Ow(
    e,
    (o) => {
      o.memoizedState = t();
    },
    r,
  );
  return n;
}
s(Si, 'useMemoLike');
function gf(e, t) {
  return Si('useMemo', e, t);
}
s(gf, 'useMemo');
function Eo(e, t) {
  return Si('useCallback', () => e, t);
}
s(Eo, 'useCallback');
function bf(e, t) {
  return Si(e, () => ({ current: t }), []);
}
s(bf, 'useRefLike');
function Cw(e) {
  return bf('useRef', e);
}
s(Cw, 'useRef');
function Iw() {
  const e = hf();
  if (e != null && e.currentPhase !== 'NONE') e.hasUpdates = !0;
  else
    try {
      Ut.getChannel().emit(Gp);
    } catch {
      ke.warn('State updates of Storybook preview hooks work only in browser');
    }
}
s(Iw, 'triggerUpdate');
function vf(e, t) {
  const r = bf(e, typeof t == 'function' ? t() : t),
    n = s((o) => {
      ((r.current = typeof o == 'function' ? o(r.current) : o), Iw());
    }, 'setState');
  return [r.current, n];
}
s(vf, 'useStateLike');
function Nw(e) {
  return vf('useState', e);
}
s(Nw, 'useState');
function $w(e, t, r) {
  const n = r != null ? () => r(t) : t,
    [o, i] = vf('useReducer', n);
  return [o, s((l) => i((d) => e(d, l)), 'dispatch')];
}
s($w, 'useReducer');
function Zr(e, t) {
  const r = Cl(),
    n = Si('useEffect', () => ({ create: e }), t);
  r.currentEffects.includes(n) || r.currentEffects.push(n);
}
s(Zr, 'useEffect');
function qw(e, t = []) {
  const r = Ut.getChannel();
  return (
    Zr(
      () => (
        Object.entries(e).forEach(([n, o]) => r.on(n, o)),
        () => {
          Object.entries(e).forEach(([n, o]) => r.removeListener(n, o));
        }
      ),
      [...Object.keys(e), ...t],
    ),
    Eo(r.emit.bind(r), [r])
  );
}
s(qw, 'useChannel');
function _i() {
  const { currentContext: e } = Cl();
  if (e == null) throw yf();
  return e;
}
s(_i, 'useStoryContext');
function Mw(e, t) {
  const { parameters: r } = _i();
  if (e) return r[e] ?? t;
}
s(Mw, 'useParameter');
function jw() {
  const e = Ut.getChannel(),
    { id: t, args: r } = _i(),
    n = Eo((i) => e.emit(Xp, { storyId: t, updatedArgs: i }), [e, t]),
    o = Eo((i) => e.emit(Wp, { storyId: t, argNames: i }), [e, t]);
  return [r, n, o];
}
s(jw, 'useArgs');
function kw() {
  const e = Ut.getChannel(),
    { globals: t } = _i(),
    r = Eo((n) => e.emit(Yp, { globals: n }), [e]);
  return [t, r];
}
s(kw, 'useGlobals');
var FL = s(({ name: e, parameterName: t, wrapper: r, skipIfNoParametersOrOptions: n = !1 }) => {
  const o = s(
    (i) => (a, l) => {
      const d = l.parameters && l.parameters[t];
      return (d && d.disable) || (n && !i && !d) ? a(l) : r(a, l, { options: i, parameters: d });
    },
    'decorator',
  );
  return (...i) =>
    typeof i[0] == 'function'
      ? o()(...i)
      : (...a) => {
          if (a.length > 1) return i.length > 1 ? o(i)(...a) : o(...i)(...a);
          throw new Error(`Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`);
        };
}, 'makeDecorator');
function Dw(e) {
  return e
    .replace(/_/g, ' ')
    .replace(/-/g, ' ')
    .replace(/\./g, ' ')
    .replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, o) => `${r} ${n}${o}`)
    .replace(/([a-z])([A-Z])/g, (t, r, n) => `${r} ${n}`)
    .replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`)
    .replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`)
    .replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`)
    .replace(/ +/g, ' ')
    .trim();
}
s(Dw, 'toStartCaseStr');
var $g = Ke(hq(), 1),
  Lw = s((e) => e.map((t) => typeof t < 'u').filter(Boolean).length, 'count'),
  BL = s((e, t) => {
    const { exists: r, eq: n, neq: o, truthy: i } = e;
    if (Lw([r, n, o, i]) > 1)
      throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: o })}`);
    if (typeof n < 'u') return (0, $g.isEqual)(t, n);
    if (typeof o < 'u') return !(0, $g.isEqual)(t, o);
    if (typeof r < 'u') {
      const l = typeof t < 'u';
      return r ? l : !l;
    }
    return (typeof i > 'u' ? !0 : i) ? !!t : !t;
  }, 'testValue'),
  JL = s((e, t, r) => {
    if (!e.if) return !0;
    const { arg: n, global: o } = e.if;
    if (Lw([n, o]) !== 1)
      throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n, global: o })}`);
    const i = n ? t[n] : r[o];
    return BL(e.if, i);
  }, 'includeConditionalArg');
function Fw(e) {
  return e != null && Bw(e).includes('mount');
}
s(Fw, 'mountDestructured');
function Bw(e) {
  const t = e.toString().match(/[^(]*\(([^)]*)/);
  if (!t) return [];
  const r = ku(t[1]);
  if (!r.length) return [];
  const n = r[0];
  return n.startsWith('{') && n.endsWith('}')
    ? ku(n.slice(1, -1).replace(/\s/g, '')).map((i) => i.replace(/:.*|=.*/g, ''))
    : [];
}
s(Bw, 'getUsedProps');
function ku(e) {
  const t = [],
    r = [];
  let n = 0;
  for (let i = 0; i < e.length; i++)
    if (e[i] === '{' || e[i] === '[') r.push(e[i] === '{' ? '}' : ']');
    else if (e[i] === r[r.length - 1]) r.pop();
    else if (!r.length && e[i] === ',') {
      const a = e.substring(n, i).trim();
      (a && t.push(a), (n = i + 1));
    }
  const o = e.substring(n).trim();
  return (o && t.push(o), t);
}
s(ku, 'splitByComma');
var Jw = {};
Rt(Jw, { argsEnhancers: () => HL });
var Uw = s((e, t) => typeof t[e] > 'u' && !(e in t), 'isInInitialArgs'),
  UL = s((e) => {
    const {
      initialArgs: t,
      argTypes: r,
      id: n,
      parameters: { actions: o },
    } = e;
    if (!o || o.disable || !o.argTypesRegex || !r) return {};
    const i = new RegExp(o.argTypesRegex);
    return Object.entries(r)
      .filter(([l]) => !!i.test(l))
      .reduce((l, [d, u]) => (Uw(d, t) && (l[d] = Yo(d, { implicit: !0, id: n })), l), {});
  }, 'inferActionsFromArgTypesRegex'),
  VL = s((e) => {
    const {
      initialArgs: t,
      argTypes: r,
      parameters: { actions: n },
    } = e;
    return n?.disable || !r
      ? {}
      : Object.entries(r)
          .filter(([i, a]) => !!a.action)
          .reduce(
            (i, [a, l]) => (Uw(a, t) && (i[a] = Yo(typeof l.action == 'string' ? l.action : a)), i),
            {},
          );
  }, 'addActionsFromArgTypes'),
  HL = [VL, UL],
  Vw = {};
Rt(Vw, { loaders: () => sH });
var Hw = {};
Rt(Hw, {
  buildQueries: () => DU,
  clearAllMocks: () => Ny,
  configure: () => LU,
  createEvent: () => FU,
  expect: () => rH,
  findAllByAltText: () => JU,
  findAllByDisplayValue: () => UU,
  findAllByLabelText: () => VU,
  findAllByPlaceholderText: () => HU,
  findAllByRole: () => zU,
  findAllByTestId: () => GU,
  findAllByText: () => WU,
  findAllByTitle: () => KU,
  findByAltText: () => YU,
  findByDisplayValue: () => XU,
  findByLabelText: () => QU,
  findByPlaceholderText: () => ZU,
  findByRole: () => eV,
  findByTestId: () => tV,
  findByText: () => rV,
  findByTitle: () => nV,
  fireEvent: () => BU,
  fn: () => Cy,
  getAllByAltText: () => oV,
  getAllByDisplayValue: () => sV,
  getAllByLabelText: () => iV,
  getAllByPlaceholderText: () => aV,
  getAllByRole: () => lV,
  getAllByTestId: () => cV,
  getAllByText: () => uV,
  getAllByTitle: () => dV,
  getByAltText: () => pV,
  getByDisplayValue: () => fV,
  getByLabelText: () => mV,
  getByPlaceholderText: () => yV,
  getByRole: () => hV,
  getByTestId: () => gV,
  getByText: () => bV,
  getByTitle: () => vV,
  getConfig: () => TV,
  getDefaultNormalizer: () => EV,
  getElementError: () => wV,
  getNodeText: () => SV,
  getQueriesForElement: () => _V,
  getRoles: () => AV,
  getSuggestedQuery: () => RV,
  isInaccessible: () => PV,
  isMockFunction: () => An,
  logDOM: () => xV,
  logRoles: () => OV,
  mocked: () => dR,
  mocks: () => Li,
  onMockCall: () => Oy,
  prettyDOM: () => CV,
  prettyFormat: () => eH,
  queries: () => IV,
  queryAllByAltText: () => NV,
  queryAllByAttribute: () => $V,
  queryAllByDisplayValue: () => qV,
  queryAllByLabelText: () => MV,
  queryAllByPlaceholderText: () => jV,
  queryAllByRole: () => kV,
  queryAllByTestId: () => DV,
  queryAllByText: () => LV,
  queryAllByTitle: () => FV,
  queryByAltText: () => BV,
  queryByAttribute: () => JV,
  queryByDisplayValue: () => UV,
  queryByLabelText: () => VV,
  queryByPlaceholderText: () => HV,
  queryByRole: () => zV,
  queryByTestId: () => GV,
  queryByText: () => WV,
  queryByTitle: () => KV,
  queryHelpers: () => YV,
  resetAllMocks: () => $y,
  restoreAllMocks: () => qy,
  sb: () => nH,
  screen: () => XV,
  spyOn: () => IJ,
  uninstrumentedUserEvent: () => nI,
  userEvent: () => tH,
  waitFor: () => QV,
  waitForElementToBeRemoved: () => ZV,
  within: () => rI,
});
var zL = {
    reset: [0, 0],
    bold: [1, 22, '\x1B[22m\x1B[1m'],
    dim: [2, 22, '\x1B[22m\x1B[2m'],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBright: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
    bgBlackBright: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49],
  },
  zw = Object.entries(zL);
function Ai(e) {
  return String(e);
}
s(Ai, 'a');
Ai.open = '';
Ai.close = '';
zw.reduce((e, [t]) => ((e[t] = Ai), e), { isColorSupported: !1 });
function Gw(e = !1) {
  let t = typeof process < 'u' ? process : void 0,
    r = t?.env || {},
    n = t?.argv || [];
  return (
    (!('NO_COLOR' in r || n.includes('--no-color')) &&
      ('FORCE_COLOR' in r ||
        n.includes('--color') ||
        t?.platform === 'win32' ||
        (e && r.TERM !== 'dumb') ||
        'CI' in r)) ||
    (typeof window < 'u' && !!window.chrome)
  );
}
s(Gw, 'C');
function Ww(e = !1) {
  let t = Gw(e),
    r = s((a, l, d, u) => {
      let p = '',
        f = 0;
      do ((p += a.substring(f, u) + d), (f = u + l.length), (u = a.indexOf(l, f)));
      while (~u);
      return p + a.substring(f);
    }, 'i'),
    n = s((a, l, d = a) => {
      let u = s((p) => {
        let f = String(p),
          m = f.indexOf(l, a.length);
        return ~m ? a + r(f, l, d, m) + l : a + f + l;
      }, 'o');
      return ((u.open = a), (u.close = l), u);
    }, 'g'),
    o = { isColorSupported: t },
    i = s((a) => `\x1B[${a}m`, 'd');
  for (let [a, l] of zw) o[a] = t ? n(i(l[0]), i(l[1]), l[2]) : Ai;
  return o;
}
s(Ww, 'p');
var Ue = Ww();
function Tf(e, t) {
  return (
    t.forEach(function (r) {
      r &&
        typeof r != 'string' &&
        !Array.isArray(r) &&
        Object.keys(r).forEach(function (n) {
          if (n !== 'default' && !(n in e)) {
            var o = Object.getOwnPropertyDescriptor(r, n);
            Object.defineProperty(
              e,
              n,
              o.get
                ? o
                : {
                    enumerable: !0,
                    get: s(function () {
                      return r[n];
                    }, 'get'),
                  },
            );
          }
        });
    }),
    Object.freeze(e)
  );
}
s(Tf, '_mergeNamespaces');
function Kw(e, t) {
  const r = Object.keys(e),
    n = t === null ? r : r.sort(t);
  if (Object.getOwnPropertySymbols)
    for (const o of Object.getOwnPropertySymbols(e))
      Object.getOwnPropertyDescriptor(e, o).enumerable && n.push(o);
  return n;
}
s(Kw, 'getKeysOfEnumerableProperties');
function Lo(e, t, r, n, o, i, a = ': ') {
  let l = '',
    d = 0,
    u = e.next();
  if (!u.done) {
    l += t.spacingOuter;
    const p = r + t.indent;
    for (; !u.done; ) {
      if (((l += p), d++ === t.maxWidth)) {
        l += '';
        break;
      }
      const f = i(u.value[0], t, p, n, o),
        m = i(u.value[1], t, p, n, o);
      ((l += f + a + m),
        (u = e.next()),
        u.done ? t.min || (l += ',') : (l += `,${t.spacingInner}`));
    }
    l += t.spacingOuter + r;
  }
  return l;
}
s(Lo, 'printIteratorEntries');
function Il(e, t, r, n, o, i) {
  let a = '',
    l = 0,
    d = e.next();
  if (!d.done) {
    a += t.spacingOuter;
    const u = r + t.indent;
    for (; !d.done; ) {
      if (((a += u), l++ === t.maxWidth)) {
        a += '';
        break;
      }
      ((a += i(d.value, t, u, n, o)),
        (d = e.next()),
        d.done ? t.min || (a += ',') : (a += `,${t.spacingInner}`));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
s(Il, 'printIteratorValues');
function Zs(e, t, r, n, o, i) {
  let a = '';
  e = e instanceof ArrayBuffer ? new DataView(e) : e;
  const l = s((u) => u instanceof DataView, 'isDataView'),
    d = l(e) ? e.byteLength : e.length;
  if (d > 0) {
    a += t.spacingOuter;
    const u = r + t.indent;
    for (let p = 0; p < d; p++) {
      if (((a += u), p === t.maxWidth)) {
        a += '';
        break;
      }
      ((l(e) || p in e) && (a += i(l(e) ? e.getInt8(p) : e[p], t, u, n, o)),
        p < d - 1 ? (a += `,${t.spacingInner}`) : t.min || (a += ','));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
s(Zs, 'printListItems');
function Nl(e, t, r, n, o, i) {
  let a = '';
  const l = Kw(e, t.compareKeys);
  if (l.length > 0) {
    a += t.spacingOuter;
    const d = r + t.indent;
    for (let u = 0; u < l.length; u++) {
      const p = l[u],
        f = i(p, t, d, n, o),
        m = i(e[p], t, d, n, o);
      ((a += `${d + f}: ${m}`),
        u < l.length - 1 ? (a += `,${t.spacingInner}`) : t.min || (a += ','));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
s(Nl, 'printObjectProperties');
var GL = typeof Symbol == 'function' && Symbol.for ? Symbol.for('jest.asymmetricMatcher') : 1267621,
  zi = ' ',
  WL = s((e, t, r, n, o, i) => {
    const a = e.toString();
    if (a === 'ArrayContaining' || a === 'ArrayNotContaining')
      return ++n > t.maxDepth ? `[${a}]` : `${a + zi}[${Zs(e.sample, t, r, n, o, i)}]`;
    if (a === 'ObjectContaining' || a === 'ObjectNotContaining')
      return ++n > t.maxDepth ? `[${a}]` : `${a + zi}{${Nl(e.sample, t, r, n, o, i)}}`;
    if (
      a === 'StringMatching' ||
      a === 'StringNotMatching' ||
      a === 'StringContaining' ||
      a === 'StringNotContaining'
    )
      return a + zi + i(e.sample, t, r, n, o);
    if (typeof e.toAsymmetricMatcher != 'function')
      throw new TypeError(
        `Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`,
      );
    return e.toAsymmetricMatcher();
  }, 'serialize$5'),
  KL = s((e) => e && e.$$typeof === GL, 'test$5'),
  YL = { serialize: WL, test: KL },
  XL = ' ',
  Yw = new Set(['DOMStringMap', 'NamedNodeMap']),
  QL = /^(?:HTML\w*Collection|NodeList)$/;
function Xw(e) {
  return Yw.has(e) || QL.test(e);
}
s(Xw, 'testName');
var ZL = s((e) => e && e.constructor && !!e.constructor.name && Xw(e.constructor.name), 'test$4');
function Qw(e) {
  return e.constructor.name === 'NamedNodeMap';
}
s(Qw, 'isNamedNodeMap');
var eF = s((e, t, r, n, o, i) => {
    const a = e.constructor.name;
    return ++n > t.maxDepth
      ? `[${a}]`
      : (t.min ? '' : a + XL) +
          (Yw.has(a)
            ? `{${Nl(Qw(e) ? [...e].reduce((l, d) => ((l[d.name] = d.value), l), {}) : { ...e }, t, r, n, o, i)}}`
            : `[${Zs([...e], t, r, n, o, i)}]`);
  }, 'serialize$4'),
  tF = { serialize: eF, test: ZL };
function Ef(e) {
  return e.replaceAll('<', '&lt;').replaceAll('>', '&gt;');
}
s(Ef, 'escapeHTML');
function $l(e, t, r, n, o, i, a) {
  const l = n + r.indent,
    d = r.colors;
  return e
    .map((u) => {
      const p = t[u];
      let f = a(p, r, l, o, i);
      return (
        typeof p != 'string' &&
          (f.includes(`
`) && (f = r.spacingOuter + l + f + r.spacingOuter + n),
          (f = `{${f}}`)),
        `${r.spacingInner + n + d.prop.open + u + d.prop.close}=${d.value.open}${f}${d.value.close}`
      );
    })
    .join('');
}
s($l, 'printProps');
function ql(e, t, r, n, o, i) {
  return e
    .map((a) => t.spacingOuter + r + (typeof a == 'string' ? wf(a, t) : i(a, t, r, n, o)))
    .join('');
}
s(ql, 'printChildren');
function wf(e, t) {
  const r = t.colors.content;
  return r.open + Ef(e) + r.close;
}
s(wf, 'printText');
function Zw(e, t) {
  const r = t.colors.comment;
  return `${r.open}<!--${Ef(e)}-->${r.close}`;
}
s(Zw, 'printComment');
function Ml(e, t, r, n, o) {
  const i = n.colors.tag;
  return `${i.open}<${e}${t && i.close + t + n.spacingOuter + o + i.open}${r ? `>${i.close}${r}${n.spacingOuter}${o}${i.open}</${e}` : `${t && !n.min ? '' : ' '}/`}>${i.close}`;
}
s(Ml, 'printElement');
function jl(e, t) {
  const r = t.colors.tag;
  return `${r.open}<${e}${r.close} ${r.open} />${r.close}`;
}
s(jl, 'printElementAsLeaf');
var rF = 1,
  eS = 3,
  tS = 8,
  rS = 11,
  nF = /^(?:(?:HTML|SVG)\w*)?Element$/;
function nS(e) {
  try {
    return typeof e.hasAttribute == 'function' && e.hasAttribute('is');
  } catch {
    return !1;
  }
}
s(nS, 'testHasAttribute');
function oS(e) {
  const t = e.constructor.name,
    { nodeType: r, tagName: n } = e,
    o = (typeof n == 'string' && n.includes('-')) || nS(e);
  return (
    (r === rF && (nF.test(t) || o)) ||
    (r === eS && t === 'Text') ||
    (r === tS && t === 'Comment') ||
    (r === rS && t === 'DocumentFragment')
  );
}
s(oS, 'testNode');
var oF = s((e) => {
  var t;
  return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && oS(e);
}, 'test$3');
function sS(e) {
  return e.nodeType === eS;
}
s(sS, 'nodeIsText');
function iS(e) {
  return e.nodeType === tS;
}
s(iS, 'nodeIsComment');
function ta(e) {
  return e.nodeType === rS;
}
s(ta, 'nodeIsFragment');
var sF = s((e, t, r, n, o, i) => {
    if (sS(e)) return wf(e.data, t);
    if (iS(e)) return Zw(e.data, t);
    const a = ta(e) ? 'DocumentFragment' : e.tagName.toLowerCase();
    return ++n > t.maxDepth
      ? jl(a, t)
      : Ml(
          a,
          $l(
            ta(e) ? [] : Array.from(e.attributes, (l) => l.name).sort(),
            ta(e) ? {} : [...e.attributes].reduce((l, d) => ((l[d.name] = d.value), l), {}),
            t,
            r + t.indent,
            n,
            o,
            i,
          ),
          ql(Array.prototype.slice.call(e.childNodes || e.children), t, r + t.indent, n, o, i),
          t,
          r,
        );
  }, 'serialize$3'),
  iF = { serialize: sF, test: oF },
  aF = '@@__IMMUTABLE_ITERABLE__@@',
  lF = '@@__IMMUTABLE_LIST__@@',
  cF = '@@__IMMUTABLE_KEYED__@@',
  uF = '@@__IMMUTABLE_MAP__@@',
  qg = '@@__IMMUTABLE_ORDERED__@@',
  dF = '@@__IMMUTABLE_RECORD__@@',
  pF = '@@__IMMUTABLE_SEQ__@@',
  fF = '@@__IMMUTABLE_SET__@@',
  mF = '@@__IMMUTABLE_STACK__@@',
  wo = s((e) => `Immutable.${e}`, 'getImmutableName'),
  kl = s((e) => `[${e}]`, 'printAsLeaf'),
  ei = ' ',
  Mg = '';
function aS(e, t, r, n, o, i, a) {
  return ++n > t.maxDepth ? kl(wo(a)) : `${wo(a) + ei}{${Lo(e.entries(), t, r, n, o, i)}}`;
}
s(aS, 'printImmutableEntries');
function lS(e) {
  let t = 0;
  return {
    next() {
      if (t < e._keys.length) {
        const r = e._keys[t++];
        return { done: !1, value: [r, e.get(r)] };
      }
      return { done: !0, value: void 0 };
    },
  };
}
s(lS, 'getRecordEntries');
function cS(e, t, r, n, o, i) {
  const a = wo(e._name || 'Record');
  return ++n > t.maxDepth ? kl(a) : `${a + ei}{${Lo(lS(e), t, r, n, o, i)}}`;
}
s(cS, 'printImmutableRecord');
function uS(e, t, r, n, o, i) {
  const a = wo('Seq');
  return ++n > t.maxDepth
    ? kl(a)
    : e[cF]
      ? `${a + ei}{${e._iter || e._object ? Lo(e.entries(), t, r, n, o, i) : Mg}}`
      : `${a + ei}[${e._iter || e._array || e._collection || e._iterable ? Il(e.values(), t, r, n, o, i) : Mg}]`;
}
s(uS, 'printImmutableSeq');
function ra(e, t, r, n, o, i, a) {
  return ++n > t.maxDepth ? kl(wo(a)) : `${wo(a) + ei}[${Il(e.values(), t, r, n, o, i)}]`;
}
s(ra, 'printImmutableValues');
var yF = s(
    (e, t, r, n, o, i) =>
      e[uF]
        ? aS(e, t, r, n, o, i, e[qg] ? 'OrderedMap' : 'Map')
        : e[lF]
          ? ra(e, t, r, n, o, i, 'List')
          : e[fF]
            ? ra(e, t, r, n, o, i, e[qg] ? 'OrderedSet' : 'Set')
            : e[mF]
              ? ra(e, t, r, n, o, i, 'Stack')
              : e[pF]
                ? uS(e, t, r, n, o, i)
                : cS(e, t, r, n, o, i),
    'serialize$2',
  ),
  hF = s((e) => e && (e[aF] === !0 || e[dF] === !0), 'test$2'),
  gF = { serialize: yF, test: hF };
function Sf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
s(Sf, 'getDefaultExportFromCjs');
var su = { exports: {} },
  Ie = {},
  jg;
function dS() {
  if (jg) return Ie;
  jg = 1;
  var e = Symbol.for('react.transitional.element'),
    t = Symbol.for('react.portal'),
    r = Symbol.for('react.fragment'),
    n = Symbol.for('react.strict_mode'),
    o = Symbol.for('react.profiler'),
    i = Symbol.for('react.consumer'),
    a = Symbol.for('react.context'),
    l = Symbol.for('react.forward_ref'),
    d = Symbol.for('react.suspense'),
    u = Symbol.for('react.suspense_list'),
    p = Symbol.for('react.memo'),
    f = Symbol.for('react.lazy'),
    m = Symbol.for('react.view_transition'),
    h = Symbol.for('react.client.reference');
  function g(v) {
    if (typeof v == 'object' && v !== null) {
      var E = v.$$typeof;
      switch (E) {
        case e:
          switch (((v = v.type), v)) {
            case r:
            case o:
            case n:
            case d:
            case u:
            case m:
              return v;
            default:
              switch (((v = v && v.$$typeof), v)) {
                case a:
                case l:
                case f:
                case p:
                  return v;
                case i:
                  return v;
                default:
                  return E;
              }
          }
        case t:
          return E;
      }
    }
  }
  return (
    s(g, 'typeOf'),
    (Ie.ContextConsumer = i),
    (Ie.ContextProvider = a),
    (Ie.Element = e),
    (Ie.ForwardRef = l),
    (Ie.Fragment = r),
    (Ie.Lazy = f),
    (Ie.Memo = p),
    (Ie.Portal = t),
    (Ie.Profiler = o),
    (Ie.StrictMode = n),
    (Ie.Suspense = d),
    (Ie.SuspenseList = u),
    (Ie.isContextConsumer = function (v) {
      return g(v) === i;
    }),
    (Ie.isContextProvider = function (v) {
      return g(v) === a;
    }),
    (Ie.isElement = function (v) {
      return typeof v == 'object' && v !== null && v.$$typeof === e;
    }),
    (Ie.isForwardRef = function (v) {
      return g(v) === l;
    }),
    (Ie.isFragment = function (v) {
      return g(v) === r;
    }),
    (Ie.isLazy = function (v) {
      return g(v) === f;
    }),
    (Ie.isMemo = function (v) {
      return g(v) === p;
    }),
    (Ie.isPortal = function (v) {
      return g(v) === t;
    }),
    (Ie.isProfiler = function (v) {
      return g(v) === o;
    }),
    (Ie.isStrictMode = function (v) {
      return g(v) === n;
    }),
    (Ie.isSuspense = function (v) {
      return g(v) === d;
    }),
    (Ie.isSuspenseList = function (v) {
      return g(v) === u;
    }),
    (Ie.isValidElementType = function (v) {
      return (
        typeof v == 'string' ||
        typeof v == 'function' ||
        v === r ||
        v === o ||
        v === n ||
        v === d ||
        v === u ||
        (typeof v == 'object' &&
          v !== null &&
          (v.$$typeof === f ||
            v.$$typeof === p ||
            v.$$typeof === a ||
            v.$$typeof === i ||
            v.$$typeof === l ||
            v.$$typeof === h ||
            v.getModuleId !== void 0))
      );
    }),
    (Ie.typeOf = g),
    Ie
  );
}
s(dS, 'requireReactIs_production');
var kg;
function pS() {
  return (kg || ((kg = 1), (su.exports = dS())), su.exports);
}
s(pS, 'requireReactIs$1');
var fS = pS(),
  bF = Sf(fS),
  vF = Tf({ __proto__: null, default: bF }, [fS]),
  iu = { exports: {} },
  Oe = {},
  Dg;
function mS() {
  if (Dg) return Oe;
  Dg = 1;
  var e = Symbol.for('react.element'),
    t = Symbol.for('react.portal'),
    r = Symbol.for('react.fragment'),
    n = Symbol.for('react.strict_mode'),
    o = Symbol.for('react.profiler'),
    i = Symbol.for('react.provider'),
    a = Symbol.for('react.context'),
    l = Symbol.for('react.server_context'),
    d = Symbol.for('react.forward_ref'),
    u = Symbol.for('react.suspense'),
    p = Symbol.for('react.suspense_list'),
    f = Symbol.for('react.memo'),
    m = Symbol.for('react.lazy'),
    h = Symbol.for('react.offscreen'),
    g;
  g = Symbol.for('react.module.reference');
  function v(E) {
    if (typeof E == 'object' && E !== null) {
      var b = E.$$typeof;
      switch (b) {
        case e:
          switch (((E = E.type), E)) {
            case r:
            case o:
            case n:
            case u:
            case p:
              return E;
            default:
              switch (((E = E && E.$$typeof), E)) {
                case l:
                case a:
                case d:
                case m:
                case f:
                case i:
                  return E;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return (
    s(v, 'v'),
    (Oe.ContextConsumer = a),
    (Oe.ContextProvider = i),
    (Oe.Element = e),
    (Oe.ForwardRef = d),
    (Oe.Fragment = r),
    (Oe.Lazy = m),
    (Oe.Memo = f),
    (Oe.Portal = t),
    (Oe.Profiler = o),
    (Oe.StrictMode = n),
    (Oe.Suspense = u),
    (Oe.SuspenseList = p),
    (Oe.isAsyncMode = function () {
      return !1;
    }),
    (Oe.isConcurrentMode = function () {
      return !1;
    }),
    (Oe.isContextConsumer = function (E) {
      return v(E) === a;
    }),
    (Oe.isContextProvider = function (E) {
      return v(E) === i;
    }),
    (Oe.isElement = function (E) {
      return typeof E == 'object' && E !== null && E.$$typeof === e;
    }),
    (Oe.isForwardRef = function (E) {
      return v(E) === d;
    }),
    (Oe.isFragment = function (E) {
      return v(E) === r;
    }),
    (Oe.isLazy = function (E) {
      return v(E) === m;
    }),
    (Oe.isMemo = function (E) {
      return v(E) === f;
    }),
    (Oe.isPortal = function (E) {
      return v(E) === t;
    }),
    (Oe.isProfiler = function (E) {
      return v(E) === o;
    }),
    (Oe.isStrictMode = function (E) {
      return v(E) === n;
    }),
    (Oe.isSuspense = function (E) {
      return v(E) === u;
    }),
    (Oe.isSuspenseList = function (E) {
      return v(E) === p;
    }),
    (Oe.isValidElementType = function (E) {
      return (
        typeof E == 'string' ||
        typeof E == 'function' ||
        E === r ||
        E === o ||
        E === n ||
        E === u ||
        E === p ||
        E === h ||
        (typeof E == 'object' &&
          E !== null &&
          (E.$$typeof === m ||
            E.$$typeof === f ||
            E.$$typeof === i ||
            E.$$typeof === a ||
            E.$$typeof === d ||
            E.$$typeof === g ||
            E.getModuleId !== void 0))
      );
    }),
    (Oe.typeOf = v),
    Oe
  );
}
s(mS, 'requireReactIs_production_min');
var Lg;
function yS() {
  return (Lg || ((Lg = 1), (iu.exports = mS())), iu.exports);
}
s(yS, 'requireReactIs');
var hS = yS(),
  TF = Sf(hS),
  EF = Tf({ __proto__: null, default: TF }, [hS]),
  wF = [
    'isAsyncMode',
    'isConcurrentMode',
    'isContextConsumer',
    'isContextProvider',
    'isElement',
    'isForwardRef',
    'isFragment',
    'isLazy',
    'isMemo',
    'isPortal',
    'isProfiler',
    'isStrictMode',
    'isSuspense',
    'isSuspenseList',
    'isValidElementType',
  ],
  hn = Object.fromEntries(wF.map((e) => [e, (t) => EF[e](t) || vF[e](t)]));
function _f(e, t = []) {
  if (Array.isArray(e)) for (const r of e) _f(r, t);
  else e != null && e !== !1 && e !== '' && t.push(e);
  return t;
}
s(_f, 'getChildren');
function Du(e) {
  const t = e.type;
  if (typeof t == 'string') return t;
  if (typeof t == 'function') return t.displayName || t.name || 'Unknown';
  if (hn.isFragment(e)) return 'React.Fragment';
  if (hn.isSuspense(e)) return 'React.Suspense';
  if (typeof t == 'object' && t !== null) {
    if (hn.isContextProvider(e)) return 'Context.Provider';
    if (hn.isContextConsumer(e)) return 'Context.Consumer';
    if (hn.isForwardRef(e)) {
      if (t.displayName) return t.displayName;
      const r = t.render.displayName || t.render.name || '';
      return r === '' ? 'ForwardRef' : `ForwardRef(${r})`;
    }
    if (hn.isMemo(e)) {
      const r = t.displayName || t.type.displayName || t.type.name || '';
      return r === '' ? 'Memo' : `Memo(${r})`;
    }
  }
  return 'UNDEFINED';
}
s(Du, 'getType');
function gS(e) {
  const { props: t } = e;
  return Object.keys(t)
    .filter((r) => r !== 'children' && t[r] !== void 0)
    .sort();
}
s(gS, 'getPropKeys$1');
var SF = s(
    (e, t, r, n, o, i) =>
      ++n > t.maxDepth
        ? jl(Du(e), t)
        : Ml(
            Du(e),
            $l(gS(e), e.props, t, r + t.indent, n, o, i),
            ql(_f(e.props.children), t, r + t.indent, n, o, i),
            t,
            r,
          ),
    'serialize$1',
  ),
  _F = s((e) => e != null && hn.isElement(e), 'test$1'),
  AF = { serialize: SF, test: _F },
  RF = typeof Symbol == 'function' && Symbol.for ? Symbol.for('react.test.json') : 245830487;
function bS(e) {
  const { props: t } = e;
  return t
    ? Object.keys(t)
        .filter((r) => t[r] !== void 0)
        .sort()
    : [];
}
s(bS, 'getPropKeys');
var PF = s(
    (e, t, r, n, o, i) =>
      ++n > t.maxDepth
        ? jl(e.type, t)
        : Ml(
            e.type,
            e.props ? $l(bS(e), e.props, t, r + t.indent, n, o, i) : '',
            e.children ? ql(e.children, t, r + t.indent, n, o, i) : '',
            t,
            r,
          ),
    'serialize',
  ),
  xF = s((e) => e && e.$$typeof === RF, 'test'),
  OF = { serialize: PF, test: xF },
  vS = Object.prototype.toString,
  CF = Date.prototype.toISOString,
  IF = Error.prototype.toString,
  Fg = RegExp.prototype.toString;
function Ls(e) {
  return (typeof e.constructor == 'function' && e.constructor.name) || 'Object';
}
s(Ls, 'getConstructorName');
function TS(e) {
  return typeof window < 'u' && e === window;
}
s(TS, 'isWindow');
var NF = /^Symbol\((.*)\)(.*)$/,
  $F = /\n/g,
  ES = class extends Error {
    constructor(t, r) {
      (super(t), (this.stack = r), (this.name = this.constructor.name));
    }
  };
s(ES, 'PrettyFormatPluginError');
var wS = ES;
function SS(e) {
  return (
    e === '[object Array]' ||
    e === '[object ArrayBuffer]' ||
    e === '[object DataView]' ||
    e === '[object Float32Array]' ||
    e === '[object Float64Array]' ||
    e === '[object Int8Array]' ||
    e === '[object Int16Array]' ||
    e === '[object Int32Array]' ||
    e === '[object Uint8Array]' ||
    e === '[object Uint8ClampedArray]' ||
    e === '[object Uint16Array]' ||
    e === '[object Uint32Array]'
  );
}
s(SS, 'isToStringedArrayType');
function _S(e) {
  return Object.is(e, -0) ? '-0' : String(e);
}
s(_S, 'printNumber');
function AS(e) {
  return `${e}n`;
}
s(AS, 'printBigInt');
function Lu(e, t) {
  return t ? `[Function ${e.name || 'anonymous'}]` : '[Function]';
}
s(Lu, 'printFunction');
function Fu(e) {
  return String(e).replace(NF, 'Symbol($1)');
}
s(Fu, 'printSymbol');
function Bu(e) {
  return `[${IF.call(e)}]`;
}
s(Bu, 'printError');
function Af(e, t, r, n) {
  if (e === !0 || e === !1) return `${e}`;
  if (e === void 0) return 'undefined';
  if (e === null) return 'null';
  const o = typeof e;
  if (o === 'number') return _S(e);
  if (o === 'bigint') return AS(e);
  if (o === 'string') return n ? `"${e.replaceAll(/"|\\/g, '\\$&')}"` : `"${e}"`;
  if (o === 'function') return Lu(e, t);
  if (o === 'symbol') return Fu(e);
  const i = vS.call(e);
  return i === '[object WeakMap]'
    ? 'WeakMap {}'
    : i === '[object WeakSet]'
      ? 'WeakSet {}'
      : i === '[object Function]' || i === '[object GeneratorFunction]'
        ? Lu(e, t)
        : i === '[object Symbol]'
          ? Fu(e)
          : i === '[object Date]'
            ? Number.isNaN(+e)
              ? 'Date { NaN }'
              : CF.call(e)
            : i === '[object Error]'
              ? Bu(e)
              : i === '[object RegExp]'
                ? r
                  ? Fg.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, '\\$&')
                  : Fg.call(e)
                : e instanceof Error
                  ? Bu(e)
                  : null;
}
s(Af, 'printBasicValue');
function Rf(e, t, r, n, o, i) {
  if (o.includes(e)) return '[Circular]';
  ((o = [...o]), o.push(e));
  const a = ++n > t.maxDepth,
    l = t.min;
  if (t.callToJSON && !a && e.toJSON && typeof e.toJSON == 'function' && !i)
    return Ar(e.toJSON(), t, r, n, o, !0);
  const d = vS.call(e);
  return d === '[object Arguments]'
    ? a
      ? '[Arguments]'
      : `${l ? '' : 'Arguments '}[${Zs(e, t, r, n, o, Ar)}]`
    : SS(d)
      ? a
        ? `[${e.constructor.name}]`
        : `${l || (!t.printBasicPrototype && e.constructor.name === 'Array') ? '' : `${e.constructor.name} `}[${Zs(e, t, r, n, o, Ar)}]`
      : d === '[object Map]'
        ? a
          ? '[Map]'
          : `Map {${Lo(e.entries(), t, r, n, o, Ar, ' => ')}}`
        : d === '[object Set]'
          ? a
            ? '[Set]'
            : `Set {${Il(e.values(), t, r, n, o, Ar)}}`
          : a || TS(e)
            ? `[${Ls(e)}]`
            : `${l || (!t.printBasicPrototype && Ls(e) === 'Object') ? '' : `${Ls(e)} `}{${Nl(e, t, r, n, o, Ar)}}`;
}
s(Rf, 'printComplexValue');
var qF = {
  test: s((e) => e && e instanceof Error, 'test'),
  serialize(e, t, r, n, o, i) {
    if (o.includes(e)) return '[Circular]';
    o = [...o, e];
    const a = ++n > t.maxDepth,
      { message: l, cause: d, ...u } = e,
      p = {
        message: l,
        ...(typeof d < 'u' ? { cause: d } : {}),
        ...(e instanceof AggregateError ? { errors: e.errors } : {}),
        ...u,
      },
      f = e.name !== 'Error' ? e.name : Ls(e);
    return a ? `[${f}]` : `${f} {${Lo(Object.entries(p).values(), t, r, n, o, i)}}`;
  },
};
function RS(e) {
  return e.serialize != null;
}
s(RS, 'isNewPlugin');
function Pf(e, t, r, n, o, i) {
  let a;
  try {
    a = RS(e)
      ? e.serialize(t, r, n, o, i, Ar)
      : e.print(
          t,
          (l) => Ar(l, r, n, o, i),
          (l) => {
            const d = n + r.indent;
            return (
              d +
              l.replaceAll(
                $F,
                `
${d}`,
              )
            );
          },
          { edgeSpacing: r.spacingOuter, min: r.min, spacing: r.spacingInner },
          r.colors,
        );
  } catch (l) {
    throw new wS(l.message, l.stack);
  }
  if (typeof a != 'string')
    throw new TypeError(
      `pretty-format: Plugin must return type "string" but instead returned "${typeof a}".`,
    );
  return a;
}
s(Pf, 'printPlugin');
function xf(e, t) {
  for (const r of e)
    try {
      if (r.test(t)) return r;
    } catch (n) {
      throw new wS(n.message, n.stack);
    }
  return null;
}
s(xf, 'findPlugin');
function Ar(e, t, r, n, o, i) {
  const a = xf(t.plugins, e);
  if (a !== null) return Pf(a, e, t, r, n, o);
  const l = Af(e, t.printFunctionName, t.escapeRegex, t.escapeString);
  return l !== null ? l : Rf(e, t, r, n, o, i);
}
s(Ar, 'printer');
var Of = { comment: 'gray', content: 'reset', prop: 'yellow', tag: 'cyan', value: 'green' },
  PS = Object.keys(Of),
  Kt = {
    callToJSON: !0,
    compareKeys: void 0,
    escapeRegex: !1,
    escapeString: !0,
    highlight: !1,
    indent: 2,
    maxDepth: Number.POSITIVE_INFINITY,
    maxWidth: Number.POSITIVE_INFINITY,
    min: !1,
    plugins: [],
    printBasicPrototype: !0,
    printFunctionName: !0,
    theme: Of,
  };
function xS(e) {
  for (const t of Object.keys(e))
    if (!Object.prototype.hasOwnProperty.call(Kt, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  if (e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
s(xS, 'validateOptions');
function OS() {
  return PS.reduce((e, t) => {
    const r = Of[t],
      n = r && Ue[r];
    if (n && typeof n.close == 'string' && typeof n.open == 'string') e[t] = n;
    else
      throw new Error(
        `pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`,
      );
    return e;
  }, Object.create(null));
}
s(OS, 'getColorsHighlight');
function CS() {
  return PS.reduce((e, t) => ((e[t] = { close: '', open: '' }), e), Object.create(null));
}
s(CS, 'getColorsEmpty');
function Cf(e) {
  return e?.printFunctionName ?? Kt.printFunctionName;
}
s(Cf, 'getPrintFunctionName');
function If(e) {
  return e?.escapeRegex ?? Kt.escapeRegex;
}
s(If, 'getEscapeRegex');
function Nf(e) {
  return e?.escapeString ?? Kt.escapeString;
}
s(Nf, 'getEscapeString');
function Ju(e) {
  return {
    callToJSON: e?.callToJSON ?? Kt.callToJSON,
    colors: e?.highlight ? OS() : CS(),
    compareKeys:
      typeof e?.compareKeys == 'function' || e?.compareKeys === null
        ? e.compareKeys
        : Kt.compareKeys,
    escapeRegex: If(e),
    escapeString: Nf(e),
    indent: e?.min ? '' : IS(e?.indent ?? Kt.indent),
    maxDepth: e?.maxDepth ?? Kt.maxDepth,
    maxWidth: e?.maxWidth ?? Kt.maxWidth,
    min: e?.min ?? Kt.min,
    plugins: e?.plugins ?? Kt.plugins,
    printBasicPrototype: e?.printBasicPrototype ?? !0,
    printFunctionName: Cf(e),
    spacingInner: e?.min
      ? ' '
      : `
`,
    spacingOuter: e?.min
      ? ''
      : `
`,
  };
}
s(Ju, 'getConfig');
function IS(e) {
  return Array.from({ length: e + 1 }).join(' ');
}
s(IS, 'createIndent');
function Xt(e, t) {
  if (t && (xS(t), t.plugins)) {
    const n = xf(t.plugins, e);
    if (n !== null) return Pf(n, e, Ju(t), '', 0, []);
  }
  const r = Af(e, Cf(t), If(t), Nf(t));
  return r !== null ? r : Rf(e, Ju(t), '', 0, []);
}
s(Xt, 'format');
var $f = {
    AsymmetricMatcher: YL,
    DOMCollection: tF,
    DOMElement: iF,
    Immutable: gF,
    ReactElement: AF,
    ReactTestComponent: OF,
    Error: qF,
  },
  Bg = {
    bold: ['1', '22'],
    dim: ['2', '22'],
    italic: ['3', '23'],
    underline: ['4', '24'],
    inverse: ['7', '27'],
    hidden: ['8', '28'],
    strike: ['9', '29'],
    black: ['30', '39'],
    red: ['31', '39'],
    green: ['32', '39'],
    yellow: ['33', '39'],
    blue: ['34', '39'],
    magenta: ['35', '39'],
    cyan: ['36', '39'],
    white: ['37', '39'],
    brightblack: ['30;1', '39'],
    brightred: ['31;1', '39'],
    brightgreen: ['32;1', '39'],
    brightyellow: ['33;1', '39'],
    brightblue: ['34;1', '39'],
    brightmagenta: ['35;1', '39'],
    brightcyan: ['36;1', '39'],
    brightwhite: ['37;1', '39'],
    grey: ['90', '39'],
  },
  MF = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red',
  },
  So = '';
function NS(e, t) {
  const r = Bg[MF[t]] || Bg[t] || '';
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
s(NS, 'colorise');
function $S(
  {
    showHidden: e = !1,
    depth: t = 2,
    colors: r = !1,
    customInspect: n = !0,
    showProxy: o = !1,
    maxArrayLength: i = 1 / 0,
    breakLength: a = 1 / 0,
    seen: l = [],
    truncate: d = 1 / 0,
    stylize: u = String,
  } = {},
  p,
) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!o,
    maxArrayLength: Number(i),
    breakLength: Number(a),
    truncate: Number(d),
    seen: l,
    inspect: p,
    stylize: u,
  };
  return (f.colors && (f.stylize = NS), f);
}
s($S, 'normaliseOptions');
function qS(e) {
  return e >= '\uD800' && e <= '\uDBFF';
}
s(qS, 'isHighSurrogate');
function Mr(e, t, r = So) {
  e = String(e);
  const n = r.length,
    o = e.length;
  if (n > t && o > n) return r;
  if (o > t && o > n) {
    let i = t - n;
    return (i > 0 && qS(e[i - 1]) && (i = i - 1), `${e.slice(0, i)}${r}`);
  }
  return e;
}
s(Mr, 'truncate');
function Vt(e, t, r, n = ', ') {
  r = r || t.inspect;
  const o = e.length;
  if (o === 0) return '';
  const i = t.truncate;
  let a = '',
    l = '',
    d = '';
  for (let u = 0; u < o; u += 1) {
    const p = u + 1 === e.length,
      f = u + 2 === e.length;
    d = `${So}(${e.length - u})`;
    const m = e[u];
    t.truncate = i - a.length - (p ? 0 : n.length);
    const h = l || r(m, t) + (p ? '' : n),
      g = a.length + h.length,
      v = g + d.length;
    if (
      (p && g > i && a.length + d.length <= i) ||
      (!p && !f && v > i) ||
      ((l = p ? '' : r(e[u + 1], t) + (f ? '' : n)), !p && f && v > i && g + l.length > i)
    )
      break;
    if (((a += h), !p && !f && g + l.length >= i)) {
      d = `${So}(${e.length - u - 1})`;
      break;
    }
    d = '';
  }
  return `${a}${d}`;
}
s(Vt, 'inspectList');
function MS(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
    ? e
    : JSON.stringify(e)
        .replace(/'/g, "\\'")
        .replace(/\\"/g, '"')
        .replace(/(^"|"$)/g, "'");
}
s(MS, 'quoteComplexKey');
function _o([e, t], r) {
  return (
    (r.truncate -= 2),
    typeof e == 'string' ? (e = MS(e)) : typeof e != 'number' && (e = `[${r.inspect(e, r)}]`),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e}: ${t}`
  );
}
s(_o, 'inspectProperty');
function jS(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length) return '[]';
  t.truncate -= 4;
  const n = Vt(e, t);
  t.truncate -= n.length;
  let o = '';
  return (
    r.length &&
      (o = Vt(
        r.map((i) => [i, e[i]]),
        t,
        _o,
      )),
    `[ ${n}${o ? `, ${o}` : ''} ]`
  );
}
s(jS, 'inspectArray');
var jF = s(
  (e) =>
    typeof Buffer == 'function' && e instanceof Buffer
      ? 'Buffer'
      : e[Symbol.toStringTag]
        ? e[Symbol.toStringTag]
        : e.constructor.name,
  'getArrayName',
);
function rr(e, t) {
  const r = jF(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length) return `${r}[]`;
  let o = '';
  for (let a = 0; a < e.length; a++) {
    const l = `${t.stylize(Mr(e[a], t.truncate), 'number')}${a === e.length - 1 ? '' : ', '}`;
    if (((t.truncate -= l.length), e[a] !== e.length && t.truncate <= 3)) {
      o += `${So}(${e.length - e[a] + 1})`;
      break;
    }
    o += l;
  }
  let i = '';
  return (
    n.length &&
      (i = Vt(
        n.map((a) => [a, e[a]]),
        t,
        _o,
      )),
    `${r}[ ${o}${i ? `, ${i}` : ''} ]`
  );
}
s(rr, 'inspectTypedArray');
function kS(e, t) {
  const r = e.toJSON();
  if (r === null) return 'Invalid Date';
  const n = r.split('T'),
    o = n[0];
  return t.stylize(`${o}T${Mr(n[1], t.truncate - o.length - 1)}`, 'date');
}
s(kS, 'inspectDate');
function Uu(e, t) {
  const r = e[Symbol.toStringTag] || 'Function',
    n = e.name;
  return n
    ? t.stylize(`[${r} ${Mr(n, t.truncate - 11)}]`, 'special')
    : t.stylize(`[${r}]`, 'special');
}
s(Uu, 'inspectFunction');
function DS([e, t], r) {
  return (
    (r.truncate -= 4),
    (e = r.inspect(e, r)),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e} => ${t}`
  );
}
s(DS, 'inspectMapEntry');
function LS(e) {
  const t = [];
  return (
    e.forEach((r, n) => {
      t.push([n, r]);
    }),
    t
  );
}
s(LS, 'mapToEntries');
function FS(e, t) {
  return e.size === 0 ? 'Map{}' : ((t.truncate -= 7), `Map{ ${Vt(LS(e), t, DS)} }`);
}
s(FS, 'inspectMap');
var kF = Number.isNaN || ((e) => e !== e);
function Vu(e, t) {
  return kF(e)
    ? t.stylize('NaN', 'number')
    : e === 1 / 0
      ? t.stylize('Infinity', 'number')
      : e === -1 / 0
        ? t.stylize('-Infinity', 'number')
        : e === 0
          ? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
          : t.stylize(Mr(String(e), t.truncate), 'number');
}
s(Vu, 'inspectNumber');
function Hu(e, t) {
  let r = Mr(e.toString(), t.truncate - 1);
  return (r !== So && (r += 'n'), t.stylize(r, 'bigint'));
}
s(Hu, 'inspectBigInt');
function BS(e, t) {
  const r = e.toString().split('/')[2],
    n = t.truncate - (2 + r.length),
    o = e.source;
  return t.stylize(`/${Mr(o, n)}/${r}`, 'regexp');
}
s(BS, 'inspectRegExp');
function JS(e) {
  const t = [];
  return (
    e.forEach((r) => {
      t.push(r);
    }),
    t
  );
}
s(JS, 'arrayFromSet');
function US(e, t) {
  return e.size === 0 ? 'Set{}' : ((t.truncate -= 7), `Set{ ${Vt(JS(e), t)} }`);
}
s(US, 'inspectSet');
var Jg = new RegExp(
    "['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
    'g',
  ),
  DF = { '\b': '\\b', '	': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '\\': '\\\\' },
  LF = 16;
function VS(e) {
  return DF[e] || `\\u${`0000${e.charCodeAt(0).toString(LF)}`.slice(-4)}`;
}
s(VS, 'escape');
function zu(e, t) {
  return (Jg.test(e) && (e = e.replace(Jg, VS)), t.stylize(`'${Mr(e, t.truncate - 2)}'`, 'string'));
}
s(zu, 'inspectString');
function Gu(e) {
  return 'description' in Symbol.prototype
    ? e.description
      ? `Symbol(${e.description})`
      : 'Symbol()'
    : e.toString();
}
s(Gu, 'inspectSymbol');
var FF = s(() => 'Promise{}', 'getPromiseValue'),
  BF = FF;
function Fs(e, t) {
  const r = Object.getOwnPropertyNames(e),
    n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0) return '{}';
  if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e))) return '[Circular]';
  t.seen.push(e);
  const o = Vt(
      r.map((l) => [l, e[l]]),
      t,
      _o,
    ),
    i = Vt(
      n.map((l) => [l, e[l]]),
      t,
      _o,
    );
  t.seen.pop();
  let a = '';
  return (o && i && (a = ', '), `{ ${o}${a}${i} }`);
}
s(Fs, 'inspectObject');
var au = typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1;
function HS(e, t) {
  let r = '';
  return (
    au && au in e && (r = e[au]),
    (r = r || e.constructor.name),
    (!r || r === '_class') && (r = '<Anonymous Class>'),
    (t.truncate -= r.length),
    `${r}${Fs(e, t)}`
  );
}
s(HS, 'inspectClass');
function zS(e, t) {
  return e.length === 0 ? 'Arguments[]' : ((t.truncate -= 13), `Arguments[ ${Vt(e, t)} ]`);
}
s(zS, 'inspectArguments');
var JF = [
  'stack',
  'line',
  'column',
  'name',
  'message',
  'fileName',
  'lineNumber',
  'columnNumber',
  'number',
  'description',
  'cause',
];
function GS(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((a) => JF.indexOf(a) === -1),
    n = e.name;
  t.truncate -= n.length;
  let o = '';
  if (
    (typeof e.message == 'string' ? (o = Mr(e.message, t.truncate)) : r.unshift('message'),
    (o = o ? `: ${o}` : ''),
    (t.truncate -= o.length + 5),
    (t.seen = t.seen || []),
    t.seen.includes(e))
  )
    return '[Circular]';
  t.seen.push(e);
  const i = Vt(
    r.map((a) => [a, e[a]]),
    t,
    _o,
  );
  return `${n}${o}${i ? ` { ${i} }` : ''}`;
}
s(GS, 'inspectObject');
function WS([e, t], r) {
  return (
    (r.truncate -= 3),
    t
      ? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
      : `${r.stylize(String(e), 'yellow')}`
  );
}
s(WS, 'inspectAttribute');
function Ea(e, t) {
  return Vt(
    e,
    t,
    KS,
    `
`,
  );
}
s(Ea, 'inspectNodeCollection');
function KS(e, t) {
  switch (e.nodeType) {
    case 1:
      return qf(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
s(KS, 'inspectNode');
function qf(e, t) {
  const r = e.getAttributeNames(),
    n = e.tagName.toLowerCase(),
    o = t.stylize(`<${n}`, 'special'),
    i = t.stylize('>', 'special'),
    a = t.stylize(`</${n}>`, 'special');
  t.truncate -= n.length * 2 + 5;
  let l = '';
  (r.length > 0 &&
    ((l += ' '),
    (l += Vt(
      r.map((p) => [p, e.getAttribute(p)]),
      t,
      WS,
      ' ',
    ))),
    (t.truncate -= l.length));
  const d = t.truncate;
  let u = Ea(e.children, t);
  return (u && u.length > d && (u = `${So}(${e.children.length})`), `${o}${l}${i}${u}${a}`);
}
s(qf, 'inspectHTML');
var UF = typeof Symbol == 'function' && typeof Symbol.for == 'function',
  lu = UF ? Symbol.for('chai/inspect') : '@@chai/inspect',
  cu = Symbol.for('nodejs.util.inspect.custom'),
  Ug = new WeakMap(),
  Vg = {},
  Hg = {
    undefined: s((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
    null: s((e, t) => t.stylize('null', 'null'), 'null'),
    boolean: s((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
    Boolean: s((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
    number: Vu,
    Number: Vu,
    bigint: Hu,
    BigInt: Hu,
    string: zu,
    String: zu,
    function: Uu,
    Function: Uu,
    symbol: Gu,
    Symbol: Gu,
    Array: jS,
    Date: kS,
    Map: FS,
    Set: US,
    RegExp: BS,
    Promise: BF,
    WeakSet: s((e, t) => t.stylize('WeakSet{}', 'special'), 'WeakSet'),
    WeakMap: s((e, t) => t.stylize('WeakMap{}', 'special'), 'WeakMap'),
    Arguments: zS,
    Int8Array: rr,
    Uint8Array: rr,
    Uint8ClampedArray: rr,
    Int16Array: rr,
    Uint16Array: rr,
    Int32Array: rr,
    Uint32Array: rr,
    Float32Array: rr,
    Float64Array: rr,
    Generator: s(() => '', 'Generator'),
    DataView: s(() => '', 'DataView'),
    ArrayBuffer: s(() => '', 'ArrayBuffer'),
    Error: GS,
    HTMLCollection: Ea,
    NodeList: Ea,
  },
  VF = s(
    (e, t, r, n) =>
      lu in e && typeof e[lu] == 'function'
        ? e[lu](t)
        : cu in e && typeof e[cu] == 'function'
          ? e[cu](t.depth, t, n)
          : 'inspect' in e && typeof e.inspect == 'function'
            ? e.inspect(t.depth, t)
            : 'constructor' in e && Ug.has(e.constructor)
              ? Ug.get(e.constructor)(e, t)
              : Vg[r]
                ? Vg[r](e, t)
                : '',
    'inspectCustom',
  ),
  HF = Object.prototype.toString;
function Bs(e, t = {}) {
  const r = $S(t, Bs),
    { customInspect: n } = r;
  let o = e === null ? 'null' : typeof e;
  if ((o === 'object' && (o = HF.call(e).slice(8, -1)), o in Hg)) return Hg[o](e, r);
  if (n && e) {
    const a = VF(e, r, o, Bs);
    if (a) return typeof a == 'string' ? a : Bs(a, r);
  }
  const i = e ? Object.getPrototypeOf(e) : !1;
  return i === Object.prototype || i === null
    ? Fs(e, r)
    : e && typeof HTMLElement == 'function' && e instanceof HTMLElement
      ? qf(e, r)
      : 'constructor' in e
        ? e.constructor !== Object
          ? HS(e, r)
          : Fs(e, r)
        : e === Object(e)
          ? Fs(e, r)
          : r.stylize(String(e), o);
}
s(Bs, 'inspect');
var {
    AsymmetricMatcher: zF,
    DOMCollection: GF,
    DOMElement: WF,
    Immutable: KF,
    ReactElement: YF,
    ReactTestComponent: XF,
  } = $f,
  zg = [XF, YF, WF, GF, KF, zF];
function _t(e, t = 10, { maxLength: r, ...n } = {}) {
  const o = r ?? 1e4;
  let i;
  try {
    i = Xt(e, { maxDepth: t, escapeString: !1, plugins: zg, ...n });
  } catch {
    i = Xt(e, { callToJSON: !1, maxDepth: t, escapeString: !1, plugins: zg, ...n });
  }
  return i.length >= o && t > 1
    ? _t(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), { maxLength: r, ...n })
    : i;
}
s(_t, 'stringify');
var QF = /%[sdjifoOc%]/g;
function YS(...e) {
  if (typeof e[0] != 'string') {
    const i = [];
    for (let a = 0; a < e.length; a++) i.push(Qn(e[a], { depth: 0, colors: !1 }));
    return i.join(' ');
  }
  const t = e.length;
  let r = 1;
  const n = e[0];
  let o = String(n).replace(QF, (i) => {
    if (i === '%%') return '%';
    if (r >= t) return i;
    switch (i) {
      case '%s': {
        const a = e[r++];
        return typeof a == 'bigint'
          ? `${a.toString()}n`
          : typeof a == 'number' && a === 0 && 1 / a < 0
            ? '-0'
            : typeof a == 'object' && a !== null
              ? typeof a.toString == 'function' && a.toString !== Object.prototype.toString
                ? a.toString()
                : Qn(a, { depth: 0, colors: !1 })
              : String(a);
      }
      case '%d': {
        const a = e[r++];
        return typeof a == 'bigint' ? `${a.toString()}n` : Number(a).toString();
      }
      case '%i': {
        const a = e[r++];
        return typeof a == 'bigint' ? `${a.toString()}n` : Number.parseInt(String(a)).toString();
      }
      case '%f':
        return Number.parseFloat(String(e[r++])).toString();
      case '%o':
        return Qn(e[r++], { showHidden: !0, showProxy: !0 });
      case '%O':
        return Qn(e[r++]);
      case '%c':
        return (r++, '');
      case '%j':
        try {
          return JSON.stringify(e[r++]);
        } catch (a) {
          const l = a.message;
          if (
            l.includes('circular structure') ||
            l.includes('cyclic structures') ||
            l.includes('cyclic object')
          )
            return '[Circular]';
          throw a;
        }
      default:
        return i;
    }
  });
  for (let i = e[r]; r < t; i = e[++r])
    i === null || typeof i != 'object' ? (o += ` ${i}`) : (o += ` ${Qn(i)}`);
  return o;
}
s(YS, 'format');
function Qn(e, t = {}) {
  return (t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), Bs(e, t));
}
s(Qn, 'inspect');
function Mf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
s(Mf, 'getDefaultExportFromCjs');
function nr(e, t, r) {
  const n = typeof e;
  if (!r.includes(n)) throw new TypeError(`${t} value must be ${r.join(' or ')}, received "${n}"`);
}
s(nr, 'assertTypes');
function Js(e) {
  return e != null && typeof e == 'object' && !Array.isArray(e);
}
s(Js, 'isObject');
function XS(e) {
  return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
s(XS, 'isFinalObj');
function ti(e) {
  return Object.prototype.toString.apply(e).slice(8, -1);
}
s(ti, 'getType');
function QS(e, t) {
  const r = typeof t == 'function' ? t : (n) => t.add(n);
  (Object.getOwnPropertyNames(e).forEach(r), Object.getOwnPropertySymbols(e).forEach(r));
}
s(QS, 'collectOwnProperties');
function jf(e) {
  const t = new Set();
  return XS(e) ? [] : (QS(e, t), Array.from(t));
}
s(jf, 'getOwnProperties');
var ZS = { forceWritable: !1 };
function Wu(e, t = ZS) {
  return wa(e, new WeakMap(), t);
}
s(Wu, 'deepClone');
function wa(e, t, r = ZS) {
  let n, o;
  if (t.has(e)) return t.get(e);
  if (Array.isArray(e)) {
    for (o = Array.from({ length: (n = e.length) }), t.set(e, o); n--; ) o[n] = wa(e[n], t, r);
    return o;
  }
  if (Object.prototype.toString.call(e) === '[object Object]') {
    ((o = Object.create(Object.getPrototypeOf(e))), t.set(e, o));
    const i = jf(e);
    for (const a of i) {
      const l = Object.getOwnPropertyDescriptor(e, a);
      if (!l) continue;
      const d = wa(e[a], t, r);
      r.forceWritable
        ? Object.defineProperty(o, a, {
            enumerable: l.enumerable,
            configurable: !0,
            writable: !0,
            value: d,
          })
        : 'get' in l
          ? Object.defineProperty(o, a, {
              ...l,
              get() {
                return d;
              },
            })
          : Object.defineProperty(o, a, { ...l, value: d });
    }
    return o;
  }
  return e;
}
s(wa, 'clone');
function e_() {}
s(e_, 'noop');
var Tt = -1,
  dt = 1,
  Je = 0,
  t_ = class {
    constructor(t, r) {
      Be(this, 0);
      Be(this, 1);
      ((this[0] = t), (this[1] = r));
    }
  };
s(t_, 'Diff');
var Le = t_;
function r_(e, t) {
  if (!e || !t || e.charAt(0) !== t.charAt(0)) return 0;
  let r = 0,
    n = Math.min(e.length, t.length),
    o = n,
    i = 0;
  for (; r < o; )
    (e.substring(i, o) === t.substring(i, o) ? ((r = o), (i = r)) : (n = o),
      (o = Math.floor((n - r) / 2 + r)));
  return o;
}
s(r_, 'diff_commonPrefix');
function kf(e, t) {
  if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1)) return 0;
  let r = 0,
    n = Math.min(e.length, t.length),
    o = n,
    i = 0;
  for (; r < o; )
    (e.substring(e.length - o, e.length - i) === t.substring(t.length - o, t.length - i)
      ? ((r = o), (i = r))
      : (n = o),
      (o = Math.floor((n - r) / 2 + r)));
  return o;
}
s(kf, 'diff_commonSuffix');
function Ku(e, t) {
  const r = e.length,
    n = t.length;
  if (r === 0 || n === 0) return 0;
  r > n ? (e = e.substring(r - n)) : r < n && (t = t.substring(0, r));
  const o = Math.min(r, n);
  if (e === t) return o;
  let i = 0,
    a = 1;
  for (;;) {
    const l = e.substring(o - a),
      d = t.indexOf(l);
    if (d === -1) return i;
    ((a += d), (d === 0 || e.substring(o - a) === t.substring(0, a)) && ((i = a), a++));
  }
}
s(Ku, 'diff_commonOverlap_');
function n_(e) {
  let t = !1;
  const r = [];
  let n = 0,
    o = null,
    i = 0,
    a = 0,
    l = 0,
    d = 0,
    u = 0;
  for (; i < e.length; )
    (e[i][0] === Je
      ? ((r[n++] = i), (a = d), (l = u), (d = 0), (u = 0), (o = e[i][1]))
      : (e[i][0] === dt ? (d += e[i][1].length) : (u += e[i][1].length),
        o &&
          o.length <= Math.max(a, l) &&
          o.length <= Math.max(d, u) &&
          (e.splice(r[n - 1], 0, new Le(Tt, o)),
          (e[r[n - 1] + 1][0] = dt),
          n--,
          n--,
          (i = n > 0 ? r[n - 1] : -1),
          (a = 0),
          (l = 0),
          (d = 0),
          (u = 0),
          (o = null),
          (t = !0))),
      i++);
  for (t && Df(e), o_(e), i = 1; i < e.length; ) {
    if (e[i - 1][0] === Tt && e[i][0] === dt) {
      const p = e[i - 1][1],
        f = e[i][1],
        m = Ku(p, f),
        h = Ku(f, p);
      (m >= h
        ? (m >= p.length / 2 || m >= f.length / 2) &&
          (e.splice(i, 0, new Le(Je, f.substring(0, m))),
          (e[i - 1][1] = p.substring(0, p.length - m)),
          (e[i + 1][1] = f.substring(m)),
          i++)
        : (h >= p.length / 2 || h >= f.length / 2) &&
          (e.splice(i, 0, new Le(Je, p.substring(0, h))),
          (e[i - 1][0] = dt),
          (e[i - 1][1] = f.substring(0, f.length - h)),
          (e[i + 1][0] = Tt),
          (e[i + 1][1] = p.substring(h)),
          i++),
        i++);
    }
    i++;
  }
}
s(n_, 'diff_cleanupSemantic');
var Gg = /[^a-z0-9]/i,
  Wg = /\s/,
  Kg = /[\r\n]/,
  ZF = /\n\r?\n$/,
  eB = /^\r?\n\r?\n/;
function o_(e) {
  let t = 1;
  for (; t < e.length - 1; ) {
    if (e[t - 1][0] === Je && e[t + 1][0] === Je) {
      let r = e[t - 1][1],
        n = e[t][1],
        o = e[t + 1][1];
      const i = kf(r, n);
      if (i) {
        const p = n.substring(n.length - i);
        ((r = r.substring(0, r.length - i)), (n = p + n.substring(0, n.length - i)), (o = p + o));
      }
      let a = r,
        l = n,
        d = o,
        u = Cs(r, n) + Cs(n, o);
      for (; n.charAt(0) === o.charAt(0); ) {
        ((r += n.charAt(0)), (n = n.substring(1) + o.charAt(0)), (o = o.substring(1)));
        const p = Cs(r, n) + Cs(n, o);
        p >= u && ((u = p), (a = r), (l = n), (d = o));
      }
      e[t - 1][1] !== a &&
        (a ? (e[t - 1][1] = a) : (e.splice(t - 1, 1), t--),
        (e[t][1] = l),
        d ? (e[t + 1][1] = d) : (e.splice(t + 1, 1), t--));
    }
    t++;
  }
}
s(o_, 'diff_cleanupSemanticLossless');
function Df(e) {
  e.push(new Le(Je, ''));
  let t = 0,
    r = 0,
    n = 0,
    o = '',
    i = '',
    a;
  for (; t < e.length; )
    switch (e[t][0]) {
      case dt:
        (n++, (i += e[t][1]), t++);
        break;
      case Tt:
        (r++, (o += e[t][1]), t++);
        break;
      case Je:
        (r + n > 1
          ? (r !== 0 &&
              n !== 0 &&
              ((a = r_(i, o)),
              a !== 0 &&
                (t - r - n > 0 && e[t - r - n - 1][0] === Je
                  ? (e[t - r - n - 1][1] += i.substring(0, a))
                  : (e.splice(0, 0, new Le(Je, i.substring(0, a))), t++),
                (i = i.substring(a)),
                (o = o.substring(a))),
              (a = kf(i, o)),
              a !== 0 &&
                ((e[t][1] = i.substring(i.length - a) + e[t][1]),
                (i = i.substring(0, i.length - a)),
                (o = o.substring(0, o.length - a)))),
            (t -= r + n),
            e.splice(t, r + n),
            o.length && (e.splice(t, 0, new Le(Tt, o)), t++),
            i.length && (e.splice(t, 0, new Le(dt, i)), t++),
            t++)
          : t !== 0 && e[t - 1][0] === Je
            ? ((e[t - 1][1] += e[t][1]), e.splice(t, 1))
            : t++,
          (n = 0),
          (r = 0),
          (o = ''),
          (i = ''));
        break;
    }
  e[e.length - 1][1] === '' && e.pop();
  let l = !1;
  for (t = 1; t < e.length - 1; )
    (e[t - 1][0] === Je &&
      e[t + 1][0] === Je &&
      (e[t][1].substring(e[t][1].length - e[t - 1][1].length) === e[t - 1][1]
        ? ((e[t][1] = e[t - 1][1] + e[t][1].substring(0, e[t][1].length - e[t - 1][1].length)),
          (e[t + 1][1] = e[t - 1][1] + e[t + 1][1]),
          e.splice(t - 1, 1),
          (l = !0))
        : e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] &&
          ((e[t - 1][1] += e[t + 1][1]),
          (e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1]),
          e.splice(t + 1, 1),
          (l = !0))),
      t++);
  l && Df(e);
}
s(Df, 'diff_cleanupMerge');
function Cs(e, t) {
  if (!e || !t) return 6;
  const r = e.charAt(e.length - 1),
    n = t.charAt(0),
    o = r.match(Gg),
    i = n.match(Gg),
    a = o && r.match(Wg),
    l = i && n.match(Wg),
    d = a && r.match(Kg),
    u = l && n.match(Kg),
    p = d && e.match(ZF),
    f = u && t.match(eB);
  return p || f ? 5 : d || u ? 4 : o && !a && l ? 3 : a || l ? 2 : o || i ? 1 : 0;
}
s(Cs, 'diff_cleanupSemanticScore_');
var s_ = 'Compared values have no visual difference.',
  tB =
    'Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.',
  Gi = {},
  Yg;
function i_() {
  if (Yg) return Gi;
  ((Yg = 1), Object.defineProperty(Gi, '__esModule', { value: !0 }), (Gi.default = m));
  const e = 'diff-sequences',
    t = 0,
    r = s((h, g, v, E, b) => {
      let S = 0;
      for (; h < g && v < E && b(h, v); ) ((h += 1), (v += 1), (S += 1));
      return S;
    }, 'countCommonItemsF'),
    n = s((h, g, v, E, b) => {
      let S = 0;
      for (; h <= g && v <= E && b(g, E); ) ((g -= 1), (E -= 1), (S += 1));
      return S;
    }, 'countCommonItemsR'),
    o = s((h, g, v, E, b, S, R) => {
      let I = 0,
        $ = -h,
        x = S[I],
        A = x;
      S[I] += r(x + 1, g, E + x - $ + 1, v, b);
      const w = h < R ? h : R;
      for (I += 1, $ += 2; I <= w; I += 1, $ += 2) {
        if (I !== h && A < S[I]) x = S[I];
        else if (((x = A + 1), g <= x)) return I - 1;
        ((A = S[I]), (S[I] = x + r(x + 1, g, E + x - $ + 1, v, b)));
      }
      return R;
    }, 'extendPathsF'),
    i = s((h, g, v, E, b, S, R) => {
      let I = 0,
        $ = h,
        x = S[I],
        A = x;
      S[I] -= n(g, x - 1, v, E + x - $ - 1, b);
      const w = h < R ? h : R;
      for (I += 1, $ -= 2; I <= w; I += 1, $ -= 2) {
        if (I !== h && S[I] < A) x = S[I];
        else if (((x = A - 1), x < g)) return I - 1;
        ((A = S[I]), (S[I] = x - n(g, x - 1, v, E + x - $ - 1, b)));
      }
      return R;
    }, 'extendPathsR'),
    a = s((h, g, v, E, b, S, R, I, $, x, A) => {
      const w = E - g,
        _ = v - g,
        N = b - E - _,
        V = -N - (h - 1),
        H = -N + (h - 1);
      let P = t;
      const D = h < I ? h : I;
      for (let F = 0, k = -h; F <= D; F += 1, k += 2) {
        const K = F === 0 || (F !== h && P < R[F]),
          X = K ? R[F] : P,
          se = K ? X : X + 1,
          ie = w + se - k,
          W = r(se + 1, v, ie + 1, b, S),
          ae = se + W;
        if (((P = R[F]), (R[F] = ae), V <= k && k <= H)) {
          const be = (h - 1 - (k + N)) / 2;
          if (be <= x && $[be] - 1 <= ae) {
            const ue = w + X - (K ? k + 1 : k - 1),
              ee = n(g, X, E, ue, S),
              Pe = X - ee,
              xe = ue - ee,
              He = Pe + 1,
              Xe = xe + 1;
            ((A.nChangePreceding = h - 1),
              h - 1 === He + Xe - g - E
                ? ((A.aEndPreceding = g), (A.bEndPreceding = E))
                : ((A.aEndPreceding = He), (A.bEndPreceding = Xe)),
              (A.nCommonPreceding = ee),
              ee !== 0 && ((A.aCommonPreceding = He), (A.bCommonPreceding = Xe)),
              (A.nCommonFollowing = W),
              W !== 0 && ((A.aCommonFollowing = se + 1), (A.bCommonFollowing = ie + 1)));
            const J = ae + 1,
              Q = ie + W + 1;
            return (
              (A.nChangeFollowing = h - 1),
              h - 1 === v + b - J - Q
                ? ((A.aStartFollowing = v), (A.bStartFollowing = b))
                : ((A.aStartFollowing = J), (A.bStartFollowing = Q)),
              !0
            );
          }
        }
      }
      return !1;
    }, 'extendOverlappablePathsF'),
    l = s((h, g, v, E, b, S, R, I, $, x, A) => {
      const w = b - v,
        _ = v - g,
        N = b - E - _,
        V = N - h,
        H = N + h;
      let P = t;
      const D = h < x ? h : x;
      for (let F = 0, k = h; F <= D; F += 1, k -= 2) {
        const K = F === 0 || (F !== h && $[F] < P),
          X = K ? $[F] : P,
          se = K ? X : X - 1,
          ie = w + se - k,
          W = n(g, se - 1, E, ie - 1, S),
          ae = se - W;
        if (((P = $[F]), ($[F] = ae), V <= k && k <= H)) {
          const be = (h + (k - N)) / 2;
          if (be <= I && ae - 1 <= R[be]) {
            const ue = ie - W;
            if (
              ((A.nChangePreceding = h),
              h === ae + ue - g - E
                ? ((A.aEndPreceding = g), (A.bEndPreceding = E))
                : ((A.aEndPreceding = ae), (A.bEndPreceding = ue)),
              (A.nCommonPreceding = W),
              W !== 0 && ((A.aCommonPreceding = ae), (A.bCommonPreceding = ue)),
              (A.nChangeFollowing = h - 1),
              h === 1)
            )
              ((A.nCommonFollowing = 0), (A.aStartFollowing = v), (A.bStartFollowing = b));
            else {
              const ee = w + X - (K ? k - 1 : k + 1),
                Pe = r(X, v, ee, b, S);
              ((A.nCommonFollowing = Pe),
                Pe !== 0 && ((A.aCommonFollowing = X), (A.bCommonFollowing = ee)));
              const xe = X + Pe,
                He = ee + Pe;
              h - 1 === v + b - xe - He
                ? ((A.aStartFollowing = v), (A.bStartFollowing = b))
                : ((A.aStartFollowing = xe), (A.bStartFollowing = He));
            }
            return !0;
          }
        }
      }
      return !1;
    }, 'extendOverlappablePathsR'),
    d = s((h, g, v, E, b, S, R, I, $) => {
      const x = E - g,
        A = b - v,
        w = v - g,
        _ = b - E,
        j = _ - w;
      let N = w,
        V = w;
      if (((R[0] = g - 1), (I[0] = v), j % 2 === 0)) {
        const H = (h || j) / 2,
          P = (w + _) / 2;
        for (let D = 1; D <= P; D += 1)
          if (((N = o(D, v, b, x, S, R, N)), D < H)) V = i(D, g, E, A, S, I, V);
          else if (l(D, g, v, E, b, S, R, N, I, V, $)) return;
      } else {
        const H = ((h || j) + 1) / 2,
          P = (w + _ + 1) / 2;
        let D = 1;
        for (N = o(D, v, b, x, S, R, N), D += 1; D <= P; D += 1)
          if (((V = i(D - 1, g, E, A, S, I, V)), D < H)) N = o(D, v, b, x, S, R, N);
          else if (a(D, g, v, E, b, S, R, N, I, V, $)) return;
      }
      throw new Error(`${e}: no overlap aStart=${g} aEnd=${v} bStart=${E} bEnd=${b}`);
    }, 'divide'),
    u = s((h, g, v, E, b, S, R, I, $, x) => {
      if (b - E < v - g) {
        if (((S = !S), S && R.length === 1)) {
          const { foundSubsequence: ae, isCommon: be } = R[0];
          R[1] = {
            foundSubsequence: s((ue, ee, Pe) => {
              ae(ue, Pe, ee);
            }, 'foundSubsequence'),
            isCommon: s((ue, ee) => be(ee, ue), 'isCommon'),
          };
        }
        const ie = g,
          W = v;
        ((g = E), (v = b), (E = ie), (b = W));
      }
      const { foundSubsequence: A, isCommon: w } = R[S ? 1 : 0];
      d(h, g, v, E, b, w, I, $, x);
      const {
        nChangePreceding: _,
        aEndPreceding: j,
        bEndPreceding: N,
        nCommonPreceding: V,
        aCommonPreceding: H,
        bCommonPreceding: P,
        nCommonFollowing: D,
        aCommonFollowing: F,
        bCommonFollowing: k,
        nChangeFollowing: K,
        aStartFollowing: X,
        bStartFollowing: se,
      } = x;
      (g < j && E < N && u(_, g, j, E, N, S, R, I, $, x),
        V !== 0 && A(V, H, P),
        D !== 0 && A(D, F, k),
        X < v && se < b && u(K, X, v, se, b, S, R, I, $, x));
    }, 'findSubsequences'),
    p = s((h, g) => {
      if (typeof g != 'number')
        throw new TypeError(`${e}: ${h} typeof ${typeof g} is not a number`);
      if (!Number.isSafeInteger(g))
        throw new RangeError(`${e}: ${h} value ${g} is not a safe integer`);
      if (g < 0) throw new RangeError(`${e}: ${h} value ${g} is a negative integer`);
    }, 'validateLength'),
    f = s((h, g) => {
      const v = typeof g;
      if (v !== 'function') throw new TypeError(`${e}: ${h} typeof ${v} is not a function`);
    }, 'validateCallback');
  function m(h, g, v, E) {
    (p('aLength', h), p('bLength', g), f('isCommon', v), f('foundSubsequence', E));
    const b = r(0, h, 0, g, v);
    if ((b !== 0 && E(b, 0, 0), h !== b || g !== b)) {
      const S = b,
        R = b,
        I = n(S, h - 1, R, g - 1, v),
        $ = h - I,
        x = g - I,
        A = b + I;
      (h !== A &&
        g !== A &&
        u(0, S, $, R, x, !1, [{ foundSubsequence: E, isCommon: v }], [t], [t], {
          aCommonFollowing: t,
          aCommonPreceding: t,
          aEndPreceding: t,
          aStartFollowing: t,
          bCommonFollowing: t,
          bCommonPreceding: t,
          bEndPreceding: t,
          bStartFollowing: t,
          nChangeFollowing: t,
          nChangePreceding: t,
          nCommonFollowing: t,
          nCommonPreceding: t,
        }),
        I !== 0 && E(I, $, x));
    }
  }
  return (s(m, 'diffSequence'), Gi);
}
s(i_, 'requireBuild');
var rB = i_(),
  a_ = Mf(rB);
function l_(e, t) {
  return e.replace(/\s+$/, (r) => t(r));
}
s(l_, 'formatTrailingSpaces');
function Dl(e, t, r, n, o, i) {
  return e.length !== 0
    ? r(`${n} ${l_(e, o)}`)
    : n !== ' '
      ? r(n)
      : t && i.length !== 0
        ? r(`${n} ${i}`)
        : '';
}
s(Dl, 'printDiffLine');
function Lf(
  e,
  t,
  { aColor: r, aIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: i },
) {
  return Dl(e, t, r, n, o, i);
}
s(Lf, 'printDeleteLine');
function Ff(
  e,
  t,
  { bColor: r, bIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: i },
) {
  return Dl(e, t, r, n, o, i);
}
s(Ff, 'printInsertLine');
function Bf(
  e,
  t,
  {
    commonColor: r,
    commonIndicator: n,
    commonLineTrailingSpaceColor: o,
    emptyFirstOrLastLinePlaceholder: i,
  },
) {
  return Dl(e, t, r, n, o, i);
}
s(Bf, 'printCommonLine');
function Yu(e, t, r, n, { patchColor: o }) {
  return o(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`);
}
s(Yu, 'createPatchMark');
function c_(e, t) {
  const r = e.length,
    n = t.contextLines,
    o = n + n;
  let i = r,
    a = !1,
    l = 0,
    d = 0;
  for (; d !== r; ) {
    const I = d;
    for (; d !== r && e[d][0] === Je; ) d += 1;
    if (I !== d)
      if (I === 0) d > n && ((i -= d - n), (a = !0));
      else if (d === r) {
        const $ = d - I;
        $ > n && ((i -= $ - n), (a = !0));
      } else {
        const $ = d - I;
        $ > o && ((i -= $ - o), (l += 1));
      }
    for (; d !== r && e[d][0] !== Je; ) d += 1;
  }
  const u = l !== 0 || a;
  l !== 0 ? (i += l + 1) : a && (i += 1);
  const p = i - 1,
    f = [];
  let m = 0;
  u && f.push('');
  let h = 0,
    g = 0,
    v = 0,
    E = 0;
  const b = s((I) => {
      const $ = f.length;
      (f.push(Bf(I, $ === 0 || $ === p, t)), (v += 1), (E += 1));
    }, 'pushCommonLine'),
    S = s((I) => {
      const $ = f.length;
      (f.push(Lf(I, $ === 0 || $ === p, t)), (v += 1));
    }, 'pushDeleteLine'),
    R = s((I) => {
      const $ = f.length;
      (f.push(Ff(I, $ === 0 || $ === p, t)), (E += 1));
    }, 'pushInsertLine');
  for (d = 0; d !== r; ) {
    let I = d;
    for (; d !== r && e[d][0] === Je; ) d += 1;
    if (I !== d)
      if (I === 0) {
        d > n && ((I = d - n), (h = I), (g = I), (v = h), (E = g));
        for (let $ = I; $ !== d; $ += 1) b(e[$][1]);
      } else if (d === r) {
        const $ = d - I > n ? I + n : d;
        for (let x = I; x !== $; x += 1) b(e[x][1]);
      } else {
        const $ = d - I;
        if ($ > o) {
          const x = I + n;
          for (let w = I; w !== x; w += 1) b(e[w][1]);
          ((f[m] = Yu(h, v, g, E, t)), (m = f.length), f.push(''));
          const A = $ - o;
          ((h = v + A), (g = E + A), (v = h), (E = g));
          for (let w = d - n; w !== d; w += 1) b(e[w][1]);
        } else for (let x = I; x !== d; x += 1) b(e[x][1]);
      }
    for (; d !== r && e[d][0] === Tt; ) (S(e[d][1]), (d += 1));
    for (; d !== r && e[d][0] === dt; ) (R(e[d][1]), (d += 1));
  }
  return (
    u && (f[m] = Yu(h, v, g, E, t)),
    f.join(`
`)
  );
}
s(c_, 'joinAlignedDiffsNoExpand');
function u_(e, t) {
  return e.map((r, n, o) => {
    const i = r[1],
      a = n === 0 || n === o.length - 1;
    switch (r[0]) {
      case Tt:
        return Lf(i, a, t);
      case dt:
        return Ff(i, a, t);
      default:
        return Bf(i, a, t);
    }
  }).join(`
`);
}
s(u_, 'joinAlignedDiffsExpand');
var uu = s((e) => e, 'noColor'),
  d_ = 5,
  nB = 0;
function p_() {
  return {
    aAnnotation: 'Expected',
    aColor: Ue.green,
    aIndicator: '-',
    bAnnotation: 'Received',
    bColor: Ue.red,
    bIndicator: '+',
    changeColor: Ue.inverse,
    changeLineTrailingSpaceColor: uu,
    commonColor: Ue.dim,
    commonIndicator: ' ',
    commonLineTrailingSpaceColor: uu,
    compareKeys: void 0,
    contextLines: d_,
    emptyFirstOrLastLinePlaceholder: '',
    expand: !1,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: Ue.yellow,
    printBasicPrototype: !1,
    truncateThreshold: nB,
    truncateAnnotation: '... Diff result is truncated',
    truncateAnnotationColor: uu,
  };
}
s(p_, 'getDefaultOptions');
function f_(e) {
  return e && typeof e == 'function' ? e : void 0;
}
s(f_, 'getCompareKeys');
function m_(e) {
  return typeof e == 'number' && Number.isSafeInteger(e) && e >= 0 ? e : d_;
}
s(m_, 'getContextLines');
function sn(e = {}) {
  return { ...p_(), ...e, compareKeys: f_(e.compareKeys), contextLines: m_(e.contextLines) };
}
s(sn, 'normalizeDiffOptions');
function vn(e) {
  return e.length === 1 && e[0].length === 0;
}
s(vn, 'isEmptyString');
function y_(e) {
  let t = 0,
    r = 0;
  return (
    e.forEach((n) => {
      switch (n[0]) {
        case Tt:
          t += 1;
          break;
        case dt:
          r += 1;
          break;
      }
    }),
    { a: t, b: r }
  );
}
s(y_, 'countChanges');
function h_(
  {
    aAnnotation: e,
    aColor: t,
    aIndicator: r,
    bAnnotation: n,
    bColor: o,
    bIndicator: i,
    includeChangeCounts: a,
    omitAnnotationLines: l,
  },
  d,
) {
  if (l) return '';
  let u = '',
    p = '';
  if (a) {
    const h = String(d.a),
      g = String(d.b),
      v = n.length - e.length,
      E = ' '.repeat(Math.max(0, v)),
      b = ' '.repeat(Math.max(0, -v)),
      S = g.length - h.length,
      R = ' '.repeat(Math.max(0, S)),
      I = ' '.repeat(Math.max(0, -S));
    ((u = `${E}  ${r} ${R}${h}`), (p = `${b}  ${i} ${I}${g}`));
  }
  const f = `${r} ${e}${u}`,
    m = `${i} ${n}${p}`;
  return `${t(f)}
${o(m)}

`;
}
s(h_, 'printAnnotation');
function Ll(e, t, r) {
  return (
    h_(r, y_(e)) +
    (r.expand ? u_(e, r) : c_(e, r)) +
    (t
      ? r.truncateAnnotationColor(`
${r.truncateAnnotation}`)
      : '')
  );
}
s(Ll, 'printDiffLines');
function Ri(e, t, r) {
  const n = sn(r),
    [o, i] = Jf(vn(e) ? [] : e, vn(t) ? [] : t, n);
  return Ll(o, i, n);
}
s(Ri, 'diffLinesUnified');
function g_(e, t, r, n, o) {
  if (
    (vn(e) && vn(r) && ((e = []), (r = [])),
    vn(t) && vn(n) && ((t = []), (n = [])),
    e.length !== r.length || t.length !== n.length)
  )
    return Ri(e, t, o);
  const [i, a] = Jf(r, n, o);
  let l = 0,
    d = 0;
  return (
    i.forEach((u) => {
      switch (u[0]) {
        case Tt:
          ((u[1] = e[l]), (l += 1));
          break;
        case dt:
          ((u[1] = t[d]), (d += 1));
          break;
        default:
          ((u[1] = t[d]), (l += 1), (d += 1));
      }
    }),
    Ll(i, a, sn(o))
  );
}
s(g_, 'diffLinesUnified2');
function Jf(e, t, r) {
  const n = r?.truncateThreshold ?? !1,
    o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0),
    i = n ? Math.min(e.length, o) : e.length,
    a = n ? Math.min(t.length, o) : t.length,
    l = i !== e.length || a !== t.length,
    d = s((h, g) => e[h] === t[g], 'isCommon'),
    u = [];
  let p = 0,
    f = 0;
  for (
    a_(
      i,
      a,
      d,
      s((h, g, v) => {
        for (; p !== g; p += 1) u.push(new Le(Tt, e[p]));
        for (; f !== v; f += 1) u.push(new Le(dt, t[f]));
        for (; h !== 0; h -= 1, p += 1, f += 1) u.push(new Le(Je, t[f]));
      }, 'foundSubsequence'),
    );
    p !== i;
    p += 1
  )
    u.push(new Le(Tt, e[p]));
  for (; f !== a; f += 1) u.push(new Le(dt, t[f]));
  return [u, l];
}
s(Jf, 'diffLinesRaw');
function Xu(e) {
  if (e === void 0) return 'undefined';
  if (e === null) return 'null';
  if (Array.isArray(e)) return 'array';
  if (typeof e == 'boolean') return 'boolean';
  if (typeof e == 'function') return 'function';
  if (typeof e == 'number') return 'number';
  if (typeof e == 'string') return 'string';
  if (typeof e == 'bigint') return 'bigint';
  if (typeof e == 'object') {
    if (e != null) {
      if (e.constructor === RegExp) return 'regexp';
      if (e.constructor === Map) return 'map';
      if (e.constructor === Set) return 'set';
      if (e.constructor === Date) return 'date';
    }
    return 'object';
  } else if (typeof e == 'symbol') return 'symbol';
  throw new Error(`value of unknown type: ${e}`);
}
s(Xu, 'getType');
function Qu(e) {
  return e.includes(`\r
`)
    ? `\r
`
    : `
`;
}
s(Qu, 'getNewLineSymbol');
function b_(e, t, r) {
  const n = r?.truncateThreshold ?? !1,
    o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0);
  let i = e.length,
    a = t.length;
  if (n) {
    const h = e.includes(`
`),
      g = t.includes(`
`),
      v = Qu(e),
      E = Qu(t),
      b = h
        ? `${e.split(v, o).join(v)}
`
        : e,
      S = g
        ? `${t.split(E, o).join(E)}
`
        : t;
    ((i = b.length), (a = S.length));
  }
  const l = i !== e.length || a !== t.length,
    d = s((h, g) => e[h] === t[g], 'isCommon');
  let u = 0,
    p = 0;
  const f = [];
  return (
    a_(
      i,
      a,
      d,
      s((h, g, v) => {
        (u !== g && f.push(new Le(Tt, e.slice(u, g))),
          p !== v && f.push(new Le(dt, t.slice(p, v))),
          (u = g + h),
          (p = v + h),
          f.push(new Le(Je, t.slice(v, p))));
      }, 'foundSubsequence'),
    ),
    u !== i && f.push(new Le(Tt, e.slice(u))),
    p !== a && f.push(new Le(dt, t.slice(p))),
    [f, l]
  );
}
s(b_, 'diffStrings');
function v_(e, t, r) {
  return t.reduce(
    (n, o) => n + (o[0] === Je ? o[1] : o[0] === e && o[1].length !== 0 ? r(o[1]) : ''),
    '',
  );
}
s(v_, 'concatenateRelevantDiffs');
var T_ = class {
  constructor(t, r) {
    Be(this, 'op');
    Be(this, 'line');
    Be(this, 'lines');
    Be(this, 'changeColor');
    ((this.op = t), (this.line = []), (this.lines = []), (this.changeColor = r));
  }
  pushSubstring(t) {
    this.pushDiff(new Le(this.op, t));
  }
  pushLine() {
    (this.lines.push(
      this.line.length !== 1
        ? new Le(this.op, v_(this.op, this.line, this.changeColor))
        : this.line[0][0] === this.op
          ? this.line[0]
          : new Le(this.op, this.line[0][1]),
    ),
      (this.line.length = 0));
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  pushDiff(t) {
    this.line.push(t);
  }
  align(t) {
    const r = t[1];
    if (
      r.includes(`
`)
    ) {
      const n = r.split(`
`),
        o = n.length - 1;
      n.forEach((i, a) => {
        a < o ? (this.pushSubstring(i), this.pushLine()) : i.length !== 0 && this.pushSubstring(i);
      });
    } else this.pushDiff(t);
  }
  moveLinesTo(t) {
    (this.isLineEmpty() || this.pushLine(), t.push(...this.lines), (this.lines.length = 0));
  }
};
s(T_, 'ChangeBuffer');
var Xg = T_,
  E_ = class {
    constructor(t, r) {
      Be(this, 'deleteBuffer');
      Be(this, 'insertBuffer');
      Be(this, 'lines');
      ((this.deleteBuffer = t), (this.insertBuffer = r), (this.lines = []));
    }
    pushDiffCommonLine(t) {
      this.lines.push(t);
    }
    pushDiffChangeLines(t) {
      const r = t[1].length === 0;
      ((!r || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(t),
        (!r || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(t));
    }
    flushChangeLines() {
      (this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines));
    }
    align(t) {
      const r = t[0],
        n = t[1];
      if (
        n.includes(`
`)
      ) {
        const o = n.split(`
`),
          i = o.length - 1;
        o.forEach((a, l) => {
          if (l === 0) {
            const d = new Le(r, a);
            this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()
              ? (this.flushChangeLines(), this.pushDiffCommonLine(d))
              : (this.pushDiffChangeLines(d), this.flushChangeLines());
          } else
            l < i
              ? this.pushDiffCommonLine(new Le(r, a))
              : a.length !== 0 && this.pushDiffChangeLines(new Le(r, a));
        });
      } else this.pushDiffChangeLines(t);
    }
    getLines() {
      return (this.flushChangeLines(), this.lines);
    }
  };
s(E_, 'CommonBuffer');
var oB = E_;
function w_(e, t) {
  const r = new Xg(Tt, t),
    n = new Xg(dt, t),
    o = new oB(r, n);
  return (
    e.forEach((i) => {
      switch (i[0]) {
        case Tt:
          r.align(i);
          break;
        case dt:
          n.align(i);
          break;
        default:
          o.align(i);
      }
    }),
    o.getLines()
  );
}
s(w_, 'getAlignedDiffs');
function S_(e, t) {
  if (t) {
    const r = e.length - 1;
    return e.some(
      (n, o) =>
        n[0] === Je &&
        (o !== r ||
          n[1] !==
            `
`),
    );
  }
  return e.some((r) => r[0] === Je);
}
s(S_, 'hasCommonDiff');
function __(e, t, r) {
  if (e !== t && e.length !== 0 && t.length !== 0) {
    const n =
        e.includes(`
`) ||
        t.includes(`
`),
      [o, i] = Uf(
        n
          ? `${e}
`
          : e,
        n
          ? `${t}
`
          : t,
        !0,
        r,
      );
    if (S_(o, n)) {
      const a = sn(r),
        l = w_(o, a.changeColor);
      return Ll(l, i, a);
    }
  }
  return Ri(
    e.split(`
`),
    t.split(`
`),
    r,
  );
}
s(__, 'diffStringsUnified');
function Uf(e, t, r, n) {
  const [o, i] = b_(e, t, n);
  return (r && n_(o), [o, i]);
}
s(Uf, 'diffStringsRaw');
function Sa(e, t) {
  const { commonColor: r } = sn(t);
  return r(e);
}
s(Sa, 'getCommonMessage');
var {
    AsymmetricMatcher: sB,
    DOMCollection: iB,
    DOMElement: aB,
    Immutable: lB,
    ReactElement: cB,
    ReactTestComponent: uB,
  } = $f,
  A_ = [uB, cB, aB, iB, lB, sB, $f.Error],
  Zu = { maxDepth: 20, plugins: A_ },
  R_ = { callToJSON: !1, maxDepth: 8, plugins: A_ };
function Hn(e, t, r) {
  if (Object.is(e, t)) return '';
  const n = Xu(e);
  let o = n,
    i = !1;
  if (n === 'object' && typeof e.asymmetricMatch == 'function') {
    if (
      e.$$typeof !== Symbol.for('jest.asymmetricMatcher') ||
      typeof e.getExpectedType != 'function'
    )
      return;
    ((o = e.getExpectedType()), (i = o === 'string'));
  }
  if (o !== Xu(t)) {
    let a = function (R) {
      return R.length <= E ? R : `${R.slice(0, E)}...`;
    };
    s(a, 'truncate');
    const {
        aAnnotation: l,
        aColor: d,
        aIndicator: u,
        bAnnotation: p,
        bColor: f,
        bIndicator: m,
      } = sn(r),
      h = _a(R_, r);
    let g = Xt(e, h),
      v = Xt(t, h);
    const E = 1e5;
    ((g = a(g)), (v = a(v)));
    const b = `${d(`${u} ${l}:`)} 
${g}`,
      S = `${f(`${m} ${p}:`)} 
${v}`;
    return `${b}

${S}`;
  }
  if (!i)
    switch (n) {
      case 'string':
        return Ri(
          e.split(`
`),
          t.split(`
`),
          r,
        );
      case 'boolean':
      case 'number':
        return P_(e, t, r);
      case 'map':
        return na(ed(e), ed(t), r);
      case 'set':
        return na(td(e), td(t), r);
      default:
        return na(e, t, r);
    }
}
s(Hn, 'diff');
function P_(e, t, r) {
  const n = Xt(e, Zu),
    o = Xt(t, Zu);
  return n === o
    ? ''
    : Ri(
        n.split(`
`),
        o.split(`
`),
        r,
      );
}
s(P_, 'comparePrimitive');
function ed(e) {
  return new Map(Array.from(e.entries()).sort());
}
s(ed, 'sortMap');
function td(e) {
  return new Set(Array.from(e.values()).sort());
}
s(td, 'sortSet');
function na(e, t, r) {
  let n,
    o = !1;
  try {
    const a = _a(Zu, r);
    n = rd(e, t, a, r);
  } catch {
    o = !0;
  }
  const i = Sa(s_, r);
  if (n === void 0 || n === i) {
    const a = _a(R_, r);
    ((n = rd(e, t, a, r)),
      n !== i &&
        !o &&
        (n = `${Sa(tB, r)}

${n}`));
  }
  return n;
}
s(na, 'compareObjects');
function _a(e, t) {
  const { compareKeys: r, printBasicPrototype: n, maxDepth: o } = sn(t);
  return { ...e, compareKeys: r, printBasicPrototype: n, maxDepth: o ?? e.maxDepth };
}
s(_a, 'getFormatOptions');
function rd(e, t, r, n) {
  const o = { ...r, indent: 0 },
    i = Xt(e, o),
    a = Xt(t, o);
  if (i === a) return Sa(s_, n);
  {
    const l = Xt(e, r),
      d = Xt(t, r);
    return g_(
      l.split(`
`),
      d.split(`
`),
      i.split(`
`),
      a.split(`
`),
      n,
    );
  }
}
s(rd, 'getObjectsDifference');
var Qg = 2e4;
function nd(e) {
  return ti(e) === 'Object' && typeof e.asymmetricMatch == 'function';
}
s(nd, 'isAsymmetricMatcher');
function od(e, t) {
  const r = ti(e),
    n = ti(t);
  return r === n && (r === 'Object' || r === 'Array');
}
s(od, 'isReplaceable');
function Vf(e, t, r) {
  const { aAnnotation: n, bAnnotation: o } = sn(r);
  if (
    typeof t == 'string' &&
    typeof e == 'string' &&
    t.length > 0 &&
    e.length > 0 &&
    t.length <= Qg &&
    e.length <= Qg &&
    t !== e
  ) {
    if (
      t.includes(`
`) ||
      e.includes(`
`)
    )
      return __(t, e, r);
    const [p] = Uf(t, e, !0),
      f = p.some((v) => v[0] === Je),
      m = x_(n, o),
      h = m(n) + C_(sd(p, Tt, f)),
      g = m(o) + O_(sd(p, dt, f));
    return `${h}
${g}`;
  }
  const i = Wu(t, { forceWritable: !0 }),
    a = Wu(e, { forceWritable: !0 }),
    { replacedExpected: l, replacedActual: d } = Hf(a, i);
  return Hn(l, d, r);
}
s(Vf, 'printDiffOrStringify');
function Hf(e, t, r = new WeakSet(), n = new WeakSet()) {
  return e instanceof Error && t instanceof Error && typeof e.cause < 'u' && typeof t.cause > 'u'
    ? (delete e.cause, { replacedActual: e, replacedExpected: t })
    : od(e, t)
      ? r.has(e) || n.has(t)
        ? { replacedActual: e, replacedExpected: t }
        : (r.add(e),
          n.add(t),
          jf(t).forEach((o) => {
            const i = t[o],
              a = e[o];
            if (nd(i)) i.asymmetricMatch(a) && (e[o] = i);
            else if (nd(a)) a.asymmetricMatch(i) && (t[o] = a);
            else if (od(a, i)) {
              const l = Hf(a, i, r, n);
              ((e[o] = l.replacedActual), (t[o] = l.replacedExpected));
            }
          }),
          { replacedActual: e, replacedExpected: t })
      : { replacedActual: e, replacedExpected: t };
}
s(Hf, 'replaceAsymmetricMatcher');
function x_(...e) {
  const t = e.reduce((r, n) => (n.length > r ? n.length : r), 0);
  return (r) => `${r}: ${' '.repeat(t - r.length)}`;
}
s(x_, 'getLabelPrinter');
var dB = '';
function zf(e) {
  return e.replace(/\s+$/gm, (t) => dB.repeat(t.length));
}
s(zf, 'replaceTrailingSpaces');
function O_(e) {
  return Ue.red(zf(_t(e)));
}
s(O_, 'printReceived');
function C_(e) {
  return Ue.green(zf(_t(e)));
}
s(C_, 'printExpected');
function sd(e, t, r) {
  return e.reduce(
    (n, o) => n + (o[0] === Je ? o[1] : o[0] === t ? (r ? Ue.inverse(o[1]) : o[1]) : ''),
    '',
  );
}
s(sd, 'getCommonAndChangedSubstrings');
var pB = '@@__IMMUTABLE_RECORD__@@',
  fB = '@@__IMMUTABLE_ITERABLE__@@';
function I_(e) {
  return e && (e[fB] || e[pB]);
}
s(I_, 'isImmutable');
var mB = Object.getPrototypeOf({});
function id(e) {
  return e instanceof Error
    ? `<unserializable>: ${e.message}`
    : typeof e == 'string'
      ? `<unserializable>: ${e}`
      : '<unserializable>';
}
s(id, 'getUnserializableMessage');
function Rr(e, t = new WeakMap()) {
  if (!e || typeof e == 'string') return e;
  if (e instanceof Error && 'toJSON' in e && typeof e.toJSON == 'function') {
    const r = e.toJSON();
    return (
      r &&
        r !== e &&
        typeof r == 'object' &&
        (typeof e.message == 'string' && Is(() => r.message ?? (r.message = e.message)),
        typeof e.stack == 'string' && Is(() => r.stack ?? (r.stack = e.stack)),
        typeof e.name == 'string' && Is(() => r.name ?? (r.name = e.name)),
        e.cause != null && Is(() => r.cause ?? (r.cause = Rr(e.cause, t)))),
      Rr(r, t)
    );
  }
  if (typeof e == 'function') return `Function<${e.name || 'anonymous'}>`;
  if (typeof e == 'symbol') return e.toString();
  if (typeof e != 'object') return e;
  if (typeof Buffer < 'u' && e instanceof Buffer) return `<Buffer(${e.length}) ...>`;
  if (typeof Uint8Array < 'u' && e instanceof Uint8Array) return `<Uint8Array(${e.length}) ...>`;
  if (I_(e)) return Rr(e.toJSON(), t);
  if (e instanceof Promise || (e.constructor && e.constructor.prototype === 'AsyncFunction'))
    return 'Promise';
  if (typeof Element < 'u' && e instanceof Element) return e.tagName;
  if (typeof e.asymmetricMatch == 'function') return `${e.toString()} ${YS(e.sample)}`;
  if (typeof e.toJSON == 'function') return Rr(e.toJSON(), t);
  if (t.has(e)) return t.get(e);
  if (Array.isArray(e)) {
    const r = new Array(e.length);
    return (
      t.set(e, r),
      e.forEach((n, o) => {
        try {
          r[o] = Rr(n, t);
        } catch (i) {
          r[o] = id(i);
        }
      }),
      r
    );
  } else {
    const r = Object.create(null);
    t.set(e, r);
    let n = e;
    for (; n && n !== mB; )
      (Object.getOwnPropertyNames(n).forEach((o) => {
        if (!(o in r))
          try {
            r[o] = Rr(e[o], t);
          } catch (i) {
            (delete r[o], (r[o] = id(i)));
          }
      }),
        (n = Object.getPrototypeOf(n)));
    return r;
  }
}
s(Rr, 'serializeValue');
function Is(e) {
  try {
    return e();
  } catch {}
}
s(Is, 'safe');
function N_(e) {
  return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, '');
}
s(N_, 'normalizeErrorMessage');
function Fl(e, t, r = new WeakSet()) {
  if (!e || typeof e != 'object') return { message: String(e) };
  const n = e;
  ((n.showDiff || (n.showDiff === void 0 && n.expected !== void 0 && n.actual !== void 0)) &&
    (n.diff = Vf(n.actual, n.expected, { ...t, ...n.diffOptions })),
    'expected' in n && typeof n.expected != 'string' && (n.expected = _t(n.expected, 10)),
    'actual' in n && typeof n.actual != 'string' && (n.actual = _t(n.actual, 10)));
  try {
    typeof n.message == 'string' && (n.message = N_(n.message));
  } catch {}
  try {
    !r.has(n) && typeof n.cause == 'object' && (r.add(n), (n.cause = Fl(n.cause, t, r)));
  } catch {}
  try {
    return Rr(n);
  } catch (o) {
    return Rr(
      new Error(`Failed to fully serialize error: ${o?.message}
Inner error message: ${n?.message}`),
    );
  }
}
s(Fl, 'processError');
var vr = {
    CALL: 'storybook/instrumenter/call',
    SYNC: 'storybook/instrumenter/sync',
    START: 'storybook/instrumenter/start',
    BACK: 'storybook/instrumenter/back',
    GOTO: 'storybook/instrumenter/goto',
    NEXT: 'storybook/instrumenter/next',
    END: 'storybook/instrumenter/end',
  },
  du = globalThis.__STORYBOOK_ADDONS_PREVIEW,
  yB = new Error(
    'This function ran after the play function completed. Did you forget to `await` it?',
  ),
  Zg = s((e) => Object.prototype.toString.call(e) === '[object Object]', 'isObject'),
  hB = s((e) => Object.prototype.toString.call(e) === '[object Module]', 'isModule'),
  gB = s((e) => {
    if (!Zg(e) && !hB(e)) return !1;
    if (e.constructor === void 0) return !0;
    const t = e.constructor.prototype;
    return !!Zg(t);
  }, 'isInstrumentable'),
  bB = s((e) => {
    try {
      return new e.constructor();
    } catch {
      return {};
    }
  }, 'construct'),
  pu = s(
    () => ({
      renderPhase: 'preparing',
      isDebugging: !1,
      isPlaying: !1,
      isLocked: !1,
      cursor: 0,
      calls: [],
      shadowCalls: [],
      callRefsByResult: new Map(),
      chainedCallIds: new Set(),
      ancestors: [],
      playUntil: void 0,
      resolvers: {},
      syncTimeout: void 0,
    }),
    'getInitialState',
  ),
  eb = s((e, t = !1) => {
    const r = (t ? e.shadowCalls : e.calls).filter((o) => o.retain);
    if (!r.length) return;
    const n = new Map(Array.from(e.callRefsByResult.entries()).filter(([, o]) => o.retain));
    return { cursor: r.length, calls: r, callRefsByResult: n };
  }, 'getRetainedState'),
  $_ = class {
    constructor() {
      ((this.detached = !1),
        (this.initialized = !1),
        (this.state = {}),
        (this.loadParentWindowState = s(() => {
          try {
            this.state =
              te.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
          } catch {
            this.detached = !0;
          }
        }, 'loadParentWindowState')),
        (this.updateParentWindowState = s(() => {
          try {
            te.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
          } catch {
            this.detached = !0;
          }
        }, 'updateParentWindowState')),
        this.loadParentWindowState());
      const t = s(({ storyId: d, renderPhase: u, isPlaying: p = !0, isDebugging: f = !1 }) => {
          const m = this.getState(d);
          (this.setState(d, {
            ...pu(),
            ...eb(m, f),
            renderPhase: u || m.renderPhase,
            shadowCalls: f ? m.shadowCalls : [],
            chainedCallIds: f ? m.chainedCallIds : new Set(),
            playUntil: f ? m.playUntil : void 0,
            isPlaying: p,
            isDebugging: f,
          }),
            this.sync(d));
        }, 'resetState'),
        r = s(
          (d) =>
            ({ storyId: u, playUntil: p }) => {
              this.getState(u).isDebugging ||
                this.setState(u, ({ calls: m }) => ({
                  calls: [],
                  shadowCalls: m.map((h) => ({ ...h, status: 'waiting' })),
                  isDebugging: !0,
                }));
              const f = this.getLog(u);
              (this.setState(u, ({ shadowCalls: m }) => {
                if (p || !f.length) return { playUntil: p };
                const h = m.findIndex((g) => g.id === f[0].callId);
                return {
                  playUntil: m
                    .slice(0, h)
                    .filter((g) => g.interceptable && !g.ancestors?.length)
                    .slice(-1)[0]?.id,
                };
              }),
                d.emit(va, { storyId: u, isDebugging: !0 }));
            },
          'start',
        ),
        n = s(
          (d) =>
            ({ storyId: u }) => {
              const p = this.getLog(u).filter((m) => !m.ancestors?.length),
                f = p.reduceRight((m, h, g) => (m >= 0 || h.status === 'waiting' ? m : g), -1);
              r(d)({ storyId: u, playUntil: p[f - 1]?.callId });
            },
          'back',
        ),
        o = s(
          (d) =>
            ({ storyId: u, callId: p }) => {
              const { calls: f, shadowCalls: m, resolvers: h } = this.getState(u),
                g = f.find(({ id: E }) => E === p),
                v = m.find(({ id: E }) => E === p);
              if (!g && v && Object.values(h).length > 0) {
                const E = this.getLog(u).find((b) => b.status === 'waiting')?.callId;
                (v.id !== E && this.setState(u, { playUntil: v.id }),
                  Object.values(h).forEach((b) => b()));
              } else r(d)({ storyId: u, playUntil: p });
            },
          'goto',
        ),
        i = s(
          (d) =>
            ({ storyId: u }) => {
              const { resolvers: p } = this.getState(u);
              if (Object.values(p).length > 0) Object.values(p).forEach((f) => f());
              else {
                const f = this.getLog(u).find((m) => m.status === 'waiting')?.callId;
                f ? r(d)({ storyId: u, playUntil: f }) : a({ storyId: u });
              }
            },
          'next',
        ),
        a = s(({ storyId: d }) => {
          (this.setState(d, { playUntil: void 0, isDebugging: !1 }),
            Object.values(this.getState(d).resolvers).forEach((u) => u()));
        }, 'end'),
        l = s(({ storyId: d, newPhase: u }) => {
          const { isDebugging: p } = this.getState(d);
          if (u === 'preparing' && p) return t({ storyId: d, renderPhase: u, isDebugging: p });
          if (u === 'playing') return t({ storyId: d, renderPhase: u, isDebugging: p });
          (u === 'played'
            ? this.setState(d, { renderPhase: u, isLocked: !1, isPlaying: !1, isDebugging: !1 })
            : u === 'errored'
              ? this.setState(d, { renderPhase: u, isLocked: !1, isPlaying: !1 })
              : u === 'aborted'
                ? this.setState(d, { renderPhase: u, isLocked: !0, isPlaying: !1 })
                : this.setState(d, { renderPhase: u }),
            this.sync(d));
        }, 'renderPhaseChanged');
      du &&
        du.ready().then(() => {
          ((this.channel = du.getChannel()),
            this.channel.on(va, t),
            this.channel.on(On, l),
            this.channel.on(Kp, () => {
              this.initialized ? this.cleanup() : (this.initialized = !0);
            }),
            this.channel.on(vr.START, r(this.channel)),
            this.channel.on(vr.BACK, n(this.channel)),
            this.channel.on(vr.GOTO, o(this.channel)),
            this.channel.on(vr.NEXT, i(this.channel)),
            this.channel.on(vr.END, a));
        });
    }
    getState(t) {
      return this.state[t] || pu();
    }
    setState(t, r) {
      if (t) {
        const n = this.getState(t),
          o = typeof r == 'function' ? r(n) : r;
        ((this.state = { ...this.state, [t]: { ...n, ...o } }), this.updateParentWindowState());
      }
    }
    cleanup() {
      this.state = Object.entries(this.state).reduce((n, [o, i]) => {
        const a = eb(i);
        return (a && (n[o] = Object.assign(pu(), a)), n);
      }, {});
      const r = {
        controlStates: {
          detached: this.detached,
          start: !1,
          back: !1,
          goto: !1,
          next: !1,
          end: !1,
        },
        logItems: [],
      };
      (this.channel?.emit(vr.SYNC, r), this.updateParentWindowState());
    }
    getLog(t) {
      const { calls: r, shadowCalls: n } = this.getState(t),
        o = [...n];
      r.forEach((a, l) => {
        o[l] = a;
      });
      const i = new Set();
      return o.reduceRight(
        (a, l) => (
          l.args.forEach((d) => {
            d?.__callId__ && i.add(d.__callId__);
          }),
          l.path.forEach((d) => {
            d.__callId__ && i.add(d.__callId__);
          }),
          (l.interceptable || l.exception) &&
            !i.has(l.id) &&
            (a.unshift({ callId: l.id, status: l.status, ancestors: l.ancestors }), i.add(l.id)),
          a
        ),
        [],
      );
    }
    instrument(t, r, n = 0) {
      if (!gB(t)) return t;
      const { mutate: o = !1, path: i = [] } = r,
        a = r.getKeys ? r.getKeys(t, n) : Object.keys(t);
      return (
        (n += 1),
        a.reduce(
          (l, d) => {
            const u = q_(t, d);
            if (typeof u?.get == 'function') {
              if (u.configurable) {
                const f = s(() => u?.get?.bind(t)?.(), 'getter');
                Object.defineProperty(l, d, {
                  get: s(() => this.instrument(f(), { ...r, path: i.concat(d) }, n), 'get'),
                });
              }
              return l;
            }
            const p = t[d];
            return typeof p != 'function'
              ? ((l[d] = this.instrument(p, { ...r, path: i.concat(d) }, n)), l)
              : '__originalFn__' in p && typeof p.__originalFn__ == 'function'
                ? ((l[d] = p), l)
                : ((l[d] = (...f) => this.track(d, p, t, f, r)),
                  (l[d].__originalFn__ = p),
                  Object.defineProperty(l[d], 'name', { value: d, writable: !1 }),
                  Object.keys(p).length > 0 &&
                    Object.assign(l[d], this.instrument({ ...p }, { ...r, path: i.concat(d) }, n)),
                  l);
          },
          o ? t : bB(t),
        )
      );
    }
    track(t, r, n, o, i) {
      const a = o?.[0]?.__storyId__ || te.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId,
        { cursor: l, ancestors: d } = this.getState(a);
      this.setState(a, { cursor: l + 1 });
      const u = `${d.slice(-1)[0] || a} [${l}] ${t}`,
        { path: p = [], intercept: f = !1, retain: m = !1 } = i,
        h = typeof f == 'function' ? f(t, p) : f,
        g = {
          id: u,
          cursor: l,
          storyId: a,
          ancestors: d,
          path: p,
          method: t,
          args: o,
          interceptable: h,
          retain: m,
        },
        E = (h && !d.length ? this.intercept : this.invoke).call(this, r, n, g, i);
      return this.instrument(E, { ...i, mutate: !0, path: [{ __callId__: g.id }] });
    }
    intercept(t, r, n, o) {
      const { chainedCallIds: i, isDebugging: a, playUntil: l } = this.getState(n.storyId),
        d = i.has(n.id);
      return !a || d || l
        ? (l === n.id && this.setState(n.storyId, { playUntil: void 0 }), this.invoke(t, r, n, o))
        : new Promise((u) => {
            this.setState(n.storyId, ({ resolvers: p }) => ({
              isLocked: !1,
              resolvers: { ...p, [n.id]: u },
            }));
          }).then(
            () => (
              this.setState(n.storyId, (u) => {
                const { [n.id]: p, ...f } = u.resolvers;
                return { isLocked: !0, resolvers: f };
              }),
              this.invoke(t, r, n, o)
            ),
          );
    }
    invoke(t, r, n, o) {
      const { callRefsByResult: i, renderPhase: a } = this.getState(n.storyId),
        l = 25,
        d = s((f, m, h) => {
          if (h.includes(f)) return '[Circular]';
          if (((h = [...h, f]), m > l)) return '...';
          if (i.has(f)) return i.get(f);
          if (f instanceof Array) return f.map((g) => d(g, ++m, h));
          if (f instanceof Date) return { __date__: { value: f.toISOString() } };
          if (f instanceof Error) {
            const { name: g, message: v, stack: E } = f;
            return { __error__: { name: g, message: v, stack: E } };
          }
          if (f instanceof RegExp) {
            const { flags: g, source: v } = f;
            return { __regexp__: { flags: g, source: v } };
          }
          if (f instanceof te.window?.HTMLElement) {
            const { prefix: g, localName: v, id: E, classList: b, innerText: S } = f,
              R = Array.from(b);
            return { __element__: { prefix: g, localName: v, id: E, classNames: R, innerText: S } };
          }
          return typeof f == 'function'
            ? { __function__: { name: 'getMockName' in f ? f.getMockName() : f.name } }
            : typeof f == 'symbol'
              ? { __symbol__: { description: f.description } }
              : typeof f == 'object' && f?.constructor?.name && f?.constructor?.name !== 'Object'
                ? { __class__: { name: f.constructor.name } }
                : Object.prototype.toString.call(f) === '[object Object]'
                  ? Object.fromEntries(Object.entries(f).map(([g, v]) => [g, d(v, ++m, h)]))
                  : f;
        }, 'serializeValues'),
        u = { ...n, args: n.args.map((f) => d(f, 0, [])) };
      n.path.forEach((f) => {
        f?.__callId__ &&
          this.setState(n.storyId, ({ chainedCallIds: m }) => ({
            chainedCallIds: new Set(Array.from(m).concat(f.__callId__)),
          }));
      });
      const p = s((f) => {
        if (f instanceof Error) {
          const { name: m, message: h, stack: g, callId: v = n.id } = f,
            {
              showDiff: E = void 0,
              diff: b = void 0,
              actual: S = void 0,
              expected: R = void 0,
            } = f.name === 'AssertionError' ? Fl(f) : f,
            I = {
              name: m,
              message: h,
              stack: g,
              callId: v,
              showDiff: E,
              diff: b,
              actual: S,
              expected: R,
            };
          if (
            (this.update({ ...u, status: 'error', exception: I }),
            this.setState(n.storyId, ($) => ({
              callRefsByResult: new Map([
                ...Array.from($.callRefsByResult.entries()),
                [f, { __callId__: n.id, retain: n.retain }],
              ]),
            })),
            n.ancestors?.length)
          )
            throw (
              Object.prototype.hasOwnProperty.call(f, 'callId') ||
                Object.defineProperty(f, 'callId', { value: n.id }),
              f
            );
        }
        throw f;
      }, 'handleException');
      try {
        if (a === 'played' && !n.retain) throw yB;
        const m = (o.getArgs ? o.getArgs(n, this.getState(n.storyId)) : n.args).map((g) =>
            typeof g != 'function' || M_(g) || Object.keys(g).length
              ? g
              : (...v) => {
                  const { cursor: E, ancestors: b } = this.getState(n.storyId);
                  this.setState(n.storyId, { cursor: 0, ancestors: [...b, n.id] });
                  const S = s(
                    () => this.setState(n.storyId, { cursor: E, ancestors: b }),
                    'restore',
                  );
                  let R = !1;
                  try {
                    const I = g(...v);
                    return I instanceof Promise ? ((R = !0), I.finally(S)) : I;
                  } finally {
                    R || S();
                  }
                },
          ),
          h = t.apply(r, m);
        return (
          h &&
            ['object', 'function', 'symbol'].includes(typeof h) &&
            this.setState(n.storyId, (g) => ({
              callRefsByResult: new Map([
                ...Array.from(g.callRefsByResult.entries()),
                [h, { __callId__: n.id, retain: n.retain }],
              ]),
            })),
          this.update({ ...u, status: h instanceof Promise ? 'active' : 'done' }),
          h instanceof Promise ? h.then((g) => (this.update({ ...u, status: 'done' }), g), p) : h
        );
      } catch (f) {
        return p(f);
      }
    }
    update(t) {
      (this.channel?.emit(vr.CALL, t),
        this.setState(t.storyId, ({ calls: r }) => {
          const n = r.concat(t).reduce((o, i) => Object.assign(o, { [i.id]: i }), {});
          return {
            calls: Object.values(n).sort((o, i) =>
              o.id.localeCompare(i.id, void 0, { numeric: !0 }),
            ),
          };
        }),
        this.sync(t.storyId));
    }
    sync(t) {
      const r = s(() => {
        const { isLocked: n, isPlaying: o } = this.getState(t),
          i = this.getLog(t),
          a = i.filter(({ ancestors: f }) => !f.length).find((f) => f.status === 'waiting')?.callId,
          l = i.some((f) => f.status === 'active');
        if (this.detached || n || l || i.length === 0) {
          const m = {
            controlStates: {
              detached: this.detached,
              start: !1,
              back: !1,
              goto: !1,
              next: !1,
              end: !1,
            },
            logItems: i,
          };
          this.channel?.emit(vr.SYNC, m);
          return;
        }
        const d = i.some((f) => f.status === 'done' || f.status === 'error'),
          p = {
            controlStates: {
              detached: this.detached,
              start: d,
              back: d,
              goto: !0,
              next: o,
              end: o,
            },
            logItems: i,
            pausedAt: a,
          };
        this.channel?.emit(vr.SYNC, p);
      }, 'synchronize');
      this.setState(
        t,
        ({ syncTimeout: n }) => (clearTimeout(n), { syncTimeout: setTimeout(r, 0) }),
      );
    }
  };
s($_, 'Instrumenter');
var vB = $_;
function Fo(e, t = {}) {
  try {
    let r = !1,
      n = !1;
    return (
      te.window?.location?.search?.includes('instrument=true')
        ? (r = !0)
        : te.window?.location?.search?.includes('instrument=false') && (n = !0),
      (te.window?.parent === te.window && !r) || n
        ? e
        : (te.window &&
            !te.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ &&
            (te.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new vB()),
          (te.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(e, t))
    );
  } catch (r) {
    return (Ve.warn(r), e);
  }
}
s(Fo, 'instrument');
function q_(e, t) {
  let r = e;
  for (; r != null; ) {
    const n = Object.getOwnPropertyDescriptor(r, t);
    if (n) return n;
    r = Object.getPrototypeOf(r);
  }
}
s(q_, 'getPropertyDescriptor');
function M_(e) {
  if (typeof e != 'function') return !1;
  const t = Object.getOwnPropertyDescriptor(e, 'prototype');
  return t ? !t.writable : !1;
}
s(M_, 'isClass');
var j_ = Object.defineProperty,
  z = s((e, t) => j_(e, 'name', { value: t, configurable: !0 }), '__name'),
  Gf = s((e, t) => {
    for (var r in t) j_(e, r, { get: t[r], enumerable: !0 });
  }, '__export'),
  sr = {};
Gf(sr, {
  addChainableMethod: s(() => Ql, 'addChainableMethod'),
  addLengthGuard: s(() => Uo, 'addLengthGuard'),
  addMethod: s(() => Kl, 'addMethod'),
  addProperty: s(() => Wl, 'addProperty'),
  checkError: s(() => Ct, 'checkError'),
  compareByInspect: s(() => si, 'compareByInspect'),
  eql: s(() => D_, 'eql'),
  expectTypes: s(() => em, 'expectTypes'),
  flag: s(() => me, 'flag'),
  getActual: s(() => xi, 'getActual'),
  getMessage: s(() => Ul, 'getMessage'),
  getName: s(() => Ci, 'getName'),
  getOperator: s(() => rc, 'getOperator'),
  getOwnEnumerableProperties: s(() => tc, 'getOwnEnumerableProperties'),
  getOwnEnumerablePropertySymbols: s(() => ec, 'getOwnEnumerablePropertySymbols'),
  getPathInfo: s(() => Gl, 'getPathInfo'),
  hasProperty: s(() => Oi, 'hasProperty'),
  inspect: s(() => Se, 'inspect'),
  isNaN: s(() => La, 'isNaN'),
  isNumeric: s(() => ot, 'isNumeric'),
  isProxyEnabled: s(() => Jo, 'isProxyEnabled'),
  isRegExp: s(() => ii, 'isRegExp'),
  objDisplay: s(() => Hr, 'objDisplay'),
  overwriteChainableMethod: s(() => Zl, 'overwriteChainableMethod'),
  overwriteMethod: s(() => Xl, 'overwriteMethod'),
  overwriteProperty: s(() => Yl, 'overwriteProperty'),
  proxify: s(() => zn, 'proxify'),
  test: s(() => Bl, 'test'),
  transferFlags: s(() => Ht, 'transferFlags'),
  type: s(() => Ce, 'type'),
});
var Ct = {};
Gf(Ct, {
  compatibleConstructor: s(() => Yf, 'compatibleConstructor'),
  compatibleInstance: s(() => Kf, 'compatibleInstance'),
  compatibleMessage: s(() => Xf, 'compatibleMessage'),
  getConstructorName: s(() => Qf, 'getConstructorName'),
  getMessage: s(() => Zf, 'getMessage'),
});
function Pi(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === '[object Error]';
}
s(Pi, 'isErrorInstance');
z(Pi, 'isErrorInstance');
function Wf(e) {
  return Object.prototype.toString.call(e) === '[object RegExp]';
}
s(Wf, 'isRegExp');
z(Wf, 'isRegExp');
function Kf(e, t) {
  return Pi(t) && e === t;
}
s(Kf, 'compatibleInstance');
z(Kf, 'compatibleInstance');
function Yf(e, t) {
  return Pi(t)
    ? e.constructor === t.constructor || e instanceof t.constructor
    : (typeof t == 'object' || typeof t == 'function') && t.prototype
      ? e.constructor === t || e instanceof t
      : !1;
}
s(Yf, 'compatibleConstructor');
z(Yf, 'compatibleConstructor');
function Xf(e, t) {
  const r = typeof e == 'string' ? e : e.message;
  return Wf(t) ? t.test(r) : typeof t == 'string' ? r.indexOf(t) !== -1 : !1;
}
s(Xf, 'compatibleMessage');
z(Xf, 'compatibleMessage');
function Qf(e) {
  let t = e;
  return (
    Pi(e)
      ? (t = e.constructor.name)
      : typeof e == 'function' && ((t = e.name), t === '' && (t = new e().name || t)),
    t
  );
}
s(Qf, 'getConstructorName');
z(Qf, 'getConstructorName');
function Zf(e) {
  let t = '';
  return (e && e.message ? (t = e.message) : typeof e == 'string' && (t = e), t);
}
s(Zf, 'getMessage');
z(Zf, 'getMessage');
function me(e, t, r) {
  let n = e.__flags || (e.__flags = Object.create(null));
  if (arguments.length === 3) n[t] = r;
  else return n[t];
}
s(me, 'flag');
z(me, 'flag');
function Bl(e, t) {
  let r = me(e, 'negate'),
    n = t[0];
  return r ? !n : n;
}
s(Bl, 'test');
z(Bl, 'test');
function Ce(e) {
  if (typeof e > 'u') return 'undefined';
  if (e === null) return 'null';
  const t = e[Symbol.toStringTag];
  return typeof t == 'string' ? t : Object.prototype.toString.call(e).slice(8, -1);
}
s(Ce, 'type');
z(Ce, 'type');
var TB = 'captureStackTrace' in Error,
  _s,
  Re =
    ((_s = class extends Error {
      constructor(t = 'Unspecified AssertionError', r, n) {
        super(t);
        Be(this, 'message');
        ((this.message = t), TB && Error.captureStackTrace(this, n || _s));
        for (const o in r) o in this || (this[o] = r[o]);
      }
      get name() {
        return 'AssertionError';
      }
      get ok() {
        return !1;
      }
      toJSON(t) {
        return {
          ...this,
          name: this.name,
          message: this.message,
          ok: !1,
          stack: t !== !1 ? this.stack : void 0,
        };
      }
    }),
    s(_s, '_AssertionError'),
    z(_s, 'AssertionError'),
    _s);
function em(e, t) {
  let r = me(e, 'message'),
    n = me(e, 'ssfi');
  ((r = r ? r + ': ' : ''),
    (e = me(e, 'object')),
    (t = t.map(function (a) {
      return a.toLowerCase();
    })),
    t.sort());
  let o = t
      .map(function (a, l) {
        let d = ~['a', 'e', 'i', 'o', 'u'].indexOf(a.charAt(0)) ? 'an' : 'a';
        return (t.length > 1 && l === t.length - 1 ? 'or ' : '') + d + ' ' + a;
      })
      .join(', '),
    i = Ce(e).toLowerCase();
  if (
    !t.some(function (a) {
      return i === a;
    })
  )
    throw new Re(r + 'object tested must be ' + o + ', but ' + i + ' given', void 0, n);
}
s(em, 'expectTypes');
z(em, 'expectTypes');
function xi(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
s(xi, 'getActual');
z(xi, 'getActual');
var tb = {
    bold: ['1', '22'],
    dim: ['2', '22'],
    italic: ['3', '23'],
    underline: ['4', '24'],
    inverse: ['7', '27'],
    hidden: ['8', '28'],
    strike: ['9', '29'],
    black: ['30', '39'],
    red: ['31', '39'],
    green: ['32', '39'],
    yellow: ['33', '39'],
    blue: ['34', '39'],
    magenta: ['35', '39'],
    cyan: ['36', '39'],
    white: ['37', '39'],
    brightblack: ['30;1', '39'],
    brightred: ['31;1', '39'],
    brightgreen: ['32;1', '39'],
    brightyellow: ['33;1', '39'],
    brightblue: ['34;1', '39'],
    brightmagenta: ['35;1', '39'],
    brightcyan: ['36;1', '39'],
    brightwhite: ['37;1', '39'],
    grey: ['90', '39'],
  },
  EB = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red',
  },
  Ao = '';
function tm(e, t) {
  const r = tb[EB[t]] || tb[t] || '';
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
s(tm, 'colorise');
z(tm, 'colorise');
function rm(
  {
    showHidden: e = !1,
    depth: t = 2,
    colors: r = !1,
    customInspect: n = !0,
    showProxy: o = !1,
    maxArrayLength: i = 1 / 0,
    breakLength: a = 1 / 0,
    seen: l = [],
    truncate: d = 1 / 0,
    stylize: u = String,
  } = {},
  p,
) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!o,
    maxArrayLength: Number(i),
    breakLength: Number(a),
    truncate: Number(d),
    seen: l,
    inspect: p,
    stylize: u,
  };
  return (f.colors && (f.stylize = tm), f);
}
s(rm, 'normaliseOptions');
z(rm, 'normaliseOptions');
function nm(e) {
  return e >= '\uD800' && e <= '\uDBFF';
}
s(nm, 'isHighSurrogate');
z(nm, 'isHighSurrogate');
function pr(e, t, r = Ao) {
  e = String(e);
  const n = r.length,
    o = e.length;
  if (n > t && o > n) return r;
  if (o > t && o > n) {
    let i = t - n;
    return (i > 0 && nm(e[i - 1]) && (i = i - 1), `${e.slice(0, i)}${r}`);
  }
  return e;
}
s(pr, 'truncate');
z(pr, 'truncate');
function Mt(e, t, r, n = ', ') {
  r = r || t.inspect;
  const o = e.length;
  if (o === 0) return '';
  const i = t.truncate;
  let a = '',
    l = '',
    d = '';
  for (let u = 0; u < o; u += 1) {
    const p = u + 1 === e.length,
      f = u + 2 === e.length;
    d = `${Ao}(${e.length - u})`;
    const m = e[u];
    t.truncate = i - a.length - (p ? 0 : n.length);
    const h = l || r(m, t) + (p ? '' : n),
      g = a.length + h.length,
      v = g + d.length;
    if (
      (p && g > i && a.length + d.length <= i) ||
      (!p && !f && v > i) ||
      ((l = p ? '' : r(e[u + 1], t) + (f ? '' : n)), !p && f && v > i && g + l.length > i)
    )
      break;
    if (((a += h), !p && !f && g + l.length >= i)) {
      d = `${Ao}(${e.length - u - 1})`;
      break;
    }
    d = '';
  }
  return `${a}${d}`;
}
s(Mt, 'inspectList');
z(Mt, 'inspectList');
function om(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
    ? e
    : JSON.stringify(e)
        .replace(/'/g, "\\'")
        .replace(/\\"/g, '"')
        .replace(/(^"|"$)/g, "'");
}
s(om, 'quoteComplexKey');
z(om, 'quoteComplexKey');
function Cn([e, t], r) {
  return (
    (r.truncate -= 2),
    typeof e == 'string' ? (e = om(e)) : typeof e != 'number' && (e = `[${r.inspect(e, r)}]`),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e}: ${t}`
  );
}
s(Cn, 'inspectProperty');
z(Cn, 'inspectProperty');
function sm(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length) return '[]';
  t.truncate -= 4;
  const n = Mt(e, t);
  t.truncate -= n.length;
  let o = '';
  return (
    r.length &&
      (o = Mt(
        r.map((i) => [i, e[i]]),
        t,
        Cn,
      )),
    `[ ${n}${o ? `, ${o}` : ''} ]`
  );
}
s(sm, 'inspectArray');
z(sm, 'inspectArray');
var wB = z(
  (e) =>
    typeof Buffer == 'function' && e instanceof Buffer
      ? 'Buffer'
      : e[Symbol.toStringTag]
        ? e[Symbol.toStringTag]
        : e.constructor.name,
  'getArrayName',
);
function Wt(e, t) {
  const r = wB(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length) return `${r}[]`;
  let o = '';
  for (let a = 0; a < e.length; a++) {
    const l = `${t.stylize(pr(e[a], t.truncate), 'number')}${a === e.length - 1 ? '' : ', '}`;
    if (((t.truncate -= l.length), e[a] !== e.length && t.truncate <= 3)) {
      o += `${Ao}(${e.length - e[a] + 1})`;
      break;
    }
    o += l;
  }
  let i = '';
  return (
    n.length &&
      (i = Mt(
        n.map((a) => [a, e[a]]),
        t,
        Cn,
      )),
    `${r}[ ${o}${i ? `, ${i}` : ''} ]`
  );
}
s(Wt, 'inspectTypedArray');
z(Wt, 'inspectTypedArray');
function im(e, t) {
  const r = e.toJSON();
  if (r === null) return 'Invalid Date';
  const n = r.split('T'),
    o = n[0];
  return t.stylize(`${o}T${pr(n[1], t.truncate - o.length - 1)}`, 'date');
}
s(im, 'inspectDate');
z(im, 'inspectDate');
function Aa(e, t) {
  const r = e[Symbol.toStringTag] || 'Function',
    n = e.name;
  return n
    ? t.stylize(`[${r} ${pr(n, t.truncate - 11)}]`, 'special')
    : t.stylize(`[${r}]`, 'special');
}
s(Aa, 'inspectFunction');
z(Aa, 'inspectFunction');
function am([e, t], r) {
  return (
    (r.truncate -= 4),
    (e = r.inspect(e, r)),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e} => ${t}`
  );
}
s(am, 'inspectMapEntry');
z(am, 'inspectMapEntry');
function lm(e) {
  const t = [];
  return (
    e.forEach((r, n) => {
      t.push([n, r]);
    }),
    t
  );
}
s(lm, 'mapToEntries');
z(lm, 'mapToEntries');
function cm(e, t) {
  return e.size === 0 ? 'Map{}' : ((t.truncate -= 7), `Map{ ${Mt(lm(e), t, am)} }`);
}
s(cm, 'inspectMap');
z(cm, 'inspectMap');
var SB = Number.isNaN || ((e) => e !== e);
function Ra(e, t) {
  return SB(e)
    ? t.stylize('NaN', 'number')
    : e === 1 / 0
      ? t.stylize('Infinity', 'number')
      : e === -1 / 0
        ? t.stylize('-Infinity', 'number')
        : e === 0
          ? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
          : t.stylize(pr(String(e), t.truncate), 'number');
}
s(Ra, 'inspectNumber');
z(Ra, 'inspectNumber');
function Pa(e, t) {
  let r = pr(e.toString(), t.truncate - 1);
  return (r !== Ao && (r += 'n'), t.stylize(r, 'bigint'));
}
s(Pa, 'inspectBigInt');
z(Pa, 'inspectBigInt');
function um(e, t) {
  const r = e.toString().split('/')[2],
    n = t.truncate - (2 + r.length),
    o = e.source;
  return t.stylize(`/${pr(o, n)}/${r}`, 'regexp');
}
s(um, 'inspectRegExp');
z(um, 'inspectRegExp');
function dm(e) {
  const t = [];
  return (
    e.forEach((r) => {
      t.push(r);
    }),
    t
  );
}
s(dm, 'arrayFromSet');
z(dm, 'arrayFromSet');
function pm(e, t) {
  return e.size === 0 ? 'Set{}' : ((t.truncate -= 7), `Set{ ${Mt(dm(e), t)} }`);
}
s(pm, 'inspectSet');
z(pm, 'inspectSet');
var rb = new RegExp(
    "['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
    'g',
  ),
  _B = { '\b': '\\b', '	': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '\\': '\\\\' },
  AB = 16;
function fm(e) {
  return _B[e] || `\\u${`0000${e.charCodeAt(0).toString(AB)}`.slice(-4)}`;
}
s(fm, 'escape');
z(fm, 'escape');
function xa(e, t) {
  return (rb.test(e) && (e = e.replace(rb, fm)), t.stylize(`'${pr(e, t.truncate - 2)}'`, 'string'));
}
s(xa, 'inspectString');
z(xa, 'inspectString');
function Oa(e) {
  return 'description' in Symbol.prototype
    ? e.description
      ? `Symbol(${e.description})`
      : 'Symbol()'
    : e.toString();
}
s(Oa, 'inspectSymbol');
z(Oa, 'inspectSymbol');
var RB = z(() => 'Promise{}', 'getPromiseValue'),
  PB = RB;
function po(e, t) {
  const r = Object.getOwnPropertyNames(e),
    n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0) return '{}';
  if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e))) return '[Circular]';
  t.seen.push(e);
  const o = Mt(
      r.map((l) => [l, e[l]]),
      t,
      Cn,
    ),
    i = Mt(
      n.map((l) => [l, e[l]]),
      t,
      Cn,
    );
  t.seen.pop();
  let a = '';
  return (o && i && (a = ', '), `{ ${o}${a}${i} }`);
}
s(po, 'inspectObject');
z(po, 'inspectObject');
var fu = typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1;
function mm(e, t) {
  let r = '';
  return (
    fu && fu in e && (r = e[fu]),
    (r = r || e.constructor.name),
    (!r || r === '_class') && (r = '<Anonymous Class>'),
    (t.truncate -= r.length),
    `${r}${po(e, t)}`
  );
}
s(mm, 'inspectClass');
z(mm, 'inspectClass');
function ym(e, t) {
  return e.length === 0 ? 'Arguments[]' : ((t.truncate -= 13), `Arguments[ ${Mt(e, t)} ]`);
}
s(ym, 'inspectArguments');
z(ym, 'inspectArguments');
var xB = [
  'stack',
  'line',
  'column',
  'name',
  'message',
  'fileName',
  'lineNumber',
  'columnNumber',
  'number',
  'description',
  'cause',
];
function hm(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((a) => xB.indexOf(a) === -1),
    n = e.name;
  t.truncate -= n.length;
  let o = '';
  if (
    (typeof e.message == 'string' ? (o = pr(e.message, t.truncate)) : r.unshift('message'),
    (o = o ? `: ${o}` : ''),
    (t.truncate -= o.length + 5),
    (t.seen = t.seen || []),
    t.seen.includes(e))
  )
    return '[Circular]';
  t.seen.push(e);
  const i = Mt(
    r.map((a) => [a, e[a]]),
    t,
    Cn,
  );
  return `${n}${o}${i ? ` { ${i} }` : ''}`;
}
s(hm, 'inspectObject2');
z(hm, 'inspectObject');
function gm([e, t], r) {
  return (
    (r.truncate -= 3),
    t
      ? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
      : `${r.stylize(String(e), 'yellow')}`
  );
}
s(gm, 'inspectAttribute');
z(gm, 'inspectAttribute');
function ri(e, t) {
  return Mt(
    e,
    t,
    bm,
    `
`,
  );
}
s(ri, 'inspectNodeCollection');
z(ri, 'inspectNodeCollection');
function bm(e, t) {
  switch (e.nodeType) {
    case 1:
      return Jl(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
s(bm, 'inspectNode');
z(bm, 'inspectNode');
function Jl(e, t) {
  const r = e.getAttributeNames(),
    n = e.tagName.toLowerCase(),
    o = t.stylize(`<${n}`, 'special'),
    i = t.stylize('>', 'special'),
    a = t.stylize(`</${n}>`, 'special');
  t.truncate -= n.length * 2 + 5;
  let l = '';
  (r.length > 0 &&
    ((l += ' '),
    (l += Mt(
      r.map((p) => [p, e.getAttribute(p)]),
      t,
      gm,
      ' ',
    ))),
    (t.truncate -= l.length));
  const d = t.truncate;
  let u = ri(e.children, t);
  return (u && u.length > d && (u = `${Ao}(${e.children.length})`), `${o}${l}${i}${u}${a}`);
}
s(Jl, 'inspectHTML');
z(Jl, 'inspectHTML');
var OB = typeof Symbol == 'function' && typeof Symbol.for == 'function',
  mu = OB ? Symbol.for('chai/inspect') : '@@chai/inspect',
  yu = Symbol.for('nodejs.util.inspect.custom'),
  nb = new WeakMap(),
  ob = {},
  sb = {
    undefined: z((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
    null: z((e, t) => t.stylize('null', 'null'), 'null'),
    boolean: z((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
    Boolean: z((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
    number: Ra,
    Number: Ra,
    bigint: Pa,
    BigInt: Pa,
    string: xa,
    String: xa,
    function: Aa,
    Function: Aa,
    symbol: Oa,
    Symbol: Oa,
    Array: sm,
    Date: im,
    Map: cm,
    Set: pm,
    RegExp: um,
    Promise: PB,
    WeakSet: z((e, t) => t.stylize('WeakSet{}', 'special'), 'WeakSet'),
    WeakMap: z((e, t) => t.stylize('WeakMap{}', 'special'), 'WeakMap'),
    Arguments: ym,
    Int8Array: Wt,
    Uint8Array: Wt,
    Uint8ClampedArray: Wt,
    Int16Array: Wt,
    Uint16Array: Wt,
    Int32Array: Wt,
    Uint32Array: Wt,
    Float32Array: Wt,
    Float64Array: Wt,
    Generator: z(() => '', 'Generator'),
    DataView: z(() => '', 'DataView'),
    ArrayBuffer: z(() => '', 'ArrayBuffer'),
    Error: hm,
    HTMLCollection: ri,
    NodeList: ri,
  },
  CB = z(
    (e, t, r) =>
      mu in e && typeof e[mu] == 'function'
        ? e[mu](t)
        : yu in e && typeof e[yu] == 'function'
          ? e[yu](t.depth, t)
          : 'inspect' in e && typeof e.inspect == 'function'
            ? e.inspect(t.depth, t)
            : 'constructor' in e && nb.has(e.constructor)
              ? nb.get(e.constructor)(e, t)
              : ob[r]
                ? ob[r](e, t)
                : '',
    'inspectCustom',
  ),
  IB = Object.prototype.toString;
function ni(e, t = {}) {
  const r = rm(t, ni),
    { customInspect: n } = r;
  let o = e === null ? 'null' : typeof e;
  if ((o === 'object' && (o = IB.call(e).slice(8, -1)), o in sb)) return sb[o](e, r);
  if (n && e) {
    const a = CB(e, r, o);
    if (a) return typeof a == 'string' ? a : ni(a, r);
  }
  const i = e ? Object.getPrototypeOf(e) : !1;
  return i === Object.prototype || i === null
    ? po(e, r)
    : e && typeof HTMLElement == 'function' && e instanceof HTMLElement
      ? Jl(e, r)
      : 'constructor' in e
        ? e.constructor !== Object
          ? mm(e, r)
          : po(e, r)
        : e === Object(e)
          ? po(e, r)
          : r.stylize(String(e), o);
}
s(ni, 'inspect');
z(ni, 'inspect');
var wt = {
  includeStack: !1,
  showDiff: !0,
  truncateThreshold: 40,
  useProxy: !0,
  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON'],
  deepEqual: null,
};
function Se(e, t, r, n) {
  let o = {
    colors: n,
    depth: typeof r > 'u' ? 2 : r,
    showHidden: t,
    truncate: wt.truncateThreshold ? wt.truncateThreshold : 1 / 0,
  };
  return ni(e, o);
}
s(Se, 'inspect2');
z(Se, 'inspect');
function Hr(e) {
  let t = Se(e),
    r = Object.prototype.toString.call(e);
  if (wt.truncateThreshold && t.length >= wt.truncateThreshold) {
    if (r === '[object Function]')
      return !e.name || e.name === '' ? '[Function]' : '[Function: ' + e.name + ']';
    if (r === '[object Array]') return '[ Array(' + e.length + ') ]';
    if (r === '[object Object]') {
      let n = Object.keys(e);
      return (
        '{ Object (' + (n.length > 2 ? n.splice(0, 2).join(', ') + ', ...' : n.join(', ')) + ') }'
      );
    } else return t;
  } else return t;
}
s(Hr, 'objDisplay');
z(Hr, 'objDisplay');
function Ul(e, t) {
  let r = me(e, 'negate'),
    n = me(e, 'object'),
    o = t[3],
    i = xi(e, t),
    a = r ? t[2] : t[1],
    l = me(e, 'message');
  return (
    typeof a == 'function' && (a = a()),
    (a = a || ''),
    (a = a
      .replace(/#\{this\}/g, function () {
        return Hr(n);
      })
      .replace(/#\{act\}/g, function () {
        return Hr(i);
      })
      .replace(/#\{exp\}/g, function () {
        return Hr(o);
      })),
    l ? l + ': ' + a : a
  );
}
s(Ul, 'getMessage2');
z(Ul, 'getMessage');
function Ht(e, t, r) {
  let n = e.__flags || (e.__flags = Object.create(null));
  (t.__flags || (t.__flags = Object.create(null)), (r = arguments.length === 3 ? r : !0));
  for (let o in n)
    (r || (o !== 'object' && o !== 'ssfi' && o !== 'lockSsfi' && o != 'message')) &&
      (t.__flags[o] = n[o]);
}
s(Ht, 'transferFlags');
z(Ht, 'transferFlags');
function Ca(e) {
  if (typeof e > 'u') return 'undefined';
  if (e === null) return 'null';
  const t = e[Symbol.toStringTag];
  return typeof t == 'string' ? t : Object.prototype.toString.call(e).slice(8, -1);
}
s(Ca, 'type2');
z(Ca, 'type');
function Vl() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}
s(Vl, 'FakeMap');
z(Vl, 'FakeMap');
Vl.prototype = {
  get: z(
    s(function (t) {
      return t[this._key];
    }, 'get'),
    'get',
  ),
  set: z(
    s(function (t, r) {
      Object.isExtensible(t) && Object.defineProperty(t, this._key, { value: r, configurable: !0 });
    }, 'set'),
    'set',
  ),
};
var k_ = typeof WeakMap == 'function' ? WeakMap : Vl;
function Ia(e, t, r) {
  if (!r || en(e) || en(t)) return null;
  var n = r.get(e);
  if (n) {
    var o = n.get(t);
    if (typeof o == 'boolean') return o;
  }
  return null;
}
s(Ia, 'memoizeCompare');
z(Ia, 'memoizeCompare');
function oo(e, t, r, n) {
  if (!(!r || en(e) || en(t))) {
    var o = r.get(e);
    o ? o.set(t, n) : ((o = new k_()), o.set(t, n), r.set(e, o));
  }
}
s(oo, 'memoizeSet');
z(oo, 'memoizeSet');
var D_ = Bo;
function Bo(e, t, r) {
  if (r && r.comparator) return Na(e, t, r);
  var n = Hl(e, t);
  return n !== null ? n : Na(e, t, r);
}
s(Bo, 'deepEqual');
z(Bo, 'deepEqual');
function Hl(e, t) {
  return e === t
    ? e !== 0 || 1 / e === 1 / t
    : e !== e && t !== t
      ? !0
      : en(e) || en(t)
        ? !1
        : null;
}
s(Hl, 'simpleEqual');
z(Hl, 'simpleEqual');
function Na(e, t, r) {
  ((r = r || {}), (r.memoize = r.memoize === !1 ? !1 : r.memoize || new k_()));
  var n = r && r.comparator,
    o = Ia(e, t, r.memoize);
  if (o !== null) return o;
  var i = Ia(t, e, r.memoize);
  if (i !== null) return i;
  if (n) {
    var a = n(e, t);
    if (a === !1 || a === !0) return (oo(e, t, r.memoize, a), a);
    var l = Hl(e, t);
    if (l !== null) return l;
  }
  var d = Ca(e);
  if (d !== Ca(t)) return (oo(e, t, r.memoize, !1), !1);
  oo(e, t, r.memoize, !0);
  var u = vm(e, t, d, r);
  return (oo(e, t, r.memoize, u), u);
}
s(Na, 'extensiveDeepEqual');
z(Na, 'extensiveDeepEqual');
function vm(e, t, r, n) {
  switch (r) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      return Bo(e.valueOf(), t.valueOf());
    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
      return e === t;
    case 'Error':
      return zl(e, t, ['name', 'message', 'code'], n);
    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return Ir(e, t, n);
    case 'RegExp':
      return Tm(e, t);
    case 'Generator':
      return Em(e, t, n);
    case 'DataView':
      return Ir(new Uint8Array(e.buffer), new Uint8Array(t.buffer), n);
    case 'ArrayBuffer':
      return Ir(new Uint8Array(e), new Uint8Array(t), n);
    case 'Set':
      return $a(e, t, n);
    case 'Map':
      return $a(e, t, n);
    case 'Temporal.PlainDate':
    case 'Temporal.PlainTime':
    case 'Temporal.PlainDateTime':
    case 'Temporal.Instant':
    case 'Temporal.ZonedDateTime':
    case 'Temporal.PlainYearMonth':
    case 'Temporal.PlainMonthDay':
      return e.equals(t);
    case 'Temporal.Duration':
      return e.total('nanoseconds') === t.total('nanoseconds');
    case 'Temporal.TimeZone':
    case 'Temporal.Calendar':
      return e.toString() === t.toString();
    default:
      return Sm(e, t, n);
  }
}
s(vm, 'extensiveDeepEqualByType');
z(vm, 'extensiveDeepEqualByType');
function Tm(e, t) {
  return e.toString() === t.toString();
}
s(Tm, 'regexpEqual');
z(Tm, 'regexpEqual');
function $a(e, t, r) {
  try {
    if (e.size !== t.size) return !1;
    if (e.size === 0) return !0;
  } catch {
    return !1;
  }
  var n = [],
    o = [];
  return (
    e.forEach(
      z(
        s(function (a, l) {
          n.push([a, l]);
        }, 'gatherEntries'),
        'gatherEntries',
      ),
    ),
    t.forEach(
      z(
        s(function (a, l) {
          o.push([a, l]);
        }, 'gatherEntries'),
        'gatherEntries',
      ),
    ),
    Ir(n.sort(), o.sort(), r)
  );
}
s($a, 'entriesEqual');
z($a, 'entriesEqual');
function Ir(e, t, r) {
  var n = e.length;
  if (n !== t.length) return !1;
  if (n === 0) return !0;
  for (var o = -1; ++o < n; ) if (Bo(e[o], t[o], r) === !1) return !1;
  return !0;
}
s(Ir, 'iterableEqual');
z(Ir, 'iterableEqual');
function Em(e, t, r) {
  return Ir(oi(e), oi(t), r);
}
s(Em, 'generatorEqual');
z(Em, 'generatorEqual');
function wm(e) {
  return (
    typeof Symbol < 'u' &&
    typeof e == 'object' &&
    typeof Symbol.iterator < 'u' &&
    typeof e[Symbol.iterator] == 'function'
  );
}
s(wm, 'hasIteratorFunction');
z(wm, 'hasIteratorFunction');
function qa(e) {
  if (wm(e))
    try {
      return oi(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
s(qa, 'getIteratorEntries');
z(qa, 'getIteratorEntries');
function oi(e) {
  for (var t = e.next(), r = [t.value]; t.done === !1; ) ((t = e.next()), r.push(t.value));
  return r;
}
s(oi, 'getGeneratorEntries');
z(oi, 'getGeneratorEntries');
function Ma(e) {
  var t = [];
  for (var r in e) t.push(r);
  return t;
}
s(Ma, 'getEnumerableKeys');
z(Ma, 'getEnumerableKeys');
function ja(e) {
  for (var t = [], r = Object.getOwnPropertySymbols(e), n = 0; n < r.length; n += 1) {
    var o = r[n];
    Object.getOwnPropertyDescriptor(e, o).enumerable && t.push(o);
  }
  return t;
}
s(ja, 'getEnumerableSymbols');
z(ja, 'getEnumerableSymbols');
function zl(e, t, r, n) {
  var o = r.length;
  if (o === 0) return !0;
  for (var i = 0; i < o; i += 1) if (Bo(e[r[i]], t[r[i]], n) === !1) return !1;
  return !0;
}
s(zl, 'keysEqual');
z(zl, 'keysEqual');
function Sm(e, t, r) {
  var n = Ma(e),
    o = Ma(t),
    i = ja(e),
    a = ja(t);
  if (((n = n.concat(i)), (o = o.concat(a)), n.length && n.length === o.length))
    return Ir(ka(n).sort(), ka(o).sort()) === !1 ? !1 : zl(e, t, n, r);
  var l = qa(e),
    d = qa(t);
  return l.length && l.length === d.length
    ? (l.sort(), d.sort(), Ir(l, d, r))
    : n.length === 0 && l.length === 0 && o.length === 0 && d.length === 0;
}
s(Sm, 'objectEqual');
z(Sm, 'objectEqual');
function en(e) {
  return e === null || typeof e != 'object';
}
s(en, 'isPrimitive');
z(en, 'isPrimitive');
function ka(e) {
  return e.map(
    z(
      s(function (r) {
        return typeof r == 'symbol' ? r.toString() : r;
      }, 'mapSymbol'),
      'mapSymbol',
    ),
  );
}
s(ka, 'mapSymbols');
z(ka, 'mapSymbols');
function Oi(e, t) {
  return typeof e > 'u' || e === null ? !1 : t in Object(e);
}
s(Oi, 'hasProperty');
z(Oi, 'hasProperty');
function _m(e) {
  return e
    .replace(/([^\\])\[/g, '$1.[')
    .match(/(\\\.|[^.]+?)+/g)
    .map((n) => {
      if (n === 'constructor' || n === '__proto__' || n === 'prototype') return {};
      const i = /^\[(\d+)\]$/.exec(n);
      let a = null;
      return (i ? (a = { i: parseFloat(i[1]) }) : (a = { p: n.replace(/\\([.[\]])/g, '$1') }), a);
    });
}
s(_m, 'parsePath');
z(_m, 'parsePath');
function Da(e, t, r) {
  let n = e,
    o = null;
  r = typeof r > 'u' ? t.length : r;
  for (let i = 0; i < r; i++) {
    const a = t[i];
    n && (typeof a.p > 'u' ? (n = n[a.i]) : (n = n[a.p]), i === r - 1 && (o = n));
  }
  return o;
}
s(Da, 'internalGetPathValue');
z(Da, 'internalGetPathValue');
function Gl(e, t) {
  const r = _m(t),
    n = r[r.length - 1],
    o = { parent: r.length > 1 ? Da(e, r, r.length - 1) : e, name: n.p || n.i, value: Da(e, r) };
  return ((o.exists = Oi(o.parent, o.name)), o);
}
s(Gl, 'getPathInfo');
z(Gl, 'getPathInfo');
var As,
  M =
    ((As = class {
      constructor(e, t, r, n) {
        Be(this, '__flags', {});
        return (
          me(this, 'ssfi', r || As),
          me(this, 'lockSsfi', n),
          me(this, 'object', e),
          me(this, 'message', t),
          me(this, 'eql', wt.deepEqual || D_),
          zn(this)
        );
      }
      static get includeStack() {
        return (
          console.warn(
            'Assertion.includeStack is deprecated, use chai.config.includeStack instead.',
          ),
          wt.includeStack
        );
      }
      static set includeStack(e) {
        (console.warn(
          'Assertion.includeStack is deprecated, use chai.config.includeStack instead.',
        ),
          (wt.includeStack = e));
      }
      static get showDiff() {
        return (
          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.'),
          wt.showDiff
        );
      }
      static set showDiff(e) {
        (console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.'),
          (wt.showDiff = e));
      }
      static addProperty(e, t) {
        Wl(this.prototype, e, t);
      }
      static addMethod(e, t) {
        Kl(this.prototype, e, t);
      }
      static addChainableMethod(e, t, r) {
        Ql(this.prototype, e, t, r);
      }
      static overwriteProperty(e, t) {
        Yl(this.prototype, e, t);
      }
      static overwriteMethod(e, t) {
        Xl(this.prototype, e, t);
      }
      static overwriteChainableMethod(e, t, r) {
        Zl(this.prototype, e, t, r);
      }
      assert(e, t, r, n, o, i) {
        const a = Bl(this, arguments);
        if (
          (i !== !1 && (i = !0),
          n === void 0 && o === void 0 && (i = !1),
          wt.showDiff !== !0 && (i = !1),
          !a)
        ) {
          t = Ul(this, arguments);
          const d = { actual: xi(this, arguments), expected: n, showDiff: i },
            u = rc(this, arguments);
          throw (
            u && (d.operator = u),
            new Re(t, d, wt.includeStack ? this.assert : me(this, 'ssfi'))
          );
        }
      }
      get _obj() {
        return me(this, 'object');
      }
      set _obj(e) {
        me(this, 'object', e);
      }
    }),
    s(As, '_Assertion'),
    z(As, 'Assertion'),
    As);
function Jo() {
  return wt.useProxy && typeof Proxy < 'u' && typeof Reflect < 'u';
}
s(Jo, 'isProxyEnabled');
z(Jo, 'isProxyEnabled');
function Wl(e, t, r) {
  ((r = r === void 0 ? function () {} : r),
    Object.defineProperty(e, t, {
      get: z(
        s(function n() {
          !Jo() && !me(this, 'lockSsfi') && me(this, 'ssfi', n);
          let o = r.call(this);
          if (o !== void 0) return o;
          let i = new M();
          return (Ht(this, i), i);
        }, 'propertyGetter'),
        'propertyGetter',
      ),
      configurable: !0,
    }));
}
s(Wl, 'addProperty');
z(Wl, 'addProperty');
var NB = Object.getOwnPropertyDescriptor(function () {}, 'length');
function Uo(e, t, r) {
  return (
    NB.configurable &&
      Object.defineProperty(e, 'length', {
        get: z(function () {
          throw Error(
            r
              ? 'Invalid Chai property: ' +
                  t +
                  '.length. Due to a compatibility issue, "length" cannot directly follow "' +
                  t +
                  '". Use "' +
                  t +
                  '.lengthOf" instead.'
              : 'Invalid Chai property: ' +
                  t +
                  '.length. See docs for proper usage of "' +
                  t +
                  '".',
          );
        }, 'get'),
      }),
    e
  );
}
s(Uo, 'addLengthGuard');
z(Uo, 'addLengthGuard');
function Am(e) {
  let t = Object.getOwnPropertyNames(e);
  function r(o) {
    t.indexOf(o) === -1 && t.push(o);
  }
  (s(r, 'addProperty2'), z(r, 'addProperty'));
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) (Object.getOwnPropertyNames(n).forEach(r), (n = Object.getPrototypeOf(n)));
  return t;
}
s(Am, 'getProperties');
z(Am, 'getProperties');
var ib = ['__flags', '__methods', '_obj', 'assert'];
function zn(e, t) {
  return Jo()
    ? new Proxy(e, {
        get: z(
          s(function r(n, o) {
            if (
              typeof o == 'string' &&
              wt.proxyExcludedKeys.indexOf(o) === -1 &&
              !Reflect.has(n, o)
            ) {
              if (t)
                throw Error(
                  'Invalid Chai property: ' +
                    t +
                    '.' +
                    o +
                    '. See docs for proper usage of "' +
                    t +
                    '".',
                );
              let i = null,
                a = 4;
              throw (
                Am(n).forEach(function (l) {
                  if (!Object.prototype.hasOwnProperty(l) && ib.indexOf(l) === -1) {
                    let d = Rm(o, l, a);
                    d < a && ((i = l), (a = d));
                  }
                }),
                Error(
                  i !== null
                    ? 'Invalid Chai property: ' + o + '. Did you mean "' + i + '"?'
                    : 'Invalid Chai property: ' + o,
                )
              );
            }
            return (
              ib.indexOf(o) === -1 && !me(n, 'lockSsfi') && me(n, 'ssfi', r),
              Reflect.get(n, o)
            );
          }, 'proxyGetter'),
          'proxyGetter',
        ),
      })
    : e;
}
s(zn, 'proxify');
z(zn, 'proxify');
function Rm(e, t, r) {
  if (Math.abs(e.length - t.length) >= r) return r;
  let n = [];
  for (let o = 0; o <= e.length; o++) ((n[o] = Array(t.length + 1).fill(0)), (n[o][0] = o));
  for (let o = 0; o < t.length; o++) n[0][o] = o;
  for (let o = 1; o <= e.length; o++) {
    let i = e.charCodeAt(o - 1);
    for (let a = 1; a <= t.length; a++) {
      if (Math.abs(o - a) >= r) {
        n[o][a] = r;
        continue;
      }
      n[o][a] = Math.min(
        n[o - 1][a] + 1,
        n[o][a - 1] + 1,
        n[o - 1][a - 1] + (i === t.charCodeAt(a - 1) ? 0 : 1),
      );
    }
  }
  return n[e.length][t.length];
}
s(Rm, 'stringDistanceCapped');
z(Rm, 'stringDistanceCapped');
function Kl(e, t, r) {
  let n = z(function () {
    me(this, 'lockSsfi') || me(this, 'ssfi', n);
    let o = r.apply(this, arguments);
    if (o !== void 0) return o;
    let i = new M();
    return (Ht(this, i), i);
  }, 'methodWrapper');
  (Uo(n, t, !1), (e[t] = zn(n, t)));
}
s(Kl, 'addMethod');
z(Kl, 'addMethod');
function Yl(e, t, r) {
  let n = Object.getOwnPropertyDescriptor(e, t),
    o = z(function () {}, '_super');
  (n && typeof n.get == 'function' && (o = n.get),
    Object.defineProperty(e, t, {
      get: z(
        s(function i() {
          !Jo() && !me(this, 'lockSsfi') && me(this, 'ssfi', i);
          let a = me(this, 'lockSsfi');
          me(this, 'lockSsfi', !0);
          let l = r(o).call(this);
          if ((me(this, 'lockSsfi', a), l !== void 0)) return l;
          let d = new M();
          return (Ht(this, d), d);
        }, 'overwritingPropertyGetter'),
        'overwritingPropertyGetter',
      ),
      configurable: !0,
    }));
}
s(Yl, 'overwriteProperty');
z(Yl, 'overwriteProperty');
function Xl(e, t, r) {
  let n = e[t],
    o = z(function () {
      throw new Error(t + ' is not a function');
    }, '_super');
  n && typeof n == 'function' && (o = n);
  let i = z(function () {
    me(this, 'lockSsfi') || me(this, 'ssfi', i);
    let a = me(this, 'lockSsfi');
    me(this, 'lockSsfi', !0);
    let l = r(o).apply(this, arguments);
    if ((me(this, 'lockSsfi', a), l !== void 0)) return l;
    let d = new M();
    return (Ht(this, d), d);
  }, 'overwritingMethodWrapper');
  (Uo(i, t, !1), (e[t] = zn(i, t)));
}
s(Xl, 'overwriteMethod');
z(Xl, 'overwriteMethod');
var $B = typeof Object.setPrototypeOf == 'function',
  ab = z(function () {}, 'testFn'),
  qB = Object.getOwnPropertyNames(ab).filter(function (e) {
    let t = Object.getOwnPropertyDescriptor(ab, e);
    return typeof t != 'object' ? !0 : !t.configurable;
  }),
  MB = Function.prototype.call,
  jB = Function.prototype.apply;
function Ql(e, t, r, n) {
  typeof n != 'function' && (n = z(function () {}, 'chainingBehavior'));
  let o = { method: r, chainingBehavior: n };
  (e.__methods || (e.__methods = {}),
    (e.__methods[t] = o),
    Object.defineProperty(e, t, {
      get: z(
        s(function () {
          o.chainingBehavior.call(this);
          let a = z(function () {
            me(this, 'lockSsfi') || me(this, 'ssfi', a);
            let l = o.method.apply(this, arguments);
            if (l !== void 0) return l;
            let d = new M();
            return (Ht(this, d), d);
          }, 'chainableMethodWrapper');
          if ((Uo(a, t, !0), $B)) {
            let l = Object.create(this);
            ((l.call = MB), (l.apply = jB), Object.setPrototypeOf(a, l));
          } else
            Object.getOwnPropertyNames(e).forEach(function (d) {
              if (qB.indexOf(d) !== -1) return;
              let u = Object.getOwnPropertyDescriptor(e, d);
              Object.defineProperty(a, d, u);
            });
          return (Ht(this, a), zn(a));
        }, 'chainableMethodGetter'),
        'chainableMethodGetter',
      ),
      configurable: !0,
    }));
}
s(Ql, 'addChainableMethod');
z(Ql, 'addChainableMethod');
function Zl(e, t, r, n) {
  let o = e.__methods[t],
    i = o.chainingBehavior;
  o.chainingBehavior = z(
    s(function () {
      let d = n(i).call(this);
      if (d !== void 0) return d;
      let u = new M();
      return (Ht(this, u), u);
    }, 'overwritingChainableMethodGetter'),
    'overwritingChainableMethodGetter',
  );
  let a = o.method;
  o.method = z(
    s(function () {
      let d = r(a).apply(this, arguments);
      if (d !== void 0) return d;
      let u = new M();
      return (Ht(this, u), u);
    }, 'overwritingChainableMethodWrapper'),
    'overwritingChainableMethodWrapper',
  );
}
s(Zl, 'overwriteChainableMethod');
z(Zl, 'overwriteChainableMethod');
function si(e, t) {
  return Se(e) < Se(t) ? -1 : 1;
}
s(si, 'compareByInspect');
z(si, 'compareByInspect');
function ec(e) {
  return typeof Object.getOwnPropertySymbols != 'function'
    ? []
    : Object.getOwnPropertySymbols(e).filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable;
      });
}
s(ec, 'getOwnEnumerablePropertySymbols');
z(ec, 'getOwnEnumerablePropertySymbols');
function tc(e) {
  return Object.keys(e).concat(ec(e));
}
s(tc, 'getOwnEnumerableProperties');
z(tc, 'getOwnEnumerableProperties');
var La = Number.isNaN;
function Pm(e) {
  let t = Ce(e);
  return ['Array', 'Object', 'Function'].indexOf(t) !== -1;
}
s(Pm, 'isObjectType');
z(Pm, 'isObjectType');
function rc(e, t) {
  let r = me(e, 'operator'),
    n = me(e, 'negate'),
    o = t[3],
    i = n ? t[2] : t[1];
  if (r) return r;
  if ((typeof i == 'function' && (i = i()), (i = i || ''), !i || /\shave\s/.test(i))) return;
  let a = Pm(o);
  return /\snot\s/.test(i)
    ? a
      ? 'notDeepStrictEqual'
      : 'notStrictEqual'
    : a
      ? 'deepStrictEqual'
      : 'strictEqual';
}
s(rc, 'getOperator');
z(rc, 'getOperator');
function Ci(e) {
  return e.name;
}
s(Ci, 'getName');
z(Ci, 'getName');
function ii(e) {
  return Object.prototype.toString.call(e) === '[object RegExp]';
}
s(ii, 'isRegExp2');
z(ii, 'isRegExp');
function ot(e) {
  return ['Number', 'BigInt'].includes(Ce(e));
}
s(ot, 'isNumeric');
z(ot, 'isNumeric');
var { flag: U } = sr;
[
  'to',
  'be',
  'been',
  'is',
  'and',
  'has',
  'have',
  'with',
  'that',
  'which',
  'at',
  'of',
  'same',
  'but',
  'does',
  'still',
  'also',
].forEach(function (e) {
  M.addProperty(e);
});
M.addProperty('not', function () {
  U(this, 'negate', !0);
});
M.addProperty('deep', function () {
  U(this, 'deep', !0);
});
M.addProperty('nested', function () {
  U(this, 'nested', !0);
});
M.addProperty('own', function () {
  U(this, 'own', !0);
});
M.addProperty('ordered', function () {
  U(this, 'ordered', !0);
});
M.addProperty('any', function () {
  (U(this, 'any', !0), U(this, 'all', !1));
});
M.addProperty('all', function () {
  (U(this, 'all', !0), U(this, 'any', !1));
});
var lb = {
  function: ['function', 'asyncfunction', 'generatorfunction', 'asyncgeneratorfunction'],
  asyncfunction: ['asyncfunction', 'asyncgeneratorfunction'],
  generatorfunction: ['generatorfunction', 'asyncgeneratorfunction'],
  asyncgeneratorfunction: ['asyncgeneratorfunction'],
};
function nc(e, t) {
  (t && U(this, 'message', t), (e = e.toLowerCase()));
  let r = U(this, 'object'),
    n = ~['a', 'e', 'i', 'o', 'u'].indexOf(e.charAt(0)) ? 'an ' : 'a ';
  const o = Ce(r).toLowerCase();
  lb.function.includes(e)
    ? this.assert(
        lb[e].includes(o),
        'expected #{this} to be ' + n + e,
        'expected #{this} not to be ' + n + e,
      )
    : this.assert(
        e === o,
        'expected #{this} to be ' + n + e,
        'expected #{this} not to be ' + n + e,
      );
}
s(nc, 'an');
z(nc, 'an');
M.addChainableMethod('an', nc);
M.addChainableMethod('a', nc);
function xm(e, t) {
  return (La(e) && La(t)) || e === t;
}
s(xm, 'SameValueZero');
z(xm, 'SameValueZero');
function Vo() {
  U(this, 'contains', !0);
}
s(Vo, 'includeChainingBehavior');
z(Vo, 'includeChainingBehavior');
function Ho(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = Ce(r).toLowerCase(),
    o = U(this, 'message'),
    i = U(this, 'negate'),
    a = U(this, 'ssfi'),
    l = U(this, 'deep'),
    d = l ? 'deep ' : '',
    u = l ? U(this, 'eql') : xm;
  o = o ? o + ': ' : '';
  let p = !1;
  switch (n) {
    case 'string':
      p = r.indexOf(e) !== -1;
      break;
    case 'weakset':
      if (l) throw new Re(o + 'unable to use .deep.include with WeakSet', void 0, a);
      p = r.has(e);
      break;
    case 'map':
      r.forEach(function (f) {
        p = p || u(f, e);
      });
      break;
    case 'set':
      l
        ? r.forEach(function (f) {
            p = p || u(f, e);
          })
        : (p = r.has(e));
      break;
    case 'array':
      l
        ? (p = r.some(function (f) {
            return u(f, e);
          }))
        : (p = r.indexOf(e) !== -1);
      break;
    default: {
      if (e !== Object(e))
        throw new Re(
          o +
            'the given combination of arguments (' +
            n +
            ' and ' +
            Ce(e).toLowerCase() +
            ') is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a ' +
            Ce(e).toLowerCase(),
          void 0,
          a,
        );
      let f = Object.keys(e),
        m = null,
        h = 0;
      if (
        (f.forEach(function (g) {
          let v = new M(r);
          if ((Ht(this, v, !0), U(v, 'lockSsfi', !0), !i || f.length === 1)) {
            v.property(g, e[g]);
            return;
          }
          try {
            v.property(g, e[g]);
          } catch (E) {
            if (!Ct.compatibleConstructor(E, Re)) throw E;
            (m === null && (m = E), h++);
          }
        }, this),
        i && f.length > 1 && h === f.length)
      )
        throw m;
      return;
    }
  }
  this.assert(
    p,
    'expected #{this} to ' + d + 'include ' + Se(e),
    'expected #{this} to not ' + d + 'include ' + Se(e),
  );
}
s(Ho, 'include');
z(Ho, 'include');
M.addChainableMethod('include', Ho, Vo);
M.addChainableMethod('contain', Ho, Vo);
M.addChainableMethod('contains', Ho, Vo);
M.addChainableMethod('includes', Ho, Vo);
M.addProperty('ok', function () {
  this.assert(U(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
});
M.addProperty('true', function () {
  this.assert(
    U(this, 'object') === !0,
    'expected #{this} to be true',
    'expected #{this} to be false',
    !U(this, 'negate'),
  );
});
M.addProperty('numeric', function () {
  const e = U(this, 'object');
  this.assert(
    ['Number', 'BigInt'].includes(Ce(e)),
    'expected #{this} to be numeric',
    'expected #{this} to not be numeric',
    !U(this, 'negate'),
  );
});
M.addProperty('callable', function () {
  const e = U(this, 'object'),
    t = U(this, 'ssfi'),
    r = U(this, 'message'),
    n = r ? `${r}: ` : '',
    o = U(this, 'negate'),
    i = o
      ? `${n}expected ${Se(e)} not to be a callable function`
      : `${n}expected ${Se(e)} to be a callable function`,
    a = ['Function', 'AsyncFunction', 'GeneratorFunction', 'AsyncGeneratorFunction'].includes(
      Ce(e),
    );
  if ((a && o) || (!a && !o)) throw new Re(i, void 0, t);
});
M.addProperty('false', function () {
  this.assert(
    U(this, 'object') === !1,
    'expected #{this} to be false',
    'expected #{this} to be true',
    !!U(this, 'negate'),
  );
});
M.addProperty('null', function () {
  this.assert(
    U(this, 'object') === null,
    'expected #{this} to be null',
    'expected #{this} not to be null',
  );
});
M.addProperty('undefined', function () {
  this.assert(
    U(this, 'object') === void 0,
    'expected #{this} to be undefined',
    'expected #{this} not to be undefined',
  );
});
M.addProperty('NaN', function () {
  this.assert(
    La(U(this, 'object')),
    'expected #{this} to be NaN',
    'expected #{this} not to be NaN',
  );
});
function oc() {
  let e = U(this, 'object');
  this.assert(e != null, 'expected #{this} to exist', 'expected #{this} to not exist');
}
s(oc, 'assertExist');
z(oc, 'assertExist');
M.addProperty('exist', oc);
M.addProperty('exists', oc);
M.addProperty('empty', function () {
  let e = U(this, 'object'),
    t = U(this, 'ssfi'),
    r = U(this, 'message'),
    n;
  switch (((r = r ? r + ': ' : ''), Ce(e).toLowerCase())) {
    case 'array':
    case 'string':
      n = e.length;
      break;
    case 'map':
    case 'set':
      n = e.size;
      break;
    case 'weakmap':
    case 'weakset':
      throw new Re(r + '.empty was passed a weak collection', void 0, t);
    case 'function': {
      const o = r + '.empty was passed a function ' + Ci(e);
      throw new Re(o.trim(), void 0, t);
    }
    default:
      if (e !== Object(e))
        throw new Re(r + '.empty was passed non-string primitive ' + Se(e), void 0, t);
      n = Object.keys(e).length;
  }
  this.assert(n === 0, 'expected #{this} to be empty', 'expected #{this} not to be empty');
});
function sc() {
  let e = U(this, 'object'),
    t = Ce(e);
  this.assert(
    t === 'Arguments',
    'expected #{this} to be arguments but got ' + t,
    'expected #{this} to not be arguments',
  );
}
s(sc, 'checkArguments');
z(sc, 'checkArguments');
M.addProperty('arguments', sc);
M.addProperty('Arguments', sc);
function Ii(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object');
  if (U(this, 'deep')) {
    let n = U(this, 'lockSsfi');
    (U(this, 'lockSsfi', !0), this.eql(e), U(this, 'lockSsfi', n));
  } else
    this.assert(
      e === r,
      'expected #{this} to equal #{exp}',
      'expected #{this} to not equal #{exp}',
      e,
      this._obj,
      !0,
    );
}
s(Ii, 'assertEqual');
z(Ii, 'assertEqual');
M.addMethod('equal', Ii);
M.addMethod('equals', Ii);
M.addMethod('eq', Ii);
function ic(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'eql');
  this.assert(
    r(e, U(this, 'object')),
    'expected #{this} to deeply equal #{exp}',
    'expected #{this} to not deeply equal #{exp}',
    e,
    this._obj,
    !0,
  );
}
s(ic, 'assertEql');
z(ic, 'assertEql');
M.addMethod('eql', ic);
M.addMethod('eqls', ic);
function Ni(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    o = U(this, 'message'),
    i = o ? o + ': ' : '',
    a = U(this, 'ssfi'),
    l = Ce(r).toLowerCase(),
    d = Ce(e).toLowerCase();
  if (
    (n && l !== 'map' && l !== 'set' && new M(r, o, a, !0).to.have.property('length'),
    !n && l === 'date' && d !== 'date')
  )
    throw new Re(i + 'the argument to above must be a date', void 0, a);
  if (!ot(e) && (n || ot(r))) throw new Re(i + 'the argument to above must be a number', void 0, a);
  if (!n && l !== 'date' && !ot(r)) {
    let u = l === 'string' ? "'" + r + "'" : r;
    throw new Re(i + 'expected ' + u + ' to be a number or a date', void 0, a);
  }
  if (n) {
    let u = 'length',
      p;
    (l === 'map' || l === 'set' ? ((u = 'size'), (p = r.size)) : (p = r.length),
      this.assert(
        p > e,
        'expected #{this} to have a ' + u + ' above #{exp} but got #{act}',
        'expected #{this} to not have a ' + u + ' above #{exp}',
        e,
        p,
      ));
  } else
    this.assert(
      r > e,
      'expected #{this} to be above #{exp}',
      'expected #{this} to be at most #{exp}',
      e,
    );
}
s(Ni, 'assertAbove');
z(Ni, 'assertAbove');
M.addMethod('above', Ni);
M.addMethod('gt', Ni);
M.addMethod('greaterThan', Ni);
function $i(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    o = U(this, 'message'),
    i = o ? o + ': ' : '',
    a = U(this, 'ssfi'),
    l = Ce(r).toLowerCase(),
    d = Ce(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && l !== 'map' && l !== 'set' && new M(r, o, a, !0).to.have.property('length'),
    !n && l === 'date' && d !== 'date')
  )
    u = i + 'the argument to least must be a date';
  else if (!ot(e) && (n || ot(r))) u = i + 'the argument to least must be a number';
  else if (!n && l !== 'date' && !ot(r)) {
    let f = l === 'string' ? "'" + r + "'" : r;
    u = i + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Re(u, void 0, a);
  if (n) {
    let f = 'length',
      m;
    (l === 'map' || l === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
      this.assert(
        m >= e,
        'expected #{this} to have a ' + f + ' at least #{exp} but got #{act}',
        'expected #{this} to have a ' + f + ' below #{exp}',
        e,
        m,
      ));
  } else
    this.assert(
      r >= e,
      'expected #{this} to be at least #{exp}',
      'expected #{this} to be below #{exp}',
      e,
    );
}
s($i, 'assertLeast');
z($i, 'assertLeast');
M.addMethod('least', $i);
M.addMethod('gte', $i);
M.addMethod('greaterThanOrEqual', $i);
function qi(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    o = U(this, 'message'),
    i = o ? o + ': ' : '',
    a = U(this, 'ssfi'),
    l = Ce(r).toLowerCase(),
    d = Ce(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && l !== 'map' && l !== 'set' && new M(r, o, a, !0).to.have.property('length'),
    !n && l === 'date' && d !== 'date')
  )
    u = i + 'the argument to below must be a date';
  else if (!ot(e) && (n || ot(r))) u = i + 'the argument to below must be a number';
  else if (!n && l !== 'date' && !ot(r)) {
    let f = l === 'string' ? "'" + r + "'" : r;
    u = i + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Re(u, void 0, a);
  if (n) {
    let f = 'length',
      m;
    (l === 'map' || l === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
      this.assert(
        m < e,
        'expected #{this} to have a ' + f + ' below #{exp} but got #{act}',
        'expected #{this} to not have a ' + f + ' below #{exp}',
        e,
        m,
      ));
  } else
    this.assert(
      r < e,
      'expected #{this} to be below #{exp}',
      'expected #{this} to be at least #{exp}',
      e,
    );
}
s(qi, 'assertBelow');
z(qi, 'assertBelow');
M.addMethod('below', qi);
M.addMethod('lt', qi);
M.addMethod('lessThan', qi);
function Mi(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    o = U(this, 'message'),
    i = o ? o + ': ' : '',
    a = U(this, 'ssfi'),
    l = Ce(r).toLowerCase(),
    d = Ce(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && l !== 'map' && l !== 'set' && new M(r, o, a, !0).to.have.property('length'),
    !n && l === 'date' && d !== 'date')
  )
    u = i + 'the argument to most must be a date';
  else if (!ot(e) && (n || ot(r))) u = i + 'the argument to most must be a number';
  else if (!n && l !== 'date' && !ot(r)) {
    let f = l === 'string' ? "'" + r + "'" : r;
    u = i + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Re(u, void 0, a);
  if (n) {
    let f = 'length',
      m;
    (l === 'map' || l === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
      this.assert(
        m <= e,
        'expected #{this} to have a ' + f + ' at most #{exp} but got #{act}',
        'expected #{this} to have a ' + f + ' above #{exp}',
        e,
        m,
      ));
  } else
    this.assert(
      r <= e,
      'expected #{this} to be at most #{exp}',
      'expected #{this} to be above #{exp}',
      e,
    );
}
s(Mi, 'assertMost');
z(Mi, 'assertMost');
M.addMethod('most', Mi);
M.addMethod('lte', Mi);
M.addMethod('lessThanOrEqual', Mi);
M.addMethod('within', function (e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'doLength'),
    i = U(this, 'message'),
    a = i ? i + ': ' : '',
    l = U(this, 'ssfi'),
    d = Ce(n).toLowerCase(),
    u = Ce(e).toLowerCase(),
    p = Ce(t).toLowerCase(),
    f,
    m = !0,
    h = u === 'date' && p === 'date' ? e.toISOString() + '..' + t.toISOString() : e + '..' + t;
  if (
    (o && d !== 'map' && d !== 'set' && new M(n, i, l, !0).to.have.property('length'),
    !o && d === 'date' && (u !== 'date' || p !== 'date'))
  )
    f = a + 'the arguments to within must be dates';
  else if ((!ot(e) || !ot(t)) && (o || ot(n))) f = a + 'the arguments to within must be numbers';
  else if (!o && d !== 'date' && !ot(n)) {
    let g = d === 'string' ? "'" + n + "'" : n;
    f = a + 'expected ' + g + ' to be a number or a date';
  } else m = !1;
  if (m) throw new Re(f, void 0, l);
  if (o) {
    let g = 'length',
      v;
    (d === 'map' || d === 'set' ? ((g = 'size'), (v = n.size)) : (v = n.length),
      this.assert(
        v >= e && v <= t,
        'expected #{this} to have a ' + g + ' within ' + h,
        'expected #{this} to not have a ' + g + ' within ' + h,
      ));
  } else
    this.assert(
      n >= e && n <= t,
      'expected #{this} to be within ' + h,
      'expected #{this} to not be within ' + h,
    );
});
function ac(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'ssfi'),
    o = U(this, 'message'),
    i;
  try {
    i = r instanceof e;
  } catch (l) {
    throw l instanceof TypeError
      ? ((o = o ? o + ': ' : ''),
        new Re(
          o + 'The instanceof assertion needs a constructor but ' + Ce(e) + ' was given.',
          void 0,
          n,
        ))
      : l;
  }
  let a = Ci(e);
  (a == null && (a = 'an unnamed constructor'),
    this.assert(
      i,
      'expected #{this} to be an instance of ' + a,
      'expected #{this} to not be an instance of ' + a,
    ));
}
s(ac, 'assertInstanceOf');
z(ac, 'assertInstanceOf');
M.addMethod('instanceof', ac);
M.addMethod('instanceOf', ac);
function lc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'nested'),
    o = U(this, 'own'),
    i = U(this, 'message'),
    a = U(this, 'object'),
    l = U(this, 'ssfi'),
    d = typeof e;
  if (((i = i ? i + ': ' : ''), n)) {
    if (d !== 'string')
      throw new Re(
        i + 'the argument to property must be a string when using nested syntax',
        void 0,
        l,
      );
  } else if (d !== 'string' && d !== 'number' && d !== 'symbol')
    throw new Re(i + 'the argument to property must be a string, number, or symbol', void 0, l);
  if (n && o) throw new Re(i + 'The "nested" and "own" flags cannot be combined.', void 0, l);
  if (a == null) throw new Re(i + 'Target cannot be null or undefined.', void 0, l);
  let u = U(this, 'deep'),
    p = U(this, 'negate'),
    f = n ? Gl(a, e) : null,
    m = n ? f.value : a[e],
    h = u ? U(this, 'eql') : (E, b) => E === b,
    g = '';
  (u && (g += 'deep '), o && (g += 'own '), n && (g += 'nested '), (g += 'property '));
  let v;
  (o ? (v = Object.prototype.hasOwnProperty.call(a, e)) : n ? (v = f.exists) : (v = Oi(a, e)),
    (!p || arguments.length === 1) &&
      this.assert(
        v,
        'expected #{this} to have ' + g + Se(e),
        'expected #{this} to not have ' + g + Se(e),
      ),
    arguments.length > 1 &&
      this.assert(
        v && h(t, m),
        'expected #{this} to have ' + g + Se(e) + ' of #{exp}, but got #{act}',
        'expected #{this} to not have ' + g + Se(e) + ' of #{act}',
        t,
        m,
      ),
    U(this, 'object', m));
}
s(lc, 'assertProperty');
z(lc, 'assertProperty');
M.addMethod('property', lc);
function cc(e, t, r) {
  (U(this, 'own', !0), lc.apply(this, arguments));
}
s(cc, 'assertOwnProperty');
z(cc, 'assertOwnProperty');
M.addMethod('ownProperty', cc);
M.addMethod('haveOwnProperty', cc);
function uc(e, t, r) {
  (typeof t == 'string' && ((r = t), (t = null)), r && U(this, 'message', r));
  let n = U(this, 'object'),
    o = Object.getOwnPropertyDescriptor(Object(n), e),
    i = U(this, 'eql');
  (o && t
    ? this.assert(
        i(t, o),
        'expected the own property descriptor for ' +
          Se(e) +
          ' on #{this} to match ' +
          Se(t) +
          ', got ' +
          Se(o),
        'expected the own property descriptor for ' + Se(e) + ' on #{this} to not match ' + Se(t),
        t,
        o,
        !0,
      )
    : this.assert(
        o,
        'expected #{this} to have an own property descriptor for ' + Se(e),
        'expected #{this} to not have an own property descriptor for ' + Se(e),
      ),
    U(this, 'object', o));
}
s(uc, 'assertOwnPropertyDescriptor');
z(uc, 'assertOwnPropertyDescriptor');
M.addMethod('ownPropertyDescriptor', uc);
M.addMethod('haveOwnPropertyDescriptor', uc);
function dc() {
  U(this, 'doLength', !0);
}
s(dc, 'assertLengthChain');
z(dc, 'assertLengthChain');
function pc(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = Ce(r).toLowerCase(),
    o = U(this, 'message'),
    i = U(this, 'ssfi'),
    a = 'length',
    l;
  switch (n) {
    case 'map':
    case 'set':
      ((a = 'size'), (l = r.size));
      break;
    default:
      (new M(r, o, i, !0).to.have.property('length'), (l = r.length));
  }
  this.assert(
    l == e,
    'expected #{this} to have a ' + a + ' of #{exp} but got #{act}',
    'expected #{this} to not have a ' + a + ' of #{act}',
    e,
    l,
  );
}
s(pc, 'assertLength');
z(pc, 'assertLength');
M.addChainableMethod('length', pc, dc);
M.addChainableMethod('lengthOf', pc, dc);
function fc(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object');
  this.assert(e.exec(r), 'expected #{this} to match ' + e, 'expected #{this} not to match ' + e);
}
s(fc, 'assertMatch');
z(fc, 'assertMatch');
M.addMethod('match', fc);
M.addMethod('matches', fc);
M.addMethod('string', function (e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    o = U(this, 'ssfi');
  (new M(r, n, o, !0).is.a('string'),
    this.assert(
      ~r.indexOf(e),
      'expected #{this} to contain ' + Se(e),
      'expected #{this} to not contain ' + Se(e),
    ));
});
function mc(e) {
  let t = U(this, 'object'),
    r = Ce(t),
    n = Ce(e),
    o = U(this, 'ssfi'),
    i = U(this, 'deep'),
    a,
    l = '',
    d,
    u = !0,
    p = U(this, 'message');
  p = p ? p + ': ' : '';
  let f =
    p +
    'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';
  if (r === 'Map' || r === 'Set')
    ((l = i ? 'deeply ' : ''),
      (d = []),
      t.forEach(function (b, S) {
        d.push(S);
      }),
      n !== 'Array' && (e = Array.prototype.slice.call(arguments)));
  else {
    switch (((d = tc(t)), n)) {
      case 'Array':
        if (arguments.length > 1) throw new Re(f, void 0, o);
        break;
      case 'Object':
        if (arguments.length > 1) throw new Re(f, void 0, o);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function (b) {
      return typeof b == 'symbol' ? b : String(b);
    });
  }
  if (!e.length) throw new Re(p + 'keys required', void 0, o);
  let m = e.length,
    h = U(this, 'any'),
    g = U(this, 'all'),
    v = e,
    E = i ? U(this, 'eql') : (b, S) => b === S;
  if (
    (!h && !g && (g = !0),
    h &&
      (u = v.some(function (b) {
        return d.some(function (S) {
          return E(b, S);
        });
      })),
    g &&
      ((u = v.every(function (b) {
        return d.some(function (S) {
          return E(b, S);
        });
      })),
      U(this, 'contains') || (u = u && e.length == d.length)),
    m > 1)
  ) {
    e = e.map(function (S) {
      return Se(S);
    });
    let b = e.pop();
    (g && (a = e.join(', ') + ', and ' + b), h && (a = e.join(', ') + ', or ' + b));
  } else a = Se(e[0]);
  ((a = (m > 1 ? 'keys ' : 'key ') + a),
    (a = (U(this, 'contains') ? 'contain ' : 'have ') + a),
    this.assert(
      u,
      'expected #{this} to ' + l + a,
      'expected #{this} to not ' + l + a,
      v.slice(0).sort(si),
      d.sort(si),
      !0,
    ));
}
s(mc, 'assertKeys');
z(mc, 'assertKeys');
M.addMethod('keys', mc);
M.addMethod('key', mc);
function ji(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'ssfi'),
    i = U(this, 'message'),
    a = U(this, 'negate') || !1;
  (new M(n, i, o, !0).is.a('function'), (ii(e) || typeof e == 'string') && ((t = e), (e = null)));
  let l,
    d = !1;
  try {
    n();
  } catch (h) {
    ((d = !0), (l = h));
  }
  let u = e === void 0 && t === void 0,
    p = !!(e && t),
    f = !1,
    m = !1;
  if (u || (!u && !a)) {
    let h = 'an error';
    e instanceof Error ? (h = '#{exp}') : e && (h = Ct.getConstructorName(e));
    let g = l;
    if (l instanceof Error) g = l.toString();
    else if (typeof l == 'string') g = l;
    else if (l && (typeof l == 'object' || typeof l == 'function'))
      try {
        g = Ct.getConstructorName(l);
      } catch {}
    this.assert(
      d,
      'expected #{this} to throw ' + h,
      'expected #{this} to not throw an error but #{act} was thrown',
      e && e.toString(),
      g,
    );
  }
  if (
    (e &&
      l &&
      (e instanceof Error &&
        Ct.compatibleInstance(l, e) === a &&
        (p && a
          ? (f = !0)
          : this.assert(
              a,
              'expected #{this} to throw #{exp} but #{act} was thrown',
              'expected #{this} to not throw #{exp}' + (l && !a ? ' but #{act} was thrown' : ''),
              e.toString(),
              l.toString(),
            )),
      Ct.compatibleConstructor(l, e) === a &&
        (p && a
          ? (f = !0)
          : this.assert(
              a,
              'expected #{this} to throw #{exp} but #{act} was thrown',
              'expected #{this} to not throw #{exp}' + (l ? ' but #{act} was thrown' : ''),
              e instanceof Error ? e.toString() : e && Ct.getConstructorName(e),
              l instanceof Error ? l.toString() : l && Ct.getConstructorName(l),
            ))),
    l && t !== void 0 && t !== null)
  ) {
    let h = 'including';
    (ii(t) && (h = 'matching'),
      Ct.compatibleMessage(l, t) === a &&
        (p && a
          ? (m = !0)
          : this.assert(
              a,
              'expected #{this} to throw error ' + h + ' #{exp} but got #{act}',
              'expected #{this} to throw error not ' + h + ' #{exp}',
              t,
              Ct.getMessage(l),
            )));
  }
  (f &&
    m &&
    this.assert(
      a,
      'expected #{this} to throw #{exp} but #{act} was thrown',
      'expected #{this} to not throw #{exp}' + (l ? ' but #{act} was thrown' : ''),
      e instanceof Error ? e.toString() : e && Ct.getConstructorName(e),
      l instanceof Error ? l.toString() : l && Ct.getConstructorName(l),
    ),
    U(this, 'object', l));
}
s(ji, 'assertThrows');
z(ji, 'assertThrows');
M.addMethod('throw', ji);
M.addMethod('throws', ji);
M.addMethod('Throw', ji);
function yc(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'itself'),
    o = typeof r == 'function' && !n ? r.prototype[e] : r[e];
  this.assert(
    typeof o == 'function',
    'expected #{this} to respond to ' + Se(e),
    'expected #{this} to not respond to ' + Se(e),
  );
}
s(yc, 'respondTo');
z(yc, 'respondTo');
M.addMethod('respondTo', yc);
M.addMethod('respondsTo', yc);
M.addProperty('itself', function () {
  U(this, 'itself', !0);
});
function hc(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = e(r);
  this.assert(
    n,
    'expected #{this} to satisfy ' + Hr(e),
    'expected #{this} to not satisfy' + Hr(e),
    !U(this, 'negate'),
    n,
  );
}
s(hc, 'satisfy');
z(hc, 'satisfy');
M.addMethod('satisfy', hc);
M.addMethod('satisfies', hc);
function gc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'message'),
    i = U(this, 'ssfi');
  new M(n, o, i, !0).is.numeric;
  let a = 'A `delta` value is required for `closeTo`';
  if (t == null) throw new Re(o ? `${o}: ${a}` : a, void 0, i);
  if (
    (new M(t, o, i, !0).is.numeric, (a = 'A `expected` value is required for `closeTo`'), e == null)
  )
    throw new Re(o ? `${o}: ${a}` : a, void 0, i);
  new M(e, o, i, !0).is.numeric;
  const l = z((u) => (u < 0n ? -u : u), 'abs'),
    d = z((u) => parseFloat(parseFloat(u).toPrecision(12)), 'strip');
  this.assert(
    d(l(n - e)) <= t,
    'expected #{this} to be close to ' + e + ' +/- ' + t,
    'expected #{this} not to be close to ' + e + ' +/- ' + t,
  );
}
s(gc, 'closeTo');
z(gc, 'closeTo');
M.addMethod('closeTo', gc);
M.addMethod('approximately', gc);
function Om(e, t, r, n, o) {
  let i = Array.from(t),
    a = Array.from(e);
  if (!n) {
    if (a.length !== i.length) return !1;
    i = i.slice();
  }
  return a.every(function (l, d) {
    if (o) return r ? r(l, i[d]) : l === i[d];
    if (!r) {
      let u = i.indexOf(l);
      return u === -1 ? !1 : (n || i.splice(u, 1), !0);
    }
    return i.some(function (u, p) {
      return r(l, u) ? (n || i.splice(p, 1), !0) : !1;
    });
  });
}
s(Om, 'isSubsetOf');
z(Om, 'isSubsetOf');
M.addMethod('members', function (e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    o = U(this, 'ssfi');
  (new M(r, n, o, !0).to.be.iterable, new M(e, n, o, !0).to.be.iterable);
  let i = U(this, 'contains'),
    a = U(this, 'ordered'),
    l,
    d,
    u;
  i
    ? ((l = a ? 'an ordered superset' : 'a superset'),
      (d = 'expected #{this} to be ' + l + ' of #{exp}'),
      (u = 'expected #{this} to not be ' + l + ' of #{exp}'))
    : ((l = a ? 'ordered members' : 'members'),
      (d = 'expected #{this} to have the same ' + l + ' as #{exp}'),
      (u = 'expected #{this} to not have the same ' + l + ' as #{exp}'));
  let p = U(this, 'deep') ? U(this, 'eql') : void 0;
  this.assert(Om(e, r, p, i, a), d, u, e, r, !0);
});
M.addProperty('iterable', function (e) {
  e && U(this, 'message', e);
  let t = U(this, 'object');
  this.assert(
    t != null && t[Symbol.iterator],
    'expected #{this} to be an iterable',
    'expected #{this} to not be an iterable',
    t,
  );
});
function Cm(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    o = U(this, 'ssfi'),
    i = U(this, 'contains'),
    a = U(this, 'deep'),
    l = U(this, 'eql');
  (new M(e, n, o, !0).to.be.an('array'),
    i
      ? this.assert(
          e.some(function (d) {
            return r.indexOf(d) > -1;
          }),
          'expected #{this} to contain one of #{exp}',
          'expected #{this} to not contain one of #{exp}',
          e,
          r,
        )
      : a
        ? this.assert(
            e.some(function (d) {
              return l(r, d);
            }),
            'expected #{this} to deeply equal one of #{exp}',
            'expected #{this} to deeply equal one of #{exp}',
            e,
            r,
          )
        : this.assert(
            e.indexOf(r) > -1,
            'expected #{this} to be one of #{exp}',
            'expected #{this} to not be one of #{exp}',
            e,
            r,
          ));
}
s(Cm, 'oneOf');
z(Cm, 'oneOf');
M.addMethod('oneOf', Cm);
function bc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'message'),
    i = U(this, 'ssfi');
  new M(n, o, i, !0).is.a('function');
  let a;
  (t
    ? (new M(e, o, i, !0).to.have.property(t), (a = e[t]))
    : (new M(e, o, i, !0).is.a('function'), (a = e())),
    n());
  let l = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', l),
    U(this, 'deltaBehavior', 'change'),
    U(this, 'realDelta', l !== a),
    this.assert(a !== l, 'expected ' + d + ' to change', 'expected ' + d + ' to not change'));
}
s(bc, 'assertChanges');
z(bc, 'assertChanges');
M.addMethod('change', bc);
M.addMethod('changes', bc);
function vc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'message'),
    i = U(this, 'ssfi');
  new M(n, o, i, !0).is.a('function');
  let a;
  (t
    ? (new M(e, o, i, !0).to.have.property(t), (a = e[t]))
    : (new M(e, o, i, !0).is.a('function'), (a = e())),
    new M(a, o, i, !0).is.a('number'),
    n());
  let l = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', l),
    U(this, 'deltaBehavior', 'increase'),
    U(this, 'realDelta', l - a),
    this.assert(l - a > 0, 'expected ' + d + ' to increase', 'expected ' + d + ' to not increase'));
}
s(vc, 'assertIncreases');
z(vc, 'assertIncreases');
M.addMethod('increase', vc);
M.addMethod('increases', vc);
function Tc(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    o = U(this, 'message'),
    i = U(this, 'ssfi');
  new M(n, o, i, !0).is.a('function');
  let a;
  (t
    ? (new M(e, o, i, !0).to.have.property(t), (a = e[t]))
    : (new M(e, o, i, !0).is.a('function'), (a = e())),
    new M(a, o, i, !0).is.a('number'),
    n());
  let l = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', l),
    U(this, 'deltaBehavior', 'decrease'),
    U(this, 'realDelta', a - l),
    this.assert(l - a < 0, 'expected ' + d + ' to decrease', 'expected ' + d + ' to not decrease'));
}
s(Tc, 'assertDecreases');
z(Tc, 'assertDecreases');
M.addMethod('decrease', Tc);
M.addMethod('decreases', Tc);
function Im(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'deltaMsgObj'),
    n = U(this, 'initialDeltaValue'),
    o = U(this, 'finalDeltaValue'),
    i = U(this, 'deltaBehavior'),
    a = U(this, 'realDelta'),
    l;
  (i === 'change' ? (l = Math.abs(o - n) === Math.abs(e)) : (l = a === Math.abs(e)),
    this.assert(
      l,
      'expected ' + r + ' to ' + i + ' by ' + e,
      'expected ' + r + ' to not ' + i + ' by ' + e,
    ));
}
s(Im, 'assertDelta');
z(Im, 'assertDelta');
M.addMethod('by', Im);
M.addProperty('extensible', function () {
  let e = U(this, 'object'),
    t = e === Object(e) && Object.isExtensible(e);
  this.assert(t, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
});
M.addProperty('sealed', function () {
  let e = U(this, 'object'),
    t = e === Object(e) ? Object.isSealed(e) : !0;
  this.assert(t, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
});
M.addProperty('frozen', function () {
  let e = U(this, 'object'),
    t = e === Object(e) ? Object.isFrozen(e) : !0;
  this.assert(t, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
});
M.addProperty('finite', function (e) {
  let t = U(this, 'object');
  this.assert(
    typeof t == 'number' && isFinite(t),
    'expected #{this} to be a finite number',
    'expected #{this} to not be a finite number',
  );
});
function ai(e, t) {
  return e === t
    ? !0
    : typeof t != typeof e
      ? !1
      : typeof e != 'object' || e === null
        ? e === t
        : t
          ? Array.isArray(e)
            ? Array.isArray(t)
              ? e.every(function (r) {
                  return t.some(function (n) {
                    return ai(r, n);
                  });
                })
              : !1
            : e instanceof Date
              ? t instanceof Date
                ? e.getTime() === t.getTime()
                : !1
              : Object.keys(e).every(function (r) {
                  let n = e[r],
                    o = t[r];
                  return typeof n == 'object' && n !== null && o !== null
                    ? ai(n, o)
                    : typeof n == 'function'
                      ? n(o)
                      : o === n;
                })
          : !1;
}
s(ai, 'compareSubset');
z(ai, 'compareSubset');
M.addMethod('containSubset', function (e) {
  const t = me(this, 'object'),
    r = wt.showDiff;
  this.assert(
    ai(e, t),
    'expected #{act} to contain subset #{exp}',
    'expected #{act} to not contain subset #{exp}',
    e,
    t,
    r,
  );
});
function zr(e, t) {
  return new M(e, t);
}
s(zr, 'expect');
z(zr, 'expect');
zr.fail = function (e, t, r, n) {
  throw (
    arguments.length < 2 && ((r = e), (e = void 0)),
    (r = r || 'expect.fail()'),
    new Re(r, { actual: e, expected: t, operator: n }, zr.fail)
  );
};
var L_ = {};
Gf(L_, { Should: s(() => DB, 'Should'), should: s(() => kB, 'should') });
function Ec() {
  function e() {
    return this instanceof String ||
      this instanceof Number ||
      this instanceof Boolean ||
      (typeof Symbol == 'function' && this instanceof Symbol) ||
      (typeof BigInt == 'function' && this instanceof BigInt)
      ? new M(this.valueOf(), null, e)
      : new M(this, null, e);
  }
  (s(e, 'shouldGetter'), z(e, 'shouldGetter'));
  function t(n) {
    Object.defineProperty(this, 'should', {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0,
    });
  }
  (s(t, 'shouldSetter'),
    z(t, 'shouldSetter'),
    Object.defineProperty(Object.prototype, 'should', { set: t, get: e, configurable: !0 }));
  let r = {};
  return (
    (r.fail = function (n, o, i, a) {
      throw (
        arguments.length < 2 && ((i = n), (n = void 0)),
        (i = i || 'should.fail()'),
        new Re(i, { actual: n, expected: o, operator: a }, r.fail)
      );
    }),
    (r.equal = function (n, o, i) {
      new M(n, i).to.equal(o);
    }),
    (r.Throw = function (n, o, i, a) {
      new M(n, a).to.Throw(o, i);
    }),
    (r.exist = function (n, o) {
      new M(n, o).to.exist;
    }),
    (r.not = {}),
    (r.not.equal = function (n, o, i) {
      new M(n, i).to.not.equal(o);
    }),
    (r.not.Throw = function (n, o, i, a) {
      new M(n, a).to.not.Throw(o, i);
    }),
    (r.not.exist = function (n, o) {
      new M(n, o).to.not.exist;
    }),
    (r.throw = r.Throw),
    (r.not.throw = r.not.Throw),
    r
  );
}
s(Ec, 'loadShould');
z(Ec, 'loadShould');
var kB = Ec,
  DB = Ec;
function q(e, t) {
  new M(null, null, q, !0).assert(e, t, '[ negation message unavailable ]');
}
s(q, 'assert');
z(q, 'assert');
q.fail = function (e, t, r, n) {
  throw (
    arguments.length < 2 && ((r = e), (e = void 0)),
    (r = r || 'assert.fail()'),
    new Re(r, { actual: e, expected: t, operator: n }, q.fail)
  );
};
q.isOk = function (e, t) {
  new M(e, t, q.isOk, !0).is.ok;
};
q.isNotOk = function (e, t) {
  new M(e, t, q.isNotOk, !0).is.not.ok;
};
q.equal = function (e, t, r) {
  let n = new M(e, r, q.equal, !0);
  n.assert(
    t == me(n, 'object'),
    'expected #{this} to equal #{exp}',
    'expected #{this} to not equal #{act}',
    t,
    e,
    !0,
  );
};
q.notEqual = function (e, t, r) {
  let n = new M(e, r, q.notEqual, !0);
  n.assert(
    t != me(n, 'object'),
    'expected #{this} to not equal #{exp}',
    'expected #{this} to equal #{act}',
    t,
    e,
    !0,
  );
};
q.strictEqual = function (e, t, r) {
  new M(e, r, q.strictEqual, !0).to.equal(t);
};
q.notStrictEqual = function (e, t, r) {
  new M(e, r, q.notStrictEqual, !0).to.not.equal(t);
};
q.deepEqual = q.deepStrictEqual = function (e, t, r) {
  new M(e, r, q.deepEqual, !0).to.eql(t);
};
q.notDeepEqual = function (e, t, r) {
  new M(e, r, q.notDeepEqual, !0).to.not.eql(t);
};
q.isAbove = function (e, t, r) {
  new M(e, r, q.isAbove, !0).to.be.above(t);
};
q.isAtLeast = function (e, t, r) {
  new M(e, r, q.isAtLeast, !0).to.be.least(t);
};
q.isBelow = function (e, t, r) {
  new M(e, r, q.isBelow, !0).to.be.below(t);
};
q.isAtMost = function (e, t, r) {
  new M(e, r, q.isAtMost, !0).to.be.most(t);
};
q.isTrue = function (e, t) {
  new M(e, t, q.isTrue, !0).is.true;
};
q.isNotTrue = function (e, t) {
  new M(e, t, q.isNotTrue, !0).to.not.equal(!0);
};
q.isFalse = function (e, t) {
  new M(e, t, q.isFalse, !0).is.false;
};
q.isNotFalse = function (e, t) {
  new M(e, t, q.isNotFalse, !0).to.not.equal(!1);
};
q.isNull = function (e, t) {
  new M(e, t, q.isNull, !0).to.equal(null);
};
q.isNotNull = function (e, t) {
  new M(e, t, q.isNotNull, !0).to.not.equal(null);
};
q.isNaN = function (e, t) {
  new M(e, t, q.isNaN, !0).to.be.NaN;
};
q.isNotNaN = function (e, t) {
  new M(e, t, q.isNotNaN, !0).not.to.be.NaN;
};
q.exists = function (e, t) {
  new M(e, t, q.exists, !0).to.exist;
};
q.notExists = function (e, t) {
  new M(e, t, q.notExists, !0).to.not.exist;
};
q.isUndefined = function (e, t) {
  new M(e, t, q.isUndefined, !0).to.equal(void 0);
};
q.isDefined = function (e, t) {
  new M(e, t, q.isDefined, !0).to.not.equal(void 0);
};
q.isCallable = function (e, t) {
  new M(e, t, q.isCallable, !0).is.callable;
};
q.isNotCallable = function (e, t) {
  new M(e, t, q.isNotCallable, !0).is.not.callable;
};
q.isObject = function (e, t) {
  new M(e, t, q.isObject, !0).to.be.a('object');
};
q.isNotObject = function (e, t) {
  new M(e, t, q.isNotObject, !0).to.not.be.a('object');
};
q.isArray = function (e, t) {
  new M(e, t, q.isArray, !0).to.be.an('array');
};
q.isNotArray = function (e, t) {
  new M(e, t, q.isNotArray, !0).to.not.be.an('array');
};
q.isString = function (e, t) {
  new M(e, t, q.isString, !0).to.be.a('string');
};
q.isNotString = function (e, t) {
  new M(e, t, q.isNotString, !0).to.not.be.a('string');
};
q.isNumber = function (e, t) {
  new M(e, t, q.isNumber, !0).to.be.a('number');
};
q.isNotNumber = function (e, t) {
  new M(e, t, q.isNotNumber, !0).to.not.be.a('number');
};
q.isNumeric = function (e, t) {
  new M(e, t, q.isNumeric, !0).is.numeric;
};
q.isNotNumeric = function (e, t) {
  new M(e, t, q.isNotNumeric, !0).is.not.numeric;
};
q.isFinite = function (e, t) {
  new M(e, t, q.isFinite, !0).to.be.finite;
};
q.isBoolean = function (e, t) {
  new M(e, t, q.isBoolean, !0).to.be.a('boolean');
};
q.isNotBoolean = function (e, t) {
  new M(e, t, q.isNotBoolean, !0).to.not.be.a('boolean');
};
q.typeOf = function (e, t, r) {
  new M(e, r, q.typeOf, !0).to.be.a(t);
};
q.notTypeOf = function (e, t, r) {
  new M(e, r, q.notTypeOf, !0).to.not.be.a(t);
};
q.instanceOf = function (e, t, r) {
  new M(e, r, q.instanceOf, !0).to.be.instanceOf(t);
};
q.notInstanceOf = function (e, t, r) {
  new M(e, r, q.notInstanceOf, !0).to.not.be.instanceOf(t);
};
q.include = function (e, t, r) {
  new M(e, r, q.include, !0).include(t);
};
q.notInclude = function (e, t, r) {
  new M(e, r, q.notInclude, !0).not.include(t);
};
q.deepInclude = function (e, t, r) {
  new M(e, r, q.deepInclude, !0).deep.include(t);
};
q.notDeepInclude = function (e, t, r) {
  new M(e, r, q.notDeepInclude, !0).not.deep.include(t);
};
q.nestedInclude = function (e, t, r) {
  new M(e, r, q.nestedInclude, !0).nested.include(t);
};
q.notNestedInclude = function (e, t, r) {
  new M(e, r, q.notNestedInclude, !0).not.nested.include(t);
};
q.deepNestedInclude = function (e, t, r) {
  new M(e, r, q.deepNestedInclude, !0).deep.nested.include(t);
};
q.notDeepNestedInclude = function (e, t, r) {
  new M(e, r, q.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
q.ownInclude = function (e, t, r) {
  new M(e, r, q.ownInclude, !0).own.include(t);
};
q.notOwnInclude = function (e, t, r) {
  new M(e, r, q.notOwnInclude, !0).not.own.include(t);
};
q.deepOwnInclude = function (e, t, r) {
  new M(e, r, q.deepOwnInclude, !0).deep.own.include(t);
};
q.notDeepOwnInclude = function (e, t, r) {
  new M(e, r, q.notDeepOwnInclude, !0).not.deep.own.include(t);
};
q.match = function (e, t, r) {
  new M(e, r, q.match, !0).to.match(t);
};
q.notMatch = function (e, t, r) {
  new M(e, r, q.notMatch, !0).to.not.match(t);
};
q.property = function (e, t, r) {
  new M(e, r, q.property, !0).to.have.property(t);
};
q.notProperty = function (e, t, r) {
  new M(e, r, q.notProperty, !0).to.not.have.property(t);
};
q.propertyVal = function (e, t, r, n) {
  new M(e, n, q.propertyVal, !0).to.have.property(t, r);
};
q.notPropertyVal = function (e, t, r, n) {
  new M(e, n, q.notPropertyVal, !0).to.not.have.property(t, r);
};
q.deepPropertyVal = function (e, t, r, n) {
  new M(e, n, q.deepPropertyVal, !0).to.have.deep.property(t, r);
};
q.notDeepPropertyVal = function (e, t, r, n) {
  new M(e, n, q.notDeepPropertyVal, !0).to.not.have.deep.property(t, r);
};
q.ownProperty = function (e, t, r) {
  new M(e, r, q.ownProperty, !0).to.have.own.property(t);
};
q.notOwnProperty = function (e, t, r) {
  new M(e, r, q.notOwnProperty, !0).to.not.have.own.property(t);
};
q.ownPropertyVal = function (e, t, r, n) {
  new M(e, n, q.ownPropertyVal, !0).to.have.own.property(t, r);
};
q.notOwnPropertyVal = function (e, t, r, n) {
  new M(e, n, q.notOwnPropertyVal, !0).to.not.have.own.property(t, r);
};
q.deepOwnPropertyVal = function (e, t, r, n) {
  new M(e, n, q.deepOwnPropertyVal, !0).to.have.deep.own.property(t, r);
};
q.notDeepOwnPropertyVal = function (e, t, r, n) {
  new M(e, n, q.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, r);
};
q.nestedProperty = function (e, t, r) {
  new M(e, r, q.nestedProperty, !0).to.have.nested.property(t);
};
q.notNestedProperty = function (e, t, r) {
  new M(e, r, q.notNestedProperty, !0).to.not.have.nested.property(t);
};
q.nestedPropertyVal = function (e, t, r, n) {
  new M(e, n, q.nestedPropertyVal, !0).to.have.nested.property(t, r);
};
q.notNestedPropertyVal = function (e, t, r, n) {
  new M(e, n, q.notNestedPropertyVal, !0).to.not.have.nested.property(t, r);
};
q.deepNestedPropertyVal = function (e, t, r, n) {
  new M(e, n, q.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, r);
};
q.notDeepNestedPropertyVal = function (e, t, r, n) {
  new M(e, n, q.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, r);
};
q.lengthOf = function (e, t, r) {
  new M(e, r, q.lengthOf, !0).to.have.lengthOf(t);
};
q.hasAnyKeys = function (e, t, r) {
  new M(e, r, q.hasAnyKeys, !0).to.have.any.keys(t);
};
q.hasAllKeys = function (e, t, r) {
  new M(e, r, q.hasAllKeys, !0).to.have.all.keys(t);
};
q.containsAllKeys = function (e, t, r) {
  new M(e, r, q.containsAllKeys, !0).to.contain.all.keys(t);
};
q.doesNotHaveAnyKeys = function (e, t, r) {
  new M(e, r, q.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
q.doesNotHaveAllKeys = function (e, t, r) {
  new M(e, r, q.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
q.hasAnyDeepKeys = function (e, t, r) {
  new M(e, r, q.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
q.hasAllDeepKeys = function (e, t, r) {
  new M(e, r, q.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
q.containsAllDeepKeys = function (e, t, r) {
  new M(e, r, q.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
q.doesNotHaveAnyDeepKeys = function (e, t, r) {
  new M(e, r, q.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
q.doesNotHaveAllDeepKeys = function (e, t, r) {
  new M(e, r, q.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
q.throws = function (e, t, r, n) {
  (typeof t == 'string' || t instanceof RegExp) && ((r = t), (t = null));
  let o = new M(e, n, q.throws, !0).to.throw(t, r);
  return me(o, 'object');
};
q.doesNotThrow = function (e, t, r, n) {
  ((typeof t == 'string' || t instanceof RegExp) && ((r = t), (t = null)),
    new M(e, n, q.doesNotThrow, !0).to.not.throw(t, r));
};
q.operator = function (e, t, r, n) {
  let o;
  switch (t) {
    case '==':
      o = e == r;
      break;
    case '===':
      o = e === r;
      break;
    case '>':
      o = e > r;
      break;
    case '>=':
      o = e >= r;
      break;
    case '<':
      o = e < r;
      break;
    case '<=':
      o = e <= r;
      break;
    case '!=':
      o = e != r;
      break;
    case '!==':
      o = e !== r;
      break;
    default:
      throw ((n = n && n + ': '), new Re(n + 'Invalid operator "' + t + '"', void 0, q.operator));
  }
  let i = new M(o, n, q.operator, !0);
  i.assert(
    me(i, 'object') === !0,
    'expected ' + Se(e) + ' to be ' + t + ' ' + Se(r),
    'expected ' + Se(e) + ' to not be ' + t + ' ' + Se(r),
  );
};
q.closeTo = function (e, t, r, n) {
  new M(e, n, q.closeTo, !0).to.be.closeTo(t, r);
};
q.approximately = function (e, t, r, n) {
  new M(e, n, q.approximately, !0).to.be.approximately(t, r);
};
q.sameMembers = function (e, t, r) {
  new M(e, r, q.sameMembers, !0).to.have.same.members(t);
};
q.notSameMembers = function (e, t, r) {
  new M(e, r, q.notSameMembers, !0).to.not.have.same.members(t);
};
q.sameDeepMembers = function (e, t, r) {
  new M(e, r, q.sameDeepMembers, !0).to.have.same.deep.members(t);
};
q.notSameDeepMembers = function (e, t, r) {
  new M(e, r, q.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
q.sameOrderedMembers = function (e, t, r) {
  new M(e, r, q.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
q.notSameOrderedMembers = function (e, t, r) {
  new M(e, r, q.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
q.sameDeepOrderedMembers = function (e, t, r) {
  new M(e, r, q.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
q.notSameDeepOrderedMembers = function (e, t, r) {
  new M(e, r, q.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
q.includeMembers = function (e, t, r) {
  new M(e, r, q.includeMembers, !0).to.include.members(t);
};
q.notIncludeMembers = function (e, t, r) {
  new M(e, r, q.notIncludeMembers, !0).to.not.include.members(t);
};
q.includeDeepMembers = function (e, t, r) {
  new M(e, r, q.includeDeepMembers, !0).to.include.deep.members(t);
};
q.notIncludeDeepMembers = function (e, t, r) {
  new M(e, r, q.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
q.includeOrderedMembers = function (e, t, r) {
  new M(e, r, q.includeOrderedMembers, !0).to.include.ordered.members(t);
};
q.notIncludeOrderedMembers = function (e, t, r) {
  new M(e, r, q.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
q.includeDeepOrderedMembers = function (e, t, r) {
  new M(e, r, q.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
q.notIncludeDeepOrderedMembers = function (e, t, r) {
  new M(e, r, q.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
q.oneOf = function (e, t, r) {
  new M(e, r, q.oneOf, !0).to.be.oneOf(t);
};
q.isIterable = function (e, t) {
  if (e == null || !e[Symbol.iterator])
    throw (
      (t = t ? `${t} expected ${Se(e)} to be an iterable` : `expected ${Se(e)} to be an iterable`),
      new Re(t, void 0, q.isIterable)
    );
};
q.changes = function (e, t, r, n) {
  (arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new M(e, n, q.changes, !0).to.change(t, r));
};
q.changesBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new M(e, o, q.changesBy, !0).to.change(t, r).by(n);
};
q.doesNotChange = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new M(e, n, q.doesNotChange, !0).to.not.change(t, r)
  );
};
q.changesButNotBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new M(e, o, q.changesButNotBy, !0).to.change(t, r).but.not.by(n);
};
q.increases = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new M(e, n, q.increases, !0).to.increase(t, r)
  );
};
q.increasesBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new M(e, o, q.increasesBy, !0).to.increase(t, r).by(n);
};
q.doesNotIncrease = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new M(e, n, q.doesNotIncrease, !0).to.not.increase(t, r)
  );
};
q.increasesButNotBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new M(e, o, q.increasesButNotBy, !0).to.increase(t, r).but.not.by(n);
};
q.decreases = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new M(e, n, q.decreases, !0).to.decrease(t, r)
  );
};
q.decreasesBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new M(e, o, q.decreasesBy, !0).to.decrease(t, r).by(n);
};
q.doesNotDecrease = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new M(e, n, q.doesNotDecrease, !0).to.not.decrease(t, r)
  );
};
q.doesNotDecreaseBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  return new M(e, o, q.doesNotDecreaseBy, !0).to.not.decrease(t, r).by(n);
};
q.decreasesButNotBy = function (e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == 'function') {
    let i = n;
    ((n = r), (o = i));
  } else arguments.length === 3 && ((n = r), (r = null));
  new M(e, o, q.decreasesButNotBy, !0).to.decrease(t, r).but.not.by(n);
};
q.ifError = function (e) {
  if (e) throw e;
};
q.isExtensible = function (e, t) {
  new M(e, t, q.isExtensible, !0).to.be.extensible;
};
q.isNotExtensible = function (e, t) {
  new M(e, t, q.isNotExtensible, !0).to.not.be.extensible;
};
q.isSealed = function (e, t) {
  new M(e, t, q.isSealed, !0).to.be.sealed;
};
q.isNotSealed = function (e, t) {
  new M(e, t, q.isNotSealed, !0).to.not.be.sealed;
};
q.isFrozen = function (e, t) {
  new M(e, t, q.isFrozen, !0).to.be.frozen;
};
q.isNotFrozen = function (e, t) {
  new M(e, t, q.isNotFrozen, !0).to.not.be.frozen;
};
q.isEmpty = function (e, t) {
  new M(e, t, q.isEmpty, !0).to.be.empty;
};
q.isNotEmpty = function (e, t) {
  new M(e, t, q.isNotEmpty, !0).to.not.be.empty;
};
q.containsSubset = function (e, t, r) {
  new M(e, r).to.containSubset(t);
};
q.doesNotContainSubset = function (e, t, r) {
  new M(e, r).to.not.containSubset(t);
};
var LB = [
  ['isOk', 'ok'],
  ['isNotOk', 'notOk'],
  ['throws', 'throw'],
  ['throws', 'Throw'],
  ['isExtensible', 'extensible'],
  ['isNotExtensible', 'notExtensible'],
  ['isSealed', 'sealed'],
  ['isNotSealed', 'notSealed'],
  ['isFrozen', 'frozen'],
  ['isNotFrozen', 'notFrozen'],
  ['isEmpty', 'empty'],
  ['isNotEmpty', 'notEmpty'],
  ['isCallable', 'isFunction'],
  ['isNotCallable', 'isNotFunction'],
  ['containsSubset', 'containSubset'],
];
for (const [e, t] of LB) q[t] = q[e];
var cb = [];
function Sn(e) {
  const t = {
    use: Sn,
    AssertionError: Re,
    util: sr,
    config: wt,
    expect: zr,
    assert: q,
    Assertion: M,
    ...L_,
  };
  return (~cb.indexOf(e) || (e(t, sr), cb.push(e)), t);
}
s(Sn, 'use');
z(Sn, 'use');
var F_ = {};
Rt(F_, {
  toAppearAfter: () => bA,
  toAppearBefore: () => Ga,
  toBeChecked: () => py,
  toBeDisabled: () => oy,
  toBeEmpty: () => Um,
  toBeEmptyDOMElement: () => Vm,
  toBeEnabled: () => sy,
  toBeInTheDOM: () => Ba,
  toBeInTheDocument: () => Jm,
  toBeInvalid: () => ly,
  toBePartiallyChecked: () => my,
  toBePartiallyPressed: () => vy,
  toBePressed: () => by,
  toBeRequired: () => iy,
  toBeValid: () => cy,
  toBeVisible: () => Zm,
  toContainElement: () => Ja,
  toContainHTML: () => Hm,
  toHaveAccessibleDescription: () => Ua,
  toHaveAccessibleErrorMessage: () => Gm,
  toHaveAccessibleName: () => Ha,
  toHaveAttribute: () => Wm,
  toHaveClass: () => Km,
  toHaveDescription: () => yy,
  toHaveDisplayValue: () => dy,
  toHaveErrorMessage: () => hy,
  toHaveFocus: () => Ym,
  toHaveFormValues: () => Xm,
  toHaveRole: () => Va,
  toHaveSelection: () => gy,
  toHaveStyle: () => za,
  toHaveTextContent: () => zm,
  toHaveValue: () => uy,
});
var ub = Ke(Jv(), 1),
  B_ = class extends Error {
    constructor(r, n, o, i, a) {
      super(`${r}:${o}:${i}: ${n}`);
      Be(this, 'reason');
      Be(this, 'filename');
      Be(this, 'line');
      Be(this, 'column');
      Be(this, 'source');
      ((this.reason = n),
        (this.filename = r),
        (this.line = o),
        (this.column = i),
        (this.source = a));
    }
  };
s(B_, 't');
var FB = B_,
  J_ = class {
    constructor(t, r, n) {
      Be(this, 'start');
      Be(this, 'end');
      Be(this, 'source');
      ((this.start = t), (this.end = r), (this.source = n));
    }
  };
s(J_, 'e');
var BB = J_,
  tt;
(function (e) {
  ((e.stylesheet = 'stylesheet'),
    (e.rule = 'rule'),
    (e.declaration = 'declaration'),
    (e.comment = 'comment'),
    (e.container = 'container'),
    (e.charset = 'charset'),
    (e.document = 'document'),
    (e.customMedia = 'custom-media'),
    (e.fontFace = 'font-face'),
    (e.host = 'host'),
    (e.import = 'import'),
    (e.keyframes = 'keyframes'),
    (e.keyframe = 'keyframe'),
    (e.layer = 'layer'),
    (e.media = 'media'),
    (e.namespace = 'namespace'),
    (e.page = 'page'),
    (e.startingStyle = 'starting-style'),
    (e.supports = 'supports'));
})(tt || (tt = {}));
var db = s((e, t, r) => {
    let n = r,
      o = 1e4;
    do {
      const i = t.map((d) => e.indexOf(d, n));
      i.push(e.indexOf('\\', n));
      const a = i.filter((d) => d !== -1);
      if (a.length === 0) return -1;
      const l = Math.min(...a);
      if (e[l] !== '\\') return l;
      ((n = l + 2), o--);
    } while (o > 0);
    throw new Error('Too many escaping');
  }, 's'),
  ad = s((e, t, r) => {
    let n = r,
      o = 1e4;
    do {
      const i = t.map((d) => e.indexOf(d, n));
      (i.push(e.indexOf('(', n)),
        i.push(e.indexOf('"', n)),
        i.push(e.indexOf("'", n)),
        i.push(e.indexOf('\\', n)));
      const a = i.filter((d) => d !== -1);
      if (a.length === 0) return -1;
      const l = Math.min(...a);
      switch (e[l]) {
        case '\\':
          n = l + 2;
          break;
        case '(':
          {
            const d = ad(e, [')'], l + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        case '"':
          {
            const d = db(e, ['"'], l + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        case "'":
          {
            const d = db(e, ["'"], l + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        default:
          return l;
      }
      o--;
    } while (o > 0);
    throw new Error('Too many escaping');
  }, 'n'),
  hu = /\/\*[^]*?(?:\*\/|$)/g;
function xt(e) {
  return e ? e.trim() : '';
}
s(xt, 'o');
function Fa(e, t) {
  const r = e && typeof e.type == 'string',
    n = r ? e : t;
  for (const o in e) {
    const i = e[o];
    Array.isArray(i)
      ? i.forEach((a) => {
          Fa(a, n);
        })
      : i && typeof i == 'object' && Fa(i, n);
  }
  return (
    r &&
      Object.defineProperty(e, 'parent', {
        configurable: !0,
        writable: !0,
        enumerable: !1,
        value: t || null,
      }),
    e
  );
}
s(Fa, 'c');
var JB = s((e, t) => {
    t = t || {};
    let r = 1,
      n = 1;
    function o() {
      const w = { line: r, column: n };
      return (_) => ((_.position = new BB(w, { line: r, column: n }, t?.source || '')), f(), _);
    }
    s(o, 'u');
    const i = [];
    function a(w) {
      const _ = new FB(t?.source || '', w, r, n, e);
      if (!t?.silent) throw _;
      i.push(_);
    }
    s(a, 'l');
    function l() {
      const w = /^{\s*/.exec(e);
      return !!w && (p(w), !0);
    }
    s(l, 'f');
    function d() {
      const w = /^}/.exec(e);
      return !!w && (p(w), !0);
    }
    s(d, 'd');
    function u() {
      let w;
      const _ = [];
      for (f(), m(_); e.length && e.charAt(0) !== '}' && ((w = x() || A()), w); ) (_.push(w), m(_));
      return _;
    }
    s(u, 'y');
    function p(w) {
      const _ = w[0];
      return (
        (function (j) {
          const N = j.match(/\n/g);
          N && (r += N.length);
          const V = j.lastIndexOf(`
`);
          n = ~V ? j.length - V : n + j.length;
        })(_),
        (e = e.slice(_.length)),
        w
      );
    }
    s(p, 'g');
    function f() {
      const w = /^\s*/.exec(e);
      w && p(w);
    }
    s(f, '$');
    function m(w) {
      w = w || [];
      let _ = h();
      for (; _; ) (w.push(_), (_ = h()));
      return w;
    }
    s(m, 'x');
    function h() {
      const w = o();
      if (e.charAt(0) !== '/' || e.charAt(1) !== '*') return;
      const _ = /^\/\*[^]*?\*\//.exec(e);
      return _
        ? (p(_), w({ type: tt.comment, comment: _[0].slice(2, -2) }))
        : a('End of comment missing');
    }
    s(h, 'V');
    function g() {
      const w = /^([^{]+)/.exec(e);
      if (w)
        return (
          p(w),
          ((_, j) => {
            const N = [];
            let V = 0;
            for (; V < _.length; ) {
              const H = ad(_, j, V);
              if (H === -1) return (N.push(_.substring(V)), N);
              (N.push(_.substring(V, H)), (V = H + 1));
            }
            return N;
          })(xt(w[0]).replace(hu, ''), [',']).map((_) => xt(_))
        );
    }
    s(g, 'k');
    function v() {
      const w = o(),
        _ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(e);
      if (!_) return;
      p(_);
      const j = xt(_[0]),
        N = /^:\s*/.exec(e);
      if (!N) return a("property missing ':'");
      p(N);
      let V = '';
      const H = ad(e, [';', '}']);
      H !== -1 && ((V = e.substring(0, H)), p([V]), (V = xt(V).replace(hu, '')));
      const P = w({ type: tt.declaration, property: j.replace(hu, ''), value: V }),
        D = /^[;\s]*/.exec(e);
      return (D && p(D), P);
    }
    s(v, 'v');
    function E() {
      const w = [];
      if (!l()) return a("missing '{'");
      m(w);
      let _ = v();
      for (; _; ) (w.push(_), m(w), (_ = v()));
      return d() ? w : a("missing '}'");
    }
    s(E, 'w');
    function b() {
      const w = [],
        _ = o();
      let j = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
      for (; j; ) {
        const N = p(j);
        w.push(N[1]);
        const V = /^,\s*/.exec(e);
        (V && p(V), (j = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e)));
      }
      if (w.length) return _({ type: tt.keyframe, values: w, declarations: E() || [] });
    }
    s(b, 'b');
    const S = $('import'),
      R = $('charset'),
      I = $('namespace');
    function $(w) {
      const _ = new RegExp(
        '^@' + w + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`,
      );
      return () => {
        const j = o(),
          N = _.exec(e);
        if (!N) return;
        const V = p(N),
          H = { type: w };
        return ((H[w] = V[1].trim()), j(H));
      };
    }
    s($, 'M');
    function x() {
      if (e[0] === '@')
        return (
          (function () {
            const w = o(),
              _ = /^@([-\w]+)?keyframes\s*/.exec(e);
            if (!_) return;
            const j = p(_)[1],
              N = /^([-\w]+)\s*/.exec(e);
            if (!N) return a('@keyframes missing name');
            const V = p(N)[1];
            if (!l()) return a("@keyframes missing '{'");
            let H = m(),
              P = b();
            for (; P; ) (H.push(P), (H = H.concat(m())), (P = b()));
            return d()
              ? w({ type: tt.keyframes, name: V, vendor: j, keyframes: H })
              : a("@keyframes missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@media *([^{]+)/.exec(e);
            if (!_) return;
            const j = xt(p(_)[1]);
            if (!l()) return a("@media missing '{'");
            const N = m().concat(u());
            return d() ? w({ type: tt.media, media: j, rules: N }) : a("@media missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(e);
            if (!_) return;
            const j = p(_);
            return w({ type: tt.customMedia, name: xt(j[1]), media: xt(j[2]) });
          })() ||
          (function () {
            const w = o(),
              _ = /^@supports *([^{]+)/.exec(e);
            if (!_) return;
            const j = xt(p(_)[1]);
            if (!l()) return a("@supports missing '{'");
            const N = m().concat(u());
            return d()
              ? w({ type: tt.supports, supports: j, rules: N })
              : a("@supports missing '}'");
          })() ||
          S() ||
          R() ||
          I() ||
          (function () {
            const w = o(),
              _ = /^@([-\w]+)?document *([^{]+)/.exec(e);
            if (!_) return;
            const j = p(_),
              N = xt(j[1]),
              V = xt(j[2]);
            if (!l()) return a("@document missing '{'");
            const H = m().concat(u());
            return d()
              ? w({ type: tt.document, document: V, vendor: N, rules: H })
              : a("@document missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@page */.exec(e);
            if (!_) return;
            p(_);
            const j = g() || [];
            if (!l()) return a("@page missing '{'");
            let N = m(),
              V = v();
            for (; V; ) (N.push(V), (N = N.concat(m())), (V = v()));
            return d()
              ? w({ type: tt.page, selectors: j, declarations: N })
              : a("@page missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@host\s*/.exec(e);
            if (!_) return;
            if ((p(_), !l())) return a("@host missing '{'");
            const j = m().concat(u());
            return d() ? w({ type: tt.host, rules: j }) : a("@host missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@font-face\s*/.exec(e);
            if (!_) return;
            if ((p(_), !l())) return a("@font-face missing '{'");
            let j = m(),
              N = v();
            for (; N; ) (j.push(N), (j = j.concat(m())), (N = v()));
            return d() ? w({ type: tt.fontFace, declarations: j }) : a("@font-face missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@container *([^{]+)/.exec(e);
            if (!_) return;
            const j = xt(p(_)[1]);
            if (!l()) return a("@container missing '{'");
            const N = m().concat(u());
            return d()
              ? w({ type: tt.container, container: j, rules: N })
              : a("@container missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@starting-style\s*/.exec(e);
            if (!_) return;
            if ((p(_), !l())) return a("@starting-style missing '{'");
            const j = m().concat(u());
            return d() ? w({ type: tt.startingStyle, rules: j }) : a("@starting-style missing '}'");
          })() ||
          (function () {
            const w = o(),
              _ = /^@layer *([^{;@]+)/.exec(e);
            if (!_) return;
            const j = xt(p(_)[1]);
            if (!l()) {
              const V = /^[;\s]*/.exec(e);
              return (V && p(V), w({ type: tt.layer, layer: j }));
            }
            const N = m().concat(u());
            return d() ? w({ type: tt.layer, layer: j, rules: N }) : a("@layer missing '}'");
          })()
        );
    }
    s(x, 'A');
    function A() {
      const w = o(),
        _ = g();
      return _
        ? (m(), w({ type: tt.rule, selectors: _, declarations: E() || [] }))
        : a('selector missing');
    }
    return (
      s(A, 'S'),
      Fa(
        (function () {
          const w = u();
          return {
            type: tt.stylesheet,
            stylesheet: { source: t?.source, rules: w, parsingErrors: i },
          };
        })(),
      )
    );
  }, 'm'),
  UB = Object.prototype.toString;
function ld(e) {
  return typeof e == 'function' || UB.call(e) === '[object Function]';
}
s(ld, 'isCallable');
function U_(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
s(U_, 'toInteger');
var VB = Math.pow(2, 53) - 1;
function V_(e) {
  var t = U_(e);
  return Math.min(Math.max(t, 0), VB);
}
s(V_, 'toLength');
function Ft(e, t) {
  var r = Array,
    n = Object(e);
  if (e == null)
    throw new TypeError('Array.from requires an array-like object - not null or undefined');
  if (typeof t < 'u' && !ld(t))
    throw new TypeError('Array.from: when provided, the second argument must be a function');
  for (var o = V_(n.length), i = ld(r) ? Object(new r(o)) : new Array(o), a = 0, l; a < o; )
    ((l = n[a]), t ? (i[a] = t(l, a)) : (i[a] = l), (a += 1));
  return ((i.length = o), i);
}
s(Ft, 'arrayFrom');
function Ro(e) {
  '@babel/helpers - typeof';
  return (
    (Ro =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    Ro(e)
  );
}
s(Ro, '_typeof');
function H_(e, t) {
  if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
s(H_, '_classCallCheck');
function cd(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    ((n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      'value' in n && (n.writable = !0),
      Object.defineProperty(e, Nm(n.key), n));
  }
}
s(cd, '_defineProperties');
function z_(e, t, r) {
  return (
    t && cd(e.prototype, t),
    r && cd(e, r),
    Object.defineProperty(e, 'prototype', { writable: !1 }),
    e
  );
}
s(z_, '_createClass');
function G_(e, t, r) {
  return (
    (t = Nm(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(G_, '_defineProperty');
function Nm(e) {
  var t = W_(e, 'string');
  return Ro(t) === 'symbol' ? t : String(t);
}
s(Nm, '_toPropertyKey');
function W_(e, t) {
  if (Ro(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (Ro(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
s(W_, '_toPrimitive');
var HB = (function () {
    function e() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      (H_(this, e), G_(this, 'items', void 0), (this.items = t));
    }
    return (
      s(e, 'SetLike'),
      z_(e, [
        {
          key: 'add',
          value: s(function (r) {
            return (this.has(r) === !1 && this.items.push(r), this);
          }, 'add'),
        },
        {
          key: 'clear',
          value: s(function () {
            this.items = [];
          }, 'clear'),
        },
        {
          key: 'delete',
          value: s(function (r) {
            var n = this.items.length;
            return (
              (this.items = this.items.filter(function (o) {
                return o !== r;
              })),
              n !== this.items.length
            );
          }, '_delete'),
        },
        {
          key: 'forEach',
          value: s(function (r) {
            var n = this;
            this.items.forEach(function (o) {
              r(o, o, n);
            });
          }, 'forEach'),
        },
        {
          key: 'has',
          value: s(function (r) {
            return this.items.indexOf(r) !== -1;
          }, 'has'),
        },
        {
          key: 'size',
          get: s(function () {
            return this.items.length;
          }, 'get'),
        },
      ]),
      e
    );
  })(),
  zB = typeof Set > 'u' ? Set : HB;
function pt(e) {
  var t;
  return (t = e.localName) !== null && t !== void 0 ? t : e.tagName.toLowerCase();
}
s(pt, 'getLocalName');
var GB = {
    article: 'article',
    aside: 'complementary',
    button: 'button',
    datalist: 'listbox',
    dd: 'definition',
    details: 'group',
    dialog: 'dialog',
    dt: 'term',
    fieldset: 'group',
    figure: 'figure',
    form: 'form',
    footer: 'contentinfo',
    h1: 'heading',
    h2: 'heading',
    h3: 'heading',
    h4: 'heading',
    h5: 'heading',
    h6: 'heading',
    header: 'banner',
    hr: 'separator',
    html: 'document',
    legend: 'legend',
    li: 'listitem',
    math: 'math',
    main: 'main',
    menu: 'list',
    nav: 'navigation',
    ol: 'list',
    optgroup: 'group',
    option: 'option',
    output: 'status',
    progress: 'progressbar',
    section: 'region',
    summary: 'button',
    table: 'table',
    tbody: 'rowgroup',
    textarea: 'textbox',
    tfoot: 'rowgroup',
    td: 'cell',
    th: 'columnheader',
    thead: 'rowgroup',
    tr: 'row',
    ul: 'list',
  },
  WB = {
    caption: new Set(['aria-label', 'aria-labelledby']),
    code: new Set(['aria-label', 'aria-labelledby']),
    deletion: new Set(['aria-label', 'aria-labelledby']),
    emphasis: new Set(['aria-label', 'aria-labelledby']),
    generic: new Set(['aria-label', 'aria-labelledby', 'aria-roledescription']),
    insertion: new Set(['aria-label', 'aria-labelledby']),
    none: new Set(['aria-label', 'aria-labelledby']),
    paragraph: new Set(['aria-label', 'aria-labelledby']),
    presentation: new Set(['aria-label', 'aria-labelledby']),
    strong: new Set(['aria-label', 'aria-labelledby']),
    subscript: new Set(['aria-label', 'aria-labelledby']),
    superscript: new Set(['aria-label', 'aria-labelledby']),
  };
function K_(e, t) {
  return [
    'aria-atomic',
    'aria-busy',
    'aria-controls',
    'aria-current',
    'aria-description',
    'aria-describedby',
    'aria-details',
    'aria-dropeffect',
    'aria-flowto',
    'aria-grabbed',
    'aria-hidden',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-live',
    'aria-owns',
    'aria-relevant',
    'aria-roledescription',
  ].some(function (r) {
    var n;
    return e.hasAttribute(r) && !((n = WB[t]) !== null && n !== void 0 && n.has(r));
  });
}
s(K_, 'hasGlobalAriaAttributes');
function $m(e, t) {
  return K_(e, t);
}
s($m, 'ignorePresentationalRole');
function Y_(e) {
  var t = Q_(e);
  if (t === null || ud.indexOf(t) !== -1) {
    var r = X_(e);
    if (ud.indexOf(t || '') === -1 || $m(e, r || '')) return r;
  }
  return t;
}
s(Y_, 'getRole');
function X_(e) {
  var t = GB[pt(e)];
  if (t !== void 0) return t;
  switch (pt(e)) {
    case 'a':
    case 'area':
    case 'link':
      if (e.hasAttribute('href')) return 'link';
      break;
    case 'img':
      return e.getAttribute('alt') === '' && !$m(e, 'img') ? 'presentation' : 'img';
    case 'input': {
      var r = e,
        n = r.type;
      switch (n) {
        case 'button':
        case 'image':
        case 'reset':
        case 'submit':
          return 'button';
        case 'checkbox':
        case 'radio':
          return n;
        case 'range':
          return 'slider';
        case 'email':
        case 'tel':
        case 'text':
        case 'url':
          return e.hasAttribute('list') ? 'combobox' : 'textbox';
        case 'search':
          return e.hasAttribute('list') ? 'combobox' : 'searchbox';
        case 'number':
          return 'spinbutton';
        default:
          return null;
      }
    }
    case 'select':
      return e.hasAttribute('multiple') || e.size > 1 ? 'listbox' : 'combobox';
  }
  return null;
}
s(X_, 'getImplicitRole');
function Q_(e) {
  var t = e.getAttribute('role');
  if (t !== null) {
    var r = t.trim().split(' ')[0];
    if (r.length > 0) return r;
  }
  return null;
}
s(Q_, 'getExplicitRole');
var ud = ['presentation', 'none'];
function Me(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
s(Me, 'isElement');
function qm(e) {
  return Me(e) && pt(e) === 'caption';
}
s(qm, 'isHTMLTableCaptionElement');
function Us(e) {
  return Me(e) && pt(e) === 'input';
}
s(Us, 'isHTMLInputElement');
function Z_(e) {
  return Me(e) && pt(e) === 'optgroup';
}
s(Z_, 'isHTMLOptGroupElement');
function e0(e) {
  return Me(e) && pt(e) === 'select';
}
s(e0, 'isHTMLSelectElement');
function t0(e) {
  return Me(e) && pt(e) === 'table';
}
s(t0, 'isHTMLTableElement');
function r0(e) {
  return Me(e) && pt(e) === 'textarea';
}
s(r0, 'isHTMLTextAreaElement');
function n0(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument,
    r = t.defaultView;
  if (r === null) throw new TypeError('no window available');
  return r;
}
s(n0, 'safeWindow');
function o0(e) {
  return Me(e) && pt(e) === 'fieldset';
}
s(o0, 'isHTMLFieldSetElement');
function s0(e) {
  return Me(e) && pt(e) === 'legend';
}
s(s0, 'isHTMLLegendElement');
function i0(e) {
  return Me(e) && pt(e) === 'slot';
}
s(i0, 'isHTMLSlotElement');
function a0(e) {
  return Me(e) && e.ownerSVGElement !== void 0;
}
s(a0, 'isSVGElement');
function l0(e) {
  return Me(e) && pt(e) === 'svg';
}
s(l0, 'isSVGSVGElement');
function c0(e) {
  return a0(e) && pt(e) === 'title';
}
s(c0, 'isSVGTitleElement');
function li(e, t) {
  if (Me(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(' '),
      n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r
      .map(function (o) {
        return n.getElementById(o);
      })
      .filter(function (o) {
        return o !== null;
      });
  }
  return [];
}
s(li, 'queryIdRefs');
function ir(e, t) {
  return Me(e) ? t.indexOf(Y_(e)) !== -1 : !1;
}
s(ir, 'hasAnyConcreteRoles');
function u0(e) {
  return e.trim().replace(/\s\s+/g, ' ');
}
s(u0, 'asFlatString');
function d0(e, t) {
  if (!Me(e)) return !1;
  if (e.hasAttribute('hidden') || e.getAttribute('aria-hidden') === 'true') return !0;
  var r = t(e);
  return r.getPropertyValue('display') === 'none' || r.getPropertyValue('visibility') === 'hidden';
}
s(d0, 'isHidden');
function p0(e) {
  return ir(e, ['button', 'combobox', 'listbox', 'textbox']) || Mm(e, 'range');
}
s(p0, 'isControl');
function Mm(e, t) {
  if (!Me(e)) return !1;
  switch (t) {
    case 'range':
      return ir(e, ['meter', 'progressbar', 'scrollbar', 'slider', 'spinbutton']);
    default:
      throw new TypeError(
        "No knowledge about abstract role '".concat(t, "'. This is likely a bug :("),
      );
  }
}
s(Mm, 'hasAbstractRole');
function dd(e, t) {
  var r = Ft(e.querySelectorAll(t));
  return (
    li(e, 'aria-owns').forEach(function (n) {
      r.push.apply(r, Ft(n.querySelectorAll(t)));
    }),
    r
  );
}
s(dd, 'querySelectorAllSubtree');
function f0(e) {
  return e0(e) ? e.selectedOptions || dd(e, '[selected]') : dd(e, '[aria-selected="true"]');
}
s(f0, 'querySelectedOptions');
function m0(e) {
  return ir(e, ud);
}
s(m0, 'isMarkedPresentational');
function y0(e) {
  return qm(e);
}
s(y0, 'isNativeHostLanguageTextAlternativeElement');
function h0(e) {
  return ir(e, [
    'button',
    'cell',
    'checkbox',
    'columnheader',
    'gridcell',
    'heading',
    'label',
    'legend',
    'link',
    'menuitem',
    'menuitemcheckbox',
    'menuitemradio',
    'option',
    'radio',
    'row',
    'rowheader',
    'switch',
    'tab',
    'tooltip',
    'treeitem',
  ]);
}
s(h0, 'allowsNameFromContent');
function g0(e) {
  return !1;
}
s(g0, 'isDescendantOfNativeHostLanguageTextAlternativeElement');
function b0(e) {
  return Us(e) || r0(e) ? e.value : e.textContent || '';
}
s(b0, 'getValueOfTextbox');
function pd(e) {
  var t = e.getPropertyValue('content');
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : '';
}
s(pd, 'getTextualContent');
function jm(e) {
  var t = pt(e);
  return (
    t === 'button' ||
    (t === 'input' && e.getAttribute('type') !== 'hidden') ||
    t === 'meter' ||
    t === 'output' ||
    t === 'progress' ||
    t === 'select' ||
    t === 'textarea'
  );
}
s(jm, 'isLabelableElement');
function km(e) {
  if (jm(e)) return e;
  var t = null;
  return (
    e.childNodes.forEach(function (r) {
      if (t === null && Me(r)) {
        var n = km(r);
        n !== null && (t = n);
      }
    }),
    t
  );
}
s(km, 'findLabelableElement');
function v0(e) {
  if (e.control !== void 0) return e.control;
  var t = e.getAttribute('for');
  return t !== null ? e.ownerDocument.getElementById(t) : km(e);
}
s(v0, 'getControlOfLabel');
function T0(e) {
  var t = e.labels;
  if (t === null) return t;
  if (t !== void 0) return Ft(t);
  if (!jm(e)) return null;
  var r = e.ownerDocument;
  return Ft(r.querySelectorAll('label')).filter(function (n) {
    return v0(n) === e;
  });
}
s(T0, 'getLabels');
function E0(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? Ft(e.childNodes) : t;
}
s(E0, 'getSlotContents');
function Dm(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = new zB(),
    n = n0(e),
    o = t.compute,
    i = o === void 0 ? 'name' : o,
    a = t.computedStyleSupportsPseudoElements,
    l = a === void 0 ? t.getComputedStyle !== void 0 : a,
    d = t.getComputedStyle,
    u = d === void 0 ? n.getComputedStyle.bind(n) : d,
    p = t.hidden,
    f = p === void 0 ? !1 : p;
  function m(b, S) {
    var R = '';
    if (Me(b) && l) {
      var I = u(b, '::before'),
        $ = pd(I);
      R = ''.concat($, ' ').concat(R);
    }
    var x = i0(b) ? E0(b) : Ft(b.childNodes).concat(li(b, 'aria-owns'));
    if (
      (x.forEach(function (_) {
        var j = E(_, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !1, recursion: !0 }),
          N = Me(_) ? u(_).getPropertyValue('display') : 'inline',
          V = N !== 'inline' ? ' ' : '';
        R += ''.concat(V).concat(j).concat(V);
      }),
      Me(b) && l)
    ) {
      var A = u(b, '::after'),
        w = pd(A);
      R = ''.concat(R, ' ').concat(w);
    }
    return R.trim();
  }
  s(m, 'computeMiscTextAlternative');
  function h(b, S) {
    var R = b.getAttributeNode(S);
    return R !== null && !r.has(R) && R.value.trim() !== '' ? (r.add(R), R.value) : null;
  }
  s(h, 'useAttribute');
  function g(b) {
    return Me(b) ? h(b, 'title') : null;
  }
  s(g, 'computeTooltipAttributeValue');
  function v(b) {
    if (!Me(b)) return null;
    if (o0(b)) {
      r.add(b);
      for (var S = Ft(b.childNodes), R = 0; R < S.length; R += 1) {
        var I = S[R];
        if (s0(I)) return E(I, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (t0(b)) {
      r.add(b);
      for (var $ = Ft(b.childNodes), x = 0; x < $.length; x += 1) {
        var A = $[x];
        if (qm(A)) return E(A, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (l0(b)) {
      r.add(b);
      for (var w = Ft(b.childNodes), _ = 0; _ < w.length; _ += 1) {
        var j = w[_];
        if (c0(j)) return j.textContent;
      }
      return null;
    } else if (pt(b) === 'img' || pt(b) === 'area') {
      var N = h(b, 'alt');
      if (N !== null) return N;
    } else if (Z_(b)) {
      var V = h(b, 'label');
      if (V !== null) return V;
    }
    if (Us(b) && (b.type === 'button' || b.type === 'submit' || b.type === 'reset')) {
      var H = h(b, 'value');
      if (H !== null) return H;
      if (b.type === 'submit') return 'Submit';
      if (b.type === 'reset') return 'Reset';
    }
    var P = T0(b);
    if (P !== null && P.length !== 0)
      return (
        r.add(b),
        Ft(P)
          .map(function (K) {
            return E(K, { isEmbeddedInLabel: !0, isReferenced: !1, recursion: !0 });
          })
          .filter(function (K) {
            return K.length > 0;
          })
          .join(' ')
      );
    if (Us(b) && b.type === 'image') {
      var D = h(b, 'alt');
      if (D !== null) return D;
      var F = h(b, 'title');
      return F !== null ? F : 'Submit Query';
    }
    if (ir(b, ['button'])) {
      var k = m(b, { isEmbeddedInLabel: !1 });
      if (k !== '') return k;
    }
    return null;
  }
  s(v, 'computeElementTextAlternative');
  function E(b, S) {
    if (r.has(b)) return '';
    if (!f && d0(b, u) && !S.isReferenced) return (r.add(b), '');
    var R = Me(b) ? b.getAttributeNode('aria-labelledby') : null,
      I = R !== null && !r.has(R) ? li(b, 'aria-labelledby') : [];
    if (i === 'name' && !S.isReferenced && I.length > 0)
      return (
        r.add(R),
        I.map(function (N) {
          return E(N, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !0, recursion: !1 });
        }).join(' ')
      );
    var $ = S.recursion && p0(b) && i === 'name';
    if (!$) {
      var x = ((Me(b) && b.getAttribute('aria-label')) || '').trim();
      if (x !== '' && i === 'name') return (r.add(b), x);
      if (!m0(b)) {
        var A = v(b);
        if (A !== null) return (r.add(b), A);
      }
    }
    if (ir(b, ['menu'])) return (r.add(b), '');
    if ($ || S.isEmbeddedInLabel || S.isReferenced) {
      if (ir(b, ['combobox', 'listbox'])) {
        r.add(b);
        var w = f0(b);
        return w.length === 0
          ? Us(b)
            ? b.value
            : ''
          : Ft(w)
              .map(function (N) {
                return E(N, {
                  isEmbeddedInLabel: S.isEmbeddedInLabel,
                  isReferenced: !1,
                  recursion: !0,
                });
              })
              .join(' ');
      }
      if (Mm(b, 'range'))
        return (
          r.add(b),
          b.hasAttribute('aria-valuetext')
            ? b.getAttribute('aria-valuetext')
            : b.hasAttribute('aria-valuenow')
              ? b.getAttribute('aria-valuenow')
              : b.getAttribute('value') || ''
        );
      if (ir(b, ['textbox'])) return (r.add(b), b0(b));
    }
    if (h0(b) || (Me(b) && S.isReferenced) || y0(b) || g0()) {
      var _ = m(b, { isEmbeddedInLabel: S.isEmbeddedInLabel });
      if (_ !== '') return (r.add(b), _);
    }
    if (b.nodeType === b.TEXT_NODE) return (r.add(b), b.textContent || '');
    if (S.recursion) return (r.add(b), m(b, { isEmbeddedInLabel: S.isEmbeddedInLabel }));
    var j = g(b);
    return j !== null ? (r.add(b), j) : (r.add(b), '');
  }
  return (
    s(E, 'computeTextAlternative'),
    u0(E(e, { isEmbeddedInLabel: !1, isReferenced: i === 'description', recursion: !1 }))
  );
}
s(Dm, 'computeTextAlternative');
function Po(e) {
  '@babel/helpers - typeof';
  return (
    (Po =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    Po(e)
  );
}
s(Po, '_typeof');
function fd(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    (t &&
      (n = n.filter(function (o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })),
      r.push.apply(r, n));
  }
  return r;
}
s(fd, 'ownKeys');
function md(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? fd(Object(r), !0).forEach(function (n) {
          w0(e, n, r[n]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : fd(Object(r)).forEach(function (n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
          });
  }
  return e;
}
s(md, '_objectSpread');
function w0(e, t, r) {
  return (
    (t = S0(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(w0, '_defineProperty');
function S0(e) {
  var t = _0(e, 'string');
  return Po(t) === 'symbol' ? t : String(t);
}
s(S0, '_toPropertyKey');
function _0(e, t) {
  if (Po(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (Po(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
s(_0, '_toPrimitive');
function A0(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = li(e, 'aria-describedby')
      .map(function (i) {
        return Dm(i, md(md({}, t), {}, { compute: 'description' }));
      })
      .join(' ');
  if (r === '') {
    var n = e.getAttribute('aria-description');
    r = n === null ? '' : n;
  }
  if (r === '') {
    var o = e.getAttribute('title');
    r = o === null ? '' : o;
  }
  return r;
}
s(A0, 'computeAccessibleDescription');
function R0(e) {
  return ir(e, [
    'caption',
    'code',
    'deletion',
    'emphasis',
    'generic',
    'insertion',
    'none',
    'paragraph',
    'presentation',
    'strong',
    'subscript',
    'superscript',
  ]);
}
s(R0, 'prohibitsNaming');
function P0(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return R0(e) ? '' : Dm(e, t);
}
s(P0, 'computeAccessibleName');
var Lm = Ke(Fp(), 1),
  KB = Ke(Uv(), 1),
  YB = Ke(Vv(), 1),
  x0 = class extends Error {
    constructor(t, r, n, o) {
      (super(), Error.captureStackTrace && Error.captureStackTrace(this, n));
      let i = '';
      try {
        i = o.utils.printWithType('Received', r, o.utils.printReceived);
      } catch {}
      this.message = [
        o.utils.matcherHint(`${o.isNot ? '.not' : ''}.${n.name}`, 'received', ''),
        '',
        `${o.utils.RECEIVED_COLOR('received')} value must ${t}.`,
        i,
      ].join(`
`);
    }
  };
s(x0, 'GenericTypeError');
var O0 = x0,
  C0 = class extends O0 {
    constructor(...t) {
      super('be an HTMLElement or an SVGElement', ...t);
    }
  };
s(C0, 'HtmlElementTypeError');
var pb = C0,
  I0 = class extends O0 {
    constructor(...t) {
      super('be a Node', ...t);
    }
  };
s(I0, 'NodeTypeError');
var fb = I0;
function Fm(e, t, ...r) {
  if (!e || !e.ownerDocument || !e.ownerDocument.defaultView) throw new t(e, ...r);
}
s(Fm, 'checkHasWindow');
function N0(e, ...t) {
  Fm(e, fb, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.Node)) throw new fb(e, ...t);
}
s(N0, 'checkNode');
function we(e, ...t) {
  Fm(e, pb, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.HTMLElement) && !(e instanceof r.SVGElement)) throw new pb(e, ...t);
}
s(we, 'checkHtmlElement');
var $0 = class extends Error {
  constructor(t, r, n) {
    (super(),
      Error.captureStackTrace && Error.captureStackTrace(this, r),
      (this.message = [
        t.message,
        '',
        n.utils.RECEIVED_COLOR('Failing css:'),
        n.utils.RECEIVED_COLOR(`${t.css}`),
      ].join(`
`)));
  }
};
s($0, 'InvalidCSSError');
var XB = $0;
function q0(e, ...t) {
  const r = JB(`selector { ${e} }`, { silent: !0 }).stylesheet;
  if (r.parsingErrors && r.parsingErrors.length > 0) {
    const { reason: o, line: i } = r.parsingErrors[0];
    throw new XB(
      { css: e, message: `Syntax error parsing expected css: ${o} on line: ${i}` },
      ...t,
    );
  }
  return r.rules[0].declarations
    .filter((o) => o.type === 'declaration')
    .reduce((o, { property: i, value: a }) => Object.assign(o, { [i]: a }), {});
}
s(q0, 'parseCSS');
function yd(e, t) {
  return typeof t == 'string' ? t : e.utils.stringify(t);
}
s(yd, 'display');
function We(e, t, r, n, o, i) {
  return [
    `${t}
`,
    `${r}:
${e.utils.EXPECTED_COLOR((0, ub.default)(yd(e, n), 2))}`,
    `${o}:
${e.utils.RECEIVED_COLOR((0, ub.default)(yd(e, i), 2))}`,
  ].join(`
`);
}
s(We, 'getMessage');
function M0(e, t) {
  return t instanceof RegExp ? t.test(e) : e.includes(String(t));
}
s(M0, 'matches');
function ki(e, t) {
  console.warn(`Warning: ${e} has been deprecated and will be removed in future updates.`, t);
}
s(ki, 'deprecate');
function Di(e) {
  return e.replace(/\s+/g, ' ').trim();
}
s(Di, 'normalize');
function Nr(e) {
  return e.tagName && e.tagName.toLowerCase();
}
s(Nr, 'getTag');
function j0({ multiple: e, options: t }) {
  const r = [...t].filter((n) => n.selected);
  if (e) return [...r].map((n) => n.value);
  if (r.length !== 0) return r[0].value;
}
s(j0, 'getSelectValue');
function k0(e) {
  switch (e.type) {
    case 'number':
      return e.value === '' ? null : Number(e.value);
    case 'checkbox':
      return e.checked;
    default:
      return e.value;
  }
}
s(k0, 'getInputValue');
var QB = ['meter', 'progressbar', 'slider', 'spinbutton'];
function D0(e) {
  if (QB.includes(e.getAttribute('role'))) return Number(e.getAttribute('aria-valuenow'));
}
s(D0, 'getAccessibleValue');
function Bm(e) {
  if (e)
    switch (e.tagName.toLowerCase()) {
      case 'input':
        return k0(e);
      case 'select':
        return j0(e);
      default:
        return e.value ?? D0(e);
    }
}
s(Bm, 'getSingleElementValue');
function L0(e, { wordConnector: t = ', ', lastWordConnector: r = ' and ' } = {}) {
  return [e.slice(0, -1).join(t), e[e.length - 1]].join(e.length > 1 ? r : '');
}
s(L0, 'toSentence');
function wc(e, t) {
  return Array.isArray(e) && Array.isArray(t)
    ? [...new Set(e)].every((r) => new Set(t).has(r))
    : e === t;
}
s(wc, 'compareAsSet');
function Ba(e, t) {
  return (
    ki(
      'toBeInTheDOM',
      'Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container.',
    ),
    e && we(e, Ba, this),
    t && we(t, Ba, this),
    {
      pass: t ? t.contains(e) : !!e,
      message: s(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInTheDOM`, 'element', ''),
            '',
            'Received:',
            `  ${this.utils.printReceived(e && e.cloneNode(!1))}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(Ba, 'toBeInTheDOM');
function Jm(e) {
  (e !== null || !this.isNot) && we(e, Jm, this);
  const t = e === null ? !1 : e.ownerDocument === e.getRootNode({ composed: !0 }),
    r = s(
      () =>
        `expected document not to contain element, found ${this.utils.stringify(e.cloneNode(!0))} instead`,
      'errorFound',
    ),
    n = s(() => 'element could not be found in the document', 'errorNotFound');
  return {
    pass: t,
    message: s(
      () =>
        [
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInTheDocument`, 'element', ''),
          '',
          this.utils.RECEIVED_COLOR(this.isNot ? r() : n()),
        ].join(`
`),
      'message',
    ),
  };
}
s(Jm, 'toBeInTheDocument');
function Um(e) {
  return (
    ki('toBeEmpty', 'Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM.'),
    we(e, Um, this),
    {
      pass: e.innerHTML === '',
      message: s(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeEmpty`, 'element', ''),
            '',
            'Received:',
            `  ${this.utils.printReceived(e.innerHTML)}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(Um, 'toBeEmpty');
function Vm(e) {
  return (
    we(e, Vm, this),
    {
      pass: F0(e),
      message: s(
        () =>
          [
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toBeEmptyDOMElement`,
              'element',
              '',
            ),
            '',
            'Received:',
            `  ${this.utils.printReceived(e.innerHTML)}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(Vm, 'toBeEmptyDOMElement');
function F0(e) {
  return [...e.childNodes].filter((r) => r.nodeType !== 8).length === 0;
}
s(F0, 'isEmptyElement');
function Ja(e, t) {
  return (
    we(e, Ja, this),
    t !== null && we(t, Ja, this),
    {
      pass: e.contains(t),
      message: s(
        () =>
          [
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toContainElement`,
              'element',
              'element',
            ),
            '',
            this.utils
              .RECEIVED_COLOR(`${this.utils.stringify(e.cloneNode(!1))} ${this.isNot ? 'contains:' : 'does not contain:'} ${this.utils.stringify(t && t.cloneNode(!1))}
        `),
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(Ja, 'toContainElement');
function B0(e, t) {
  const r = e.ownerDocument.createElement('div');
  return ((r.innerHTML = t), r.innerHTML);
}
s(B0, 'getNormalizedHtml');
function Hm(e, t) {
  if ((we(e, Hm, this), typeof t != 'string'))
    throw new Error(`.toContainHTML() expects a string value, got ${t}`);
  return {
    pass: e.outerHTML.includes(B0(e, t)),
    message: s(
      () =>
        [
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toContainHTML`, 'element', ''),
          'Expected:',
          `  ${this.utils.EXPECTED_COLOR(t)}`,
          'Received:',
          `  ${this.utils.printReceived(e.cloneNode(!0))}`,
        ].join(`
`),
      'message',
    ),
  };
}
s(Hm, 'toContainHTML');
function zm(e, t, r = { normalizeWhitespace: !0 }) {
  N0(e, zm, this);
  const n = r.normalizeWhitespace ? Di(e.textContent) : e.textContent.replace(/\u00a0/g, ' '),
    o = n !== '' && t === '';
  return {
    pass: !o && M0(n, t),
    message: s(() => {
      const i = this.isNot ? 'not to' : 'to';
      return We(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveTextContent`, 'element', ''),
        o
          ? 'Checking with empty string will always match, use .toBeEmptyDOMElement() instead'
          : `Expected element ${i} have text content`,
        t,
        'Received',
        n,
      );
    }, 'message'),
  };
}
s(zm, 'toHaveTextContent');
function Ua(e, t) {
  we(e, Ua, this);
  const r = A0(e),
    n = arguments.length === 1;
  let o = !1;
  return (
    n ? (o = r !== '') : (o = t instanceof RegExp ? t.test(r) : this.equals(r, t)),
    {
      pass: o,
      message: s(() => {
        const i = this.isNot ? 'not to' : 'to';
        return We(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${Ua.name}`, 'element', ''),
          `Expected element ${i} have accessible description`,
          t,
          'Received',
          r,
        );
      }, 'message'),
    }
  );
}
s(Ua, 'toHaveAccessibleDescription');
var Rs = 'aria-invalid',
  ZB = ['false'];
function Gm(e, t) {
  we(e, Gm, this);
  const r = this.isNot ? 'not to' : 'to',
    n = this.isNot ? '.not.toHaveAccessibleErrorMessage' : '.toHaveAccessibleErrorMessage',
    o = e.getAttribute('aria-errormessage');
  if (!!o && /\s+/.test(o))
    return {
      pass: !1,
      message: s(
        () =>
          We(
            this,
            this.utils.matcherHint(n, 'element'),
            "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
            '',
            'Received',
            `aria-errormessage="${o}"`,
          ),
        'message',
      ),
    };
  const a = e.getAttribute(Rs);
  if (!e.hasAttribute(Rs) || ZB.includes(a))
    return {
      pass: !1,
      message: s(
        () =>
          We(
            this,
            this.utils.matcherHint(n, 'element'),
            'Expected element to be marked as invalid with attribute',
            `${Rs}="${String(!0)}"`,
            'Received',
            e.hasAttribute('aria-invalid') ? `${Rs}="${e.getAttribute(Rs)}` : null,
          ),
        'message',
      ),
    };
  const d = Di(e.ownerDocument.getElementById(o)?.textContent ?? '');
  return {
    pass: t === void 0 ? !!d : t instanceof RegExp ? t.test(d) : this.equals(d, t),
    message: s(
      () =>
        We(
          this,
          this.utils.matcherHint(n, 'element'),
          `Expected element ${r} have accessible error message`,
          t ?? '',
          'Received',
          d,
        ),
      'message',
    ),
  };
}
s(Gm, 'toHaveAccessibleErrorMessage');
var eJ = V0(Lm.elementRoles);
function Va(e, t) {
  we(e, Va, this);
  const r = J0(e);
  return {
    pass: r.some((o) => o === t),
    message: s(() => {
      const o = this.isNot ? 'not to' : 'to';
      return We(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${Va.name}`, 'element', ''),
        `Expected element ${o} have role`,
        t,
        'Received',
        r.join(', '),
      );
    }, 'message'),
  };
}
s(Va, 'toHaveRole');
function J0(e) {
  return e.hasAttribute('role') ? e.getAttribute('role').split(' ').filter(Boolean) : U0(e);
}
s(J0, 'getExplicitOrImplicitRoles');
function U0(e) {
  for (const { match: t, roles: r } of eJ) if (t(e)) return [...r];
  return [];
}
s(U0, 'getImplicitAriaRoles');
function V0(e) {
  function t({ name: a, attributes: l }) {
    return `${a}${l.map(({ name: d, value: u, constraints: p = [] }) => (p.indexOf('undefined') !== -1 ? `:not([${d}])` : u ? `[${d}="${u}"]` : `[${d}]`)).join('')}`;
  }
  s(t, 'makeElementSelector');
  function r({ attributes: a = [] }) {
    return a.length;
  }
  s(r, 'getSelectorSpecificity');
  function n({ specificity: a }, { specificity: l }) {
    return l - a;
  }
  s(n, 'bySelectorSpecificity');
  function o(a) {
    let { attributes: l = [] } = a;
    const d = l.findIndex((p) => p.value && p.name === 'type' && p.value === 'text');
    d >= 0 && (l = [...l.slice(0, d), ...l.slice(d + 1)]);
    const u = t({ ...a, attributes: l });
    return (p) => (d >= 0 && p.type !== 'text' ? !1 : p.matches(u));
  }
  s(o, 'match');
  let i = [];
  for (const [a, l] of e.entries())
    i = [...i, { match: o(a), roles: Array.from(l), specificity: r(a) }];
  return i.sort(n);
}
s(V0, 'buildElementRoleList');
function Ha(e, t) {
  we(e, Ha, this);
  const r = P0(e),
    n = arguments.length === 1;
  let o = !1;
  return (
    n ? (o = r !== '') : (o = t instanceof RegExp ? t.test(r) : this.equals(r, t)),
    {
      pass: o,
      message: s(() => {
        const i = this.isNot ? 'not to' : 'to';
        return We(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${Ha.name}`, 'element', ''),
          `Expected element ${i} have accessible name`,
          t,
          'Received',
          r,
        );
      }, 'message'),
    }
  );
}
s(Ha, 'toHaveAccessibleName');
function hd(e, t, r) {
  return r === void 0 ? t : `${t}=${e(r)}`;
}
s(hd, 'printAttribute');
function H0(e, t, r) {
  return r === void 0
    ? `element.hasAttribute(${e(t)})`
    : `element.getAttribute(${e(t)}) === ${e(r)}`;
}
s(H0, 'getAttributeComment');
function Wm(e, t, r) {
  we(e, Wm, this);
  const n = r !== void 0,
    o = e.hasAttribute(t),
    i = e.getAttribute(t);
  return {
    pass: n ? o && this.equals(i, r) : o,
    message: s(() => {
      const a = this.isNot ? 'not to' : 'to',
        l = o ? hd(this.utils.stringify, t, i) : null,
        d = this.utils.matcherHint(
          `${this.isNot ? '.not' : ''}.toHaveAttribute`,
          'element',
          this.utils.printExpected(t),
          {
            secondArgument: n ? this.utils.printExpected(r) : void 0,
            comment: H0(this.utils.stringify, t, r),
          },
        );
      return We(
        this,
        d,
        `Expected the element ${a} have attribute`,
        hd(this.utils.stringify, t, r),
        'Received',
        l,
      );
    }, 'message'),
  };
}
s(Wm, 'toHaveAttribute');
function z0(e) {
  const t = e.pop();
  let r, n;
  return (
    typeof t == 'object' && !(t instanceof RegExp)
      ? ((r = e), (n = t))
      : ((r = e.concat(t)), (n = { exact: !1 })),
    { expectedClassNames: r, options: n }
  );
}
s(z0, 'getExpectedClassNamesAndOptions');
function gd(e) {
  return e ? e.split(/\s+/).filter((t) => t.length > 0) : [];
}
s(gd, 'splitClassNames');
function bd(e, t) {
  return e.every((r) => (typeof r == 'string' ? t.includes(r) : t.some((n) => r.test(n))));
}
s(bd, 'isSubset$1');
function Km(e, ...t) {
  we(e, Km, this);
  const { expectedClassNames: r, options: n } = z0(t),
    o = gd(e.getAttribute('class')),
    i = r.reduce((l, d) => l.concat(typeof d == 'string' || !d ? gd(d) : d), []),
    a = i.some((l) => l instanceof RegExp);
  if (n.exact && a) throw new Error('Exact option does not support RegExp expected class names');
  return n.exact
    ? {
        pass: bd(i, o) && i.length === o.length,
        message: s(() => {
          const l = this.isNot ? 'not to' : 'to';
          return We(
            this,
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toHaveClass`,
              'element',
              this.utils.printExpected(i.join(' ')),
            ),
            `Expected the element ${l} have EXACTLY defined classes`,
            i.join(' '),
            'Received',
            o.join(' '),
          );
        }, 'message'),
      }
    : i.length > 0
      ? {
          pass: bd(i, o),
          message: s(() => {
            const l = this.isNot ? 'not to' : 'to';
            return We(
              this,
              this.utils.matcherHint(
                `${this.isNot ? '.not' : ''}.toHaveClass`,
                'element',
                this.utils.printExpected(i.join(' ')),
              ),
              `Expected the element ${l} have class`,
              i.join(' '),
              'Received',
              o.join(' '),
            );
          }, 'message'),
        }
      : {
          pass: this.isNot ? o.length > 0 : !1,
          message: s(
            () =>
              this.isNot
                ? We(
                    this,
                    this.utils.matcherHint('.not.toHaveClass', 'element', ''),
                    'Expected the element to have classes',
                    '(none)',
                    'Received',
                    o.join(' '),
                  )
                : [
                    this.utils.matcherHint('.toHaveClass', 'element'),
                    'At least one expected class must be provided.',
                  ].join(`
`),
            'message',
          ),
        };
}
s(Km, 'toHaveClass');
function G0(e, t) {
  const r = {},
    n = e.createElement('div');
  return (
    Object.keys(t).forEach((o) => {
      ((n.style[o] = t[o]), (r[o] = n.style[o]));
    }),
    r
  );
}
s(G0, 'getStyleDeclaration');
function W0(e, t) {
  return (
    !!Object.keys(e).length &&
    Object.entries(e).every(([r, n]) => {
      const o = r.startsWith('--'),
        i = [r];
      return (
        o || i.push(r.toLowerCase()),
        i.some((a) => t[a] === n || t.getPropertyValue(a) === n)
      );
    })
  );
}
s(W0, 'isSubset');
function vd(e) {
  return Object.keys(e)
    .sort()
    .map((t) => `${t}: ${e[t]};`).join(`
`);
}
s(vd, 'printoutStyles');
function K0(e, t, r) {
  const n = Array.from(r)
    .filter((i) => t[i] !== void 0)
    .reduce((i, a) => Object.assign(i, { [a]: r.getPropertyValue(a) }), {});
  return e(vd(t), vd(n)).replace(
    `${KB.default.red('+ Received')}
`,
    '',
  );
}
s(K0, 'expectedDiff');
function za(e, t) {
  we(e, za, this);
  const r = typeof t == 'object' ? t : q0(t, za, this),
    { getComputedStyle: n } = e.ownerDocument.defaultView,
    o = G0(e.ownerDocument, r),
    i = n(e);
  return {
    pass: W0(o, i),
    message: s(() => {
      const a = `${this.isNot ? '.not' : ''}.toHaveStyle`;
      return [this.utils.matcherHint(a, 'element', ''), K0(this.utils.diff, o, i)].join(`

`);
    }, 'message'),
  };
}
s(za, 'toHaveStyle');
function Ym(e) {
  return (
    we(e, Ym, this),
    {
      pass: e.ownerDocument.activeElement === e,
      message: s(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveFocus`, 'element', ''),
            '',
            ...(this.isNot
              ? ['Received element is focused:', `  ${this.utils.printReceived(e)}`]
              : [
                  'Expected element with focus:',
                  `  ${this.utils.printExpected(e)}`,
                  'Received element with focus:',
                  `  ${this.utils.printReceived(e.ownerDocument.activeElement)}`,
                ]),
          ].join(`
`),
        'message',
      ),
    }
  );
}
s(Ym, 'toHaveFocus');
function Y0(e) {
  const t = [...new Set(e.map((r) => r.type))];
  if (t.length !== 1)
    throw new Error('Multiple form elements with the same name must be of the same type');
  switch (t[0]) {
    case 'radio': {
      const r = e.find((n) => n.checked);
      return r ? r.value : void 0;
    }
    case 'checkbox':
      return e.filter((r) => r.checked).map((r) => r.value);
    default:
      return e.map((r) => r.value);
  }
}
s(Y0, 'getMultiElementValue');
function X0(e, t) {
  const r = [...e.querySelectorAll(`[name="${(0, YB.default)(t)}"]`)];
  if (r.length !== 0)
    switch (r.length) {
      case 1:
        return Bm(r[0]);
      default:
        return Y0(r);
    }
}
s(X0, 'getFormValue');
function Q0(e) {
  return /\[\]$/.test(e) ? e.slice(0, -2) : e;
}
s(Q0, 'getPureName');
function Z0(e) {
  return Array.from(e.elements)
    .map((r) => r.name)
    .reduce((r, n) => ({ ...r, [Q0(n)]: X0(e, n) }), {});
}
s(Z0, 'getAllFormValues');
function Xm(e, t) {
  if ((we(e, Xm, this), !e.elements))
    throw new Error('toHaveFormValues must be called on a form or a fieldset');
  const r = Z0(e);
  return {
    pass: Object.entries(t).every(([n, o]) => wc(r[n], o)),
    message: s(() => {
      const n = this.isNot ? 'not to' : 'to',
        o = `${this.isNot ? '.not' : ''}.toHaveFormValues`,
        i = Object.keys(r)
          .filter((a) => t.hasOwnProperty(a))
          .reduce((a, l) => ({ ...a, [l]: r[l] }), {});
      return [
        this.utils.matcherHint(o, 'element', ''),
        `Expected the element ${n} have form values`,
        this.utils.diff(t, i),
      ].join(`

`);
    }, 'message'),
  };
}
s(Xm, 'toHaveFormValues');
function eA(e) {
  const { getComputedStyle: t } = e.ownerDocument.defaultView,
    { display: r, visibility: n, opacity: o } = t(e);
  return r !== 'none' && n !== 'hidden' && n !== 'collapse' && o !== '0' && o !== 0;
}
s(eA, 'isStyleVisible');
function tA(e, t) {
  let r;
  return (
    t
      ? (r = e.nodeName === 'DETAILS' && t.nodeName !== 'SUMMARY' ? e.hasAttribute('open') : !0)
      : (r = e.nodeName === 'DETAILS' ? e.hasAttribute('open') : !0),
    !e.hasAttribute('hidden') && r
  );
}
s(tA, 'isAttributeVisible');
function Qm(e, t) {
  return eA(e) && tA(e, t) && (!e.parentElement || Qm(e.parentElement, e));
}
s(Qm, 'isElementVisible');
function Zm(e) {
  we(e, Zm, this);
  const t = e.ownerDocument === e.getRootNode({ composed: !0 }),
    r = t && Qm(e);
  return {
    pass: r,
    message: s(() => {
      const n = r ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeVisible`, 'element', ''),
        '',
        `Received element ${n} visible${t ? '' : ' (element is not in the document)'}:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(Zm, 'toBeVisible');
var tJ = ['fieldset', 'input', 'select', 'optgroup', 'option', 'button', 'textarea'];
function rA(e, t) {
  return (
    Nr(e) === 'legend' &&
    Nr(t) === 'fieldset' &&
    e.isSameNode(Array.from(t.children).find((r) => Nr(r) === 'legend'))
  );
}
s(rA, 'isFirstLegendChildOfFieldset');
function nA(e, t) {
  return ty(t) && !rA(e, t);
}
s(nA, 'isElementDisabledByParent');
function oA(e) {
  return e.includes('-');
}
s(oA, 'isCustomElement');
function ey(e) {
  const t = Nr(e);
  return tJ.includes(t) || oA(t);
}
s(ey, 'canElementBeDisabled');
function ty(e) {
  return ey(e) && e.hasAttribute('disabled');
}
s(ty, 'isElementDisabled');
function ry(e) {
  const t = e.parentElement;
  return !!t && (nA(e, t) || ry(t));
}
s(ry, 'isAncestorDisabled');
function ny(e) {
  return ey(e) && (ty(e) || ry(e));
}
s(ny, 'isElementOrAncestorDisabled');
function oy(e) {
  we(e, oy, this);
  const t = ny(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeDisabled`, 'element', ''),
        '',
        `Received element ${r} disabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(oy, 'toBeDisabled');
function sy(e) {
  we(e, sy, this);
  const t = !ny(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeEnabled`, 'element', ''),
        '',
        `Received element ${r} enabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(sy, 'toBeEnabled');
var rJ = ['select', 'textarea'],
  nJ = ['input', 'select', 'textarea'],
  oJ = ['color', 'hidden', 'range', 'submit', 'image', 'reset'],
  sJ = [
    'checkbox',
    'combobox',
    'gridcell',
    'listbox',
    'radiogroup',
    'spinbutton',
    'textbox',
    'tree',
  ];
function sA(e) {
  return rJ.includes(Nr(e)) && e.hasAttribute('required');
}
s(sA, 'isRequiredOnFormTagsExceptInput');
function iA(e) {
  return (
    Nr(e) === 'input' &&
    e.hasAttribute('required') &&
    ((e.hasAttribute('type') && !oJ.includes(e.getAttribute('type'))) || !e.hasAttribute('type'))
  );
}
s(iA, 'isRequiredOnSupportedInput');
function aA(e) {
  return (
    e.hasAttribute('aria-required') &&
    e.getAttribute('aria-required') === 'true' &&
    (nJ.includes(Nr(e)) || (e.hasAttribute('role') && sJ.includes(e.getAttribute('role'))))
  );
}
s(aA, 'isElementRequiredByARIA');
function iy(e) {
  we(e, iy, this);
  const t = sA(e) || iA(e) || aA(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeRequired`, 'element', ''),
        '',
        `Received element ${r} required:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(iy, 'toBeRequired');
var iJ = ['form', 'input', 'select', 'textarea'];
function lA(e) {
  return e.hasAttribute('aria-invalid') && e.getAttribute('aria-invalid') !== 'false';
}
s(lA, 'isElementHavingAriaInvalid');
function cA(e) {
  return iJ.includes(Nr(e));
}
s(cA, 'isSupportsValidityMethod');
function ay(e) {
  const t = lA(e);
  return cA(e) ? t || !e.checkValidity() : t;
}
s(ay, 'isElementInvalid');
function ly(e) {
  we(e, ly, this);
  const t = ay(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInvalid`, 'element', ''),
        '',
        `Received element ${r} currently invalid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(ly, 'toBeInvalid');
function cy(e) {
  we(e, cy, this);
  const t = !ay(e);
  return {
    pass: t,
    message: s(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeValid`, 'element', ''),
        '',
        `Received element ${r} currently valid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(cy, 'toBeValid');
function uy(e, t) {
  if (
    (we(e, uy, this), e.tagName.toLowerCase() === 'input' && ['checkbox', 'radio'].includes(e.type))
  )
    throw new Error(
      'input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead',
    );
  const r = Bm(e),
    n = t !== void 0;
  let o = t,
    i = r;
  return (
    t == r && t !== r && ((o = `${t} (${typeof t})`), (i = `${r} (${typeof r})`)),
    {
      pass: n ? wc(r, t) : !!r,
      message: s(() => {
        const a = this.isNot ? 'not to' : 'to',
          l = this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveValue`, 'element', t);
        return We(this, l, `Expected the element ${a} have value`, n ? o : '(any)', 'Received', i);
      }, 'message'),
    }
  );
}
s(uy, 'toHaveValue');
function dy(e, t) {
  we(e, dy, this);
  const r = e.tagName.toLowerCase();
  if (!['select', 'input', 'textarea'].includes(r))
    throw new Error(
      '.toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead.',
    );
  if (r === 'input' && ['radio', 'checkbox'].includes(e.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${e.type}"], try with another matcher instead.`,
    );
  const n = uA(r, e),
    o = dA(t),
    i = o.filter((d) =>
      n.some((u) => (d instanceof RegExp ? d.test(u) : this.equals(u, String(d)))),
    ).length,
    a = i === n.length,
    l = i === o.length;
  return {
    pass: a && l,
    message: s(
      () =>
        We(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveDisplayValue`, 'element', ''),
          `Expected element ${this.isNot ? 'not ' : ''}to have display value`,
          t,
          'Received',
          n,
        ),
      'message',
    ),
  };
}
s(dy, 'toHaveDisplayValue');
function uA(e, t) {
  return e === 'select'
    ? Array.from(t)
        .filter((r) => r.selected)
        .map((r) => r.textContent)
    : [t.value];
}
s(uA, 'getValues');
function dA(e) {
  return e instanceof Array ? e : [e];
}
s(dA, 'getExpectedValues');
function py(e) {
  we(e, py, this);
  const t = s(
      () => e.tagName.toLowerCase() === 'input' && ['checkbox', 'radio'].includes(e.type),
      'isValidInput',
    ),
    r = s(
      () =>
        fy(e.getAttribute('role')) && ['true', 'false'].includes(e.getAttribute('aria-checked')),
      'isValidAriaElement',
    );
  if (!t() && !r())
    return {
      pass: !1,
      message: s(
        () =>
          `only inputs with type="checkbox" or type="radio" or elements with ${pA()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`,
        'message',
      ),
    };
  const n = s(() => (t() ? e.checked : e.getAttribute('aria-checked') === 'true'), 'isChecked');
  return {
    pass: n(),
    message: s(() => {
      const o = n() ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeChecked`, 'element', ''),
        '',
        `Received element ${o} checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(py, 'toBeChecked');
function pA() {
  return L0(
    fA().map((e) => `role="${e}"`),
    { lastWordConnector: ' or ' },
  );
}
s(pA, 'supportedRolesSentence');
function fA() {
  return Lm.roles.keys().filter(fy);
}
s(fA, 'supportedRoles');
function fy(e) {
  return Lm.roles.get(e)?.props['aria-checked'] !== void 0;
}
s(fy, 'roleSupportsChecked');
function my(e) {
  we(e, my, this);
  const t = s(() => e.tagName.toLowerCase() === 'input' && e.type === 'checkbox', 'isValidInput'),
    r = s(() => e.getAttribute('role') === 'checkbox', 'isValidAriaElement');
  if (!t() && !r())
    return {
      pass: !1,
      message: s(
        () =>
          'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead',
        'message',
      ),
    };
  const n = s(() => {
    const o = e.getAttribute('aria-checked') === 'mixed';
    return (t() && e.indeterminate) || o;
  }, 'isPartiallyChecked');
  return {
    pass: n(),
    message: s(() => {
      const o = n() ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBePartiallyChecked`, 'element', ''),
        '',
        `Received element ${o} partially checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
s(my, 'toBePartiallyChecked');
function yy(e, t) {
  (ki('toHaveDescription', 'Please use toHaveAccessibleDescription.'), we(e, yy, this));
  const r = t !== void 0,
    o = (e.getAttribute('aria-describedby') || '').split(/\s+/).filter(Boolean);
  let i = '';
  if (o.length > 0) {
    const a = e.ownerDocument,
      l = o.map((d) => a.getElementById(d)).filter(Boolean);
    i = Di(l.map((d) => d.textContent).join(' '));
  }
  return {
    pass: r ? (t instanceof RegExp ? t.test(i) : this.equals(i, t)) : !!i,
    message: s(() => {
      const a = this.isNot ? 'not to' : 'to';
      return We(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveDescription`, 'element', ''),
        `Expected the element ${a} have description`,
        this.utils.printExpected(t),
        'Received',
        this.utils.printReceived(i),
      );
    }, 'message'),
  };
}
s(yy, 'toHaveDescription');
function hy(e, t) {
  if (
    (ki('toHaveErrorMessage', 'Please use toHaveAccessibleErrorMessage.'),
    we(e, hy, this),
    !e.hasAttribute('aria-invalid') || e.getAttribute('aria-invalid') === 'false')
  ) {
    const a = this.isNot ? '.not' : '';
    return {
      pass: !1,
      message: s(
        () =>
          We(
            this,
            this.utils.matcherHint(`${a}.toHaveErrorMessage`, 'element', ''),
            'Expected the element to have invalid state indicated by',
            'aria-invalid="true"',
            'Received',
            e.hasAttribute('aria-invalid')
              ? `aria-invalid="${e.getAttribute('aria-invalid')}"`
              : this.utils.printReceived(''),
          ),
        'message',
      ),
    };
  }
  const r = t !== void 0,
    o = (e.getAttribute('aria-errormessage') || '').split(/\s+/).filter(Boolean);
  let i = '';
  if (o.length > 0) {
    const a = e.ownerDocument,
      l = o.map((d) => a.getElementById(d)).filter(Boolean);
    i = Di(l.map((d) => d.textContent).join(' '));
  }
  return {
    pass: r ? (t instanceof RegExp ? t.test(i) : this.equals(i, t)) : !!i,
    message: s(() => {
      const a = this.isNot ? 'not to' : 'to';
      return We(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveErrorMessage`, 'element', ''),
        `Expected the element ${a} have error message`,
        this.utils.printExpected(t),
        'Received',
        this.utils.printReceived(i),
      );
    }, 'message'),
  };
}
s(hy, 'toHaveErrorMessage');
function mA(e) {
  const t = e.ownerDocument.getSelection();
  if (['input', 'textarea'].includes(e.tagName.toLowerCase()))
    return ['radio', 'checkbox'].includes(e.type)
      ? ''
      : e.value.toString().substring(e.selectionStart, e.selectionEnd);
  if (t.anchorNode === null || t.focusNode === null) return '';
  const r = t.getRangeAt(0),
    n = e.ownerDocument.createRange();
  if (t.containsNode(e, !1)) (n.selectNodeContents(e), t.removeAllRanges(), t.addRange(n));
  else if (!(e.contains(t.anchorNode) && e.contains(t.focusNode))) {
    const i = e === r.startContainer || e.contains(r.startContainer),
      a = e === r.endContainer || e.contains(r.endContainer);
    (t.removeAllRanges(),
      (i || a) &&
        (n.selectNodeContents(e),
        i && n.setStart(r.startContainer, r.startOffset),
        a && n.setEnd(r.endContainer, r.endOffset),
        t.addRange(n)));
  }
  const o = t.toString();
  return (t.removeAllRanges(), t.addRange(r), o);
}
s(mA, 'getSelection');
function gy(e, t) {
  we(e, gy, this);
  const r = t !== void 0;
  if (r && typeof t != 'string')
    throw new Error('expected selection must be a string or undefined');
  const n = mA(e);
  return {
    pass: r ? wc(n, t) : !!n,
    message: s(() => {
      const o = this.isNot ? 'not to' : 'to',
        i = this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveSelection`, 'element', t);
      return We(
        this,
        i,
        `Expected the element ${o} have selection`,
        r ? t : '(any)',
        'Received',
        n,
      );
    }, 'message'),
  };
}
s(gy, 'toHaveSelection');
function by(e) {
  we(e, by, this);
  const t = (e.getAttribute('role') || '').split(' ').map((a) => a.trim()),
    r =
      e.tagName.toLowerCase() === 'button' ||
      (e.tagName.toLowerCase() === 'input' && e.type === 'button') ||
      t.includes('button'),
    n = e.getAttribute('aria-pressed');
  return !r || !(n === 'true' || n === 'false')
    ? {
        pass: !1,
        message: s(
          () =>
            'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()',
          'message',
        ),
      }
    : {
        pass: r && n === 'true',
        message: s(() => {
          const a = this.utils.matcherHint(
            `${this.isNot ? '.not' : ''}.toBePressed`,
            'element',
            '',
          );
          return We(
            this,
            a,
            'Expected element to have',
            `aria-pressed="${this.isNot ? 'false' : 'true'}"`,
            'Received',
            `aria-pressed="${n}"`,
          );
        }, 'message'),
      };
}
s(by, 'toBePressed');
function vy(e) {
  we(e, vy, this);
  const t = (e.getAttribute('role') || '').split(' ').map((a) => a.trim()),
    r =
      e.tagName.toLowerCase() === 'button' ||
      (e.tagName.toLowerCase() === 'input' && e.type === 'button') ||
      t.includes('button'),
    n = e.getAttribute('aria-pressed');
  return !r || !(n === 'true' || n === 'false' || n === 'mixed')
    ? {
        pass: !1,
        message: s(
          () =>
            'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()',
          'message',
        ),
      }
    : {
        pass: r && n === 'mixed',
        message: s(() => {
          const a = this.isNot ? 'not to' : 'to',
            l = this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toBePartiallyPressed`,
              'element',
              '',
            );
          return We(
            this,
            l,
            `Expected element ${a} have`,
            'aria-pressed="mixed"',
            'Received',
            `aria-pressed="${n}"`,
          );
        }, 'message'),
      };
}
s(vy, 'toBePartiallyPressed');
var aJ = 1,
  yA = 2,
  hA = 4,
  lJ = 8,
  cJ = 16,
  uJ = 32,
  mb = {
    [aJ]: 'Node.DOCUMENT_POSITION_DISCONNECTED',
    [yA]: 'Node.DOCUMENT_POSITION_PRECEDING',
    [hA]: 'Node.DOCUMENT_POSITION_FOLLOWING',
    [lJ]: 'Node.DOCUMENT_POSITION_CONTAINS',
    [cJ]: 'Node.DOCUMENT_POSITION_CONTAINED_BY',
    [uJ]: 'Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
  };
function gA(e) {
  return e in mb ? `${mb[e]} (${e})` : `Unknown document position (${e})`;
}
s(gA, 'makeDocumentPositionErrorString');
function Ty(e, t) {
  return function (r, n) {
    (we(r, Ga, this), we(n, Ga, this));
    const o = r.compareDocumentPosition(n);
    return {
      pass: o === t,
      message: s(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${e}`, 'element', 'secondElement'),
            '',
            `Received: ${gA(o)}`,
          ].join(`
`),
        'message',
      ),
    };
  };
}
s(Ty, 'checkToAppear');
function Ga(e, t) {
  return Ty('toAppearBefore', hA).apply(this, [e, t]);
}
s(Ga, 'toAppearBefore');
function bA(e, t) {
  return Ty('toAppearAfter', yA).apply(this, [e, t]);
}
s(bA, 'toAppearAfter');
Ke(Jv(), 1);
Ke(Fp(), 1);
Ke(Uv(), 1);
Ke(Vv(), 1);
var gu, yb;
function vA() {
  if (yb) return gu;
  yb = 1;
  var e, t, r, n, o, i, a, l, d, u, p, f, m, h, g, v, E, b, S;
  return (
    (m =
      /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy),
    (f =
      /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y),
    (e =
      /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy),
    (g = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y),
    (p =
      /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y),
    (v = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y),
    (S = /[\t\v\f\ufeff\p{Zs}]+/uy),
    (l = /\r?\n|[\r\u2028\u2029]/y),
    (d = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y),
    (h = /\/\/.*/y),
    (r = /[<>.:={}]|\/(?![\/*])/y),
    (t = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy),
    (n = /(['"])(?:(?!\1)[^])*(\1)?/y),
    (o = /[^<>{}]+/y),
    (b =
      /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/),
    (E = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/),
    (i = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/),
    (a = /^(?:return|throw|yield)$/),
    (u = RegExp(l.source)),
    (gu = s(function* (R, { jsx: I = !1 } = {}) {
      var $, x, A, w, _, j, N, V, H, P, D, F, k, K;
      for ({ length: j } = R, w = 0, _ = '', K = [{ tag: 'JS' }], $ = [], D = 0, F = !1; w < j; ) {
        switch (((V = K[K.length - 1]), V.tag)) {
          case 'JS':
          case 'JSNonExpressionParen':
          case 'InterpolationInTemplate':
          case 'InterpolationInJSX':
            if (R[w] === '/' && (b.test(_) || i.test(_)) && ((m.lastIndex = w), (N = m.exec(R)))) {
              ((w = m.lastIndex),
                (_ = N[0]),
                (F = !0),
                yield {
                  type: 'RegularExpressionLiteral',
                  value: N[0],
                  closed: N[1] !== void 0 && N[1] !== '\\',
                });
              continue;
            }
            if (((f.lastIndex = w), (N = f.exec(R)))) {
              switch (((k = N[0]), (H = f.lastIndex), (P = k), k)) {
                case '(':
                  (_ === '?NonExpressionParenKeyword' &&
                    K.push({ tag: 'JSNonExpressionParen', nesting: D }),
                    D++,
                    (F = !1));
                  break;
                case ')':
                  (D--,
                    (F = !0),
                    V.tag === 'JSNonExpressionParen' &&
                      D === V.nesting &&
                      (K.pop(), (P = '?NonExpressionParenEnd'), (F = !1)));
                  break;
                case '{':
                  ((f.lastIndex = 0),
                    (A = !E.test(_) && (b.test(_) || i.test(_))),
                    $.push(A),
                    (F = !1));
                  break;
                case '}':
                  switch (V.tag) {
                    case 'InterpolationInTemplate':
                      if ($.length === V.nesting) {
                        ((v.lastIndex = w),
                          (N = v.exec(R)),
                          (w = v.lastIndex),
                          (_ = N[0]),
                          N[1] === '${'
                            ? ((_ = '?InterpolationInTemplate'),
                              (F = !1),
                              yield { type: 'TemplateMiddle', value: N[0] })
                            : (K.pop(),
                              (F = !0),
                              yield { type: 'TemplateTail', value: N[0], closed: N[1] === '`' }));
                        continue;
                      }
                      break;
                    case 'InterpolationInJSX':
                      if ($.length === V.nesting) {
                        (K.pop(), (w += 1), (_ = '}'), yield { type: 'JSXPunctuator', value: '}' });
                        continue;
                      }
                  }
                  ((F = $.pop()), (P = F ? '?ExpressionBraceEnd' : '}'));
                  break;
                case ']':
                  F = !0;
                  break;
                case '++':
                case '--':
                  P = F ? '?PostfixIncDec' : '?UnaryIncDec';
                  break;
                case '<':
                  if (I && (b.test(_) || i.test(_))) {
                    (K.push({ tag: 'JSXTag' }),
                      (w += 1),
                      (_ = '<'),
                      yield { type: 'JSXPunctuator', value: k });
                    continue;
                  }
                  F = !1;
                  break;
                default:
                  F = !1;
              }
              ((w = H), (_ = P), yield { type: 'Punctuator', value: k });
              continue;
            }
            if (((e.lastIndex = w), (N = e.exec(R)))) {
              switch (((w = e.lastIndex), (P = N[0]), N[0])) {
                case 'for':
                case 'if':
                case 'while':
                case 'with':
                  _ !== '.' && _ !== '?.' && (P = '?NonExpressionParenKeyword');
              }
              ((_ = P),
                (F = !i.test(N[0])),
                yield { type: N[1] === '#' ? 'PrivateIdentifier' : 'IdentifierName', value: N[0] });
              continue;
            }
            if (((g.lastIndex = w), (N = g.exec(R)))) {
              ((w = g.lastIndex),
                (_ = N[0]),
                (F = !0),
                yield { type: 'StringLiteral', value: N[0], closed: N[2] !== void 0 });
              continue;
            }
            if (((p.lastIndex = w), (N = p.exec(R)))) {
              ((w = p.lastIndex),
                (_ = N[0]),
                (F = !0),
                yield { type: 'NumericLiteral', value: N[0] });
              continue;
            }
            if (((v.lastIndex = w), (N = v.exec(R)))) {
              ((w = v.lastIndex),
                (_ = N[0]),
                N[1] === '${'
                  ? ((_ = '?InterpolationInTemplate'),
                    K.push({ tag: 'InterpolationInTemplate', nesting: $.length }),
                    (F = !1),
                    yield { type: 'TemplateHead', value: N[0] })
                  : ((F = !0),
                    yield { type: 'NoSubstitutionTemplate', value: N[0], closed: N[1] === '`' }));
              continue;
            }
            break;
          case 'JSXTag':
          case 'JSXTagEnd':
            if (((r.lastIndex = w), (N = r.exec(R)))) {
              switch (((w = r.lastIndex), (P = N[0]), N[0])) {
                case '<':
                  K.push({ tag: 'JSXTag' });
                  break;
                case '>':
                  (K.pop(),
                    _ === '/' || V.tag === 'JSXTagEnd'
                      ? ((P = '?JSX'), (F = !0))
                      : K.push({ tag: 'JSXChildren' }));
                  break;
                case '{':
                  (K.push({ tag: 'InterpolationInJSX', nesting: $.length }),
                    (P = '?InterpolationInJSX'),
                    (F = !1));
                  break;
                case '/':
                  _ === '<' &&
                    (K.pop(),
                    K[K.length - 1].tag === 'JSXChildren' && K.pop(),
                    K.push({ tag: 'JSXTagEnd' }));
              }
              ((_ = P), yield { type: 'JSXPunctuator', value: N[0] });
              continue;
            }
            if (((t.lastIndex = w), (N = t.exec(R)))) {
              ((w = t.lastIndex), (_ = N[0]), yield { type: 'JSXIdentifier', value: N[0] });
              continue;
            }
            if (((n.lastIndex = w), (N = n.exec(R)))) {
              ((w = n.lastIndex),
                (_ = N[0]),
                yield { type: 'JSXString', value: N[0], closed: N[2] !== void 0 });
              continue;
            }
            break;
          case 'JSXChildren':
            if (((o.lastIndex = w), (N = o.exec(R)))) {
              ((w = o.lastIndex), (_ = N[0]), yield { type: 'JSXText', value: N[0] });
              continue;
            }
            switch (R[w]) {
              case '<':
                (K.push({ tag: 'JSXTag' }),
                  w++,
                  (_ = '<'),
                  yield { type: 'JSXPunctuator', value: '<' });
                continue;
              case '{':
                (K.push({ tag: 'InterpolationInJSX', nesting: $.length }),
                  w++,
                  (_ = '?InterpolationInJSX'),
                  (F = !1),
                  yield { type: 'JSXPunctuator', value: '{' });
                continue;
            }
        }
        if (((S.lastIndex = w), (N = S.exec(R)))) {
          ((w = S.lastIndex), yield { type: 'WhiteSpace', value: N[0] });
          continue;
        }
        if (((l.lastIndex = w), (N = l.exec(R)))) {
          ((w = l.lastIndex),
            (F = !1),
            a.test(_) && (_ = '?NoLineTerminatorHere'),
            yield { type: 'LineTerminatorSequence', value: N[0] });
          continue;
        }
        if (((d.lastIndex = w), (N = d.exec(R)))) {
          ((w = d.lastIndex),
            u.test(N[0]) && ((F = !1), a.test(_) && (_ = '?NoLineTerminatorHere')),
            yield { type: 'MultiLineComment', value: N[0], closed: N[1] !== void 0 });
          continue;
        }
        if (((h.lastIndex = w), (N = h.exec(R)))) {
          ((w = h.lastIndex), (F = !1), yield { type: 'SingleLineComment', value: N[0] });
          continue;
        }
        ((x = String.fromCodePoint(R.codePointAt(w))),
          (w += x.length),
          (_ = x),
          (F = !1),
          yield { type: V.tag.startsWith('JSX') ? 'JSXInvalid' : 'Invalid', value: x });
      }
    }, 'jsTokens_1')),
    gu
  );
}
s(vA, 'requireJsTokens');
var dJ = vA();
Mf(dJ);
var TA = {
  keyword: [
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
  ],
  strict: [
    'implements',
    'interface',
    'let',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
  ],
};
new Set(TA.keyword);
new Set(TA.strict);
function Vs(e, t) {
  if (!e) throw new Error(t);
}
s(Vs, 'S');
function Tn(e, t) {
  return typeof t === e;
}
s(Tn, 'f');
function EA(e) {
  return e instanceof Promise;
}
s(EA, 'w');
function xo(e, t, r) {
  Object.defineProperty(e, t, r);
}
s(xo, 'u');
function _n(e, t, r) {
  xo(e, t, { value: r, configurable: !0, writable: !0 });
}
s(_n, 'l');
var Gr = Symbol.for('tinyspy:spy'),
  pJ = new Set(),
  fJ = s((e) => {
    ((e.called = !1),
      (e.callCount = 0),
      (e.calls = []),
      (e.results = []),
      (e.resolves = []),
      (e.next = []));
  }, 'h'),
  mJ = s((e) => (xo(e, Gr, { value: { reset: s(() => fJ(e[Gr]), 'reset') } }), e[Gr]), 'k'),
  Td = s((e) => e[Gr] || mJ(e), 'T');
function wA(e) {
  Vs(Tn('function', e) || Tn('undefined', e), 'cannot spy on a non-function value');
  let t = s(function (...n) {
    let o = Td(t);
    ((o.called = !0), o.callCount++, o.calls.push(n));
    let i = o.next.shift();
    if (i) {
      o.results.push(i);
      let [p, f] = i;
      if (p === 'ok') return f;
      throw f;
    }
    let a,
      l = 'ok',
      d = o.results.length;
    if (o.impl)
      try {
        (new.target ? (a = Reflect.construct(o.impl, n, new.target)) : (a = o.impl.apply(this, n)),
          (l = 'ok'));
      } catch (p) {
        throw ((a = p), (l = 'error'), o.results.push([l, p]), p);
      }
    let u = [l, a];
    return (
      EA(a) &&
        a.then(
          (p) => (o.resolves[d] = ['ok', p]),
          (p) => (o.resolves[d] = ['error', p]),
        ),
      o.results.push(u),
      a
    );
  }, 't');
  (_n(t, '_isMockFunction', !0),
    _n(t, 'length', e ? e.length : 0),
    _n(t, 'name', (e && e.name) || 'spy'));
  let r = Td(t);
  return (r.reset(), (r.impl = e), t);
}
s(wA, 'R');
function SA(e) {
  return !!e && e._isMockFunction === !0;
}
s(SA, 'v');
var _A = s((e, t) => {
    let r = Object.getOwnPropertyDescriptor(e, t);
    if (r) return [e, r];
    let n = Object.getPrototypeOf(e);
    for (; n !== null; ) {
      let o = Object.getOwnPropertyDescriptor(n, t);
      if (o) return [n, o];
      n = Object.getPrototypeOf(n);
    }
  }, 'b'),
  hb = s((e, t) => {
    t != null &&
      typeof t == 'function' &&
      t.prototype != null &&
      Object.setPrototypeOf(e.prototype, t.prototype);
  }, 'P');
function Ey(e, t, r) {
  (Vs(!Tn('undefined', e), 'spyOn could not find an object to spy upon'),
    Vs(Tn('object', e) || Tn('function', e), 'cannot spyOn on a primitive value'));
  let [n, o] = (() => {
      if (!Tn('object', t)) return [t, 'value'];
      if ('getter' in t && 'setter' in t) throw new Error('cannot spy on both getter and setter');
      if ('getter' in t) return [t.getter, 'get'];
      if ('setter' in t) return [t.setter, 'set'];
      throw new Error('specify getter or setter to spy on');
    })(),
    [i, a] = _A(e, n) || [];
  Vs(a || n in e, `${String(n)} does not exist`);
  let l = !1;
  o === 'value' && a && !a.value && a.get && ((o = 'get'), (l = !0), (r = a.get()));
  let d;
  (a ? (d = a[o]) : o !== 'value' ? (d = s(() => e[n], 'p')) : (d = e[n]),
    d && PA(d) && (d = d[Gr].getOriginal()));
  let u = s((h) => {
      let { value: g, ...v } = a || { configurable: !0, writable: !0 };
      (o !== 'value' && delete v.writable, (v[o] = h), xo(e, n, v));
    }, 'g'),
    p = s(() => {
      i !== e ? Reflect.deleteProperty(e, n) : a && !d ? xo(e, n, a) : u(d);
    }, 'a');
  r || (r = d);
  let f = RA(wA(r), r);
  o === 'value' && hb(f, d);
  let m = f[Gr];
  return (
    _n(m, 'restore', p),
    _n(m, 'getOriginal', () => (l ? d() : d)),
    _n(m, 'willCall', (h) => ((m.impl = h), f)),
    u(l ? () => (hb(f, r), f) : f),
    pJ.add(f),
    f
  );
}
s(Ey, 'M');
var yJ = new Set(['length', 'name', 'prototype']);
function AA(e) {
  let t = new Set(),
    r = {};
  for (; e && e !== Object.prototype && e !== Function.prototype; ) {
    let n = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
    for (let o of n)
      r[o] || yJ.has(o) || (t.add(o), (r[o] = Object.getOwnPropertyDescriptor(e, o)));
    e = Object.getPrototypeOf(e);
  }
  return { properties: t, descriptors: r };
}
s(AA, 'D');
function RA(e, t) {
  if (!t || Gr in t) return e;
  let { properties: r, descriptors: n } = AA(t);
  for (let o of r) {
    let i = n[o];
    _A(e, o) || xo(e, o, i);
  }
  return e;
}
s(RA, 'E');
function PA(e) {
  return SA(e) && 'getOriginal' in e[Gr];
}
s(PA, 'j');
var Li = new Set();
function An(e) {
  return typeof e == 'function' && '_isMockFunction' in e && e._isMockFunction;
}
s(An, 'isMockFunction');
function xA(e, t, r) {
  const o = r ? { [{ get: 'getter', set: 'setter' }[r]]: t } : t;
  let i;
  const a = OA(e, t),
    l = a && a[r || 'value'];
  An(l) && (i = l.mock._state());
  try {
    const d = Ey(e, o),
      u = wy(d);
    return (i && u.mock._state(i), u);
  } catch (d) {
    throw d instanceof TypeError &&
      Symbol.toStringTag &&
      e[Symbol.toStringTag] === 'Module' &&
      (d.message.includes('Cannot redefine property') ||
        d.message.includes('Cannot replace module namespace') ||
        d.message.includes("can't redefine non-configurable property"))
      ? new TypeError(
          `Cannot spy on export "${String(o)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`,
          { cause: d },
        )
      : d;
  }
}
s(xA, 'spyOn');
var hJ = 0;
function wy(e) {
  const t = e;
  let r,
    n = [],
    o = !1,
    i = [],
    a = [],
    l = [];
  const d = Td(e),
    u = {
      get calls() {
        return d.calls;
      },
      get contexts() {
        return a;
      },
      get instances() {
        return i;
      },
      get invocationCallOrder() {
        return l;
      },
      get results() {
        return d.results.map(([h, g]) => ({ type: h === 'error' ? 'throw' : 'return', value: g }));
      },
      get settledResults() {
        return d.resolves.map(([h, g]) => ({
          type: h === 'error' ? 'rejected' : 'fulfilled',
          value: g,
        }));
      },
      get lastCall() {
        return d.calls[d.calls.length - 1];
      },
      _state(h) {
        return (
          h &&
            ((r = h.implementation),
            (n = h.onceImplementations),
            (o = h.implementationChangedTemporarily)),
          { implementation: r, onceImplementations: n, implementationChangedTemporarily: o }
        );
      },
    };
  function p(...h) {
    return (
      i.push(this),
      a.push(this),
      l.push(++hJ),
      (o ? r : n.shift() || r || d.getOriginal() || (() => {})).apply(this, h)
    );
  }
  s(p, 'mockCall');
  let f = t.name;
  ((t.getMockName = () => f || 'vi.fn()'),
    (t.mockName = (h) => ((f = h), t)),
    (t.mockClear = () => (d.reset(), (i = []), (a = []), (l = []), t)),
    (t.mockReset = () => (t.mockClear(), (r = void 0), (n = []), t)),
    (t.mockRestore = () => (t.mockReset(), d.restore(), t)),
    Symbol.dispose && (t[Symbol.dispose] = () => t.mockRestore()),
    (t.getMockImplementation = () => (o ? r : n.at(0) || r)),
    (t.mockImplementation = (h) => ((r = h), d.willCall(p), t)),
    (t.mockImplementationOnce = (h) => (n.push(h), t)));
  function m(h, g) {
    const v = r;
    ((r = h), d.willCall(p), (o = !0));
    const E = s(() => {
        ((r = v), (o = !1));
      }, 'reset'),
      b = g();
    return typeof b == 'object' && b && typeof b.then == 'function'
      ? b.then(() => (E(), t))
      : (E(), t);
  }
  return (
    s(m, 'withImplementation'),
    (t.withImplementation = m),
    (t.mockReturnThis = () =>
      t.mockImplementation(function () {
        return this;
      })),
    (t.mockReturnValue = (h) => t.mockImplementation(() => h)),
    (t.mockReturnValueOnce = (h) => t.mockImplementationOnce(() => h)),
    (t.mockResolvedValue = (h) => t.mockImplementation(() => Promise.resolve(h))),
    (t.mockResolvedValueOnce = (h) => t.mockImplementationOnce(() => Promise.resolve(h))),
    (t.mockRejectedValue = (h) => t.mockImplementation(() => Promise.reject(h))),
    (t.mockRejectedValueOnce = (h) => t.mockImplementationOnce(() => Promise.reject(h))),
    Object.defineProperty(t, 'mock', { get: s(() => u, 'get') }),
    d.willCall(p),
    Li.add(t),
    t
  );
}
s(wy, 'enhanceSpy');
function Ed(e) {
  const t = wy(Ey({ spy: e || function () {} }, 'spy'));
  return (e && t.mockImplementation(e), t);
}
s(Ed, 'fn');
function OA(e, t) {
  const r = Object.getOwnPropertyDescriptor(e, t);
  if (r) return r;
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    const o = Object.getOwnPropertyDescriptor(n, t);
    if (o) return o;
    n = Object.getPrototypeOf(n);
  }
}
s(OA, 'getDescriptor');
var ci = Symbol.for('matchers-object'),
  ui = Symbol.for('$$jest-matchers-object-storybook'),
  Sy = Symbol.for('expect-global'),
  wd = Symbol.for('asymmetric-matchers-object'),
  gJ = {
    toSatisfy(e, t, r) {
      const { printReceived: n, printExpected: o, matcherHint: i } = this.utils,
        a = t(e);
      return {
        pass: a,
        message: s(
          () =>
            a
              ? `${i('.not.toSatisfy', 'received', '')}

Expected value to not satisfy:
${r || o(t)}
Received:
${n(e)}`
              : `${i('.toSatisfy', 'received', '')}

Expected value to satisfy:
${r || o(t)}

Received:
${n(e)}`,
          'message',
        ),
      };
    },
    toBeOneOf(e, t) {
      const { equals: r, customTesters: n } = this,
        { printReceived: o, printExpected: i, matcherHint: a } = this.utils;
      if (!Array.isArray(t))
        throw new TypeError(`You must provide an array to ${a('.toBeOneOf')}, not '${typeof t}'.`);
      const l = t.length === 0 || t.some((d) => r(d, e, n));
      return {
        pass: l,
        message: s(
          () =>
            l
              ? `${a('.not.toBeOneOf', 'received', '')}

Expected value to not be one of:
${i(t)}
Received:
${o(e)}`
              : `${a('.toBeOneOf', 'received', '')}

Expected value to be one of:
${i(t)}

Received:
${o(e)}`,
          'message',
        ),
      };
    },
  },
  Wa = Ue.green,
  _y = Ue.red,
  bJ = Ue.inverse,
  vJ = Ue.bold,
  Dr = Ue.dim;
function CA(e, t = 'received', r = 'expected', n = {}) {
  const {
    comment: o = '',
    isDirectExpectCall: i = !1,
    isNot: a = !1,
    promise: l = '',
    secondArgument: d = '',
    expectedColor: u = Wa,
    receivedColor: p = _y,
    secondArgumentColor: f = Wa,
  } = n;
  let m = '',
    h = 'expect';
  return (
    !i && t !== '' && ((m += Dr(`${h}(`) + p(t)), (h = ')')),
    l !== '' && ((m += Dr(`${h}.`) + l), (h = '')),
    a && ((m += `${Dr(`${h}.`)}not`), (h = '')),
    e.includes('.') ? (h += e) : ((m += Dr(`${h}.`) + e), (h = '')),
    r === '' ? (h += '()') : ((m += Dr(`${h}(`) + u(r)), d && (m += Dr(', ') + f(d)), (h = ')')),
    o !== '' && (h += ` // ${o}`),
    h !== '' && (m += Dr(h)),
    m
  );
}
s(CA, 'matcherHint');
var TJ = '';
function Ay(e) {
  return e.replace(/\s+$/gm, (t) => TJ.repeat(t.length));
}
s(Ay, 'replaceTrailingSpaces');
function IA(e) {
  return _y(Ay(_t(e)));
}
s(IA, 'printReceived');
function NA(e) {
  return Wa(Ay(_t(e)));
}
s(NA, 'printExpected');
function Ry() {
  return {
    EXPECTED_COLOR: Wa,
    RECEIVED_COLOR: _y,
    INVERTED_COLOR: bJ,
    BOLD_WEIGHT: vJ,
    DIM_COLOR: Dr,
    diff: Hn,
    matcherHint: CA,
    printReceived: IA,
    printExpected: NA,
    printDiffOrStringify: Vf,
    printWithType: $A,
  };
}
s(Ry, 'getMatcherUtils');
function $A(e, t, r) {
  const n = ti(t),
    o =
      n !== 'null' && n !== 'undefined'
        ? `${e} has type:  ${n}
`
        : '',
    i = `${e} has value: ${r(t)}`;
  return o + i;
}
s($A, 'printWithType');
function Sc() {
  return globalThis[ui].customEqualityTesters;
}
s(Sc, 'getCustomEqualityTesters');
function Ae(e, t, r, n) {
  return ((r = r || []), fo(e, t, [], [], r, n ? Py : jA));
}
s(Ae, 'equals');
function Sd(e) {
  return !!e && typeof e == 'object' && 'asymmetricMatch' in e && Jt('Function', e.asymmetricMatch);
}
s(Sd, 'isAsymmetric');
function qA(e, t) {
  const r = Sd(e),
    n = Sd(t);
  if (!(r && n)) {
    if (r) return e.asymmetricMatch(t);
    if (n) return t.asymmetricMatch(e);
  }
}
s(qA, 'asymmetricMatch');
function fo(e, t, r, n, o, i) {
  let a = !0;
  const l = qA(e, t);
  if (l !== void 0) return l;
  const d = { equals: Ae };
  for (let g = 0; g < o.length; g++) {
    const v = o[g].call(d, e, t, o);
    if (v !== void 0) return v;
  }
  if (typeof URL == 'function' && e instanceof URL && t instanceof URL) return e.href === t.href;
  if (Object.is(e, t)) return !0;
  if (e === null || t === null) return e === t;
  const u = Object.prototype.toString.call(e);
  if (u !== Object.prototype.toString.call(t)) return !1;
  switch (u) {
    case '[object Boolean]':
    case '[object String]':
    case '[object Number]':
      return typeof e != typeof t
        ? !1
        : typeof e != 'object' && typeof t != 'object'
          ? Object.is(e, t)
          : Object.is(e.valueOf(), t.valueOf());
    case '[object Date]': {
      const g = +e,
        v = +t;
      return g === v || (Number.isNaN(g) && Number.isNaN(v));
    }
    case '[object RegExp]':
      return e.source === t.source && e.flags === t.flags;
    case '[object Temporal.Instant]':
    case '[object Temporal.ZonedDateTime]':
    case '[object Temporal.PlainDateTime]':
    case '[object Temporal.PlainDate]':
    case '[object Temporal.PlainTime]':
    case '[object Temporal.PlainYearMonth]':
    case '[object Temporal.PlainMonthDay]':
      return e.equals(t);
    case '[object Temporal.Duration]':
      return e.toString() === t.toString();
  }
  if (typeof e != 'object' || typeof t != 'object') return !1;
  if (Ad(e) && Ad(t)) return e.isEqualNode(t);
  let p = r.length;
  for (; p--; ) {
    if (r[p] === e) return n[p] === t;
    if (n[p] === t) return !1;
  }
  if ((r.push(e), n.push(t), u === '[object Array]' && e.length !== t.length)) return !1;
  if (e instanceof Error && t instanceof Error)
    try {
      return MA(e, t, r, n, o, i);
    } finally {
      (r.pop(), n.pop());
    }
  const f = _d(e, i);
  let m,
    h = f.length;
  if (_d(t, i).length !== h) return !1;
  for (; h--; ) if (((m = f[h]), (a = i(t, m) && fo(e[m], t[m], r, n, o, i)), !a)) return !1;
  return (r.pop(), n.pop(), a);
}
s(fo, 'eq');
function MA(e, t, r, n, o, i) {
  let a =
    Object.getPrototypeOf(e) === Object.getPrototypeOf(t) &&
    e.name === t.name &&
    e.message === t.message;
  return (
    typeof t.cause < 'u' && a && (a = fo(e.cause, t.cause, r, n, o, i)),
    e instanceof AggregateError &&
      t instanceof AggregateError &&
      a &&
      (a = fo(e.errors, t.errors, r, n, o, i)),
    a && (a = fo({ ...e }, { ...t }, r, n, o, i)),
    a
  );
}
s(MA, 'isErrorEqual');
function _d(e, t) {
  const r = [];
  for (const n in e) t(e, n) && r.push(n);
  return r.concat(
    Object.getOwnPropertySymbols(e).filter((n) => Object.getOwnPropertyDescriptor(e, n).enumerable),
  );
}
s(_d, 'keys');
function jA(e, t) {
  return Py(e, t) && e[t] !== void 0;
}
s(jA, 'hasDefinedKey');
function Py(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
s(Py, 'hasKey');
function Jt(e, t) {
  return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
s(Jt, 'isA');
function Ad(e) {
  return (
    e !== null &&
    typeof e == 'object' &&
    'nodeType' in e &&
    typeof e.nodeType == 'number' &&
    'nodeName' in e &&
    typeof e.nodeName == 'string' &&
    'isEqualNode' in e &&
    typeof e.isEqualNode == 'function'
  );
}
s(Ad, 'isDomNode');
var kA = '@@__IMMUTABLE_KEYED__@@',
  DA = '@@__IMMUTABLE_SET__@@',
  EJ = '@@__IMMUTABLE_LIST__@@',
  _c = '@@__IMMUTABLE_ORDERED__@@',
  wJ = '@@__IMMUTABLE_RECORD__@@';
function LA(e) {
  return !!(e && e[kA] && !e[_c]);
}
s(LA, 'isImmutableUnorderedKeyed');
function FA(e) {
  return !!(e && e[DA] && !e[_c]);
}
s(FA, 'isImmutableUnorderedSet');
function Fi(e) {
  return e != null && typeof e == 'object' && !Array.isArray(e);
}
s(Fi, 'isObjectLiteral');
function BA(e) {
  return !!(e && Fi(e) && e[EJ]);
}
s(BA, 'isImmutableList');
function JA(e) {
  return !!(e && Fi(e) && e[kA] && e[_c]);
}
s(JA, 'isImmutableOrderedKeyed');
function UA(e) {
  return !!(e && Fi(e) && e[DA] && e[_c]);
}
s(UA, 'isImmutableOrderedSet');
function VA(e) {
  return !!(e && Fi(e) && e[wJ]);
}
s(VA, 'isImmutableRecord');
var HA = Symbol.iterator;
function Rd(e) {
  return !!(e != null && e[HA]);
}
s(Rd, 'hasIterator');
function $t(e, t, r = [], n = [], o = []) {
  if (
    typeof e != 'object' ||
    typeof t != 'object' ||
    Array.isArray(e) ||
    Array.isArray(t) ||
    !Rd(e) ||
    !Rd(t)
  )
    return;
  if (e.constructor !== t.constructor) return !1;
  let i = n.length;
  for (; i--; ) if (n[i] === e) return o[i] === t;
  (n.push(e), o.push(t));
  const a = [...r.filter((u) => u !== $t), l];
  function l(u, p) {
    return $t(u, p, [...r], [...n], [...o]);
  }
  if ((s(l, 'iterableEqualityWithStack'), e.size !== void 0)) {
    if (e.size !== t.size) return !1;
    if (Jt('Set', e) || FA(e)) {
      let u = !0;
      for (const p of e)
        if (!t.has(p)) {
          let f = !1;
          for (const m of t) Ae(p, m, a) === !0 && (f = !0);
          if (f === !1) {
            u = !1;
            break;
          }
        }
      return (n.pop(), o.pop(), u);
    } else if (Jt('Map', e) || LA(e)) {
      let u = !0;
      for (const p of e)
        if (!t.has(p[0]) || !Ae(p[1], t.get(p[0]), a)) {
          let f = !1;
          for (const m of t) {
            const h = Ae(p[0], m[0], a);
            let g = !1;
            (h === !0 && (g = Ae(p[1], m[1], a)), g === !0 && (f = !0));
          }
          if (f === !1) {
            u = !1;
            break;
          }
        }
      return (n.pop(), o.pop(), u);
    }
  }
  const d = t[HA]();
  for (const u of e) {
    const p = d.next();
    if (p.done || !Ae(u, p.value, a)) return !1;
  }
  if (!d.next().done) return !1;
  if (!BA(e) && !JA(e) && !UA(e) && !VA(e)) {
    const u = Object.entries(e),
      p = Object.entries(t);
    if (!Ae(u, p, a)) return !1;
  }
  return (n.pop(), o.pop(), !0);
}
s($t, 'iterableEquality');
function Ac(e, t) {
  return !e || typeof e != 'object' || e === Object.prototype
    ? !1
    : Object.prototype.hasOwnProperty.call(e, t) || Ac(Object.getPrototypeOf(e), t);
}
s(Ac, 'hasPropertyInObject');
function zA(e) {
  return Js(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
s(zA, 'isObjectWithKeys');
function zo(e, t, r = []) {
  const n = r.filter((i) => i !== zo),
    o = s(
      (i = new WeakMap()) =>
        (a, l) => {
          if (zA(l))
            return Object.keys(l).every((d) => {
              if (l[d] != null && typeof l[d] == 'object') {
                if (i.has(l[d])) return Ae(a[d], l[d], n);
                i.set(l[d], !0);
              }
              const u = a != null && Ac(a, d) && Ae(a[d], l[d], [...n, o(i)]);
              return (i.delete(l[d]), u);
            });
        },
      'subsetEqualityWithContext',
    );
  return o()(e, t);
}
s(zo, 'subsetEquality');
function Pd(e, t) {
  if (!(e == null || t == null || e.constructor === t.constructor)) return !1;
}
s(Pd, 'typeEquality');
function xd(e, t) {
  let r = e,
    n = t;
  if (!(e instanceof DataView && t instanceof DataView)) {
    if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer)) return;
    try {
      ((r = new DataView(e)), (n = new DataView(t)));
    } catch {
      return;
    }
  }
  if (r.byteLength !== n.byteLength) return !1;
  for (let o = 0; o < r.byteLength; o++) if (r.getUint8(o) !== n.getUint8(o)) return !1;
  return !0;
}
s(xd, 'arrayBufferEquality');
function Ka(e, t, r = []) {
  if (!Array.isArray(e) || !Array.isArray(t)) return;
  const n = Object.keys(e),
    o = Object.keys(t),
    i = r.filter((a) => a !== Ka);
  return Ae(e, t, i, !0) && Ae(n, o);
}
s(Ka, 'sparseArrayEquality');
function GA(e, t = '#{this}', r = '#{exp}') {
  const n = `expected ${t} to be ${r} // Object.is equality`;
  return ['toStrictEqual', 'toEqual'].includes(e)
    ? `${n}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
`
    : n;
}
s(GA, 'generateToBeMessage');
function WA(e, t) {
  return `${t} ${e}${t === 1 ? '' : 's'}`;
}
s(WA, 'pluralize');
function oa(e) {
  return [
    ...Object.keys(e),
    ...Object.getOwnPropertySymbols(e).filter((t) => {
      var r;
      return (r = Object.getOwnPropertyDescriptor(e, t)) === null || r === void 0
        ? void 0
        : r.enumerable;
    }),
  ];
}
s(oa, 'getObjectKeys');
function KA(e, t, r) {
  let n = 0;
  const o = s(
    (i = new WeakMap()) =>
      (a, l) => {
        if (Array.isArray(a)) {
          if (Array.isArray(l) && l.length === a.length) return l.map((d, u) => o(i)(a[u], d));
        } else {
          if (a instanceof Date) return a;
          if (Js(a) && Js(l)) {
            if (Ae(a, l, [...r, $t, zo])) return l;
            const d = {};
            (i.set(a, d),
              typeof a.constructor == 'function' &&
                typeof a.constructor.name == 'string' &&
                Object.defineProperty(d, 'constructor', { enumerable: !1, value: a.constructor }));
            for (const u of oa(a))
              Ac(l, u)
                ? (d[u] = i.has(a[u]) ? i.get(a[u]) : o(i)(a[u], l[u]))
                : i.has(a[u]) || ((n += 1), Js(a[u]) && (n += oa(a[u]).length), o(i)(a[u], l[u]));
            if (oa(d).length > 0) return d;
          }
        }
        return a;
      },
    'getObjectSubsetWithContext',
  );
  return { subset: o()(e, t), stripped: n };
}
s(KA, 'getObjectSubset');
if (!Object.prototype.hasOwnProperty.call(globalThis, ci)) {
  const e = new WeakMap();
  Object.defineProperty(globalThis, ci, { get: s(() => e, 'get') });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, ui)) {
  const e = Object.create(null),
    t = [];
  Object.defineProperty(globalThis, ui, {
    configurable: !0,
    get: s(
      () => ({ state: globalThis[ci].get(globalThis[Sy]), matchers: e, customEqualityTesters: t }),
      'get',
    ),
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, wd)) {
  const e = Object.create(null);
  Object.defineProperty(globalThis, wd, { get: s(() => e, 'get') });
}
function di(e) {
  return globalThis[ci].get(e);
}
s(di, 'getState');
function sa(e, t) {
  const r = globalThis[ci],
    n = r.get(t) || {},
    o = Object.defineProperties(n, {
      ...Object.getOwnPropertyDescriptors(n),
      ...Object.getOwnPropertyDescriptors(e),
    });
  r.set(t, o);
}
s(sa, 'setState');
var YA = class {
  constructor(t, r = !1) {
    Be(this, '$$typeof', Symbol.for('jest.asymmetricMatcher'));
    ((this.sample = t), (this.inverse = r));
  }
  getMatcherContext(t) {
    return {
      ...di(t || globalThis[Sy]),
      equals: Ae,
      isNot: this.inverse,
      customTesters: Sc(),
      utils: { ...Ry(), diff: Hn, stringify: _t, iterableEquality: $t, subsetEquality: zo },
    };
  }
};
s(YA, 'AsymmetricMatcher');
var jr = YA;
jr.prototype[Symbol.for('chai/inspect')] = function (e) {
  const t = _t(this, e.depth, { min: !0 });
  return t.length <= e.truncate ? t : `${this.toString()}{}`;
};
var XA = class extends jr {
  constructor(t, r = !1) {
    if (!Jt('String', t)) throw new Error('Expected is not a string');
    super(t, r);
  }
  asymmetricMatch(t) {
    const r = Jt('String', t) && t.includes(this.sample);
    return this.inverse ? !r : r;
  }
  toString() {
    return `String${this.inverse ? 'Not' : ''}Containing`;
  }
  getExpectedType() {
    return 'string';
  }
};
s(XA, 'StringContaining');
var gb = XA,
  QA = class extends jr {
    asymmetricMatch(t) {
      return t != null;
    }
    toString() {
      return 'Anything';
    }
    toAsymmetricMatcher() {
      return 'Anything';
    }
  };
s(QA, 'Anything');
var SJ = QA,
  ZA = class extends jr {
    constructor(t, r = !1) {
      super(t, r);
    }
    getPrototype(t) {
      return Object.getPrototypeOf
        ? Object.getPrototypeOf(t)
        : t.constructor.prototype === t
          ? null
          : t.constructor.prototype;
    }
    hasProperty(t, r) {
      return t
        ? Object.prototype.hasOwnProperty.call(t, r)
          ? !0
          : this.hasProperty(this.getPrototype(t), r)
        : !1;
    }
    asymmetricMatch(t) {
      if (typeof this.sample != 'object')
        throw new TypeError(
          `You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`,
        );
      let r = !0;
      const n = this.getMatcherContext();
      for (const o in this.sample)
        if (!this.hasProperty(t, o) || !Ae(this.sample[o], t[o], n.customTesters)) {
          r = !1;
          break;
        }
      return this.inverse ? !r : r;
    }
    toString() {
      return `Object${this.inverse ? 'Not' : ''}Containing`;
    }
    getExpectedType() {
      return 'object';
    }
  };
s(ZA, 'ObjectContaining');
var bb = ZA,
  eR = class extends jr {
    constructor(t, r = !1) {
      super(t, r);
    }
    asymmetricMatch(t) {
      if (!Array.isArray(this.sample))
        throw new TypeError(
          `You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`,
        );
      const r = this.getMatcherContext(),
        n =
          this.sample.length === 0 ||
          (Array.isArray(t) && this.sample.every((o) => t.some((i) => Ae(o, i, r.customTesters))));
      return this.inverse ? !n : n;
    }
    toString() {
      return `Array${this.inverse ? 'Not' : ''}Containing`;
    }
    getExpectedType() {
      return 'array';
    }
  };
s(eR, 'ArrayContaining');
var vb = eR,
  tR = class extends jr {
    constructor(t) {
      if (typeof t > 'u')
        throw new TypeError(
          'any() expects to be passed a constructor function. Please pass one or use anything() to match any object.',
        );
      super(t);
    }
    fnNameFor(t) {
      if (t.name) return t.name;
      const n = Function.prototype.toString
        .call(t)
        .match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
      return n ? n[1] : '<anonymous>';
    }
    asymmetricMatch(t) {
      return this.sample === String
        ? typeof t == 'string' || t instanceof String
        : this.sample === Number
          ? typeof t == 'number' || t instanceof Number
          : this.sample === Function
            ? typeof t == 'function' || typeof t == 'function'
            : this.sample === Boolean
              ? typeof t == 'boolean' || t instanceof Boolean
              : this.sample === BigInt
                ? typeof t == 'bigint' || t instanceof BigInt
                : this.sample === Symbol
                  ? typeof t == 'symbol' || t instanceof Symbol
                  : this.sample === Object
                    ? typeof t == 'object'
                    : t instanceof this.sample;
    }
    toString() {
      return 'Any';
    }
    getExpectedType() {
      return this.sample === String
        ? 'string'
        : this.sample === Number
          ? 'number'
          : this.sample === Function
            ? 'function'
            : this.sample === Object
              ? 'object'
              : this.sample === Boolean
                ? 'boolean'
                : this.fnNameFor(this.sample);
    }
    toAsymmetricMatcher() {
      return `Any<${this.fnNameFor(this.sample)}>`;
    }
  };
s(tR, 'Any');
var _J = tR,
  rR = class extends jr {
    constructor(t, r = !1) {
      if (!Jt('String', t) && !Jt('RegExp', t))
        throw new Error('Expected is not a String or a RegExp');
      super(new RegExp(t), r);
    }
    asymmetricMatch(t) {
      const r = Jt('String', t) && this.sample.test(t);
      return this.inverse ? !r : r;
    }
    toString() {
      return `String${this.inverse ? 'Not' : ''}Matching`;
    }
    getExpectedType() {
      return 'string';
    }
  };
s(rR, 'StringMatching');
var Tb = rR,
  nR = class extends jr {
    constructor(r, n = 2, o = !1) {
      if (!Jt('Number', r)) throw new Error('Expected is not a Number');
      if (!Jt('Number', n)) throw new Error('Precision is not a Number');
      super(r);
      Be(this, 'precision');
      ((this.inverse = o), (this.precision = n));
    }
    asymmetricMatch(r) {
      if (!Jt('Number', r)) return !1;
      let n = !1;
      return (
        (r === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY) ||
        (r === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY)
          ? (n = !0)
          : (n = Math.abs(this.sample - r) < 10 ** -this.precision / 2),
        this.inverse ? !n : n
      );
    }
    toString() {
      return `Number${this.inverse ? 'Not' : ''}CloseTo`;
    }
    getExpectedType() {
      return 'number';
    }
    toAsymmetricMatcher() {
      return [this.toString(), this.sample, `(${WA('digit', this.precision)})`].join(' ');
    }
  };
s(nR, 'CloseTo');
var Eb = nR,
  AJ = s((e, t) => {
    (t.addMethod(e.expect, 'anything', () => new SJ()),
      t.addMethod(e.expect, 'any', (r) => new _J(r)),
      t.addMethod(e.expect, 'stringContaining', (r) => new gb(r)),
      t.addMethod(e.expect, 'objectContaining', (r) => new bb(r)),
      t.addMethod(e.expect, 'arrayContaining', (r) => new vb(r)),
      t.addMethod(e.expect, 'stringMatching', (r) => new Tb(r)),
      t.addMethod(e.expect, 'closeTo', (r, n) => new Eb(r, n)),
      (e.expect.not = {
        stringContaining: s((r) => new gb(r, !0), 'stringContaining'),
        objectContaining: s((r) => new bb(r, !0), 'objectContaining'),
        arrayContaining: s((r) => new vb(r, !0), 'arrayContaining'),
        stringMatching: s((r) => new Tb(r, !0), 'stringMatching'),
        closeTo: s((r, n) => new Eb(r, n, !0), 'closeTo'),
      }));
  }, 'JestAsymmetricMatchers');
function Od(e, t, r) {
  const n = e.flag(t, 'negate') ? 'not.' : '',
    o = `${e.flag(t, '_name')}(${r ? 'expected' : ''})`,
    i = e.flag(t, 'promise');
  return `expect(actual)${i ? `.${i}` : ''}.${n}${o}`;
}
s(Od, 'createAssertionMessage');
function Cd(e, t, r, n) {
  const o = e;
  if (o && t instanceof Promise) {
    ((t = t.finally(() => {
      if (!o.promises) return;
      const a = o.promises.indexOf(t);
      a !== -1 && o.promises.splice(a, 1);
    })),
      o.promises || (o.promises = []),
      o.promises.push(t));
    let i = !1;
    return (
      o.onFinished ?? (o.onFinished = []),
      o.onFinished.push(() => {
        if (!i) {
          var a;
          const d = (
            ((a = globalThis.__vitest_worker__) === null || a === void 0
              ? void 0
              : a.onFilterStackTrace) || ((u) => u || '')
          )(n.stack);
          console.warn(
            [
              `Promise returned by \`${r}\` was not awaited. `,
              'Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ',
              `Please remember to await the assertion.
`,
              d,
            ].join(''),
          );
        }
      }),
      {
        then(a, l) {
          return ((i = !0), t.then(a, l));
        },
        catch(a) {
          return t.catch(a);
        },
        finally(a) {
          return t.finally(a);
        },
        [Symbol.toStringTag]: 'Promise',
      }
    );
  }
  return t;
}
s(Cd, 'recordAsyncExpect');
function Id(e, t) {
  var r;
  (e.result || (e.result = { state: 'fail' }),
    (e.result.state = 'fail'),
    (r = e.result).errors || (r.errors = []),
    e.result.errors.push(Fl(t)));
}
s(Id, 'handleTestError');
function xy(e, t, r) {
  return function (...n) {
    if ((t !== 'withTest' && e.flag(this, '_name', t), !e.flag(this, 'soft')))
      return r.apply(this, n);
    const o = e.flag(this, 'vitest-test');
    if (!o) throw new Error('expect.soft() can only be used inside a test');
    try {
      const i = r.apply(this, n);
      return i && typeof i == 'object' && typeof i.then == 'function'
        ? i.then(e_, (a) => {
            Id(o, a);
          })
        : i;
    } catch (i) {
      Id(o, i);
    }
  };
}
s(xy, 'wrapAssertion');
var RJ = s((e, t) => {
  const { AssertionError: r } = e,
    n = Sc();
  function o(u, p) {
    const f = s((m) => {
      const h = xy(t, m, p);
      (t.addMethod(e.Assertion.prototype, m, h), t.addMethod(globalThis[ui].matchers, m, h));
    }, 'addMethod');
    Array.isArray(u) ? u.forEach((m) => f(m)) : f(u);
  }
  (s(o, 'def'),
    ['throw', 'throws', 'Throw'].forEach((u) => {
      t.overwriteMethod(
        e.Assertion.prototype,
        u,
        (p) =>
          function (...f) {
            const m = t.flag(this, 'promise'),
              h = t.flag(this, 'object'),
              g = t.flag(this, 'negate');
            if (m === 'rejects')
              t.flag(this, 'object', () => {
                throw h;
              });
            else if (m === 'resolves' && typeof h != 'function') {
              if (g) return;
              {
                const v =
                    t.flag(this, 'message') || "expected promise to throw an error, but it didn't",
                  E = { showDiff: !1 };
                throw new r(v, E, t.flag(this, 'ssfi'));
              }
            }
            p.apply(this, f);
          },
      );
    }),
    o('withTest', function (u) {
      return (t.flag(this, 'vitest-test', u), this);
    }),
    o('toEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Ae(p, u, [...n, $t]);
      return this.assert(
        f,
        'expected #{this} to deeply equal #{exp}',
        'expected #{this} to not deeply equal #{exp}',
        u,
        p,
      );
    }),
    o('toStrictEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Ae(p, u, [...n, $t, Pd, Ka, xd], !0);
      return this.assert(
        f,
        'expected #{this} to strictly equal #{exp}',
        'expected #{this} to not strictly equal #{exp}',
        u,
        p,
      );
    }),
    o('toBe', function (u) {
      const p = this._obj,
        f = Object.is(p, u);
      let m = '';
      return (
        f ||
          (Ae(p, u, [...n, $t, Pd, Ka, xd], !0)
            ? (m = 'toStrictEqual')
            : Ae(p, u, [...n, $t]) && (m = 'toEqual')),
        this.assert(f, GA(m), 'expected #{this} not to be #{exp} // Object.is equality', u, p)
      );
    }),
    o('toMatchObject', function (u) {
      const p = this._obj,
        f = Ae(p, u, [...n, $t, zo]),
        m = t.flag(this, 'negate'),
        { subset: h, stripped: g } = KA(p, u, n);
      if ((f && m) || (!f && !m)) {
        const v = t.getMessage(this, [
            f,
            'expected #{this} to match object #{exp}',
            'expected #{this} to not match object #{exp}',
            u,
            h,
            !1,
          ]),
          E =
            g === 0
              ? v
              : `${v}
(${g} matching ${g === 1 ? 'property' : 'properties'} omitted from actual)`;
        throw new r(E, { showDiff: !0, expected: u, actual: h });
      }
    }),
    o('toMatch', function (u) {
      const p = this._obj;
      if (typeof p != 'string')
        throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof p}`);
      return this.assert(
        typeof u == 'string' ? p.includes(u) : p.match(u),
        'expected #{this} to match #{exp}',
        'expected #{this} not to match #{exp}',
        u,
        p,
      );
    }),
    o('toContain', function (u) {
      const p = this._obj;
      if (typeof Node < 'u' && p instanceof Node) {
        if (!(u instanceof Node))
          throw new TypeError(
            `toContain() expected a DOM node as the argument, but got ${typeof u}`,
          );
        return this.assert(
          p.contains(u),
          'expected #{this} to contain element #{exp}',
          'expected #{this} not to contain element #{exp}',
          u,
          p,
        );
      }
      if (typeof DOMTokenList < 'u' && p instanceof DOMTokenList) {
        nr(u, 'class name', ['string']);
        const m = t.flag(this, 'negate') ? p.value.replace(u, '').trim() : `${p.value} ${u}`;
        return this.assert(
          p.contains(u),
          `expected "${p.value}" to contain "${u}"`,
          `expected "${p.value}" not to contain "${u}"`,
          m,
          p.value,
        );
      }
      return typeof p == 'string' && typeof u == 'string'
        ? this.assert(
            p.includes(u),
            'expected #{this} to contain #{exp}',
            'expected #{this} not to contain #{exp}',
            u,
            p,
          )
        : (p != null && typeof p != 'string' && t.flag(this, 'object', Array.from(p)),
          this.contain(u));
    }),
    o('toContainEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Array.from(p).findIndex((m) => Ae(m, u, n));
      this.assert(
        f !== -1,
        'expected #{this} to deep equally contain #{exp}',
        'expected #{this} to not deep equally contain #{exp}',
        u,
      );
    }),
    o('toBeTruthy', function () {
      const u = t.flag(this, 'object');
      this.assert(!!u, 'expected #{this} to be truthy', 'expected #{this} to not be truthy', !0, u);
    }),
    o('toBeFalsy', function () {
      const u = t.flag(this, 'object');
      this.assert(!u, 'expected #{this} to be falsy', 'expected #{this} to not be falsy', !1, u);
    }),
    o('toBeGreaterThan', function (u) {
      const p = this._obj;
      return (
        nr(p, 'actual', ['number', 'bigint']),
        nr(u, 'expected', ['number', 'bigint']),
        this.assert(
          p > u,
          `expected ${p} to be greater than ${u}`,
          `expected ${p} to be not greater than ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    o('toBeGreaterThanOrEqual', function (u) {
      const p = this._obj;
      return (
        nr(p, 'actual', ['number', 'bigint']),
        nr(u, 'expected', ['number', 'bigint']),
        this.assert(
          p >= u,
          `expected ${p} to be greater than or equal to ${u}`,
          `expected ${p} to be not greater than or equal to ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    o('toBeLessThan', function (u) {
      const p = this._obj;
      return (
        nr(p, 'actual', ['number', 'bigint']),
        nr(u, 'expected', ['number', 'bigint']),
        this.assert(
          p < u,
          `expected ${p} to be less than ${u}`,
          `expected ${p} to be not less than ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    o('toBeLessThanOrEqual', function (u) {
      const p = this._obj;
      return (
        nr(p, 'actual', ['number', 'bigint']),
        nr(u, 'expected', ['number', 'bigint']),
        this.assert(
          p <= u,
          `expected ${p} to be less than or equal to ${u}`,
          `expected ${p} to be not less than or equal to ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    o('toBeNaN', function () {
      const u = t.flag(this, 'object');
      this.assert(
        Number.isNaN(u),
        'expected #{this} to be NaN',
        'expected #{this} not to be NaN',
        Number.NaN,
        u,
      );
    }),
    o('toBeUndefined', function () {
      const u = t.flag(this, 'object');
      this.assert(
        u === void 0,
        'expected #{this} to be undefined',
        'expected #{this} not to be undefined',
        void 0,
        u,
      );
    }),
    o('toBeNull', function () {
      const u = t.flag(this, 'object');
      this.assert(
        u === null,
        'expected #{this} to be null',
        'expected #{this} not to be null',
        null,
        u,
      );
    }),
    o('toBeDefined', function () {
      const u = t.flag(this, 'object');
      this.assert(
        typeof u < 'u',
        'expected #{this} to be defined',
        'expected #{this} to be undefined',
        u,
      );
    }),
    o('toBeTypeOf', function (u) {
      const p = typeof this._obj,
        f = u === p;
      return this.assert(
        f,
        'expected #{this} to be type of #{exp}',
        'expected #{this} not to be type of #{exp}',
        u,
        p,
      );
    }),
    o('toBeInstanceOf', function (u) {
      return this.instanceOf(u);
    }),
    o('toHaveLength', function (u) {
      return this.have.length(u);
    }),
    o('toHaveProperty', function (...u) {
      Array.isArray(u[0]) &&
        (u[0] = u[0].map((S) => String(S).replace(/([.[\]])/g, '\\$1')).join('.'));
      const p = this._obj,
        [f, m] = u,
        h = s(
          () =>
            Object.prototype.hasOwnProperty.call(p, f)
              ? { value: p[f], exists: !0 }
              : t.getPathInfo(p, f),
          'getValue',
        ),
        { value: g, exists: v } = h(),
        E = v && (u.length === 1 || Ae(m, g, n)),
        b = u.length === 1 ? '' : ` with value ${t.objDisplay(m)}`;
      return this.assert(
        E,
        `expected #{this} to have property "${f}"${b}`,
        `expected #{this} to not have property "${f}"${b}`,
        m,
        v ? g : void 0,
      );
    }),
    o('toBeCloseTo', function (u, p = 2) {
      const f = this._obj;
      let m = !1,
        h = 0,
        g = 0;
      return (
        (u === Number.POSITIVE_INFINITY && f === Number.POSITIVE_INFINITY) ||
        (u === Number.NEGATIVE_INFINITY && f === Number.NEGATIVE_INFINITY)
          ? (m = !0)
          : ((h = 10 ** -p / 2), (g = Math.abs(f - u)), (m = g < h)),
        this.assert(
          m,
          `expected #{this} to be close to #{exp}, received difference is ${g}, but expected ${h}`,
          `expected #{this} to not be close to #{exp}, received difference is ${g}, but expected ${h}`,
          u,
          f,
          !1,
        )
      );
    }));
  function i(u) {
    if (!An(u._obj)) throw new TypeError(`${t.inspect(u._obj)} is not a spy or a call to a spy!`);
  }
  s(i, 'assertIsMock');
  function a(u) {
    return (i(u), u._obj);
  }
  (s(a, 'getSpy'),
    o(['toHaveBeenCalledTimes', 'toBeCalledTimes'], function (u) {
      const p = a(this),
        f = p.getMockName(),
        m = p.mock.calls.length;
      return this.assert(
        m === u,
        `expected "${f}" to be called #{exp} times, but got ${m} times`,
        `expected "${f}" to not be called #{exp} times`,
        u,
        m,
        !1,
      );
    }),
    o('toHaveBeenCalledOnce', function () {
      const u = a(this),
        p = u.getMockName(),
        f = u.mock.calls.length;
      return this.assert(
        f === 1,
        `expected "${p}" to be called once, but got ${f} times`,
        `expected "${p}" to not be called once`,
        1,
        f,
        !1,
      );
    }),
    o(['toHaveBeenCalled', 'toBeCalled'], function () {
      const u = a(this),
        p = u.getMockName(),
        f = u.mock.calls.length,
        m = f > 0,
        h = t.flag(this, 'negate');
      let g = t.getMessage(this, [
        m,
        `expected "${p}" to be called at least once`,
        `expected "${p}" to not be called at all, but actually been called ${f} times`,
        !0,
        m,
      ]);
      if ((m && h && (g = ia(u, g)), (m && h) || (!m && !h))) throw new r(g);
    }));
  function l(u, p) {
    return u.length === p.length && u.every((f, m) => Ae(f, p[m], [...n, $t]));
  }
  (s(l, 'equalsArgumentArray'),
    o(['toHaveBeenCalledWith', 'toBeCalledWith'], function (...u) {
      const p = a(this),
        f = p.getMockName(),
        m = p.mock.calls.some((v) => l(v, u)),
        h = t.flag(this, 'negate'),
        g = t.getMessage(this, [
          m,
          `expected "${f}" to be called with arguments: #{exp}`,
          `expected "${f}" to not be called with arguments: #{exp}`,
          u,
        ]);
      if ((m && h) || (!m && !h)) throw new r(ia(p, g, u));
    }),
    o('toHaveBeenCalledExactlyOnceWith', function (...u) {
      const p = a(this),
        f = p.getMockName(),
        m = p.mock.calls.length,
        g = p.mock.calls.some((b) => l(b, u)) && m === 1,
        v = t.flag(this, 'negate'),
        E = t.getMessage(this, [
          g,
          `expected "${f}" to be called once with arguments: #{exp}`,
          `expected "${f}" to not be called once with arguments: #{exp}`,
          u,
        ]);
      if ((g && v) || (!g && !v)) throw new r(ia(p, E, u));
    }),
    o(['toHaveBeenNthCalledWith', 'nthCalledWith'], function (u, ...p) {
      const f = a(this),
        m = f.getMockName(),
        h = f.mock.calls[u - 1],
        g = f.mock.calls.length,
        v = u <= g;
      this.assert(
        h && l(h, p),
        `expected ${mo(u)} "${m}" call to have been called with #{exp}${v ? '' : `, but called only ${g} times`}`,
        `expected ${mo(u)} "${m}" call to not have been called with #{exp}`,
        p,
        h,
        v,
      );
    }),
    o(['toHaveBeenLastCalledWith', 'lastCalledWith'], function (...u) {
      const p = a(this),
        f = p.getMockName(),
        m = p.mock.calls[p.mock.calls.length - 1];
      this.assert(
        m && l(m, u),
        `expected last "${f}" call to have been called with #{exp}`,
        `expected last "${f}" call to not have been called with #{exp}`,
        u,
        m,
      );
    }));
  function d(u, p, f) {
    const m = u.mock.invocationCallOrder,
      h = p.mock.invocationCallOrder;
    return m.length === 0 ? !f : h.length === 0 ? !1 : m[0] < h[0];
  }
  (s(d, 'isSpyCalledBeforeAnotherSpy'),
    o(['toHaveBeenCalledBefore'], function (u, p = !0) {
      const f = a(this);
      if (!An(u)) throw new TypeError(`${t.inspect(u)} is not a spy or a call to a spy`);
      this.assert(
        d(f, u, p),
        `expected "${f.getMockName()}" to have been called before "${u.getMockName()}"`,
        `expected "${f.getMockName()}" to not have been called before "${u.getMockName()}"`,
        u,
        f,
      );
    }),
    o(['toHaveBeenCalledAfter'], function (u, p = !0) {
      const f = a(this);
      if (!An(u)) throw new TypeError(`${t.inspect(u)} is not a spy or a call to a spy`);
      this.assert(
        d(u, f, p),
        `expected "${f.getMockName()}" to have been called after "${u.getMockName()}"`,
        `expected "${f.getMockName()}" to not have been called after "${u.getMockName()}"`,
        u,
        f,
      );
    }),
    o(['toThrow', 'toThrowError'], function (u) {
      if (typeof u == 'string' || typeof u > 'u' || u instanceof RegExp)
        return this.throws(u === '' ? /^$/ : u);
      const p = this._obj,
        f = t.flag(this, 'promise'),
        m = t.flag(this, 'negate');
      let h = null;
      if (f === 'rejects') h = p;
      else if (f === 'resolves' && typeof p != 'function') {
        if (m) return;
        {
          const g = t.flag(this, 'message') || "expected promise to throw an error, but it didn't",
            v = { showDiff: !1 };
          throw new r(g, v, t.flag(this, 'ssfi'));
        }
      } else {
        let g = !1;
        try {
          p();
        } catch (v) {
          ((g = !0), (h = v));
        }
        if (!g && !m) {
          const v = t.flag(this, 'message') || "expected function to throw an error, but it didn't",
            E = { showDiff: !1 };
          throw new r(v, E, t.flag(this, 'ssfi'));
        }
      }
      if (typeof u == 'function') {
        const g = u.name || u.prototype.constructor.name;
        return this.assert(
          h && h instanceof u,
          `expected error to be instance of ${g}`,
          `expected error not to be instance of ${g}`,
          u,
          h,
        );
      }
      if (u instanceof Error) {
        const g = Ae(h, u, [...n, $t]);
        return this.assert(
          g,
          'expected a thrown error to be #{exp}',
          'expected a thrown error not to be #{exp}',
          u,
          h,
        );
      }
      if (
        typeof u == 'object' &&
        'asymmetricMatch' in u &&
        typeof u.asymmetricMatch == 'function'
      ) {
        const g = u;
        return this.assert(
          h && g.asymmetricMatch(h),
          'expected error to match asymmetric matcher',
          'expected error not to match asymmetric matcher',
          g,
          h,
        );
      }
      throw new Error(
        `"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof u}"`,
      );
    }),
    [
      {
        name: 'toHaveResolved',
        condition: s(
          (u) =>
            u.mock.settledResults.length > 0 &&
            u.mock.settledResults.some(({ type: p }) => p === 'fulfilled'),
          'condition',
        ),
        action: 'resolved',
      },
      {
        name: ['toHaveReturned', 'toReturn'],
        condition: s(
          (u) => u.mock.calls.length > 0 && u.mock.results.some(({ type: p }) => p !== 'throw'),
          'condition',
        ),
        action: 'called',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function () {
        const m = a(this),
          h = m.getMockName(),
          g = p(m);
        this.assert(
          g,
          `expected "${h}" to be successfully ${f} at least once`,
          `expected "${h}" to not be successfully ${f}`,
          g,
          !g,
          !1,
        );
      });
    }),
    [
      {
        name: 'toHaveResolvedTimes',
        condition: s(
          (u, p) =>
            u.mock.settledResults.reduce((f, { type: m }) => (m === 'fulfilled' ? ++f : f), 0) ===
            p,
          'condition',
        ),
        action: 'resolved',
      },
      {
        name: ['toHaveReturnedTimes', 'toReturnTimes'],
        condition: s(
          (u, p) => u.mock.results.reduce((f, { type: m }) => (m === 'throw' ? f : ++f), 0) === p,
          'condition',
        ),
        action: 'called',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function (m) {
        const h = a(this),
          g = h.getMockName(),
          v = p(h, m);
        this.assert(
          v,
          `expected "${g}" to be successfully ${f} ${m} times`,
          `expected "${g}" to not be successfully ${f} ${m} times`,
          `expected resolved times: ${m}`,
          `received resolved times: ${v}`,
          !1,
        );
      });
    }),
    [
      {
        name: 'toHaveResolvedWith',
        condition: s(
          (u, p) =>
            u.mock.settledResults.some(({ type: f, value: m }) => f === 'fulfilled' && Ae(p, m)),
          'condition',
        ),
        action: 'resolve',
      },
      {
        name: ['toHaveReturnedWith', 'toReturnWith'],
        condition: s(
          (u, p) => u.mock.results.some(({ type: f, value: m }) => f === 'return' && Ae(p, m)),
          'condition',
        ),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function (m) {
        const h = a(this),
          g = p(h, m),
          v = t.flag(this, 'negate');
        if ((g && v) || (!g && !v)) {
          const E = h.getMockName(),
            b = t.getMessage(this, [
              g,
              `expected "${E}" to ${f} with: #{exp} at least once`,
              `expected "${E}" to not ${f} with: #{exp}`,
              m,
            ]),
            S = f === 'return' ? h.mock.results : h.mock.settledResults;
          throw new r(oR(h, S, b, m));
        }
      });
    }),
    [
      {
        name: 'toHaveLastResolvedWith',
        condition: s((u, p) => {
          const f = u.mock.settledResults[u.mock.settledResults.length - 1];
          return f && f.type === 'fulfilled' && Ae(f.value, p);
        }, 'condition'),
        action: 'resolve',
      },
      {
        name: ['toHaveLastReturnedWith', 'lastReturnedWith'],
        condition: s((u, p) => {
          const f = u.mock.results[u.mock.results.length - 1];
          return f && f.type === 'return' && Ae(f.value, p);
        }, 'condition'),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function (m) {
        const h = a(this),
          g = f === 'return' ? h.mock.results : h.mock.settledResults,
          v = g[g.length - 1],
          E = h.getMockName();
        this.assert(
          p(h, m),
          `expected last "${E}" call to ${f} #{exp}`,
          `expected last "${E}" call to not ${f} #{exp}`,
          m,
          v?.value,
        );
      });
    }),
    [
      {
        name: 'toHaveNthResolvedWith',
        condition: s((u, p, f) => {
          const m = u.mock.settledResults[p - 1];
          return m && m.type === 'fulfilled' && Ae(m.value, f);
        }, 'condition'),
        action: 'resolve',
      },
      {
        name: ['toHaveNthReturnedWith', 'nthReturnedWith'],
        condition: s((u, p, f) => {
          const m = u.mock.results[p - 1];
          return m && m.type === 'return' && Ae(m.value, f);
        }, 'condition'),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      o(u, function (m, h) {
        const g = a(this),
          v = g.getMockName(),
          b = (f === 'return' ? g.mock.results : g.mock.settledResults)[m - 1],
          S = `${mo(m)} call`;
        this.assert(
          p(g, m, h),
          `expected ${S} "${v}" call to ${f} #{exp}`,
          `expected ${S} "${v}" call to not ${f} #{exp}`,
          h,
          b?.value,
        );
      });
    }),
    o('withContext', function (u) {
      for (const p in u) t.flag(this, p, u[p]);
      return this;
    }),
    t.addProperty(
      e.Assertion.prototype,
      'resolves',
      s(function () {
        const p = new Error('resolves');
        (t.flag(this, 'promise', 'resolves'), t.flag(this, 'error', p));
        const f = t.flag(this, 'vitest-test'),
          m = t.flag(this, 'object');
        if (t.flag(this, 'poll'))
          throw new SyntaxError('expect.poll() is not supported in combination with .resolves');
        if (typeof m?.then != 'function')
          throw new TypeError(
            `You must provide a Promise to expect() when using .resolves, not '${typeof m}'.`,
          );
        const h = new Proxy(this, {
          get: s((g, v, E) => {
            const b = Reflect.get(g, v, E);
            return typeof b != 'function'
              ? b instanceof e.Assertion
                ? h
                : b
              : (...S) => {
                  t.flag(this, '_name', v);
                  const R = m.then(
                    (I) => (t.flag(this, 'object', I), b.call(this, ...S)),
                    (I) => {
                      const $ = new r(`promise rejected "${t.inspect(I)}" instead of resolving`, {
                        showDiff: !1,
                      });
                      throw (($.cause = I), ($.stack = p.stack.replace(p.message, $.message)), $);
                    },
                  );
                  return Cd(f, R, Od(t, this, !!S.length), p);
                };
          }, 'get'),
        });
        return h;
      }, '__VITEST_RESOLVES__'),
    ),
    t.addProperty(
      e.Assertion.prototype,
      'rejects',
      s(function () {
        const p = new Error('rejects');
        (t.flag(this, 'promise', 'rejects'), t.flag(this, 'error', p));
        const f = t.flag(this, 'vitest-test'),
          m = t.flag(this, 'object'),
          h = typeof m == 'function' ? m() : m;
        if (t.flag(this, 'poll'))
          throw new SyntaxError('expect.poll() is not supported in combination with .rejects');
        if (typeof h?.then != 'function')
          throw new TypeError(
            `You must provide a Promise to expect() when using .rejects, not '${typeof h}'.`,
          );
        const g = new Proxy(this, {
          get: s((v, E, b) => {
            const S = Reflect.get(v, E, b);
            return typeof S != 'function'
              ? S instanceof e.Assertion
                ? g
                : S
              : (...R) => {
                  t.flag(this, '_name', E);
                  const I = h.then(
                    ($) => {
                      const x = new r(`promise resolved "${t.inspect($)}" instead of rejecting`, {
                        showDiff: !0,
                        expected: new Error('rejected promise'),
                        actual: $,
                      });
                      throw ((x.stack = p.stack.replace(p.message, x.message)), x);
                    },
                    ($) => (t.flag(this, 'object', $), S.call(this, ...R)),
                  );
                  return Cd(f, I, Od(t, this, !!R.length), p);
                };
          }, 'get'),
        });
        return g;
      }, '__VITEST_REJECTS__'),
    ));
}, 'JestChaiExpect');
function mo(e) {
  const t = e % 10,
    r = e % 100;
  return t === 1 && r !== 11
    ? `${e}st`
    : t === 2 && r !== 12
      ? `${e}nd`
      : t === 3 && r !== 13
        ? `${e}rd`
        : `${e}th`;
}
s(mo, 'ordinalOf');
function ia(e, t, r) {
  return (
    e.mock.calls.length &&
      (t += Ue.gray(`

Received: 

${e.mock.calls.map((n, o) => {
  let i = Ue.bold(`  ${mo(o + 1)} ${e.getMockName()} call:

`);
  return (
    r
      ? (i += Hn(r, n, { omitAnnotationLines: !0 }))
      : (i += _t(n)
          .split(
            `
`,
          )
          .map((a) => `    ${a}`).join(`
`)),
    (i += `
`),
    i
  );
}).join(`
`)}`)),
    (t += Ue.gray(`

Number of calls: ${Ue.bold(e.mock.calls.length)}
`)),
    t
  );
}
s(ia, 'formatCalls');
function oR(e, t, r, n) {
  return (
    t.length &&
      (r += Ue.gray(`

Received: 

${t.map((o, i) => {
  let a = Ue.bold(`  ${mo(i + 1)} ${e.getMockName()} call return:

`);
  return (
    n
      ? (a += Hn(n, o.value, { omitAnnotationLines: !0 }))
      : (a += _t(o)
          .split(
            `
`,
          )
          .map((l) => `    ${l}`).join(`
`)),
    (a += `
`),
    a
  );
}).join(`
`)}`)),
    (r += Ue.gray(`

Number of calls: ${Ue.bold(e.mock.calls.length)}
`)),
    r
  );
}
s(oR, 'formatReturns');
function sR(e, t) {
  const r = e._obj,
    n = sr.flag(e, 'negate'),
    o = sr.flag(e, 'promise') || '',
    i = { ...Ry(), diff: Hn, stringify: _t, iterableEquality: $t, subsetEquality: zo };
  return {
    state: {
      ...di(t),
      customTesters: Sc(),
      isNot: n,
      utils: i,
      promise: o,
      equals: Ae,
      suppressedErrors: [],
      soft: sr.flag(e, 'soft'),
      poll: sr.flag(e, 'poll'),
    },
    isNot: n,
    obj: r,
  };
}
s(sR, 'getMatcherState');
var iR = class extends Error {
  constructor(t, r, n) {
    (super(t), (this.actual = r), (this.expected = n));
  }
};
s(iR, 'JestExtendError');
var wb = iR;
function aR(e, t, r) {
  return (n, o) => {
    Object.entries(r).forEach(([i, a]) => {
      function l(...m) {
        const { state: h, isNot: g, obj: v } = sR(this, t),
          E = a.call(h, v, ...m);
        if (E && typeof E == 'object' && typeof E.then == 'function')
          return E.then(({ pass: x, message: A, actual: w, expected: _ }) => {
            if ((x && g) || (!x && !g)) throw new wb(A(), w, _);
          });
        const { pass: b, message: S, actual: R, expected: I } = E;
        if ((b && g) || (!b && !g)) throw new wb(S(), R, I);
      }
      s(l, 'expectWrapper');
      const d = xy(o, i, l);
      (o.addMethod(globalThis[ui].matchers, i, d), o.addMethod(e.Assertion.prototype, i, d));
      const u = class extends jr {
        constructor(h = !1, ...g) {
          super(g, h);
        }
        asymmetricMatch(h) {
          const { pass: g } = a.call(this.getMatcherContext(t), h, ...this.sample);
          return this.inverse ? !g : g;
        }
        toString() {
          return `${this.inverse ? 'not.' : ''}${i}`;
        }
        getExpectedType() {
          return 'any';
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((h) => _t(h)).join(', ')}>`;
        }
      };
      s(u, 'CustomMatcher');
      let p = u;
      const f = s((...m) => new p(!1, ...m), 'customMatcher');
      (Object.defineProperty(t, i, { configurable: !0, enumerable: !0, value: f, writable: !0 }),
        Object.defineProperty(t.not, i, {
          configurable: !0,
          enumerable: !0,
          value: s((...m) => new p(!0, ...m), 'value'),
          writable: !0,
        }),
        Object.defineProperty(globalThis[wd], i, {
          configurable: !0,
          enumerable: !0,
          value: f,
          writable: !0,
        }));
    });
  };
}
s(aR, 'JestExtendPlugin');
var PJ = s((e, t) => {
  t.addMethod(e.expect, 'extend', (r, n) => {
    Sn(aR(e, r, n));
  });
}, 'JestExtend');
function lR() {
  (Sn(PJ), Sn(RJ), Sn(AJ));
  const e = s((n, o) => {
    const { assertionCalls: i } = di(e);
    return (sa({ assertionCalls: i + 1, soft: !1 }, e), zr(n, o));
  }, 'expect');
  (Object.assign(e, zr),
    (e.getState = () => di(e)),
    (e.setState = (n) => sa(n, e)),
    (e.extend = (n) => zr.extend(e, n)),
    (e.soft = (...n) => {
      const o = e(...n);
      return (e.setState({ soft: !0 }), o);
    }),
    e.extend(gJ),
    (e.unreachable = (n) => {
      q.fail(`expected${n ? ` "${n}" ` : ' '}not to be reached`);
    }));
  function t(n) {
    const o = s(
      () =>
        new Error(
          `expected number of assertions to be ${n}, but got ${e.getState().assertionCalls}`,
        ),
      'errorGen',
    );
    ('captureStackTrace' in Error &&
      typeof Error.captureStackTrace == 'function' &&
      Error.captureStackTrace(o(), t),
      e.setState({ expectedAssertionsNumber: n, expectedAssertionsNumberErrorGen: o }));
  }
  s(t, 'assertions');
  function r() {
    const n = new Error('expected any number of assertion, but got none');
    ('captureStackTrace' in Error &&
      typeof Error.captureStackTrace == 'function' &&
      Error.captureStackTrace(n, r),
      e.setState({ isExpectingAssertions: !0, isExpectingAssertionsError: n }));
  }
  return (
    s(r, 'hasAssertions'),
    sa(
      {
        assertionCalls: 0,
        isExpectingAssertions: !1,
        isExpectingAssertionsError: null,
        expectedAssertionsNumber: null,
        expectedAssertionsNumberErrorGen: null,
      },
      e,
    ),
    sr.addMethod(e, 'assertions', t),
    sr.addMethod(e, 'hasAssertions', r),
    e.extend(F_),
    e
  );
}
s(lR, 'createExpect');
var cR = lR();
Object.defineProperty(globalThis, Sy, { value: cR, writable: !0, configurable: !0 });
function uR(e, t, r) {
  Object.defineProperty(e, t, r);
}
s(uR, 'f');
var aa = Symbol.for('tinyspy:spy'),
  xJ = s((e) => {
    ((e.called = !1),
      (e.callCount = 0),
      (e.calls = []),
      (e.results = []),
      (e.resolves = []),
      (e.next = []));
  }, 'P'),
  OJ = s((e) => (uR(e, aa, { value: { reset: s(() => xJ(e[aa]), 'reset') } }), e[aa]), 'K'),
  CJ = s((e) => e[aa] || OJ(e), 'T'),
  Nd = new Set();
function Oy(e) {
  return (Nd.add(e), () => void Nd.delete(e));
}
s(Oy, 'onMockCall');
var IJ = s((...e) => {
  const t = xA(...e);
  return Iy(t);
}, 'spyOn');
function Cy(e) {
  const t = e ? Ed(e) : Ed();
  return Iy(t);
}
s(Cy, 'fn');
function Iy(e) {
  const t = $d(e),
    r = t.mockImplementation.bind(null);
  return ((t.mockImplementation = (n) => $d(r(n))), t);
}
s(Iy, 'reactiveMock');
function $d(e) {
  const t = CJ(e),
    r = t.impl;
  return (
    t.willCall(function (...n) {
      return (Nd.forEach((o) => o(e, n)), r?.apply(this, n));
    }),
    e
  );
}
s($d, 'listenWhenCalled');
function Ny() {
  Li.forEach((e) => e.mockClear());
}
s(Ny, 'clearAllMocks');
function $y() {
  Li.forEach((e) => e.mockReset());
}
s($y, 'resetAllMocks');
function qy() {
  Li.forEach((e) => e.mockRestore());
}
s(qy, 'restoreAllMocks');
function dR(e, t = {}) {
  return e;
}
s(dR, 'mocked');
var pR = {};
Rt(pR, {
  buildQueries: () => mr,
  configure: () => uP,
  createEvent: () => zs,
  findAllByAltText: () => ox,
  findAllByDisplayValue: () => QP,
  findAllByLabelText: () => IP,
  findAllByPlaceholderText: () => FP,
  findAllByRole: () => bx,
  findAllByTestId: () => _x,
  findAllByText: () => zP,
  findAllByTitle: () => ux,
  findByAltText: () => sx,
  findByDisplayValue: () => ZP,
  findByLabelText: () => NP,
  findByPlaceholderText: () => BP,
  findByRole: () => vx,
  findByTestId: () => Ax,
  findByText: () => GP,
  findByTitle: () => dx,
  fireEvent: () => No,
  getAllByAltText: () => rx,
  getAllByDisplayValue: () => YP,
  getAllByLabelText: () => $P,
  getAllByPlaceholderText: () => DP,
  getAllByRole: () => hx,
  getAllByTestId: () => wx,
  getAllByText: () => VP,
  getAllByTitle: () => lx,
  getByAltText: () => nx,
  getByDisplayValue: () => XP,
  getByLabelText: () => qP,
  getByPlaceholderText: () => LP,
  getByRole: () => gx,
  getByTestId: () => Sx,
  getByText: () => HP,
  getByTitle: () => cx,
  getConfig: () => Ee,
  getDefaultNormalizer: () => xc,
  getElementError: () => Ji,
  getMultipleElementsFoundError: () => Ui,
  getNodeText: () => Go,
  getQueriesForElement: () => Qa,
  getRoles: () => eh,
  getSuggestedQuery: () => fi,
  isInaccessible: () => Bi,
  logDOM: () => Fd,
  logRoles: () => eU,
  makeFindQuery: () => Nn,
  makeGetAllQuery: () => Ic,
  makeSingleQuery: () => In,
  prettyDOM: () => Io,
  prettyFormat: () => My,
  queries: () => Xa,
  queryAllByAltText: () => ex,
  queryAllByAttribute: () => ln,
  queryAllByDisplayValue: () => WP,
  queryAllByLabelText: () => MP,
  queryAllByPlaceholderText: () => jP,
  queryAllByRole: () => mx,
  queryAllByTestId: () => Tx,
  queryAllByText: () => JP,
  queryAllByTitle: () => ix,
  queryByAltText: () => tx,
  queryByAttribute: () => rh,
  queryByDisplayValue: () => KP,
  queryByLabelText: () => OP,
  queryByPlaceholderText: () => kP,
  queryByRole: () => yx,
  queryByTestId: () => Ex,
  queryByText: () => UP,
  queryByTitle: () => ax,
  queryHelpers: () => tU,
  screen: () => EU,
  waitFor: () => Cc,
  waitForElementToBeRemoved: () => Px,
  within: () => Qa,
  wrapAllByQueryWithSuggestion: () => At,
  wrapSingleQueryWithSuggestion: () => Wr,
});
var My = Ke(g1()),
  NJ = Object.prototype.toString;
function qd(e) {
  return typeof e == 'function' || NJ.call(e) === '[object Function]';
}
s(qd, 'isCallable');
function fR(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
s(fR, 'toInteger');
var $J = Math.pow(2, 53) - 1;
function mR(e) {
  var t = fR(e);
  return Math.min(Math.max(t, 0), $J);
}
s(mR, 'toLength');
function Bt(e, t) {
  var r = Array,
    n = Object(e);
  if (e == null)
    throw new TypeError('Array.from requires an array-like object - not null or undefined');
  if (typeof t < 'u' && !qd(t))
    throw new TypeError('Array.from: when provided, the second argument must be a function');
  for (var o = mR(n.length), i = qd(r) ? Object(new r(o)) : new Array(o), a = 0, l; a < o; )
    ((l = n[a]), t ? (i[a] = t(l, a)) : (i[a] = l), (a += 1));
  return ((i.length = o), i);
}
s(Bt, 'arrayFrom');
function Oo(e) {
  '@babel/helpers - typeof';
  return (
    (Oo =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    Oo(e)
  );
}
s(Oo, '_typeof');
function yR(e, t) {
  if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
s(yR, '_classCallCheck');
function Md(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    ((n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      'value' in n && (n.writable = !0),
      Object.defineProperty(e, jy(n.key), n));
  }
}
s(Md, '_defineProperties');
function hR(e, t, r) {
  return (
    t && Md(e.prototype, t),
    r && Md(e, r),
    Object.defineProperty(e, 'prototype', { writable: !1 }),
    e
  );
}
s(hR, '_createClass');
function gR(e, t, r) {
  return (
    (t = jy(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(gR, '_defineProperty');
function jy(e) {
  var t = bR(e, 'string');
  return Oo(t) === 'symbol' ? t : String(t);
}
s(jy, '_toPropertyKey');
function bR(e, t) {
  if (Oo(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (Oo(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
s(bR, '_toPrimitive');
var qJ = (function () {
    function e() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      (yR(this, e), gR(this, 'items', void 0), (this.items = t));
    }
    return (
      s(e, 'SetLike'),
      hR(e, [
        {
          key: 'add',
          value: s(function (r) {
            return (this.has(r) === !1 && this.items.push(r), this);
          }, 'add'),
        },
        {
          key: 'clear',
          value: s(function () {
            this.items = [];
          }, 'clear'),
        },
        {
          key: 'delete',
          value: s(function (r) {
            var n = this.items.length;
            return (
              (this.items = this.items.filter(function (o) {
                return o !== r;
              })),
              n !== this.items.length
            );
          }, '_delete'),
        },
        {
          key: 'forEach',
          value: s(function (r) {
            var n = this;
            this.items.forEach(function (o) {
              r(o, o, n);
            });
          }, 'forEach'),
        },
        {
          key: 'has',
          value: s(function (r) {
            return this.items.indexOf(r) !== -1;
          }, 'has'),
        },
        {
          key: 'size',
          get: s(function () {
            return this.items.length;
          }, 'get'),
        },
      ]),
      e
    );
  })(),
  MJ = typeof Set > 'u' ? Set : qJ;
function ft(e) {
  var t;
  return (t = e.localName) !== null && t !== void 0 ? t : e.tagName.toLowerCase();
}
s(ft, 'getLocalName');
var jJ = {
    article: 'article',
    aside: 'complementary',
    button: 'button',
    datalist: 'listbox',
    dd: 'definition',
    details: 'group',
    dialog: 'dialog',
    dt: 'term',
    fieldset: 'group',
    figure: 'figure',
    form: 'form',
    footer: 'contentinfo',
    h1: 'heading',
    h2: 'heading',
    h3: 'heading',
    h4: 'heading',
    h5: 'heading',
    h6: 'heading',
    header: 'banner',
    hr: 'separator',
    html: 'document',
    legend: 'legend',
    li: 'listitem',
    math: 'math',
    main: 'main',
    menu: 'list',
    nav: 'navigation',
    ol: 'list',
    optgroup: 'group',
    option: 'option',
    output: 'status',
    progress: 'progressbar',
    section: 'region',
    summary: 'button',
    table: 'table',
    tbody: 'rowgroup',
    textarea: 'textbox',
    tfoot: 'rowgroup',
    td: 'cell',
    th: 'columnheader',
    thead: 'rowgroup',
    tr: 'row',
    ul: 'list',
  },
  kJ = {
    caption: new Set(['aria-label', 'aria-labelledby']),
    code: new Set(['aria-label', 'aria-labelledby']),
    deletion: new Set(['aria-label', 'aria-labelledby']),
    emphasis: new Set(['aria-label', 'aria-labelledby']),
    generic: new Set(['aria-label', 'aria-labelledby', 'aria-roledescription']),
    insertion: new Set(['aria-label', 'aria-labelledby']),
    paragraph: new Set(['aria-label', 'aria-labelledby']),
    presentation: new Set(['aria-label', 'aria-labelledby']),
    strong: new Set(['aria-label', 'aria-labelledby']),
    subscript: new Set(['aria-label', 'aria-labelledby']),
    superscript: new Set(['aria-label', 'aria-labelledby']),
  };
function vR(e, t) {
  return [
    'aria-atomic',
    'aria-busy',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-dropeffect',
    'aria-flowto',
    'aria-grabbed',
    'aria-hidden',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-live',
    'aria-owns',
    'aria-relevant',
    'aria-roledescription',
  ].some(function (r) {
    var n;
    return e.hasAttribute(r) && !((n = kJ[t]) !== null && n !== void 0 && n.has(r));
  });
}
s(vR, 'hasGlobalAriaAttributes');
function ky(e, t) {
  return vR(e, t);
}
s(ky, 'ignorePresentationalRole');
function TR(e) {
  var t = wR(e);
  if (t === null || t === 'presentation') {
    var r = ER(e);
    if (t !== 'presentation' || ky(e, r || '')) return r;
  }
  return t;
}
s(TR, 'getRole');
function ER(e) {
  var t = jJ[ft(e)];
  if (t !== void 0) return t;
  switch (ft(e)) {
    case 'a':
    case 'area':
    case 'link':
      if (e.hasAttribute('href')) return 'link';
      break;
    case 'img':
      return e.getAttribute('alt') === '' && !ky(e, 'img') ? 'presentation' : 'img';
    case 'input': {
      var r = e,
        n = r.type;
      switch (n) {
        case 'button':
        case 'image':
        case 'reset':
        case 'submit':
          return 'button';
        case 'checkbox':
        case 'radio':
          return n;
        case 'range':
          return 'slider';
        case 'email':
        case 'tel':
        case 'text':
        case 'url':
          return e.hasAttribute('list') ? 'combobox' : 'textbox';
        case 'search':
          return e.hasAttribute('list') ? 'combobox' : 'searchbox';
        case 'number':
          return 'spinbutton';
        default:
          return null;
      }
    }
    case 'select':
      return e.hasAttribute('multiple') || e.size > 1 ? 'listbox' : 'combobox';
  }
  return null;
}
s(ER, 'getImplicitRole');
function wR(e) {
  var t = e.getAttribute('role');
  if (t !== null) {
    var r = t.trim().split(' ')[0];
    if (r.length > 0) return r;
  }
  return null;
}
s(wR, 'getExplicitRole');
function je(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
s(je, 'isElement');
function Dy(e) {
  return je(e) && ft(e) === 'caption';
}
s(Dy, 'isHTMLTableCaptionElement');
function Hs(e) {
  return je(e) && ft(e) === 'input';
}
s(Hs, 'isHTMLInputElement');
function SR(e) {
  return je(e) && ft(e) === 'optgroup';
}
s(SR, 'isHTMLOptGroupElement');
function _R(e) {
  return je(e) && ft(e) === 'select';
}
s(_R, 'isHTMLSelectElement');
function AR(e) {
  return je(e) && ft(e) === 'table';
}
s(AR, 'isHTMLTableElement');
function RR(e) {
  return je(e) && ft(e) === 'textarea';
}
s(RR, 'isHTMLTextAreaElement');
function PR(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument,
    r = t.defaultView;
  if (r === null) throw new TypeError('no window available');
  return r;
}
s(PR, 'safeWindow');
function xR(e) {
  return je(e) && ft(e) === 'fieldset';
}
s(xR, 'isHTMLFieldSetElement');
function OR(e) {
  return je(e) && ft(e) === 'legend';
}
s(OR, 'isHTMLLegendElement');
function CR(e) {
  return je(e) && ft(e) === 'slot';
}
s(CR, 'isHTMLSlotElement');
function IR(e) {
  return je(e) && e.ownerSVGElement !== void 0;
}
s(IR, 'isSVGElement');
function NR(e) {
  return je(e) && ft(e) === 'svg';
}
s(NR, 'isSVGSVGElement');
function $R(e) {
  return IR(e) && ft(e) === 'title';
}
s($R, 'isSVGTitleElement');
function pi(e, t) {
  if (je(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(' '),
      n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r
      .map(function (o) {
        return n.getElementById(o);
      })
      .filter(function (o) {
        return o !== null;
      });
  }
  return [];
}
s(pi, 'queryIdRefs');
function ar(e, t) {
  return je(e) ? t.indexOf(TR(e)) !== -1 : !1;
}
s(ar, 'hasAnyConcreteRoles');
function qR(e) {
  return e.trim().replace(/\s\s+/g, ' ');
}
s(qR, 'asFlatString');
function MR(e, t) {
  if (!je(e)) return !1;
  if (e.hasAttribute('hidden') || e.getAttribute('aria-hidden') === 'true') return !0;
  var r = t(e);
  return r.getPropertyValue('display') === 'none' || r.getPropertyValue('visibility') === 'hidden';
}
s(MR, 'isHidden');
function jR(e) {
  return ar(e, ['button', 'combobox', 'listbox', 'textbox']) || Ly(e, 'range');
}
s(jR, 'isControl');
function Ly(e, t) {
  if (!je(e)) return !1;
  switch (t) {
    case 'range':
      return ar(e, ['meter', 'progressbar', 'scrollbar', 'slider', 'spinbutton']);
    default:
      throw new TypeError(
        "No knowledge about abstract role '".concat(t, "'. This is likely a bug :("),
      );
  }
}
s(Ly, 'hasAbstractRole');
function jd(e, t) {
  var r = Bt(e.querySelectorAll(t));
  return (
    pi(e, 'aria-owns').forEach(function (n) {
      r.push.apply(r, Bt(n.querySelectorAll(t)));
    }),
    r
  );
}
s(jd, 'querySelectorAllSubtree');
function kR(e) {
  return _R(e) ? e.selectedOptions || jd(e, '[selected]') : jd(e, '[aria-selected="true"]');
}
s(kR, 'querySelectedOptions');
function DR(e) {
  return ar(e, ['none', 'presentation']);
}
s(DR, 'isMarkedPresentational');
function LR(e) {
  return Dy(e);
}
s(LR, 'isNativeHostLanguageTextAlternativeElement');
function FR(e) {
  return ar(e, [
    'button',
    'cell',
    'checkbox',
    'columnheader',
    'gridcell',
    'heading',
    'label',
    'legend',
    'link',
    'menuitem',
    'menuitemcheckbox',
    'menuitemradio',
    'option',
    'radio',
    'row',
    'rowheader',
    'switch',
    'tab',
    'tooltip',
    'treeitem',
  ]);
}
s(FR, 'allowsNameFromContent');
function BR(e) {
  return !1;
}
s(BR, 'isDescendantOfNativeHostLanguageTextAlternativeElement');
function JR(e) {
  return Hs(e) || RR(e) ? e.value : e.textContent || '';
}
s(JR, 'getValueOfTextbox');
function kd(e) {
  var t = e.getPropertyValue('content');
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : '';
}
s(kd, 'getTextualContent');
function Fy(e) {
  var t = ft(e);
  return (
    t === 'button' ||
    (t === 'input' && e.getAttribute('type') !== 'hidden') ||
    t === 'meter' ||
    t === 'output' ||
    t === 'progress' ||
    t === 'select' ||
    t === 'textarea'
  );
}
s(Fy, 'isLabelableElement');
function By(e) {
  if (Fy(e)) return e;
  var t = null;
  return (
    e.childNodes.forEach(function (r) {
      if (t === null && je(r)) {
        var n = By(r);
        n !== null && (t = n);
      }
    }),
    t
  );
}
s(By, 'findLabelableElement');
function UR(e) {
  if (e.control !== void 0) return e.control;
  var t = e.getAttribute('for');
  return t !== null ? e.ownerDocument.getElementById(t) : By(e);
}
s(UR, 'getControlOfLabel');
function VR(e) {
  var t = e.labels;
  if (t === null) return t;
  if (t !== void 0) return Bt(t);
  if (!Fy(e)) return null;
  var r = e.ownerDocument;
  return Bt(r.querySelectorAll('label')).filter(function (n) {
    return UR(n) === e;
  });
}
s(VR, 'getLabels');
function HR(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? Bt(e.childNodes) : t;
}
s(HR, 'getSlotContents');
function Jy(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = new MJ(),
    n = PR(e),
    o = t.compute,
    i = o === void 0 ? 'name' : o,
    a = t.computedStyleSupportsPseudoElements,
    l = a === void 0 ? t.getComputedStyle !== void 0 : a,
    d = t.getComputedStyle,
    u = d === void 0 ? n.getComputedStyle.bind(n) : d,
    p = t.hidden,
    f = p === void 0 ? !1 : p;
  function m(b, S) {
    var R = '';
    if (je(b) && l) {
      var I = u(b, '::before'),
        $ = kd(I);
      R = ''.concat($, ' ').concat(R);
    }
    var x = CR(b) ? HR(b) : Bt(b.childNodes).concat(pi(b, 'aria-owns'));
    if (
      (x.forEach(function (_) {
        var j = E(_, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !1, recursion: !0 }),
          N = je(_) ? u(_).getPropertyValue('display') : 'inline',
          V = N !== 'inline' ? ' ' : '';
        R += ''.concat(V).concat(j).concat(V);
      }),
      je(b) && l)
    ) {
      var A = u(b, '::after'),
        w = kd(A);
      R = ''.concat(R, ' ').concat(w);
    }
    return R.trim();
  }
  s(m, 'computeMiscTextAlternative');
  function h(b, S) {
    var R = b.getAttributeNode(S);
    return R !== null && !r.has(R) && R.value.trim() !== '' ? (r.add(R), R.value) : null;
  }
  s(h, 'useAttribute');
  function g(b) {
    return je(b) ? h(b, 'title') : null;
  }
  s(g, 'computeTooltipAttributeValue');
  function v(b) {
    if (!je(b)) return null;
    if (xR(b)) {
      r.add(b);
      for (var S = Bt(b.childNodes), R = 0; R < S.length; R += 1) {
        var I = S[R];
        if (OR(I)) return E(I, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (AR(b)) {
      r.add(b);
      for (var $ = Bt(b.childNodes), x = 0; x < $.length; x += 1) {
        var A = $[x];
        if (Dy(A)) return E(A, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (NR(b)) {
      r.add(b);
      for (var w = Bt(b.childNodes), _ = 0; _ < w.length; _ += 1) {
        var j = w[_];
        if ($R(j)) return j.textContent;
      }
      return null;
    } else if (ft(b) === 'img' || ft(b) === 'area') {
      var N = h(b, 'alt');
      if (N !== null) return N;
    } else if (SR(b)) {
      var V = h(b, 'label');
      if (V !== null) return V;
    }
    if (Hs(b) && (b.type === 'button' || b.type === 'submit' || b.type === 'reset')) {
      var H = h(b, 'value');
      if (H !== null) return H;
      if (b.type === 'submit') return 'Submit';
      if (b.type === 'reset') return 'Reset';
    }
    var P = VR(b);
    if (P !== null && P.length !== 0)
      return (
        r.add(b),
        Bt(P)
          .map(function (K) {
            return E(K, { isEmbeddedInLabel: !0, isReferenced: !1, recursion: !0 });
          })
          .filter(function (K) {
            return K.length > 0;
          })
          .join(' ')
      );
    if (Hs(b) && b.type === 'image') {
      var D = h(b, 'alt');
      if (D !== null) return D;
      var F = h(b, 'title');
      return F !== null ? F : 'Submit Query';
    }
    if (ar(b, ['button'])) {
      var k = m(b, { isEmbeddedInLabel: !1 });
      if (k !== '') return k;
    }
    return null;
  }
  s(v, 'computeElementTextAlternative');
  function E(b, S) {
    if (r.has(b)) return '';
    if (!f && MR(b, u) && !S.isReferenced) return (r.add(b), '');
    var R = je(b) ? b.getAttributeNode('aria-labelledby') : null,
      I = R !== null && !r.has(R) ? pi(b, 'aria-labelledby') : [];
    if (i === 'name' && !S.isReferenced && I.length > 0)
      return (
        r.add(R),
        I.map(function (N) {
          return E(N, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !0, recursion: !1 });
        }).join(' ')
      );
    var $ = S.recursion && jR(b) && i === 'name';
    if (!$) {
      var x = ((je(b) && b.getAttribute('aria-label')) || '').trim();
      if (x !== '' && i === 'name') return (r.add(b), x);
      if (!DR(b)) {
        var A = v(b);
        if (A !== null) return (r.add(b), A);
      }
    }
    if (ar(b, ['menu'])) return (r.add(b), '');
    if ($ || S.isEmbeddedInLabel || S.isReferenced) {
      if (ar(b, ['combobox', 'listbox'])) {
        r.add(b);
        var w = kR(b);
        return w.length === 0
          ? Hs(b)
            ? b.value
            : ''
          : Bt(w)
              .map(function (N) {
                return E(N, {
                  isEmbeddedInLabel: S.isEmbeddedInLabel,
                  isReferenced: !1,
                  recursion: !0,
                });
              })
              .join(' ');
      }
      if (Ly(b, 'range'))
        return (
          r.add(b),
          b.hasAttribute('aria-valuetext')
            ? b.getAttribute('aria-valuetext')
            : b.hasAttribute('aria-valuenow')
              ? b.getAttribute('aria-valuenow')
              : b.getAttribute('value') || ''
        );
      if (ar(b, ['textbox'])) return (r.add(b), JR(b));
    }
    if (FR(b) || (je(b) && S.isReferenced) || LR(b) || BR()) {
      var _ = m(b, { isEmbeddedInLabel: S.isEmbeddedInLabel });
      if (_ !== '') return (r.add(b), _);
    }
    if (b.nodeType === b.TEXT_NODE) return (r.add(b), b.textContent || '');
    if (S.recursion) return (r.add(b), m(b, { isEmbeddedInLabel: S.isEmbeddedInLabel }));
    var j = g(b);
    return j !== null ? (r.add(b), j) : (r.add(b), '');
  }
  return (
    s(E, 'computeTextAlternative'),
    qR(E(e, { isEmbeddedInLabel: !1, isReferenced: i === 'description', recursion: !1 }))
  );
}
s(Jy, 'computeTextAlternative');
function Co(e) {
  '@babel/helpers - typeof';
  return (
    (Co =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    Co(e)
  );
}
s(Co, '_typeof');
function Dd(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    (t &&
      (n = n.filter(function (o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })),
      r.push.apply(r, n));
  }
  return r;
}
s(Dd, 'ownKeys');
function Ld(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? Dd(Object(r), !0).forEach(function (n) {
          zR(e, n, r[n]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : Dd(Object(r)).forEach(function (n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
          });
  }
  return e;
}
s(Ld, '_objectSpread');
function zR(e, t, r) {
  return (
    (t = GR(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(zR, '_defineProperty');
function GR(e) {
  var t = WR(e, 'string');
  return Co(t) === 'symbol' ? t : String(t);
}
s(GR, '_toPropertyKey');
function WR(e, t) {
  if (Co(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (Co(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
s(WR, '_toPrimitive');
function Uy(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = pi(e, 'aria-describedby')
      .map(function (o) {
        return Jy(o, Ld(Ld({}, t), {}, { compute: 'description' }));
      })
      .join(' ');
  if (r === '') {
    var n = e.getAttribute('title');
    r = n === null ? '' : n;
  }
  return r;
}
s(Uy, 'computeAccessibleDescription');
function KR(e) {
  return ar(e, [
    'caption',
    'code',
    'deletion',
    'emphasis',
    'generic',
    'insertion',
    'paragraph',
    'presentation',
    'strong',
    'subscript',
    'superscript',
  ]);
}
s(KR, 'prohibitsNaming');
function Rc(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return KR(e) ? '' : Jy(e, t);
}
s(Rc, 'computeAccessibleName');
var Lt = Ke(Fp()),
  DJ = Ke(b1());
function Vy(e) {
  return e.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
s(Vy, 'escapeHTML');
var LJ = s((e, t, r, n, o, i, a) => {
    const l = n + r.indent,
      d = r.colors;
    return e
      .map((u) => {
        const p = t[u];
        let f = a(p, r, l, o, i);
        return (
          typeof p != 'string' &&
            (f.indexOf(`
`) !== -1 && (f = r.spacingOuter + l + f + r.spacingOuter + n),
            (f = '{' + f + '}')),
          r.spacingInner +
            n +
            d.prop.open +
            u +
            d.prop.close +
            '=' +
            d.value.open +
            f +
            d.value.close
        );
      })
      .join('');
  }, 'printProps'),
  FJ = 3,
  BJ = s(
    (e, t, r, n, o, i) =>
      e
        .map((a) => {
          const l = typeof a == 'string' ? YR(a, t) : i(a, t, r, n, o);
          return l === '' && typeof a == 'object' && a !== null && a.nodeType !== FJ
            ? ''
            : t.spacingOuter + r + l;
        })
        .join(''),
    'printChildren',
  ),
  YR = s((e, t) => {
    const r = t.colors.content;
    return r.open + Vy(e) + r.close;
  }, 'printText'),
  JJ = s((e, t) => {
    const r = t.colors.comment;
    return r.open + '<!--' + Vy(e) + '-->' + r.close;
  }, 'printComment'),
  UJ = s((e, t, r, n, o) => {
    const i = n.colors.tag;
    return (
      i.open +
      '<' +
      e +
      (t && i.close + t + n.spacingOuter + o + i.open) +
      (r
        ? '>' + i.close + r + n.spacingOuter + o + i.open + '</' + e
        : (t && !n.min ? '' : ' ') + '/') +
      '>' +
      i.close
    );
  }, 'printElement'),
  VJ = s((e, t) => {
    const r = t.colors.tag;
    return r.open + '<' + e + r.close + ' ' + r.open + ' />' + r.close;
  }, 'printElementAsLeaf'),
  HJ = 1,
  XR = 3,
  QR = 8,
  ZR = 11,
  zJ = /^((HTML|SVG)\w*)?Element$/,
  eP = s((e) => {
    const { tagName: t } = e;
    return !!(
      (typeof t == 'string' && t.includes('-')) ||
      (typeof e.hasAttribute == 'function' && e.hasAttribute('is'))
    );
  }, 'isCustomElement'),
  GJ = s((e) => {
    const t = e.constructor.name,
      { nodeType: r } = e;
    return (
      (r === HJ && (zJ.test(t) || eP(e))) ||
      (r === XR && t === 'Text') ||
      (r === QR && t === 'Comment') ||
      (r === ZR && t === 'DocumentFragment')
    );
  }, 'testNode');
function tP(e) {
  return e.nodeType === XR;
}
s(tP, 'nodeIsText');
function rP(e) {
  return e.nodeType === QR;
}
s(rP, 'nodeIsComment');
function la(e) {
  return e.nodeType === ZR;
}
s(la, 'nodeIsFragment');
function nP(e) {
  return {
    test: s((t) => {
      var r;
      return ((t == null || (r = t.constructor) == null ? void 0 : r.name) || eP(t)) && GJ(t);
    }, 'test'),
    serialize: s((t, r, n, o, i, a) => {
      if (tP(t)) return YR(t.data, r);
      if (rP(t)) return JJ(t.data, r);
      const l = la(t) ? 'DocumentFragment' : t.tagName.toLowerCase();
      return ++o > r.maxDepth
        ? VJ(l, r)
        : UJ(
            l,
            LJ(
              la(t)
                ? []
                : Array.from(t.attributes)
                    .map((d) => d.name)
                    .sort(),
              la(t)
                ? {}
                : Array.from(t.attributes).reduce((d, u) => ((d[u.name] = u.value), d), {}),
              r,
              n + r.indent,
              o,
              i,
              a,
            ),
            BJ(
              Array.prototype.slice.call(t.childNodes || t.children).filter(e),
              r,
              n + r.indent,
              o,
              i,
              a,
            ),
            r,
            n,
          );
    }, 'serialize'),
  };
}
s(nP, 'createDOMElementFilter');
var oP = null,
  Hy = null,
  zy = null;
try {
  const e = module && module.require;
  ((Hy = e.call(module, 'fs').readFileSync),
    (zy = e.call(module, '@babel/code-frame').codeFrameColumns),
    (oP = e.call(module, 'picocolors')));
} catch {}
function sP(e) {
  const t = e.indexOf('(') + 1,
    r = e.indexOf(')'),
    n = e.slice(t, r),
    o = n.split(':'),
    [i, a, l] = [o[0], parseInt(o[1], 10), parseInt(o[2], 10)];
  let d = '';
  try {
    d = Hy(i, 'utf-8');
  } catch {
    return '';
  }
  const u = zy(d, { start: { line: a, column: l } }, { highlightCode: !0, linesBelow: 0 });
  return (
    oP.dim(n) +
    `
` +
    u +
    `
`
  );
}
s(sP, 'getCodeFrame');
function iP() {
  if (!Hy || !zy) return '';
  const t = new Error().stack
    .split(
      `
`,
    )
    .slice(1)
    .find((r) => !r.includes('node_modules/'));
  return sP(t);
}
s(iP, 'getUserCodeFrame');
var aP = 3;
function ca() {
  return typeof jest < 'u' && jest !== null
    ? setTimeout._isMockFunction === !0 || Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
    : !1;
}
s(ca, 'jestFakeTimersAreEnabled');
function Pc() {
  if (typeof window > 'u') throw new Error('Could not find default container');
  return window.document;
}
s(Pc, 'getDocument');
function Gy(e) {
  if (e.defaultView) return e.defaultView;
  if (e.ownerDocument && e.ownerDocument.defaultView) return e.ownerDocument.defaultView;
  if (e.window) return e.window;
  throw e.ownerDocument && e.ownerDocument.defaultView === null
    ? new Error('It looks like the window object is not available for the provided node.')
    : e.then instanceof Function
      ? new Error(
          'It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?',
        )
      : Array.isArray(e)
        ? new Error(
            'It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?',
          )
        : typeof e.debug == 'function' && typeof e.logTestingPlaygroundURL == 'function'
          ? new Error(
              'It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?',
            )
          : new Error('The given node is not an Element, the node type is: ' + typeof e + '.');
}
s(Gy, 'getWindowFromNode');
function fr(e) {
  if (!e || typeof e.querySelector != 'function' || typeof e.querySelectorAll != 'function')
    throw new TypeError(
      'Expected container to be an Element, a Document or a DocumentFragment but got ' + t(e) + '.',
    );
  function t(r) {
    return typeof r == 'object' ? (r === null ? 'null' : r.constructor.name) : typeof r;
  }
  s(t, 'getTypeName');
}
s(fr, 'checkContainerType');
var WJ = s(() => {
    if (typeof process > 'u') return !1;
    let e;
    try {
      var t;
      const r = (t = Pu) == null ? void 0 : t.COLORS;
      r && (e = JSON.parse(r));
    } catch {}
    return typeof e == 'boolean'
      ? e
      : process.versions !== void 0 && process.versions.node !== void 0;
  }, 'shouldHighlight'),
  { DOMCollection: KJ } = My.plugins,
  YJ = 1,
  XJ = 8;
function lP(e) {
  return e.nodeType !== XJ && (e.nodeType !== YJ || !e.matches(Ee().defaultIgnore));
}
s(lP, 'filterCommentsAndDefaultIgnoreTagsTags');
function Io(e, t, r) {
  if (
    (r === void 0 && (r = {}),
    e || (e = Pc().body),
    typeof t != 'number' &&
      (t = (typeof process < 'u' && typeof Pu < 'u' && Pu.DEBUG_PRINT_LIMIT) || 7e3),
    t === 0)
  )
    return '';
  e.documentElement && (e = e.documentElement);
  let n = typeof e;
  if ((n === 'object' ? (n = e.constructor.name) : (e = {}), !('outerHTML' in e)))
    throw new TypeError('Expected an element or document but got ' + n);
  const { filterNode: o = lP, ...i } = r,
    a = My.format(e, { plugins: [nP(o), KJ], printFunctionName: !1, highlight: WJ(), ...i });
  return t !== void 0 && e.outerHTML.length > t ? a.slice(0, t) + '...' : a;
}
s(Io, 'prettyDOM');
var Fd = s(function () {
    const e = iP();
    console.log(
      e
        ? Io(...arguments) +
            `

` +
            e
        : Io(...arguments),
    );
  }, 'logDOM'),
  Rn = {
    testIdAttribute: 'data-testid',
    asyncUtilTimeout: 1e3,
    asyncWrapper: s((e) => e(), 'asyncWrapper'),
    unstable_advanceTimersWrapper: s((e) => e(), 'unstable_advanceTimersWrapper'),
    eventWrapper: s((e) => e(), 'eventWrapper'),
    defaultHidden: !1,
    defaultIgnore: 'script, style',
    showOriginalStackTrace: !1,
    throwSuggestions: !1,
    getElementError(e, t) {
      const r = Io(t),
        n = new Error(
          [
            e,
            'Ignored nodes: comments, ' +
              Rn.defaultIgnore +
              `
` +
              r,
          ].filter(Boolean).join(`

`),
        );
      return ((n.name = 'TestingLibraryElementError'), n);
    },
    _disableExpensiveErrorDiagnostics: !1,
    computedStyleSupportsPseudoElements: !1,
  };
function cP(e) {
  try {
    return ((Rn._disableExpensiveErrorDiagnostics = !0), e());
  } finally {
    Rn._disableExpensiveErrorDiagnostics = !1;
  }
}
s(cP, 'runWithExpensiveErrorDiagnosticsDisabled');
function uP(e) {
  (typeof e == 'function' && (e = e(Rn)), (Rn = { ...Rn, ...e }));
}
s(uP, 'configure');
function Ee() {
  return Rn;
}
s(Ee, 'getConfig');
var QJ = ['button', 'meter', 'output', 'progress', 'select', 'textarea', 'input'];
function Wy(e) {
  return QJ.includes(e.nodeName.toLowerCase())
    ? ''
    : e.nodeType === aP
      ? e.textContent
      : Array.from(e.childNodes)
          .map((t) => Wy(t))
          .join('');
}
s(Wy, 'getTextContent');
function Ya(e) {
  let t;
  return (e.tagName.toLowerCase() === 'label' ? (t = Wy(e)) : (t = e.value || e.textContent), t);
}
s(Ya, 'getLabelContent');
function Ky(e) {
  if (e.labels !== void 0) {
    var t;
    return (t = e.labels) != null ? t : [];
  }
  if (!dP(e)) return [];
  const r = e.ownerDocument.querySelectorAll('label');
  return Array.from(r).filter((n) => n.control === e);
}
s(Ky, 'getRealLabels');
function dP(e) {
  return (
    /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) ||
    (e.tagName === 'INPUT' && e.getAttribute('type') !== 'hidden')
  );
}
s(dP, 'isLabelable');
function Yy(e, t, r) {
  let { selector: n = '*' } = r === void 0 ? {} : r;
  const o = t.getAttribute('aria-labelledby'),
    i = o ? o.split(' ') : [];
  return i.length
    ? i.map((a) => {
        const l = e.querySelector('[id="' + a + '"]');
        return l ? { content: Ya(l), formControl: null } : { content: '', formControl: null };
      })
    : Array.from(Ky(t)).map((a) => {
        const l = Ya(a),
          u = Array.from(
            a.querySelectorAll('button, input, meter, output, progress, select, textarea'),
          ).filter((p) => p.matches(n))[0];
        return { content: l, formControl: u };
      });
}
s(Yy, 'getLabels');
function Xy(e) {
  if (e == null)
    throw new Error(
      'It looks like ' +
        e +
        ' was passed instead of a matcher. Did you do something like getByText(' +
        e +
        ')?',
    );
}
s(Xy, 'assertNotNullOrUndefined');
function Gn(e, t, r, n) {
  if (typeof e != 'string') return !1;
  Xy(r);
  const o = n(e);
  return typeof r == 'string' || typeof r == 'number'
    ? o.toLowerCase().includes(r.toString().toLowerCase())
    : typeof r == 'function'
      ? r(o, t)
      : Qy(r, o);
}
s(Gn, 'fuzzyMatches');
function cr(e, t, r, n) {
  if (typeof e != 'string') return !1;
  Xy(r);
  const o = n(e);
  return r instanceof Function ? r(o, t) : r instanceof RegExp ? Qy(r, o) : o === String(r);
}
s(cr, 'matches');
function xc(e) {
  let { trim: t = !0, collapseWhitespace: r = !0 } = e === void 0 ? {} : e;
  return (n) => {
    let o = n;
    return ((o = t ? o.trim() : o), (o = r ? o.replace(/\s+/g, ' ') : o), o);
  };
}
s(xc, 'getDefaultNormalizer');
function an(e) {
  let { trim: t, collapseWhitespace: r, normalizer: n } = e;
  if (!n) return xc({ trim: t, collapseWhitespace: r });
  if (typeof t < 'u' || typeof r < 'u')
    throw new Error(
      'trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer',
    );
  return n;
}
s(an, 'makeNormalizer');
function Qy(e, t) {
  const r = e.test(t);
  return (
    e.global &&
      e.lastIndex !== 0 &&
      (console.warn(
        'To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.',
      ),
      (e.lastIndex = 0)),
    r
  );
}
s(Qy, 'matchRegExp');
function Go(e) {
  return e.matches('input[type=submit], input[type=button], input[type=reset]')
    ? e.value
    : Array.from(e.childNodes)
        .filter((t) => t.nodeType === aP && !!t.textContent)
        .map((t) => t.textContent)
        .join('');
}
s(Go, 'getNodeText');
var ZJ = pP(Lt.elementRoles);
function Zy(e) {
  return (
    e.hidden === !0 ||
    e.getAttribute('aria-hidden') === 'true' ||
    e.ownerDocument.defaultView.getComputedStyle(e).display === 'none'
  );
}
s(Zy, 'isSubtreeInaccessible');
function Bi(e, t) {
  t === void 0 && (t = {});
  const { isSubtreeInaccessible: r = Zy } = t;
  if (e.ownerDocument.defaultView.getComputedStyle(e).visibility === 'hidden') return !0;
  let o = e;
  for (; o; ) {
    if (r(o)) return !0;
    o = o.parentElement;
  }
  return !1;
}
s(Bi, 'isInaccessible');
function Oc(e) {
  for (const { match: t, roles: r } of ZJ) if (t(e)) return [...r];
  return [];
}
s(Oc, 'getImplicitAriaRoles');
function pP(e) {
  function t(a) {
    let { name: l, attributes: d } = a;
    return (
      '' +
      l +
      d
        .map((u) => {
          let { name: p, value: f, constraints: m = [] } = u;
          const h = m.indexOf('undefined') !== -1,
            g = m.indexOf('set') !== -1;
          return typeof f < 'u'
            ? '[' + p + '="' + f + '"]'
            : h
              ? ':not([' + p + '])'
              : g
                ? '[' + p + ']:not([' + p + '=""])'
                : '[' + p + ']';
        })
        .join('')
    );
  }
  s(t, 'makeElementSelector');
  function r(a) {
    let { attributes: l = [] } = a;
    return l.length;
  }
  s(r, 'getSelectorSpecificity');
  function n(a, l) {
    let { specificity: d } = a,
      { specificity: u } = l;
    return u - d;
  }
  s(n, 'bySelectorSpecificity');
  function o(a) {
    let { attributes: l = [] } = a;
    const d = l.findIndex((p) => p.value && p.name === 'type' && p.value === 'text');
    d >= 0 && (l = [...l.slice(0, d), ...l.slice(d + 1)]);
    const u = t({ ...a, attributes: l });
    return (p) => (d >= 0 && p.type !== 'text' ? !1 : p.matches(u));
  }
  s(o, 'match');
  let i = [];
  for (const [a, l] of e.entries())
    i = [...i, { match: o(a), roles: Array.from(l), specificity: r(a) }];
  return i.sort(n);
}
s(pP, 'buildElementRoleList');
function eh(e, t) {
  let { hidden: r = !1 } = t === void 0 ? {} : t;
  function n(o) {
    return [o, ...Array.from(o.children).reduce((i, a) => [...i, ...n(a)], [])];
  }
  return (
    s(n, 'flattenDOM'),
    n(e)
      .filter((o) => (r === !1 ? Bi(o) === !1 : !0))
      .reduce((o, i) => {
        let a = [];
        return (
          i.hasAttribute('role')
            ? (a = i.getAttribute('role').split(' ').slice(0, 1))
            : (a = Oc(i)),
          a.reduce(
            (l, d) => (Array.isArray(l[d]) ? { ...l, [d]: [...l[d], i] } : { ...l, [d]: [i] }),
            o,
          )
        );
      }, {})
  );
}
s(eh, 'getRoles');
function th(e, t) {
  let { hidden: r, includeDescription: n } = t;
  const o = eh(e, { hidden: r });
  return Object.entries(o)
    .filter((i) => {
      let [a] = i;
      return a !== 'generic';
    })
    .map((i) => {
      let [a, l] = i;
      const d = '-'.repeat(50),
        u = l.map((p) => {
          const f =
              'Name "' +
              Rc(p, {
                computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
              }) +
              `":
`,
            m = Io(p.cloneNode(!1));
          if (n) {
            const h =
              'Description "' +
              Uy(p, {
                computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
              }) +
              `":
`;
            return '' + f + h + m;
          }
          return '' + f + m;
        }).join(`

`);
      return (
        a +
        `:

` +
        u +
        `

` +
        d
      );
    }).join(`
`);
}
s(th, 'prettyRoles');
var eU = s(function (e, t) {
  let { hidden: r = !1 } = t === void 0 ? {} : t;
  return console.log(th(e, { hidden: r }));
}, 'logRoles');
function fP(e) {
  return e.tagName === 'OPTION' ? e.selected : Wo(e, 'aria-selected');
}
s(fP, 'computeAriaSelected');
function mP(e) {
  return e.getAttribute('aria-busy') === 'true';
}
s(mP, 'computeAriaBusy');
function yP(e) {
  if (!('indeterminate' in e && e.indeterminate))
    return 'checked' in e ? e.checked : Wo(e, 'aria-checked');
}
s(yP, 'computeAriaChecked');
function hP(e) {
  return Wo(e, 'aria-pressed');
}
s(hP, 'computeAriaPressed');
function gP(e) {
  var t, r;
  return (t = (r = Wo(e, 'aria-current')) != null ? r : e.getAttribute('aria-current')) != null
    ? t
    : !1;
}
s(gP, 'computeAriaCurrent');
function bP(e) {
  return Wo(e, 'aria-expanded');
}
s(bP, 'computeAriaExpanded');
function Wo(e, t) {
  const r = e.getAttribute(t);
  if (r === 'true') return !0;
  if (r === 'false') return !1;
}
s(Wo, 'checkBooleanAttribute');
function vP(e) {
  const t = { H1: 1, H2: 2, H3: 3, H4: 4, H5: 5, H6: 6 };
  return (e.getAttribute('aria-level') && Number(e.getAttribute('aria-level'))) || t[e.tagName];
}
s(vP, 'computeHeadingLevel');
function TP(e) {
  const t = e.getAttribute('aria-valuenow');
  return t === null ? void 0 : +t;
}
s(TP, 'computeAriaValueNow');
function EP(e) {
  const t = e.getAttribute('aria-valuemax');
  return t === null ? void 0 : +t;
}
s(EP, 'computeAriaValueMax');
function wP(e) {
  const t = e.getAttribute('aria-valuemin');
  return t === null ? void 0 : +t;
}
s(wP, 'computeAriaValueMin');
function SP(e) {
  const t = e.getAttribute('aria-valuetext');
  return t === null ? void 0 : t;
}
s(SP, 'computeAriaValueText');
var Sb = xc();
function _P(e) {
  return e.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
}
s(_P, 'escapeRegExp');
function Bd(e) {
  return new RegExp(_P(e.toLowerCase()), 'i');
}
s(Bd, 'getRegExpMatcher');
function Er(e, t, r, n) {
  let { variant: o, name: i } = n,
    a = '';
  const l = {},
    d = [['Role', 'TestId'].includes(e) ? r : Bd(r)];
  (i && (l.name = Bd(i)),
    e === 'Role' &&
      Bi(t) &&
      ((l.hidden = !0),
      (a = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `)),
    Object.keys(l).length > 0 && d.push(l));
  const u = o + 'By' + e;
  return {
    queryName: e,
    queryMethod: u,
    queryArgs: d,
    variant: o,
    warning: a,
    toString() {
      a && console.warn(a);
      let [p, f] = d;
      return (
        (p = typeof p == 'string' ? "'" + p + "'" : p),
        (f = f
          ? ', { ' +
            Object.entries(f)
              .map((m) => {
                let [h, g] = m;
                return h + ': ' + g;
              })
              .join(', ') +
            ' }'
          : ''),
        u + '(' + p + f + ')'
      );
    },
  };
}
s(Er, 'makeSuggestion');
function wr(e, t, r) {
  return r && (!t || t.toLowerCase() === e.toLowerCase());
}
s(wr, 'canSuggest');
function fi(e, t, r) {
  var n, o;
  if ((t === void 0 && (t = 'get'), e.matches(Ee().defaultIgnore))) return;
  const i = (n = e.getAttribute('role')) != null ? n : (o = Oc(e)) == null ? void 0 : o[0];
  if (i !== 'generic' && wr('Role', r, i))
    return Er('Role', e, i, {
      variant: t,
      name: Rc(e, {
        computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
      }),
    });
  const a = Yy(document, e)
    .map((m) => m.content)
    .join(' ');
  if (wr('LabelText', r, a)) return Er('LabelText', e, a, { variant: t });
  const l = e.getAttribute('placeholder');
  if (wr('PlaceholderText', r, l)) return Er('PlaceholderText', e, l, { variant: t });
  const d = Sb(Go(e));
  if (wr('Text', r, d)) return Er('Text', e, d, { variant: t });
  if (wr('DisplayValue', r, e.value)) return Er('DisplayValue', e, Sb(e.value), { variant: t });
  const u = e.getAttribute('alt');
  if (wr('AltText', r, u)) return Er('AltText', e, u, { variant: t });
  const p = e.getAttribute('title');
  if (wr('Title', r, p)) return Er('Title', e, p, { variant: t });
  const f = e.getAttribute(Ee().testIdAttribute);
  if (wr('TestId', r, f)) return Er('TestId', e, f, { variant: t });
}
s(fi, 'getSuggestedQuery');
function Ns(e, t) {
  e.stack = t.stack.replace(t.message, e.message);
}
s(Ns, 'copyStackTrace');
function AP(e, t) {
  let {
    container: r = Pc(),
    timeout: n = Ee().asyncUtilTimeout,
    showOriginalStackTrace: o = Ee().showOriginalStackTrace,
    stackTraceError: i,
    interval: a = 50,
    onTimeout: l = s(
      (u) => (
        Object.defineProperty(u, 'message', { value: Ee().getElementError(u.message, r).message }),
        u
      ),
      'onTimeout',
    ),
    mutationObserverOptions: d = { subtree: !0, childList: !0, attributes: !0, characterData: !0 },
  } = t;
  if (typeof e != 'function') throw new TypeError('Received `callback` arg must be a function');
  return new Promise(async (u, p) => {
    let f,
      m,
      h,
      g = !1,
      v = 'idle';
    const E = setTimeout($, n),
      b = ca();
    if (b) {
      const { unstable_advanceTimersWrapper: x } = Ee();
      for (I(); !g; ) {
        if (!ca()) {
          const A = new Error(
            "Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830",
          );
          (o || Ns(A, i), p(A));
          return;
        }
        if (
          (await x(async () => {
            jest.advanceTimersByTime(a);
          }),
          g)
        )
          break;
        I();
      }
    } else {
      try {
        fr(r);
      } catch (A) {
        p(A);
        return;
      }
      m = setInterval(R, a);
      const { MutationObserver: x } = Gy(r);
      ((h = new x(R)), h.observe(r, d), I());
    }
    function S(x, A) {
      ((g = !0), clearTimeout(E), b || (clearInterval(m), h.disconnect()), x ? p(x) : u(A));
    }
    s(S, 'onDone');
    function R() {
      if (ca()) {
        const x = new Error(
          "Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830",
        );
        return (o || Ns(x, i), p(x));
      } else return I();
    }
    s(R, 'checkRealTimersCallback');
    function I() {
      if (v !== 'pending')
        try {
          const x = cP(e);
          typeof x?.then == 'function'
            ? ((v = 'pending'),
              x.then(
                (A) => {
                  ((v = 'resolved'), S(null, A));
                },
                (A) => {
                  ((v = 'rejected'), (f = A));
                },
              ))
            : S(null, x);
        } catch (x) {
          f = x;
        }
    }
    s(I, 'checkCallback');
    function $() {
      let x;
      (f
        ? ((x = f), !o && x.name === 'TestingLibraryElementError' && Ns(x, i))
        : ((x = new Error('Timed out in waitFor.')), o || Ns(x, i)),
        S(l(x), null));
    }
    s($, 'handleTimeout');
  });
}
s(AP, 'waitFor');
function Cc(e, t) {
  const r = new Error('STACK_TRACE_MESSAGE');
  return Ee().asyncWrapper(() => AP(e, { stackTraceError: r, ...t }));
}
s(Cc, 'waitForWrapper');
function Ji(e, t) {
  return Ee().getElementError(e, t);
}
s(Ji, 'getElementError');
function Ui(e, t) {
  return Ji(
    e +
      '\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).',
    t,
  );
}
s(Ui, 'getMultipleElementsFoundError');
function ln(e, t, r, n) {
  let { exact: o = !0, collapseWhitespace: i, trim: a, normalizer: l } = n === void 0 ? {} : n;
  const d = o ? cr : Gn,
    u = an({ collapseWhitespace: i, trim: a, normalizer: l });
  return Array.from(t.querySelectorAll('[' + e + ']')).filter((p) => d(p.getAttribute(e), p, r, u));
}
s(ln, 'queryAllByAttribute');
function rh(e, t, r, n) {
  const o = ln(e, t, r, n);
  if (o.length > 1) throw Ui('Found multiple elements by [' + e + '=' + r + ']', t);
  return o[0] || null;
}
s(rh, 'queryByAttribute');
function In(e, t) {
  return function (r) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      o[i - 1] = arguments[i];
    const a = e(r, ...o);
    if (a.length > 1) {
      const l = a.map((d) => Ji(null, d).message).join(`

`);
      throw Ui(
        t(r, ...o) +
          `

Here are the matching elements:

` +
          l,
        r,
      );
    }
    return a[0] || null;
  };
}
s(In, 'makeSingleQuery');
function nh(e, t) {
  return Ee().getElementError(
    `A better query is available, try this:
` +
      e.toString() +
      `
`,
    t,
  );
}
s(nh, 'getSuggestionError');
function Ic(e, t) {
  return function (r) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      o[i - 1] = arguments[i];
    const a = e(r, ...o);
    if (!a.length) throw Ee().getElementError(t(r, ...o), r);
    return a;
  };
}
s(Ic, 'makeGetAllQuery');
function Nn(e) {
  return (t, r, n, o) => Cc(() => e(t, r, n), { container: t, ...o });
}
s(Nn, 'makeFindQuery');
var Wr = s(
    (e, t, r) =>
      function (n) {
        for (var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), a = 1; a < o; a++)
          i[a - 1] = arguments[a];
        const l = e(n, ...i),
          [{ suggest: d = Ee().throwSuggestions } = {}] = i.slice(-1);
        if (l && d) {
          const u = fi(l, r);
          if (u && !t.endsWith(u.queryName)) throw nh(u.toString(), n);
        }
        return l;
      },
    'wrapSingleQueryWithSuggestion',
  ),
  At = s(
    (e, t, r) =>
      function (n) {
        for (var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), a = 1; a < o; a++)
          i[a - 1] = arguments[a];
        const l = e(n, ...i),
          [{ suggest: d = Ee().throwSuggestions } = {}] = i.slice(-1);
        if (l.length && d) {
          const u = [
            ...new Set(
              l.map((p) => {
                var f;
                return (f = fi(p, r)) == null ? void 0 : f.toString();
              }),
            ),
          ];
          if (u.length === 1 && !t.endsWith(fi(l[0], r).queryName)) throw nh(u[0], n);
        }
        return l;
      },
    'wrapAllByQueryWithSuggestion',
  );
function mr(e, t, r) {
  const n = Wr(In(e, t), e.name, 'query'),
    o = Ic(e, r),
    i = In(o, t),
    a = Wr(i, e.name, 'get'),
    l = At(o, e.name.replace('query', 'get'), 'getAll'),
    d = Nn(At(o, e.name, 'findAll')),
    u = Nn(Wr(i, e.name, 'find'));
  return [n, l, a, d, u];
}
s(mr, 'buildQueries');
var tU = Object.freeze({
  __proto__: null,
  getElementError: Ji,
  wrapAllByQueryWithSuggestion: At,
  wrapSingleQueryWithSuggestion: Wr,
  getMultipleElementsFoundError: Ui,
  queryAllByAttribute: ln,
  queryByAttribute: rh,
  makeSingleQuery: In,
  makeGetAllQuery: Ic,
  makeFindQuery: Nn,
  buildQueries: mr,
});
function RP(e) {
  return Array.from(e.querySelectorAll('label,input'))
    .map((t) => ({ node: t, textToMatch: Ya(t) }))
    .filter((t) => {
      let { textToMatch: r } = t;
      return r !== null;
    });
}
s(RP, 'queryAllLabels');
var rU = s(function (e, t, r) {
    let { exact: n = !0, trim: o, collapseWhitespace: i, normalizer: a } = r === void 0 ? {} : r;
    const l = n ? cr : Gn,
      d = an({ collapseWhitespace: i, trim: o, normalizer: a });
    return RP(e)
      .filter((p) => {
        let { node: f, textToMatch: m } = p;
        return l(m, f, t, d);
      })
      .map((p) => {
        let { node: f } = p;
        return f;
      });
  }, 'queryAllLabelsByText'),
  mi = s(function (e, t, r) {
    let {
      selector: n = '*',
      exact: o = !0,
      collapseWhitespace: i,
      trim: a,
      normalizer: l,
    } = r === void 0 ? {} : r;
    fr(e);
    const d = o ? cr : Gn,
      u = an({ collapseWhitespace: i, trim: a, normalizer: l }),
      p = Array.from(e.querySelectorAll('*'))
        .filter((f) => Ky(f).length || f.hasAttribute('aria-labelledby'))
        .reduce((f, m) => {
          const h = Yy(e, m, { selector: n });
          h.filter((v) => !!v.formControl).forEach((v) => {
            d(v.content, v.formControl, t, u) && v.formControl && f.push(v.formControl);
          });
          const g = h.filter((v) => !!v.content).map((v) => v.content);
          return (
            d(g.join(' '), m, t, u) && f.push(m),
            g.length > 1 &&
              g.forEach((v, E) => {
                d(v, m, t, u) && f.push(m);
                const b = [...g];
                (b.splice(E, 1), b.length > 1 && d(b.join(' '), m, t, u) && f.push(m));
              }),
            f
          );
        }, [])
        .concat(ln('aria-label', e, t, { exact: o, normalizer: u }));
    return Array.from(new Set(p)).filter((f) => f.matches(n));
  }, 'queryAllByLabelText'),
  $n = s(function (e, t) {
    for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
      n[o - 2] = arguments[o];
    const i = mi(e, t, ...n);
    if (!i.length) {
      const a = rU(e, t, ...n);
      if (a.length) {
        const l = a.map((d) => PP(e, d)).filter((d) => !!d);
        throw l.length
          ? Ee().getElementError(
              l.map(
                (d) =>
                  'Found a label with the text of: ' +
                  t +
                  ', however the element associated with this label (<' +
                  d +
                  ' />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <' +
                  d +
                  ' />, you can use aria-label or aria-labelledby instead.',
              ).join(`

`),
              e,
            )
          : Ee().getElementError(
              'Found a label with the text of: ' +
                t +
                `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`,
              e,
            );
      } else throw Ee().getElementError('Unable to find a label with the text of: ' + t, e);
    }
    return i;
  }, 'getAllByLabelText');
function PP(e, t) {
  const r = t.getAttribute('for');
  if (!r) return null;
  const n = e.querySelector('[id="' + r + '"]');
  return n ? n.tagName.toLowerCase() : null;
}
s(PP, 'getTagNameOfElementAssociatedWithLabelViaFor');
var xP = s((e, t) => 'Found multiple elements with the text of: ' + t, 'getMultipleError$7'),
  OP = Wr(In(mi, xP), mi.name, 'query'),
  CP = In($n, xP),
  IP = Nn(At($n, $n.name, 'findAll')),
  NP = Nn(Wr(CP, $n.name, 'find')),
  $P = At($n, $n.name, 'getAll'),
  qP = Wr(CP, $n.name, 'get'),
  MP = At(mi, mi.name, 'queryAll'),
  Jd = s(function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    return (fr(t[0]), ln('placeholder', ...t));
  }, 'queryAllByPlaceholderText'),
  nU = s(
    (e, t) => 'Found multiple elements with the placeholder text of: ' + t,
    'getMultipleError$6',
  ),
  oU = s(
    (e, t) => 'Unable to find an element with the placeholder text of: ' + t,
    'getMissingError$6',
  ),
  jP = At(Jd, Jd.name, 'queryAll'),
  [kP, DP, LP, FP, BP] = mr(Jd, nU, oU),
  Ud = s(function (e, t, r) {
    let {
      selector: n = '*',
      exact: o = !0,
      collapseWhitespace: i,
      trim: a,
      ignore: l = Ee().defaultIgnore,
      normalizer: d,
    } = r === void 0 ? {} : r;
    fr(e);
    const u = o ? cr : Gn,
      p = an({ collapseWhitespace: i, trim: a, normalizer: d });
    let f = [];
    return (
      typeof e.matches == 'function' && e.matches(n) && (f = [e]),
      [...f, ...Array.from(e.querySelectorAll(n))]
        .filter((m) => !l || !m.matches(l))
        .filter((m) => u(Go(m), m, t, p))
    );
  }, 'queryAllByText'),
  sU = s((e, t) => 'Found multiple elements with the text: ' + t, 'getMultipleError$5'),
  iU = s(function (e, t, r) {
    r === void 0 && (r = {});
    const { collapseWhitespace: n, trim: o, normalizer: i, selector: a } = r,
      d = an({ collapseWhitespace: n, trim: o, normalizer: i })(t.toString()),
      u = d !== t.toString(),
      p = (a ?? '*') !== '*';
    return (
      'Unable to find an element with the text: ' +
      (u ? d + " (normalized from '" + t + "')" : t) +
      (p ? ", which matches selector '" + a + "'" : '') +
      '. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.'
    );
  }, 'getMissingError$5'),
  JP = At(Ud, Ud.name, 'queryAll'),
  [UP, VP, HP, zP, GP] = mr(Ud, sU, iU),
  Vd = s(function (e, t, r) {
    let { exact: n = !0, collapseWhitespace: o, trim: i, normalizer: a } = r === void 0 ? {} : r;
    fr(e);
    const l = n ? cr : Gn,
      d = an({ collapseWhitespace: o, trim: i, normalizer: a });
    return Array.from(e.querySelectorAll('input,textarea,select')).filter((u) =>
      u.tagName === 'SELECT'
        ? Array.from(u.options)
            .filter((f) => f.selected)
            .some((f) => l(Go(f), f, t, d))
        : l(u.value, u, t, d),
    );
  }, 'queryAllByDisplayValue'),
  aU = s(
    (e, t) => 'Found multiple elements with the display value: ' + t + '.',
    'getMultipleError$4',
  ),
  lU = s(
    (e, t) => 'Unable to find an element with the display value: ' + t + '.',
    'getMissingError$4',
  ),
  WP = At(Vd, Vd.name, 'queryAll'),
  [KP, YP, XP, QP, ZP] = mr(Vd, aU, lU),
  cU = /^(img|input|area|.+-.+)$/i,
  Hd = s(function (e, t, r) {
    return (r === void 0 && (r = {}), fr(e), ln('alt', e, t, r).filter((n) => cU.test(n.tagName)));
  }, 'queryAllByAltText'),
  uU = s((e, t) => 'Found multiple elements with the alt text: ' + t, 'getMultipleError$3'),
  dU = s((e, t) => 'Unable to find an element with the alt text: ' + t, 'getMissingError$3'),
  ex = At(Hd, Hd.name, 'queryAll'),
  [tx, rx, nx, ox, sx] = mr(Hd, uU, dU),
  pU = s((e) => {
    var t;
    return (
      e.tagName.toLowerCase() === 'title' &&
      ((t = e.parentElement) == null ? void 0 : t.tagName.toLowerCase()) === 'svg'
    );
  }, 'isSvgTitle'),
  zd = s(function (e, t, r) {
    let { exact: n = !0, collapseWhitespace: o, trim: i, normalizer: a } = r === void 0 ? {} : r;
    fr(e);
    const l = n ? cr : Gn,
      d = an({ collapseWhitespace: o, trim: i, normalizer: a });
    return Array.from(e.querySelectorAll('[title], svg > title')).filter(
      (u) => l(u.getAttribute('title'), u, t, d) || (pU(u) && l(Go(u), u, t, d)),
    );
  }, 'queryAllByTitle'),
  fU = s((e, t) => 'Found multiple elements with the title: ' + t + '.', 'getMultipleError$2'),
  mU = s((e, t) => 'Unable to find an element with the title: ' + t + '.', 'getMissingError$2'),
  ix = At(zd, zd.name, 'queryAll'),
  [ax, lx, cx, ux, dx] = mr(zd, fU, mU),
  Gd = s(function (e, t, r) {
    let {
      hidden: n = Ee().defaultHidden,
      name: o,
      description: i,
      queryFallbacks: a = !1,
      selected: l,
      busy: d,
      checked: u,
      pressed: p,
      current: f,
      level: m,
      expanded: h,
      value: { now: g, min: v, max: E, text: b } = {},
    } = r === void 0 ? {} : r;
    if ((fr(e), l !== void 0)) {
      var S;
      if (((S = Lt.roles.get(t)) == null ? void 0 : S.props['aria-selected']) === void 0)
        throw new Error('"aria-selected" is not supported on role "' + t + '".');
    }
    if (d !== void 0) {
      var R;
      if (((R = Lt.roles.get(t)) == null ? void 0 : R.props['aria-busy']) === void 0)
        throw new Error('"aria-busy" is not supported on role "' + t + '".');
    }
    if (u !== void 0) {
      var I;
      if (((I = Lt.roles.get(t)) == null ? void 0 : I.props['aria-checked']) === void 0)
        throw new Error('"aria-checked" is not supported on role "' + t + '".');
    }
    if (p !== void 0) {
      var $;
      if ((($ = Lt.roles.get(t)) == null ? void 0 : $.props['aria-pressed']) === void 0)
        throw new Error('"aria-pressed" is not supported on role "' + t + '".');
    }
    if (f !== void 0) {
      var x;
      if (((x = Lt.roles.get(t)) == null ? void 0 : x.props['aria-current']) === void 0)
        throw new Error('"aria-current" is not supported on role "' + t + '".');
    }
    if (m !== void 0 && t !== 'heading')
      throw new Error('Role "' + t + '" cannot have "level" property.');
    if (g !== void 0) {
      var A;
      if (((A = Lt.roles.get(t)) == null ? void 0 : A.props['aria-valuenow']) === void 0)
        throw new Error('"aria-valuenow" is not supported on role "' + t + '".');
    }
    if (E !== void 0) {
      var w;
      if (((w = Lt.roles.get(t)) == null ? void 0 : w.props['aria-valuemax']) === void 0)
        throw new Error('"aria-valuemax" is not supported on role "' + t + '".');
    }
    if (v !== void 0) {
      var _;
      if (((_ = Lt.roles.get(t)) == null ? void 0 : _.props['aria-valuemin']) === void 0)
        throw new Error('"aria-valuemin" is not supported on role "' + t + '".');
    }
    if (b !== void 0) {
      var j;
      if (((j = Lt.roles.get(t)) == null ? void 0 : j.props['aria-valuetext']) === void 0)
        throw new Error('"aria-valuetext" is not supported on role "' + t + '".');
    }
    if (h !== void 0) {
      var N;
      if (((N = Lt.roles.get(t)) == null ? void 0 : N.props['aria-expanded']) === void 0)
        throw new Error('"aria-expanded" is not supported on role "' + t + '".');
    }
    const V = new WeakMap();
    function H(P) {
      return (V.has(P) || V.set(P, Zy(P)), V.get(P));
    }
    return (
      s(H, 'cachedIsSubtreeInaccessible'),
      Array.from(e.querySelectorAll(px(t)))
        .filter((P) => {
          if (P.hasAttribute('role')) {
            const k = P.getAttribute('role');
            if (a)
              return k
                .split(' ')
                .filter(Boolean)
                .some((X) => X === t);
            const [K] = k.split(' ');
            return K === t;
          }
          return Oc(P).some((k) => k === t);
        })
        .filter((P) => {
          if (l !== void 0) return l === fP(P);
          if (d !== void 0) return d === mP(P);
          if (u !== void 0) return u === yP(P);
          if (p !== void 0) return p === hP(P);
          if (f !== void 0) return f === gP(P);
          if (h !== void 0) return h === bP(P);
          if (m !== void 0) return m === vP(P);
          if (g !== void 0 || E !== void 0 || v !== void 0 || b !== void 0) {
            let F = !0;
            if (
              (g !== void 0 && F && (F = g === TP(P)),
              E !== void 0 && F && (F = E === EP(P)),
              v !== void 0 && F && (F = v === wP(P)),
              b !== void 0)
            ) {
              var D;
              F && (F = cr((D = SP(P)) != null ? D : null, P, b, (k) => k));
            }
            return F;
          }
          return !0;
        })
        .filter((P) =>
          o === void 0
            ? !0
            : cr(
                Rc(P, {
                  computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
                }),
                P,
                o,
                (D) => D,
              ),
        )
        .filter((P) =>
          i === void 0
            ? !0
            : cr(
                Uy(P, {
                  computedStyleSupportsPseudoElements: Ee().computedStyleSupportsPseudoElements,
                }),
                P,
                i,
                (D) => D,
              ),
        )
        .filter((P) => (n === !1 ? Bi(P, { isSubtreeInaccessible: H }) === !1 : !0))
    );
  }, 'queryAllByRole');
function px(e) {
  var t;
  const r = '*[role~="' + e + '"]',
    n = (t = Lt.roleElements.get(e)) != null ? t : new Set(),
    o = new Set(
      Array.from(n).map((i) => {
        let { name: a } = i;
        return a;
      }),
    );
  return [r].concat(Array.from(o)).join(',');
}
s(px, 'makeRoleSelector');
var fx = s((e) => {
    let t = '';
    return (
      e === void 0
        ? (t = '')
        : typeof e == 'string'
          ? (t = ' and name "' + e + '"')
          : (t = ' and name `' + e + '`'),
      t
    );
  }, 'getNameHint'),
  yU = s(function (e, t, r) {
    let { name: n } = r === void 0 ? {} : r;
    return 'Found multiple elements with the role "' + t + '"' + fx(n);
  }, 'getMultipleError$1'),
  hU = s(function (e, t, r) {
    let { hidden: n = Ee().defaultHidden, name: o, description: i } = r === void 0 ? {} : r;
    if (Ee()._disableExpensiveErrorDiagnostics) return 'Unable to find role="' + t + '"' + fx(o);
    let a = '';
    Array.from(e.children).forEach((p) => {
      a += th(p, { hidden: n, includeDescription: i !== void 0 });
    });
    let l;
    a.length === 0
      ? n === !1
        ? (l =
            'There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole')
        : (l = 'There are no available roles.')
      : (l = (
          `
Here are the ` +
          (n === !1 ? 'accessible' : 'available') +
          ` roles:

  ` +
          a
            .replace(
              /\n/g,
              `
  `,
            )
            .replace(
              /\n\s\s\n/g,
              `

`,
            ) +
          `
`
        ).trim());
    let d = '';
    o === void 0
      ? (d = '')
      : typeof o == 'string'
        ? (d = ' and name "' + o + '"')
        : (d = ' and name `' + o + '`');
    let u = '';
    return (
      i === void 0
        ? (u = '')
        : typeof i == 'string'
          ? (u = ' and description "' + i + '"')
          : (u = ' and description `' + i + '`'),
      (
        `
Unable to find an ` +
        (n === !1 ? 'accessible ' : '') +
        'element with the role "' +
        t +
        '"' +
        d +
        u +
        `

` +
        l
      ).trim()
    );
  }, 'getMissingError$1'),
  mx = At(Gd, Gd.name, 'queryAll'),
  [yx, hx, gx, bx, vx] = mr(Gd, yU, hU),
  oh = s(() => Ee().testIdAttribute, 'getTestIdAttribute'),
  Wd = s(function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    return (fr(t[0]), ln(oh(), ...t));
  }, 'queryAllByTestId'),
  gU = s((e, t) => 'Found multiple elements by: [' + oh() + '="' + t + '"]', 'getMultipleError'),
  bU = s((e, t) => 'Unable to find an element by: [' + oh() + '="' + t + '"]', 'getMissingError'),
  Tx = At(Wd, Wd.name, 'queryAll'),
  [Ex, wx, Sx, _x, Ax] = mr(Wd, gU, bU),
  Xa = Object.freeze({
    __proto__: null,
    queryAllByLabelText: MP,
    queryByLabelText: OP,
    getAllByLabelText: $P,
    getByLabelText: qP,
    findAllByLabelText: IP,
    findByLabelText: NP,
    queryByPlaceholderText: kP,
    queryAllByPlaceholderText: jP,
    getByPlaceholderText: LP,
    getAllByPlaceholderText: DP,
    findAllByPlaceholderText: FP,
    findByPlaceholderText: BP,
    queryByText: UP,
    queryAllByText: JP,
    getByText: HP,
    getAllByText: VP,
    findAllByText: zP,
    findByText: GP,
    queryByDisplayValue: KP,
    queryAllByDisplayValue: WP,
    getByDisplayValue: XP,
    getAllByDisplayValue: YP,
    findAllByDisplayValue: QP,
    findByDisplayValue: ZP,
    queryByAltText: tx,
    queryAllByAltText: ex,
    getByAltText: nx,
    getAllByAltText: rx,
    findAllByAltText: ox,
    findByAltText: sx,
    queryByTitle: ax,
    queryAllByTitle: ix,
    getByTitle: cx,
    getAllByTitle: lx,
    findAllByTitle: ux,
    findByTitle: dx,
    queryByRole: yx,
    queryAllByRole: mx,
    getAllByRole: hx,
    getByRole: gx,
    findAllByRole: bx,
    findByRole: vx,
    queryByTestId: Ex,
    queryAllByTestId: Tx,
    getByTestId: Sx,
    getAllByTestId: wx,
    findAllByTestId: _x,
    findByTestId: Ax,
  });
function Qa(e, t, r) {
  return (
    t === void 0 && (t = Xa),
    r === void 0 && (r = {}),
    Object.keys(t).reduce((n, o) => {
      const i = t[o];
      return ((n[o] = i.bind(null, e)), n);
    }, r)
  );
}
s(Qa, 'getQueriesForElement');
var Rx = s((e) => !e || (Array.isArray(e) && !e.length), 'isRemoved');
function Kd(e) {
  if (Rx(e))
    throw new Error(
      'The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.',
    );
}
s(Kd, 'initialCheck');
async function Px(e, t) {
  const r = new Error('Timed out in waitForElementToBeRemoved.');
  if (typeof e != 'function') {
    Kd(e);
    const o = (Array.isArray(e) ? e : [e]).map((i) => {
      let a = i.parentElement;
      if (a === null) return () => null;
      for (; a.parentElement; ) a = a.parentElement;
      return () => (a.contains(i) ? i : null);
    });
    e = s(() => o.map((i) => i()).filter(Boolean), 'callback');
  }
  return (
    Kd(e()),
    Cc(() => {
      let n;
      try {
        n = e();
      } catch (o) {
        if (o.name === 'TestingLibraryElementError') return;
        throw o;
      }
      if (!Rx(n)) throw r;
    }, t)
  );
}
s(Px, 'waitForElementToBeRemoved');
var _b = {
    copy: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    cut: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    paste: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionEnd: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionStart: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionUpdate: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    keyDown: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    keyPress: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    keyUp: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    focus: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
    blur: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
    focusIn: {
      EventType: 'FocusEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    focusOut: {
      EventType: 'FocusEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    change: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
    input: { EventType: 'InputEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
    invalid: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !0 } },
    submit: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
    reset: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
    click: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, button: 0, composed: !0 },
    },
    contextMenu: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dblClick: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    drag: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    dragEnd: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
    dragEnter: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dragExit: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    dragLeave: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    dragOver: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dragStart: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    drop: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    mouseDown: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseEnter: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
    },
    mouseLeave: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
    },
    mouseMove: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseOut: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseOver: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseUp: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    select: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
    touchCancel: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    touchEnd: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    touchMove: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    touchStart: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    resize: { EventType: 'UIEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    scroll: { EventType: 'UIEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    wheel: { EventType: 'WheelEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    abort: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    canPlay: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    canPlayThrough: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    durationChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    emptied: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    encrypted: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    ended: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadedData: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadedMetadata: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadStart: { EventType: 'ProgressEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    pause: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    play: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    playing: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    progress: { EventType: 'ProgressEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    rateChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    seeked: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    seeking: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    stalled: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    suspend: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    timeUpdate: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    volumeChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    waiting: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    load: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    error: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    animationStart: { EventType: 'AnimationEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    animationEnd: { EventType: 'AnimationEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    animationIteration: {
      EventType: 'AnimationEvent',
      defaultInit: { bubbles: !0, cancelable: !1 },
    },
    transitionCancel: {
      EventType: 'TransitionEvent',
      defaultInit: { bubbles: !0, cancelable: !1 },
    },
    transitionEnd: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
    transitionRun: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    transitionStart: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    pointerOver: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerEnter: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    pointerDown: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerMove: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerUp: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerCancel: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    pointerOut: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerLeave: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    gotPointerCapture: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    lostPointerCapture: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    popState: { EventType: 'PopStateEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    offline: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    online: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    pageHide: { EventType: 'PageTransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
    pageShow: { EventType: 'PageTransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
  },
  Ab = { doubleClick: 'dblClick' };
function No(e, t) {
  return Ee().eventWrapper(() => {
    if (!t) throw new Error('Unable to fire an event - please provide an event object.');
    if (!e)
      throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
    return e.dispatchEvent(t);
  });
}
s(No, 'fireEvent');
function zs(e, t, r, n) {
  let { EventType: o = 'Event', defaultInit: i = {} } = n === void 0 ? {} : n;
  if (!t) throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
  const a = { ...i, ...r },
    { target: { value: l, files: d, ...u } = {} } = a;
  (l !== void 0 && xx(t, l),
    d !== void 0 &&
      Object.defineProperty(t, 'files', {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: d,
      }),
    Object.assign(t, u));
  const p = Gy(t),
    f = p[o] || p.Event;
  let m;
  if (typeof f == 'function') m = new f(e, a);
  else {
    m = p.document.createEvent(o);
    const { bubbles: g, cancelable: v, detail: E, ...b } = a;
    (m.initEvent(e, g, v, E),
      Object.keys(b).forEach((S) => {
        m[S] = b[S];
      }));
  }
  return (
    ['dataTransfer', 'clipboardData'].forEach((g) => {
      const v = a[g];
      typeof v == 'object' &&
        (typeof p.DataTransfer == 'function'
          ? Object.defineProperty(m, g, {
              value: Object.getOwnPropertyNames(v).reduce(
                (E, b) => (Object.defineProperty(E, b, { value: v[b] }), E),
                new p.DataTransfer(),
              ),
            })
          : Object.defineProperty(m, g, { value: v }));
    }),
    m
  );
}
s(zs, 'createEvent');
Object.keys(_b).forEach((e) => {
  const { EventType: t, defaultInit: r } = _b[e],
    n = e.toLowerCase();
  ((zs[e] = (o, i) => zs(n, o, i, { EventType: t, defaultInit: r })),
    (No[e] = (o, i) => No(o, zs[e](o, i))));
});
function xx(e, t) {
  const { set: r } = Object.getOwnPropertyDescriptor(e, 'value') || {},
    n = Object.getPrototypeOf(e),
    { set: o } = Object.getOwnPropertyDescriptor(n, 'value') || {};
  if (o && r !== o) o.call(e, t);
  else if (r) r.call(e, t);
  else throw new Error('The given element does not have a value setter');
}
s(xx, 'setNativeValue');
Object.keys(Ab).forEach((e) => {
  const t = Ab[e];
  No[e] = function () {
    return No[t](...arguments);
  };
});
function Ox(e) {
  return e.replace(
    /[ \t]*[\n][ \t]*/g,
    `
`,
  );
}
s(Ox, 'unindent');
function Cx(e) {
  return DJ.default.compressToEncodedURIComponent(Ox(e));
}
s(Cx, 'encode');
function Ix(e) {
  return 'https://testing-playground.com/#markup=' + Cx(e);
}
s(Ix, 'getPlaygroundUrl');
var vU = s((e, t, r) => (Array.isArray(e) ? e.forEach((n) => Fd(n, t, r)) : Fd(e, t, r)), 'debug'),
  TU = s(function (e) {
    if ((e === void 0 && (e = Pc().body), !e || !('innerHTML' in e))) {
      console.log("The element you're providing isn't a valid DOM element.");
      return;
    }
    if (!e.innerHTML) {
      console.log("The provided element doesn't have any children.");
      return;
    }
    const t = Ix(e.innerHTML);
    return (
      console.log(
        `Open this URL in your browser

` + t,
      ),
      t
    );
  }, 'logTestingPlaygroundURL'),
  Rb = { debug: vU, logTestingPlaygroundURL: TU },
  EU =
    typeof document < 'u' && document.body
      ? Qa(document.body, Xa, Rb)
      : Object.keys(Xa).reduce(
          (e, t) => (
            (e[t] = () => {
              throw new TypeError(
                'For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error',
              );
            }),
            e
          ),
          Rb,
        );
function he(e, t, r) {
  return (e.namespaceURI && e.namespaceURI !== 'http://www.w3.org/1999/xhtml') ||
    ((t = Array.isArray(t) ? t : [t]), !t.includes(e.tagName.toLowerCase()))
    ? !1
    : r
      ? Object.entries(r).every(([n, o]) => e[n] === o)
      : !0;
}
s(he, 'isElementType');
function jt(e) {
  var t;
  if (Nx(e) && e.defaultView) return e.defaultView;
  if (!((t = e.ownerDocument) === null || t === void 0) && t.defaultView)
    return e.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${$x(e)}`);
}
s(jt, 'getWindow');
function Nx(e) {
  return e.nodeType === 9;
}
s(Nx, 'isDocument');
function $x(e) {
  return typeof e == 'function' ? `function ${e.name}` : e === null ? 'null' : String(e);
}
s($x, 'describe');
function sh(e, t) {
  return new Promise((r, n) => {
    const o = new t();
    ((o.onerror = n),
      (o.onabort = n),
      (o.onload = () => {
        r(String(o.result));
      }),
      o.readAsText(e));
  });
}
s(sh, 'readBlobText');
function Nc(e, t) {
  const r = {
    ...t,
    length: t.length,
    item: s((n) => r[n], 'item'),
    [Symbol.iterator]: s(function* () {
      for (let o = 0; o < r.length; o++) yield r[o];
    }, 'nextFile'),
  };
  return (
    (r.constructor = e.FileList),
    e.FileList && Object.setPrototypeOf(r, e.FileList.prototype),
    Object.freeze(r),
    r
  );
}
s(Nc, 'createFileList');
function xr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(xr, '_define_property');
var qx = class {
  getAsFile() {
    return this.file;
  }
  getAsString(t) {
    typeof this.data == 'string' && t(this.data);
  }
  webkitGetAsEntry() {
    throw new Error('not implemented');
  }
  constructor(t, r) {
    (xr(this, 'kind', void 0),
      xr(this, 'type', void 0),
      xr(this, 'file', null),
      xr(this, 'data', void 0),
      typeof t == 'string'
        ? ((this.kind = 'string'), (this.type = String(r)), (this.data = t))
        : ((this.kind = 'file'), (this.type = t.type), (this.file = t)));
  }
};
s(qx, 'DataTransferItemStub');
var Mx = qx,
  jx = class extends Array {
    add(...t) {
      const r = new Mx(t[0], t[1]);
      return (this.push(r), r);
    }
    clear() {
      this.splice(0, this.length);
    }
    remove(t) {
      this.splice(t, 1);
    }
  };
s(jx, 'DataTransferItemListStub');
var wU = jx;
function $s(e, t) {
  const [r, n] = e.split('/'),
    o = !n || n === '*';
  return (i) => (t ? i.type === (o ? r : e) : o ? i.type.startsWith(`${r}/`) : i.type === r);
}
s($s, 'getTypeMatcher');
function kx(e) {
  var t;
  return new ((t = class {
    getData(r) {
      var n;
      const o =
        (n = this.items.find($s(r, !0))) !== null && n !== void 0 ? n : this.items.find($s(r, !1));
      let i = '';
      return (
        o?.getAsString((a) => {
          i = a;
        }),
        i
      );
    }
    setData(r, n) {
      const o = this.items.findIndex($s(r, !0)),
        i = new Mx(n, r);
      o >= 0 ? this.items.splice(o, 1, i) : this.items.push(i);
    }
    clearData(r) {
      if (r) {
        const n = this.items.findIndex($s(r, !0));
        n >= 0 && this.items.remove(n);
      } else this.items.clear();
    }
    get types() {
      const r = [];
      return (
        this.files.length && r.push('Files'),
        this.items.forEach((n) => r.push(n.type)),
        Object.freeze(r),
        r
      );
    }
    setDragImage() {}
    constructor() {
      (xr(this, 'dropEffect', 'none'),
        xr(this, 'effectAllowed', 'uninitialized'),
        xr(this, 'items', new wU()),
        xr(this, 'files', Nc(e, [])));
    }
  }),
  s(t, 'DataTransferStub'),
  t)();
}
s(kx, 'createDataTransferStub');
function $c(e, t = []) {
  const r = typeof e.DataTransfer > 'u' ? kx(e) : new e.DataTransfer();
  return (Object.defineProperty(r, 'files', { get: s(() => Nc(e, t), 'get') }), r);
}
s($c, 'createDataTransfer');
async function Dx(e, t) {
  return t.kind === 'file'
    ? t.getAsFile()
    : new e.Blob([await new Promise((r) => t.getAsString(r))], { type: t.type });
}
s(Dx, 'getBlobFromDataTransferItem');
function ih(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(ih, '_define_property');
function ah(e, ...t) {
  var r;
  const n = Object.fromEntries(
    t.map((o) => [typeof o == 'string' ? 'text/plain' : o.type, Promise.resolve(o)]),
  );
  return typeof e.ClipboardItem < 'u'
    ? new e.ClipboardItem(n)
    : new ((r = class {
        get types() {
          return Array.from(Object.keys(this.data));
        }
        async getType(o) {
          const i = await this.data[o];
          if (!i) throw new Error(`${o} is not one of the available MIME types on this item.`);
          return i instanceof e.Blob ? i : new e.Blob([i], { type: o });
        }
        constructor(o) {
          (ih(this, 'data', void 0), (this.data = o));
        }
      }),
      s(r, 'ClipboardItem'),
      r)(n);
}
s(ah, 'createClipboardItem');
var $o = Symbol('Manage ClipboardSub');
function Yd(e, t) {
  var r;
  return Object.assign(
    new ((r = class extends e.EventTarget {
      async read() {
        return Array.from(this.items);
      }
      async readText() {
        let n = '';
        for (const o of this.items) {
          const i = o.types.includes('text/plain')
            ? 'text/plain'
            : o.types.find((a) => a.startsWith('text/'));
          i && (n += await o.getType(i).then((a) => sh(a, e.FileReader)));
        }
        return n;
      }
      async write(n) {
        this.items = n;
      }
      async writeText(n) {
        this.items = [ah(e, n)];
      }
      constructor(...n) {
        (super(...n), ih(this, 'items', []));
      }
    }),
    s(r, 'Clipboard'),
    r)(),
    { [$o]: t },
  );
}
s(Yd, 'createClipboardStub');
function qc(e) {
  return !!e?.[$o];
}
s(qc, 'isClipboardStub');
function Lx(e) {
  if (qc(e.navigator.clipboard)) return e.navigator.clipboard[$o];
  const t = Object.getOwnPropertyDescriptor(e.navigator, 'clipboard');
  let r;
  const n = {
    resetClipboardStub: s(() => {
      r = Yd(e, n);
    }, 'resetClipboardStub'),
    detachClipboardStub: s(() => {
      t
        ? Object.defineProperty(e.navigator, 'clipboard', t)
        : Object.defineProperty(e.navigator, 'clipboard', { value: void 0, configurable: !0 });
    }, 'detachClipboardStub'),
  };
  return (
    (r = Yd(e, n)),
    Object.defineProperty(e.navigator, 'clipboard', { get: s(() => r, 'get'), configurable: !0 }),
    r[$o]
  );
}
s(Lx, 'attachClipboardStubToView');
function Fx(e) {
  qc(e.navigator.clipboard) && e.navigator.clipboard[$o].resetClipboardStub();
}
s(Fx, 'resetClipboardStubOnView');
function Bx(e) {
  qc(e.navigator.clipboard) && e.navigator.clipboard[$o].detachClipboardStub();
}
s(Bx, 'detachClipboardStubFromView');
async function Jx(e) {
  const t = e.defaultView,
    r = t?.navigator.clipboard,
    n = r && (await r.read());
  if (!n) throw new Error('The Clipboard API is unavailable.');
  const o = $c(t);
  for (const i of n)
    for (const a of i.types) o.setData(a, await i.getType(a).then((l) => sh(l, t.FileReader)));
  return o;
}
s(Jx, 'readDataTransferFromClipboard');
async function lh(e, t) {
  const r = jt(e),
    n = r.navigator.clipboard,
    o = [];
  for (let a = 0; a < t.items.length; a++) {
    const l = t.items[a],
      d = await Dx(r, l);
    o.push(ah(r, d));
  }
  if (
    !(
      n &&
      (await n.write(o).then(
        () => !0,
        () => !1,
      ))
    )
  )
    throw new Error('The Clipboard API is unavailable.');
}
s(lh, 'writeDataTransferToClipboard');
var Za = globalThis;
typeof Za.afterEach == 'function' &&
  Za.afterEach(() => {
    typeof globalThis.window < 'u' && Fx(globalThis.window);
  });
typeof Za.afterAll == 'function' &&
  Za.afterAll(() => {
    typeof globalThis.window < 'u' && Bx(globalThis.window);
  });
var Ux = [
  'input:not([type=hidden]):not([disabled])',
  'button:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  '[contenteditable=""]',
  '[contenteditable="true"]',
  'a[href]',
  '[tabindex]:not([disabled])',
].join(', ');
function Mc(e) {
  return e.matches(Ux);
}
s(Mc, 'isFocusable');
function Vx(e) {
  return new e.constructor(e.type, e);
}
s(Vx, 'cloneEvent');
function dr(e) {
  for (let r = e; r; r = r.parentElement)
    if (he(r, ['button', 'input', 'select', 'textarea', 'optgroup', 'option'])) {
      if (r.hasAttribute('disabled')) return !0;
    } else if (he(r, 'fieldset')) {
      var t;
      if (
        r.hasAttribute('disabled') &&
        !(!((t = r.querySelector(':scope > legend')) === null || t === void 0) && t.contains(e))
      )
        return !0;
    } else if (
      r.tagName.includes('-') &&
      r.constructor.formAssociated &&
      r.hasAttribute('disabled')
    )
      return !0;
  return !1;
}
s(dr, 'isDisabled');
function Ko(e) {
  const t = e.activeElement;
  return t?.shadowRoot
    ? Ko(t.shadowRoot)
    : dr(t)
      ? e.ownerDocument
        ? e.ownerDocument.body
        : e.body
      : t;
}
s(Ko, 'getActiveElement');
function ua(e) {
  var t;
  return (t = Ko(e)) !== null && t !== void 0 ? t : e.body;
}
s(ua, 'getActiveElementOrBody');
function Hx(e, t) {
  let r = e;
  do {
    if (t(r)) return r;
    r = r.parentElement;
  } while (r && r !== e.ownerDocument.body);
}
s(Hx, 'findClosest');
function tn(e) {
  return (
    e.hasAttribute('contenteditable') &&
    (e.getAttribute('contenteditable') == 'true' || e.getAttribute('contenteditable') == '')
  );
}
s(tn, 'isContentEditable');
function qo(e) {
  const t = zx(e);
  return t && (t.closest('[contenteditable=""]') || t.closest('[contenteditable="true"]'));
}
s(qo, 'getContentEditable');
function zx(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
s(zx, 'getElement');
var Gx = (function (e) {
  return (
    (e.button = 'button'),
    (e.color = 'color'),
    (e.file = 'file'),
    (e.image = 'image'),
    (e.reset = 'reset'),
    (e.submit = 'submit'),
    (e.checkbox = 'checkbox'),
    (e.radio = 'radio'),
    e
  );
})(Gx || {});
function ch(e) {
  return he(e, 'button') || (he(e, 'input') && e.type in Gx);
}
s(ch, 'isClickableInput');
function qn(e) {
  return (uh(e) && !e.readOnly) || tn(e);
}
s(qn, 'isEditable');
var Wx = (function (e) {
  return (
    (e.text = 'text'),
    (e.date = 'date'),
    (e['datetime-local'] = 'datetime-local'),
    (e.email = 'email'),
    (e.month = 'month'),
    (e.number = 'number'),
    (e.password = 'password'),
    (e.search = 'search'),
    (e.tel = 'tel'),
    (e.time = 'time'),
    (e.url = 'url'),
    (e.week = 'week'),
    e
  );
})(Wx || {});
function uh(e) {
  return he(e, 'textarea') || (he(e, 'input') && e.type in Wx);
}
s(uh, 'isEditableInputOrTextArea');
function Zt(e) {
  return dh(e) && uh(e);
}
s(Zt, 'hasOwnSelection');
function Kx(e) {
  return dh(e) && ch(e);
}
s(Kx, 'hasNoSelection');
function dh(e) {
  return e.nodeType === 1;
}
s(dh, 'isElement');
function Yx(e) {
  const t = e.ownerDocument.getSelection();
  if (t?.focusNode && Zt(e)) {
    const n = qo(t.focusNode);
    if (n) {
      if (!t.isCollapsed) {
        var r;
        const o =
          ((r = n.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === 3
            ? n.firstChild
            : n;
        t.setBaseAndExtent(o, 0, o, 0);
      }
    } else t.setBaseAndExtent(e, 0, e, 0);
  }
}
s(Yx, 'updateSelectionOnFocus');
function Mn(e, t) {
  return Ee().eventWrapper(e);
}
s(Mn, 'wrapEvent');
function $r(e) {
  const t = Hx(e, Mc),
    r = Ko(e.ownerDocument);
  (t ?? e.ownerDocument.body) !== r &&
    (Mn(t ? () => t.focus() : () => r?.blur()), Yx(t ?? e.ownerDocument.body));
}
s($r, 'focusElement');
function Xx(e) {
  !Mc(e) || !(Ko(e.ownerDocument) === e) || Mn(() => e.blur());
}
s(Xx, 'blurElement');
var rn = {};
rn.click = (e, t, r) => {
  const n = t.closest('button,input,label,select,textarea'),
    o = n && he(n, 'label') && n.control;
  if (o && o !== t)
    return () => {
      Mc(o) && ($r(o), r.dispatchEvent(o, Vx(e)));
    };
  if (he(t, 'input', { type: 'file' }))
    return () => {
      (Xx(t), t.dispatchEvent(new (jt(t).Event)('fileDialog')), $r(t));
    };
};
var Mo = Symbol('Displayed value in UI'),
  Or = Symbol('Displayed selection in UI'),
  el = Symbol('Initial value to compare on blur');
function Qx(e) {
  return typeof e == 'object' && Mo in e;
}
s(Qx, 'isUIValue');
function Zx(e) {
  return !!e && typeof e == 'object' && Or in e;
}
s(Zx, 'isUISelectionStart');
function eO(e, t) {
  (e[el] === void 0 && (e[el] = e.value),
    (e[Mo] = t),
    (e.value = Object.assign(new String(t), { [Mo]: !0 })));
}
s(eO, 'setUIValue');
function er(e) {
  return e[Mo] === void 0 ? e.value : String(e[Mo]);
}
s(er, 'getUIValue');
function jc(e) {
  e[Mo] = void 0;
}
s(jc, 'setUIValueClean');
function ph(e) {
  e[el] = void 0;
}
s(ph, 'clearInitialValue');
function tO(e) {
  return e[el];
}
s(tO, 'getInitialValue');
function rO(e, t) {
  e[Or] = t;
}
s(rO, 'setUISelectionRaw');
function Wn(e, { focusOffset: t, anchorOffset: r = t }, n = 'replace') {
  const o = er(e).length,
    i = s((f) => Math.max(0, Math.min(o, f)), 'sanitizeOffset'),
    a = n === 'replace' || e[Or] === void 0 ? i(r) : e[Or].anchorOffset,
    l = i(t),
    d = Math.min(a, l),
    u = Math.max(a, l);
  if (
    ((e[Or] = { anchorOffset: a, focusOffset: l }), e.selectionStart === d && e.selectionEnd === u)
  )
    return;
  const p = Object.assign(new Number(d), { [Or]: !0 });
  try {
    e.setSelectionRange(p, u);
  } catch {}
}
s(Wn, 'setUISelection');
function jo(e) {
  var t, r, n;
  const o =
    (n = e[Or]) !== null && n !== void 0
      ? n
      : {
          anchorOffset: (t = e.selectionStart) !== null && t !== void 0 ? t : 0,
          focusOffset: (r = e.selectionEnd) !== null && r !== void 0 ? r : 0,
        };
  return {
    ...o,
    startOffset: Math.min(o.anchorOffset, o.focusOffset),
    endOffset: Math.max(o.anchorOffset, o.focusOffset),
  };
}
s(jo, 'getUISelection');
function nO(e) {
  return !!e[Or];
}
s(nO, 'hasUISelection');
function Gs(e) {
  e[Or] = void 0;
}
s(Gs, 'setUISelectionClean');
var tl = globalThis.parseInt;
function oO(e) {
  const t = e.replace(/\D/g, '');
  if (t.length < 2) return e;
  const r = tl(t[0], 10),
    n = tl(t[1], 10);
  if (r >= 3 || (r === 2 && n >= 4)) {
    let o;
    return (r >= 3 ? (o = 1) : (o = 2), Xd(t, o));
  }
  return e.length === 2 ? e : Xd(t, 2);
}
s(oO, 'buildTimeValue');
function Xd(e, t) {
  const r = e.slice(0, t),
    n = Math.min(tl(r, 10), 23),
    o = e.slice(t),
    i = tl(o, 10),
    a = Math.min(i, 59);
  return `${n.toString().padStart(2, '0')}:${a.toString().padStart(2, '0')}`;
}
s(Xd, 'build');
function fh(e, t) {
  const r = e.cloneNode();
  return ((r.value = t), r.value === t);
}
s(fh, 'isValidDateOrTimeValue');
var sO = (function (e) {
  return (
    (e.email = 'email'),
    (e.password = 'password'),
    (e.search = 'search'),
    (e.telephone = 'telephone'),
    (e.text = 'text'),
    (e.url = 'url'),
    e
  );
})(sO || {});
function iO(e) {
  var t;
  const r = (t = e.getAttribute('maxlength')) !== null && t !== void 0 ? t : '';
  return /^\d+$/.test(r) && Number(r) >= 0 ? Number(r) : void 0;
}
s(iO, 'getMaxLength');
function aO(e) {
  return he(e, 'textarea') || (he(e, 'input') && e.type in sO);
}
s(aO, 'supportsMaxLength');
function mh(e, t, r, n) {
  if (Ws(e) && t + r >= 0 && t + r <= e.nodeValue.length) return { node: e, offset: t + r };
  const o = Qd(e, t, r);
  if (o) {
    if (Ws(o))
      return {
        node: o,
        offset: r > 0 ? Math.min(1, o.nodeValue.length) : Math.max(o.nodeValue.length - 1, 0),
      };
    if (he(o, 'br')) {
      const i = Qd(o, void 0, r);
      return i
        ? Ws(i)
          ? { node: i, offset: r > 0 ? 0 : i.nodeValue.length }
          : r < 0 && he(i, 'br')
            ? { node: o.parentNode, offset: qs(o) }
            : { node: i.parentNode, offset: qs(i) + (r > 0 ? 0 : 1) }
        : r < 0 && n === 'deleteContentBackward'
          ? { node: o.parentNode, offset: qs(o) }
          : void 0;
    } else return { node: o.parentNode, offset: qs(o) + (r > 0 ? 1 : 0) };
  }
}
s(mh, 'getNextCursorPosition');
function Qd(e, t, r) {
  const n = Number(t) + (r < 0 ? -1 : 0);
  return (
    t !== void 0 && kc(e) && n >= 0 && n < e.children.length && (e = e.children[n]),
    cO(e, r === 1 ? 'next' : 'previous', lO)
  );
}
s(Qd, 'getNextCharacterContentNode');
function lO(e) {
  if (Ws(e)) return !0;
  if (kc(e)) {
    if (he(e, ['input', 'textarea'])) return e.type !== 'hidden';
    if (he(e, 'br')) return !0;
  }
  return !1;
}
s(lO, 'isTreatedAsCharacterContent');
function qs(e) {
  let t = 0;
  for (; e.previousSibling; ) (t++, (e = e.previousSibling));
  return t;
}
s(qs, 'getOffset');
function kc(e) {
  return e.nodeType === 1;
}
s(kc, 'isElement');
function Ws(e) {
  return e.nodeType === 3;
}
s(Ws, 'isTextNode');
function cO(e, t, r) {
  for (;;) {
    var n;
    const o = e[`${t}Sibling`];
    if (o) {
      if (((e = uO(o, t === 'next' ? 'first' : 'last')), r(e))) return e;
    } else if (
      e.parentNode &&
      (!kc(e.parentNode) ||
        (!tn(e.parentNode) &&
          e.parentNode !== ((n = e.ownerDocument) === null || n === void 0 ? void 0 : n.body)))
    )
      e = e.parentNode;
    else break;
  }
}
s(cO, 'walkNodes');
function uO(e, t) {
  for (; e.hasChildNodes(); ) e = e[`${t}Child`];
  return e;
}
s(uO, 'getDescendant');
var yi = Symbol('Track programmatic changes for React workaround');
function dO(e) {
  return (
    Object.getOwnPropertyNames(e).some((t) => t.startsWith('__react')) && jt(e).REACT_VERSION === 17
  );
}
s(dO, 'isReact17Element');
function pO(e) {
  dO(e) && (e[yi] = { previousValue: String(e.value), tracked: [] });
}
s(pO, 'startTrackValue');
function fO(e, t) {
  var r, n;
  ((n = e[yi]) === null || n === void 0 || (r = n.tracked) === null || r === void 0 || r.push(t),
    e[yi] || (jc(e), Wn(e, { focusOffset: t.length })));
}
s(fO, 'trackOrSetValue');
function mO(e, t) {
  var r;
  const n = e[yi];
  if (((e[yi] = void 0), !(!(n == null || (r = n.tracked) === null || r === void 0) && r.length)))
    return;
  const o = n.tracked.length === 2 && n.tracked[0] === n.previousValue && n.tracked[1] === e.value;
  (o || jc(e), nO(e) && Wn(e, { focusOffset: o ? t : e.value.length }));
}
s(mO, 'commitValueAfterInput');
function yh(e) {
  const t = yO(e);
  if (t && Zt(t)) return { type: 'input', selection: jo(t) };
  const r = t?.ownerDocument.getSelection();
  return {
    type: qo(e) && r?.anchorNode && qo(r.anchorNode) ? 'contenteditable' : 'default',
    selection: r,
  };
}
s(yh, 'getTargetTypeAndSelection');
function yO(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
s(yO, 'getElement');
function hO(e) {
  const t = yh(e);
  if (t.type === 'input') return t.selection;
  if (t.type === 'contenteditable') {
    var r;
    return (r = t.selection) === null || r === void 0 ? void 0 : r.getRangeAt(0);
  }
}
s(hO, 'getInputRange');
function nn({ focusNode: e, focusOffset: t, anchorNode: r = e, anchorOffset: n = t }) {
  var o, i;
  if (yh(e).type === 'input') return Wn(e, { anchorOffset: n, focusOffset: t });
  (i = r.ownerDocument) === null ||
    i === void 0 ||
    (o = i.getSelection()) === null ||
    o === void 0 ||
    o.setBaseAndExtent(r, n, e, t);
}
s(nn, 'setSelection');
function hh(e) {
  return he(e, 'input') && ['date', 'time'].includes(e.type);
}
s(hh, 'isDateOrTime');
function jn(e, t, r, n = 'insertText') {
  const o = hO(t);
  o &&
    ((!hh(t) && !e.dispatchUIEvent(t, 'beforeinput', { inputType: n, data: r })) ||
      ('startContainer' in o ? gO(e, t, o, r, n) : bO(e, t, o, r, n)));
}
s(jn, 'input');
function gO(e, t, r, n, o) {
  let i = !1;
  if (!r.collapsed) ((i = !0), r.deleteContents());
  else if (['deleteContentBackward', 'deleteContentForward'].includes(o)) {
    const a = mh(r.startContainer, r.startOffset, o === 'deleteContentBackward' ? -1 : 1, o);
    if (a) {
      i = !0;
      const l = r.cloneRange();
      (l.comparePoint(a.node, a.offset) < 0
        ? l.setStart(a.node, a.offset)
        : l.setEnd(a.node, a.offset),
        l.deleteContents());
    }
  }
  if (n)
    if (r.endContainer.nodeType === 3) {
      const a = r.endOffset;
      (r.endContainer.insertData(a, n),
        r.setStart(r.endContainer, a + n.length),
        r.setEnd(r.endContainer, a + n.length));
    } else {
      const a = t.ownerDocument.createTextNode(n);
      (r.insertNode(a), r.setStart(a, n.length), r.setEnd(a, n.length));
    }
  (i || n) && e.dispatchUIEvent(t, 'input', { inputType: o });
}
s(gO, 'editContenteditable');
function bO(e, t, r, n, o) {
  let i = n;
  if (aO(t)) {
    const u = iO(t);
    if (u !== void 0 && n.length > 0) {
      const p = u - t.value.length;
      if (p > 0) i = n.substring(0, p);
      else return;
    }
  }
  const { newValue: a, newOffset: l, oldValue: d } = vO(i, t, r, o);
  (a === d && l === r.startOffset && l === r.endOffset) ||
    (he(t, 'input', { type: 'number' }) && !TO(a)) ||
    (eO(t, a),
    nn({ focusNode: t, anchorOffset: l, focusOffset: l }),
    hh(t)
      ? fh(t, a) && (Zd(e, t, l, {}), e.dispatchUIEvent(t, 'change'), ph(t))
      : Zd(e, t, l, { data: n, inputType: o }));
}
s(bO, 'editInputElement');
function vO(e, t, { startOffset: r, endOffset: n }, o) {
  const i = er(t),
    a = Math.max(0, r === n && o === 'deleteContentBackward' ? r - 1 : r),
    l = i.substring(0, a),
    d = Math.min(i.length, r === n && o === 'deleteContentForward' ? r + 1 : n),
    u = i.substring(d, i.length);
  let p = `${l}${e}${u}`,
    f = a + e.length;
  if (he(t, 'input', { type: 'time' })) {
    const m = oO(p);
    m !== '' && fh(t, m) && ((p = m), (f = m.length));
  }
  return { oldValue: i, newValue: p, newOffset: f };
}
s(vO, 'calculateNewValue');
function Zd(e, t, r, n) {
  (e.dispatchUIEvent(t, 'input', n), mO(t, r));
}
s(Zd, 'commitInput');
function TO(e) {
  var t, r;
  const n = e.split('e', 2);
  return !(
    /[^\d.\-e]/.test(e) ||
    Number((t = e.match(/-/g)) === null || t === void 0 ? void 0 : t.length) > 2 ||
    Number((r = e.match(/\./g)) === null || r === void 0 ? void 0 : r.length) > 1 ||
    (n[1] && !/^-?\d*$/.test(n[1]))
  );
}
s(TO, 'isValidNumberInput');
rn.cut = (e, t, r) => () => {
  qn(t) && jn(r, t, '', 'deleteByCut');
};
function EO(e) {
  return e ? (tn(e) ? e.textContent : er(e)) : null;
}
s(EO, 'getValueOrTextContent');
function wO(e) {
  const t = jt(e);
  for (let r = e; r?.ownerDocument; r = r.parentElement) {
    const { display: n, visibility: o } = t.getComputedStyle(r);
    if (n === 'none' || o === 'hidden') return !1;
  }
  return !0;
}
s(wO, 'isVisible');
function SO(e, t) {
  const r = e.ownerDocument,
    n = r.querySelectorAll(Ux),
    o = Array.from(n).filter((d) => d === e || !(Number(d.getAttribute('tabindex')) < 0 || dr(d)));
  Number(e.getAttribute('tabindex')) >= 0 &&
    o.sort((d, u) => {
      const p = Number(d.getAttribute('tabindex')),
        f = Number(u.getAttribute('tabindex'));
      return p === f ? 0 : p === 0 ? 1 : f === 0 ? -1 : p - f;
    });
  const i = {};
  let a = [r.body];
  const l = he(e, 'input', { type: 'radio' }) ? e.name : void 0;
  o.forEach((d) => {
    const u = d;
    if (he(u, 'input', { type: 'radio' }) && u.name) {
      if (u === e) {
        a.push(u);
        return;
      } else if (u.name === l) return;
      if (u.checked) {
        ((a = a.filter((p) => !he(p, 'input', { type: 'radio', name: u.name }))),
          a.push(u),
          (i[u.name] = u));
        return;
      }
      if (typeof i[u.name] < 'u') return;
    }
    a.push(u);
  });
  for (let d = a.findIndex((u) => u === e); ; )
    if (
      ((d += t ? -1 : 1),
      d === a.length ? (d = 0) : d === -1 && (d = a.length - 1),
      a[d] === e || a[d] === r.body || wO(a[d]))
    )
      return a[d];
}
s(SO, 'getTabDestination');
function ep(e, t) {
  if (Zt(e)) {
    const r = jo(e);
    nn({
      focusNode: e,
      focusOffset:
        r.startOffset === r.endOffset ? r.focusOffset + t : t < 0 ? r.startOffset : r.endOffset,
    });
  } else {
    const r = e.ownerDocument.getSelection();
    if (!r?.focusNode) return;
    if (r.isCollapsed) {
      const n = mh(r.focusNode, r.focusOffset, t);
      n && nn({ focusNode: n.node, focusOffset: n.offset });
    } else r[t < 0 ? 'collapseToStart' : 'collapseToEnd']();
  }
}
s(ep, 'moveSelection');
function gh(e) {
  if (Zt(e)) return nn({ focusNode: e, anchorOffset: 0, focusOffset: er(e).length });
  var t;
  const r = (t = qo(e)) !== null && t !== void 0 ? t : e.ownerDocument.body;
  nn({ focusNode: r, anchorOffset: 0, focusOffset: r.childNodes.length });
}
s(gh, 'selectAll');
function _O(e) {
  if (Zt(e)) return jo(e).startOffset === 0 && jo(e).endOffset === er(e).length;
  var t;
  const r = (t = qo(e)) !== null && t !== void 0 ? t : e.ownerDocument.body,
    n = e.ownerDocument.getSelection();
  return (
    n?.anchorNode === r &&
    n.focusNode === r &&
    n.anchorOffset === 0 &&
    n.focusOffset === r.childNodes.length
  );
}
s(_O, 'isAllSelected');
function so(e, t, r) {
  var n;
  if (Zt(e)) return nn({ focusNode: e, anchorOffset: t, focusOffset: r });
  if (tn(e) && ((n = e.firstChild) === null || n === void 0 ? void 0 : n.nodeType) === 3)
    return nn({ focusNode: e.firstChild, anchorOffset: t, focusOffset: r });
  throw new Error('Not implemented. The result of this interaction is unreliable.');
}
s(so, 'setSelectionRange');
function Ms(e, t, r) {
  const n = jt(t),
    o = Array.from(
      t.ownerDocument.querySelectorAll(
        t.name
          ? `input[type="radio"][name="${n.CSS.escape(t.name)}"]`
          : 'input[type="radio"][name=""], input[type="radio"]:not([name])',
      ),
    );
  for (let i = o.findIndex((a) => a === t) + r; ; i += r) {
    if ((o[i] || (i = r > 0 ? 0 : o.length - 1), o[i] === t)) return;
    if (!dr(o[i])) {
      ($r(o[i]), e.dispatchUIEvent(o[i], 'click'));
      return;
    }
  }
}
s(Ms, 'walkRadio');
rn.keydown = (e, t, r) => {
  var n, o;
  return (o = (n = Pb[e.key]) === null || n === void 0 ? void 0 : n.call(Pb, e, t, r)) !== null &&
    o !== void 0
    ? o
    : SU(e, t, r);
};
var Pb = {
    ArrowDown: s((e, t, r) => {
      if (he(t, 'input', { type: 'radio' })) return () => Ms(r, t, 1);
    }, 'ArrowDown'),
    ArrowLeft: s(
      (e, t, r) => (he(t, 'input', { type: 'radio' }) ? () => Ms(r, t, -1) : () => ep(t, -1)),
      'ArrowLeft',
    ),
    ArrowRight: s(
      (e, t, r) => (he(t, 'input', { type: 'radio' }) ? () => Ms(r, t, 1) : () => ep(t, 1)),
      'ArrowRight',
    ),
    ArrowUp: s((e, t, r) => {
      if (he(t, 'input', { type: 'radio' })) return () => Ms(r, t, -1);
    }, 'ArrowUp'),
    Backspace: s((e, t, r) => {
      if (qn(t))
        return () => {
          jn(r, t, '', 'deleteContentBackward');
        };
    }, 'Backspace'),
    Delete: s((e, t, r) => {
      if (qn(t))
        return () => {
          jn(r, t, '', 'deleteContentForward');
        };
    }, 'Delete'),
    End: s((e, t) => {
      if (he(t, ['input', 'textarea']) || tn(t))
        return () => {
          var r, n;
          const o =
            (n = (r = EO(t)) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0
              ? n
              : 0;
          so(t, o, o);
        };
    }, 'End'),
    Home: s((e, t) => {
      if (he(t, ['input', 'textarea']) || tn(t))
        return () => {
          so(t, 0, 0);
        };
    }, 'Home'),
    PageDown: s((e, t) => {
      if (he(t, ['input']))
        return () => {
          const r = er(t).length;
          so(t, r, r);
        };
    }, 'PageDown'),
    PageUp: s((e, t) => {
      if (he(t, ['input']))
        return () => {
          so(t, 0, 0);
        };
    }, 'PageUp'),
    Tab: s(
      (e, t, r) => () => {
        const n = SO(t, r.system.keyboard.modifiers.Shift);
        ($r(n), Zt(n) && Wn(n, { anchorOffset: 0, focusOffset: n.value.length }));
      },
      'Tab',
    ),
  },
  SU = s((e, t, r) => {
    if (e.code === 'KeyA' && r.system.keyboard.modifiers.Control) return () => gh(t);
  }, 'combinationBehavior');
rn.keypress = (e, t, r) => {
  if (e.key === 'Enter') {
    if (he(t, 'button') || (he(t, 'input') && _U.includes(t.type)) || (he(t, 'a') && t.href))
      return () => {
        r.dispatchUIEvent(t, 'click');
      };
    if (he(t, 'input')) {
      const n = t.form,
        o = n?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return o
        ? () => r.dispatchUIEvent(o, 'click')
        : n && AU.includes(t.type) && n.querySelectorAll('input').length === 1
          ? () => r.dispatchUIEvent(n, 'submit')
          : void 0;
    }
  }
  if (qn(t)) {
    const n =
        e.key === 'Enter'
          ? tn(t) && !r.system.keyboard.modifiers.Shift
            ? 'insertParagraph'
            : 'insertLineBreak'
          : 'insertText',
      o =
        e.key === 'Enter'
          ? `
`
          : e.key;
    return () => jn(r, t, o, n);
  }
};
var _U = ['button', 'color', 'file', 'image', 'reset', 'submit'],
  AU = ['email', 'month', 'password', 'search', 'tel', 'text', 'url', 'week'];
rn.keyup = (e, t, r) => {
  var n;
  return (n = xb[e.key]) === null || n === void 0 ? void 0 : n.call(xb, e, t, r);
};
var xb = {
  ' ': s((e, t, r) => {
    if (ch(t)) return () => r.dispatchUIEvent(t, 'click');
  }, ' '),
};
rn.paste = (e, t, r) => {
  if (qn(t))
    return () => {
      var n;
      const o = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.getData('text');
      o && jn(r, t, o, 'insertFromPaste');
    };
};
var AO = {
  auxclick: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  beforeinput: {
    EventType: 'InputEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  blur: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
  click: { EventType: 'PointerEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  contextmenu: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  copy: { EventType: 'ClipboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  change: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
  cut: { EventType: 'ClipboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  dblclick: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  focus: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
  focusin: { EventType: 'FocusEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  focusout: { EventType: 'FocusEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  keydown: {
    EventType: 'KeyboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  keypress: {
    EventType: 'KeyboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  keyup: { EventType: 'KeyboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  paste: {
    EventType: 'ClipboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  input: { EventType: 'InputEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  mousedown: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseenter: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
  },
  mouseleave: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
  },
  mousemove: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseout: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  mouseover: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseup: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  pointerover: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerenter: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
  pointerdown: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointermove: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerup: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointercancel: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
  },
  pointerout: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerleave: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
  submit: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
};
function bh(e) {
  return AO[e].EventType;
}
s(bh, 'getEventClass');
var RU = ['MouseEvent', 'PointerEvent'];
function RO(e) {
  return RU.includes(bh(e));
}
s(RO, 'isMouseEvent');
function PO(e) {
  return bh(e) === 'KeyboardEvent';
}
s(PO, 'isKeyboardEvent');
var PU = {
  ClipboardEvent: [OO],
  Event: [],
  FocusEvent: [Zn, CO],
  InputEvent: [Zn, IO],
  MouseEvent: [Zn, da, tp],
  PointerEvent: [Zn, da, tp, $O],
  KeyboardEvent: [Zn, da, NO],
};
function vh(e, t, r) {
  const n = jt(t),
    { EventType: o, defaultInit: i } = AO[e],
    a = new (xO(n)[o])(e, i);
  return (PU[o].forEach((l) => l(a, r ?? {})), a);
}
s(vh, 'createEvent');
function xO(e) {
  var t, r, n, o, i, a, l, d, u, p, f, m, h, g, v, E;
  const b = (E = e.Event) !== null && E !== void 0 ? E : ((t = class {}), s(t, 'Event'), t);
  var S;
  const R =
    (S = e.AnimationEvent) !== null && S !== void 0
      ? S
      : ((r = class extends b {}), s(r, 'AnimationEvent'), r);
  var I;
  const $ =
    (I = e.ClipboardEvent) !== null && I !== void 0
      ? I
      : ((n = class extends b {}), s(n, 'ClipboardEvent'), n);
  var x;
  const A =
    (x = e.PopStateEvent) !== null && x !== void 0
      ? x
      : ((o = class extends b {}), s(o, 'PopStateEvent'), o);
  var w;
  const _ =
    (w = e.ProgressEvent) !== null && w !== void 0
      ? w
      : ((i = class extends b {}), s(i, 'ProgressEvent'), i);
  var j;
  const N =
    (j = e.TransitionEvent) !== null && j !== void 0
      ? j
      : ((a = class extends b {}), s(a, 'TransitionEvent'), a);
  var V;
  const H =
    (V = e.UIEvent) !== null && V !== void 0 ? V : ((l = class extends b {}), s(l, 'UIEvent'), l);
  var P;
  const D =
    (P = e.CompositionEvent) !== null && P !== void 0
      ? P
      : ((d = class extends H {}), s(d, 'CompositionEvent'), d);
  var F;
  const k =
    (F = e.FocusEvent) !== null && F !== void 0
      ? F
      : ((u = class extends H {}), s(u, 'FocusEvent'), u);
  var K;
  const X =
    (K = e.InputEvent) !== null && K !== void 0
      ? K
      : ((p = class extends H {}), s(p, 'InputEvent'), p);
  var se;
  const ie =
    (se = e.KeyboardEvent) !== null && se !== void 0
      ? se
      : ((f = class extends H {}), s(f, 'KeyboardEvent'), f);
  var W;
  const ae =
    (W = e.MouseEvent) !== null && W !== void 0
      ? W
      : ((m = class extends H {}), s(m, 'MouseEvent'), m);
  var be;
  const ue =
    (be = e.DragEvent) !== null && be !== void 0
      ? be
      : ((h = class extends ae {}), s(h, 'DragEvent'), h);
  var ee;
  const Pe =
    (ee = e.PointerEvent) !== null && ee !== void 0
      ? ee
      : ((g = class extends ae {}), s(g, 'PointerEvent'), g);
  var xe;
  const He =
    (xe = e.TouchEvent) !== null && xe !== void 0
      ? xe
      : ((v = class extends H {}), s(v, 'TouchEvent'), v);
  return {
    Event: b,
    AnimationEvent: R,
    ClipboardEvent: $,
    PopStateEvent: A,
    ProgressEvent: _,
    TransitionEvent: N,
    UIEvent: H,
    CompositionEvent: D,
    FocusEvent: k,
    InputEvent: X,
    KeyboardEvent: ie,
    MouseEvent: ae,
    DragEvent: ue,
    PointerEvent: Pe,
    TouchEvent: He,
  };
}
s(xO, 'getEventConstructors');
function kr(e, t) {
  for (const [r, n] of Object.entries(t))
    Object.defineProperty(e, r, { get: s(() => n ?? null, 'get') });
}
s(kr, 'assignProps');
function De(e) {
  return Number(e ?? 0);
}
s(De, 'sanitizeNumber');
function OO(e, { clipboardData: t }) {
  kr(e, { clipboardData: t });
}
s(OO, 'initClipboardEvent');
function CO(e, { relatedTarget: t }) {
  kr(e, { relatedTarget: t });
}
s(CO, 'initFocusEvent');
function IO(e, { data: t, inputType: r, isComposing: n }) {
  kr(e, { data: t, isComposing: !!n, inputType: String(r) });
}
s(IO, 'initInputEvent');
function Zn(e, { view: t, detail: r }) {
  kr(e, { view: t, detail: De(r ?? 0) });
}
s(Zn, 'initUIEvent');
function da(
  e,
  {
    altKey: t,
    ctrlKey: r,
    metaKey: n,
    shiftKey: o,
    modifierAltGraph: i,
    modifierCapsLock: a,
    modifierFn: l,
    modifierFnLock: d,
    modifierNumLock: u,
    modifierScrollLock: p,
    modifierSymbol: f,
    modifierSymbolLock: m,
  },
) {
  kr(e, {
    altKey: !!t,
    ctrlKey: !!r,
    metaKey: !!n,
    shiftKey: !!o,
    getModifierState(h) {
      return !!{
        Alt: t,
        AltGraph: i,
        CapsLock: a,
        Control: r,
        Fn: l,
        FnLock: d,
        Meta: n,
        NumLock: u,
        ScrollLock: p,
        Shift: o,
        Symbol: f,
        SymbolLock: m,
      }[h];
    },
  });
}
s(da, 'initUIEventModifiers');
function NO(e, { key: t, code: r, location: n, repeat: o, isComposing: i, charCode: a }) {
  kr(e, {
    key: String(t),
    code: String(r),
    location: De(n),
    repeat: !!o,
    isComposing: !!i,
    charCode: a,
  });
}
s(NO, 'initKeyboardEvent');
function tp(
  e,
  {
    x: t,
    y: r,
    screenX: n,
    screenY: o,
    clientX: i = t,
    clientY: a = r,
    button: l,
    buttons: d,
    relatedTarget: u,
    offsetX: p,
    offsetY: f,
    pageX: m,
    pageY: h,
  },
) {
  kr(e, {
    screenX: De(n),
    screenY: De(o),
    clientX: De(i),
    x: De(i),
    clientY: De(a),
    y: De(a),
    button: De(l),
    buttons: De(d),
    relatedTarget: u,
    offsetX: De(p),
    offsetY: De(f),
    pageX: De(m),
    pageY: De(h),
  });
}
s(tp, 'initMouseEvent');
function $O(
  e,
  {
    pointerId: t,
    width: r,
    height: n,
    pressure: o,
    tangentialPressure: i,
    tiltX: a,
    tiltY: l,
    twist: d,
    pointerType: u,
    isPrimary: p,
  },
) {
  kr(e, {
    pointerId: De(t),
    width: De(r ?? 1),
    height: De(n ?? 1),
    pressure: De(o),
    tangentialPressure: De(i),
    tiltX: De(a),
    tiltY: De(l),
    twist: De(d),
    pointerType: String(u),
    isPrimary: !!p,
  });
}
s($O, 'initPointerEvent');
function qO(e, t, r, n = !1) {
  (RO(t) || PO(t)) && (r = { ...r, ...this.system.getUIEventModifiers() });
  const o = vh(t, e, r);
  return Th.call(this, e, o, n);
}
s(qO, 'dispatchUIEvent');
function Th(e, t, r = !1) {
  var n;
  const o = t.type,
    i = r ? () => {} : (n = rn[o]) === null || n === void 0 ? void 0 : n.call(rn, t, e, this);
  if (i) {
    t.preventDefault();
    let a = !1;
    return (
      Object.defineProperty(t, 'defaultPrevented', { get: s(() => a, 'get') }),
      Object.defineProperty(t, 'preventDefault', {
        value: s(() => {
          a = t.cancelable;
        }, 'value'),
      }),
      Mn(() => e.dispatchEvent(t)),
      a || i(),
      !a
    );
  }
  return Mn(() => e.dispatchEvent(t));
}
s(Th, 'dispatchEvent');
function Jr(e, t, r) {
  const n = vh(t, e, r);
  Mn(() => e.dispatchEvent(n));
}
s(Jr, 'dispatchDOMEvent');
var Ob = Symbol('patched focus/blur methods');
function Eh(e) {
  if (e.prototype[Ob]) return;
  const { focus: t, blur: r } = e.prototype;
  Object.defineProperties(e.prototype, {
    focus: { configurable: !0, get: s(() => o, 'get') },
    blur: { configurable: !0, get: s(() => i, 'get') },
    [Ob]: { configurable: !0, get: s(() => ({ focus: t, blur: r }), 'get') },
  });
  let n;
  function o(a) {
    if (this.ownerDocument.visibilityState !== 'hidden') return t.call(this, a);
    const l = rp(this.ownerDocument);
    if (l === this) return;
    const d = Symbol('focus call');
    ((n = d),
      l &&
        (r.call(l),
        Jr(l, 'blur', { relatedTarget: this }),
        Jr(l, 'focusout', { relatedTarget: n === d ? this : null })),
      n === d && (t.call(this, a), Jr(this, 'focus', { relatedTarget: l })),
      n === d && Jr(this, 'focusin', { relatedTarget: l }));
  }
  s(o, 'patchedFocus');
  function i() {
    if (this.ownerDocument.visibilityState !== 'hidden') return r.call(this);
    const a = rp(this.ownerDocument);
    if (a !== this) return;
    ((n = Symbol('blur call')),
      r.call(this),
      Jr(a, 'blur', { relatedTarget: null }),
      Jr(a, 'focusout', { relatedTarget: null }));
  }
  s(i, 'patchedBlur');
}
s(Eh, 'patchFocus');
function rp(e) {
  const t = Ko(e);
  return t?.tagName === 'BODY' ? null : t;
}
s(rp, 'getActiveTarget');
var bu = Symbol('Interceptor for programmatical calls');
function En(e, t, r) {
  const n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    o = Object.getOwnPropertyDescriptor(e, t),
    i = n?.set ? 'set' : 'value';
  if (typeof n?.[i] != 'function' || n[i][bu])
    throw new Error(`Element ${e.tagName} does not implement "${String(t)}".`);
  function a(...l) {
    const { applyNative: d = !1, realArgs: u, then: p } = r.call(this, ...l),
      f = ((!d && o) || n)[i];
    (i === 'set' ? f.call(this, u) : f.call(this, ...u), p?.());
  }
  (s(a, 'intercept'), (a[bu] = bu), Object.defineProperty(e, t, { ...(o ?? n), [i]: a }));
}
s(En, 'prepareInterceptor');
function MO(e) {
  En(
    e,
    'value',
    s(function (r) {
      const n = Qx(r);
      return (
        n && pO(this),
        { applyNative: !!n, realArgs: jO(this, r), then: n ? void 0 : () => fO(this, String(r)) }
      );
    }, 'interceptorImpl'),
  );
}
s(MO, 'prepareValueInterceptor');
function jO(e, t) {
  return he(e, 'input', { type: 'number' }) && String(t) !== '' && !Number.isNaN(Number(t))
    ? String(Number(t))
    : String(t);
}
s(jO, 'sanitizeValue');
function kO(e) {
  (En(
    e,
    'setSelectionRange',
    s(function (r, ...n) {
      const o = Zx(r);
      return {
        applyNative: !!o,
        realArgs: [Number(r), ...n],
        then: s(() => (o ? void 0 : Gs(e)), 'then'),
      };
    }, 'interceptorImpl'),
  ),
    En(
      e,
      'selectionStart',
      s(function (r) {
        return { realArgs: r, then: s(() => Gs(e), 'then') };
      }, 'interceptorImpl'),
    ),
    En(
      e,
      'selectionEnd',
      s(function (r) {
        return { realArgs: r, then: s(() => Gs(e), 'then') };
      }, 'interceptorImpl'),
    ),
    En(
      e,
      'select',
      s(function () {
        return {
          realArgs: [],
          then: s(() => rO(e, { anchorOffset: 0, focusOffset: er(e).length }), 'then'),
        };
      }, 'interceptorImpl'),
    ));
}
s(kO, 'prepareSelectionInterceptor');
function DO(e) {
  En(
    e,
    'setRangeText',
    s(function (...r) {
      return {
        realArgs: r,
        then: s(() => {
          (jc(e), Gs(e));
        }, 'then'),
      };
    }, 'interceptorImpl'),
  );
}
s(DO, 'prepareRangeTextInterceptor');
var yo = Symbol('Node prepared with document state workarounds');
function wh(e) {
  e[yo] ||
    (e.addEventListener(
      'focus',
      (t) => {
        const r = t.target;
        np(r);
      },
      { capture: !0, passive: !0 },
    ),
    e.activeElement && np(e.activeElement),
    e.addEventListener(
      'blur',
      (t) => {
        const r = t.target,
          n = tO(r);
        n !== void 0 && (r.value !== n && Jr(r, 'change'), ph(r));
      },
      { capture: !0, passive: !0 },
    ),
    (e[yo] = yo));
}
s(wh, 'prepareDocument');
function np(e) {
  e[yo] || (he(e, ['input', 'textarea']) && (MO(e), kO(e), DO(e)), (e[yo] = yo));
}
s(np, 'prepareElement');
function LO(e) {
  return FO(e) ? e : e.ownerDocument;
}
s(LO, 'getDocumentFromNode');
function FO(e) {
  return e.nodeType === 9;
}
s(FO, 'isDocument');
var Nt = (function (e) {
  return ((e[(e.Trigger = 2)] = 'Trigger'), (e[(e.Call = 1)] = 'Call'), e);
})({});
function io(e, t) {
  e.levelRefs[t] = {};
}
s(io, 'setLevelRef');
function js(e, t) {
  return e.levelRefs[t];
}
s(js, 'getLevelRef');
function kn(e) {
  const t = e.delay;
  if (typeof t == 'number')
    return Promise.all([
      new Promise((r) => globalThis.setTimeout(() => r(), t)),
      e.advanceTimers(t),
    ]);
}
s(kn, 'wait');
var pa = (function (e) {
  return (
    (e[(e.EachTrigger = 4)] = 'EachTrigger'),
    (e[(e.EachApiCall = 2)] = 'EachApiCall'),
    (e[(e.EachTarget = 1)] = 'EachTarget'),
    (e[(e.Never = 0)] = 'Never'),
    e
  );
})({});
function Lr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(Lr, '_define_property');
var tr = (function (e) {
    return (
      (e[(e.STANDARD = 0)] = 'STANDARD'),
      (e[(e.LEFT = 1)] = 'LEFT'),
      (e[(e.RIGHT = 2)] = 'RIGHT'),
      (e[(e.NUMPAD = 3)] = 'NUMPAD'),
      e
    );
  })({}),
  xU = ['Alt', 'AltGraph', 'Control', 'Fn', 'Meta', 'Shift', 'Symbol'];
function op(e) {
  return xU.includes(e);
}
s(op, 'isModifierKey');
var OU = ['CapsLock', 'FnLock', 'NumLock', 'ScrollLock', 'SymbolLock'];
function sp(e) {
  return OU.includes(e);
}
s(sp, 'isModifierLock');
var BO = class {
  isKeyPressed(t) {
    return this.pressed.has(String(t.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((t) => t.keyDef);
  }
  async keydown(t, r) {
    const n = String(r.key),
      o = String(r.code),
      i = ua(t.config.document);
    (this.setKeydownTarget(i), this.pressed.add(o, r), op(n) && (this.modifiers[n] = !0));
    const a = t.dispatchUIEvent(i, 'keydown', { key: n, code: o });
    (sp(n) && !this.modifiers[n] && ((this.modifiers[n] = !0), (this.modifierLockStart[n] = !0)),
      a && this.pressed.setUnprevented(o),
      a &&
        this.hasKeyPress(n) &&
        t.dispatchUIEvent(ua(t.config.document), 'keypress', {
          key: n,
          code: o,
          charCode: r.key === 'Enter' ? 13 : String(r.key).charCodeAt(0),
        }));
  }
  async keyup(t, r) {
    const n = String(r.key),
      o = String(r.code),
      i = this.pressed.isUnprevented(o);
    (this.pressed.delete(o),
      op(n) && !this.pressed.values().find((a) => a.keyDef.key === n) && (this.modifiers[n] = !1),
      t.dispatchUIEvent(ua(t.config.document), 'keyup', { key: n, code: o }, !i),
      sp(n) &&
        this.modifiers[n] &&
        (this.modifierLockStart[n] ? (this.modifierLockStart[n] = !1) : (this.modifiers[n] = !1)));
  }
  setKeydownTarget(t) {
    (t !== this.lastKeydownTarget && (this.carryChar = ''), (this.lastKeydownTarget = t));
  }
  hasKeyPress(t) {
    return (t.length === 1 || t === 'Enter') && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(t) {
    (Lr(this, 'system', void 0),
      Lr(this, 'modifiers', {
        Alt: !1,
        AltGraph: !1,
        CapsLock: !1,
        Control: !1,
        Fn: !1,
        FnLock: !1,
        Meta: !1,
        NumLock: !1,
        ScrollLock: !1,
        Shift: !1,
        Symbol: !1,
        SymbolLock: !1,
      }),
      Lr(
        this,
        'pressed',
        new (class {
          add(r, n) {
            var o, i, a;
            ((a = (o = this.registry)[(i = r)]) !== null && a !== void 0) ||
              (o[i] = { keyDef: n, unpreventedDefault: !1 });
          }
          has(r) {
            return !!this.registry[r];
          }
          setUnprevented(r) {
            const n = this.registry[r];
            n && (n.unpreventedDefault = !0);
          }
          isUnprevented(r) {
            var n;
            return !!(!((n = this.registry[r]) === null || n === void 0) && n.unpreventedDefault);
          }
          delete(r) {
            delete this.registry[r];
          }
          values() {
            return Object.values(this.registry);
          }
          constructor() {
            Lr(this, 'registry', {});
          }
        })(),
      ),
      Lr(this, 'carryChar', ''),
      Lr(this, 'lastKeydownTarget', void 0),
      Lr(this, 'modifierLockStart', {}),
      (this.system = t));
  }
};
s(BO, 'KeyboardHost');
var CU = BO,
  IU = [
    ...'0123456789'.split('').map((e) => ({ code: `Digit${e}`, key: e })),
    ...')!@#$%^&*('.split('').map((e, t) => ({ code: `Digit${t}`, key: e, shiftKey: !0 })),
    ...'abcdefghijklmnopqrstuvwxyz'
      .split('')
      .map((e) => ({ code: `Key${e.toUpperCase()}`, key: e })),
    ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      .split('')
      .map((e) => ({ code: `Key${e}`, key: e, shiftKey: !0 })),
    { code: 'BracketLeft', key: '[' },
    { code: 'BracketLeft', key: '{', shiftKey: !0 },
    { code: 'BracketRight', key: ']' },
    { code: 'BracketRight', key: '}', shiftKey: !0 },
    { code: 'Space', key: ' ' },
    { code: 'AltLeft', key: 'Alt', location: tr.LEFT },
    { code: 'AltRight', key: 'Alt', location: tr.RIGHT },
    { code: 'ShiftLeft', key: 'Shift', location: tr.LEFT },
    { code: 'ShiftRight', key: 'Shift', location: tr.RIGHT },
    { code: 'ControlLeft', key: 'Control', location: tr.LEFT },
    { code: 'ControlRight', key: 'Control', location: tr.RIGHT },
    { code: 'MetaLeft', key: 'Meta', location: tr.LEFT },
    { code: 'MetaRight', key: 'Meta', location: tr.RIGHT },
    { code: 'OSLeft', key: 'OS', location: tr.LEFT },
    { code: 'OSRight', key: 'OS', location: tr.RIGHT },
    { code: 'ContextMenu', key: 'ContextMenu' },
    { code: 'Tab', key: 'Tab' },
    { code: 'CapsLock', key: 'CapsLock' },
    { code: 'Backspace', key: 'Backspace' },
    { code: 'Enter', key: 'Enter' },
    { code: 'Escape', key: 'Escape' },
    { code: 'ArrowUp', key: 'ArrowUp' },
    { code: 'ArrowDown', key: 'ArrowDown' },
    { code: 'ArrowLeft', key: 'ArrowLeft' },
    { code: 'ArrowRight', key: 'ArrowRight' },
    { code: 'Home', key: 'Home' },
    { code: 'End', key: 'End' },
    { code: 'Delete', key: 'Delete' },
    { code: 'PageUp', key: 'PageUp' },
    { code: 'PageDown', key: 'PageDown' },
    { code: 'Fn', key: 'Fn' },
    { code: 'Symbol', key: 'Symbol' },
    { code: 'AltRight', key: 'AltGraph' },
  ],
  NU = [
    { name: 'MouseLeft', pointerType: 'mouse', button: 'primary' },
    { name: 'MouseRight', pointerType: 'mouse', button: 'secondary' },
    { name: 'MouseMiddle', pointerType: 'mouse', button: 'auxiliary' },
    { name: 'TouchA', pointerType: 'touch' },
    { name: 'TouchB', pointerType: 'touch' },
    { name: 'TouchC', pointerType: 'touch' },
  ];
function JO(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(JO, '_define_property');
var UO = class {
  getButtons() {
    let t = 0;
    for (const r of Object.keys(this.pressed)) t |= 2 ** Number(r);
    return t;
  }
  down(t) {
    const r = rl(t.button);
    if (r in this.pressed) {
      this.pressed[r].push(t);
      return;
    }
    return ((this.pressed[r] = [t]), r);
  }
  up(t) {
    const r = rl(t.button);
    if (
      r in this.pressed &&
      ((this.pressed[r] = this.pressed[r].filter((n) => n.name !== t.name)),
      this.pressed[r].length === 0)
    )
      return (delete this.pressed[r], r);
  }
  constructor() {
    JO(this, 'pressed', {});
  }
};
s(UO, 'Buttons');
var VO = UO,
  Cb = { primary: 0, secondary: 1, auxiliary: 2, back: 3, X1: 3, forward: 4, X2: 4 };
function rl(e = 0) {
  return e in Cb ? Cb[e] : Number(e);
}
s(rl, 'getMouseButtonId');
var Ib = { 1: 2, 2: 1 };
function nl(e) {
  return ((e = rl(e)), e in Ib ? Ib[e] : e);
}
s(nl, 'getMouseEventButton');
function HO(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(HO, '_define_property');
var zO = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(t) {
    return this.pressedKeys.has(t.name);
  }
  addPressed(t) {
    return this.pressedKeys.add(t.name);
  }
  removePressed(t) {
    return this.pressedKeys.delete(t.name);
  }
  constructor() {
    HO(this, 'pressedKeys', new Set());
  }
};
s(zO, 'Device');
var $U = zO;
function ho(e, t) {
  const r = [];
  for (let i = e; i; i = i.parentElement) r.push(i);
  const n = [];
  for (let i = t; i; i = i.parentElement) n.push(i);
  let o = 0;
  for (; !(o >= r.length || o >= n.length || r[r.length - 1 - o] !== n[n.length - 1 - o]); o++);
  return [r.slice(0, r.length - o), n.slice(0, n.length - o), n.slice(n.length - o)];
}
s(ho, 'getTreeDiff');
function ol({ target: e, node: t, offset: r }) {
  return Zt(e)
    ? { node: e, offset: r ?? er(e).length }
    : t
      ? { node: t, offset: r ?? (t.nodeType === 3 ? t.nodeValue.length : t.childNodes.length) }
      : Sh(e, r);
}
s(ol, 'resolveCaretPosition');
function Sh(e, t, r = !0) {
  let n = t === void 0 ? e.childNodes.length - 1 : 0;
  const o = t === void 0 ? -1 : 1;
  for (
    ;
    t === void 0 ? n >= (r ? Math.max(e.childNodes.length - 1, 0) : 0) : n <= e.childNodes.length;

  ) {
    if (t && n === e.childNodes.length) throw new Error('The given offset is out of bounds.');
    const i = e.childNodes.item(n),
      a = String(i.textContent);
    if (a.length)
      if (t !== void 0 && a.length < t) t -= a.length;
      else {
        if (i.nodeType === 1) return Sh(i, t, !1);
        if (i.nodeType === 3) return { node: i, offset: t ?? i.nodeValue.length };
      }
    n += o;
  }
  return { node: e, offset: e.childNodes.length };
}
s(Sh, 'findNodeAtTextOffset');
function GO({ document: e, target: t, clickCount: r, node: n, offset: o }) {
  if (Kx(t)) return;
  const i = Zt(t),
    a = String(i ? er(t) : t.textContent),
    [l, d] = n ? [o, o] : WO(a, o, r);
  if (i)
    return (
      Wn(t, { anchorOffset: l ?? a.length, focusOffset: d ?? a.length }),
      { node: t, start: l ?? 0, end: d ?? a.length }
    );
  {
    const { node: u, offset: p } = ol({ target: t, node: n, offset: l }),
      { node: f, offset: m } = ol({ target: t, node: n, offset: d }),
      h = t.ownerDocument.createRange();
    try {
      (h.setStart(u, p), h.setEnd(f, m));
    } catch {
      throw new Error('The given offset is out of bounds.');
    }
    const g = e.getSelection();
    return (g?.removeAllRanges(), g?.addRange(h.cloneRange()), h);
  }
}
s(GO, 'setSelectionPerMouseDown');
function WO(e, t, r) {
  if (r % 3 === 1 || e.length === 0) return [t, t];
  const n = t ?? e.length;
  return r % 3 === 2
    ? [
        n - e.substr(0, t).match(/(\w+|\s+|\W)?$/)[0].length,
        t === void 0 ? t : t + e.substr(t).match(/^(\w+|\s+|\W)?/)[0].length,
      ]
    : [
        n - e.substr(0, t).match(/[^\r\n]*$/)[0].length,
        t === void 0 ? t : t + e.substr(t).match(/^[^\r\n]*/)[0].length,
      ];
}
s(WO, 'getTextRange');
function KO(e, { document: t, target: r, node: n, offset: o }) {
  const i = ol({ target: r, node: n, offset: o });
  if ('node' in e) {
    if (i.node === e.node) {
      const a = i.offset < e.start ? e.end : e.start,
        l = i.offset > e.end || i.offset < e.start ? i.offset : e.end;
      Wn(e.node, { anchorOffset: a, focusOffset: l });
    }
  } else {
    const a = e.cloneRange(),
      l = a.comparePoint(i.node, i.offset);
    l < 0 ? a.setStart(i.node, i.offset) : l > 0 && a.setEnd(i.node, i.offset);
    const d = t.getSelection();
    (d?.removeAllRanges(), d?.addRange(a.cloneRange()));
  }
}
s(KO, 'modifySelectionPerMouseMove');
function _h(e, t) {
  var r, n, o, i, a, l, d, u, p, f, m, h, g, v, E, b, S, R, I, $, x, A, w, _;
  return (
    e.target !== t.target ||
    ((r = e.coords) === null || r === void 0 ? void 0 : r.x) !==
      ((n = t.coords) === null || n === void 0 ? void 0 : n.x) ||
    ((o = e.coords) === null || o === void 0 ? void 0 : o.y) !==
      ((i = t.coords) === null || i === void 0 ? void 0 : i.y) ||
    ((a = e.coords) === null || a === void 0 ? void 0 : a.clientX) !==
      ((l = t.coords) === null || l === void 0 ? void 0 : l.clientX) ||
    ((d = e.coords) === null || d === void 0 ? void 0 : d.clientY) !==
      ((u = t.coords) === null || u === void 0 ? void 0 : u.clientY) ||
    ((p = e.coords) === null || p === void 0 ? void 0 : p.offsetX) !==
      ((f = t.coords) === null || f === void 0 ? void 0 : f.offsetX) ||
    ((m = e.coords) === null || m === void 0 ? void 0 : m.offsetY) !==
      ((h = t.coords) === null || h === void 0 ? void 0 : h.offsetY) ||
    ((g = e.coords) === null || g === void 0 ? void 0 : g.pageX) !==
      ((v = t.coords) === null || v === void 0 ? void 0 : v.pageX) ||
    ((E = e.coords) === null || E === void 0 ? void 0 : E.pageY) !==
      ((b = t.coords) === null || b === void 0 ? void 0 : b.pageY) ||
    ((S = e.coords) === null || S === void 0 ? void 0 : S.screenX) !==
      ((R = t.coords) === null || R === void 0 ? void 0 : R.screenX) ||
    ((I = e.coords) === null || I === void 0 ? void 0 : I.screenY) !==
      (($ = t.coords) === null || $ === void 0 ? void 0 : $.screenY) ||
    ((x = e.caret) === null || x === void 0 ? void 0 : x.node) !==
      ((A = t.caret) === null || A === void 0 ? void 0 : A.node) ||
    ((w = e.caret) === null || w === void 0 ? void 0 : w.offset) !==
      ((_ = t.caret) === null || _ === void 0 ? void 0 : _.offset)
  );
}
s(_h, 'isDifferentPointerPosition');
function Fr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(Fr, '_define_property');
var YO = class {
  move(t, r, n) {
    const o = this.position,
      i = this.getTarget(t);
    if (((this.position = r), !_h(o, r))) return;
    const a = this.getTarget(t),
      l = this.getEventInit('mousemove'),
      [d, u] = ho(i, a);
    return {
      leave: s(() => {
        i !== a &&
          (t.dispatchUIEvent(i, 'mouseout', l),
          d.forEach((p) => t.dispatchUIEvent(p, 'mouseleave', l)));
      }, 'leave'),
      enter: s(() => {
        i !== a &&
          (t.dispatchUIEvent(a, 'mouseover', l),
          u.forEach((p) => t.dispatchUIEvent(p, 'mouseenter', l)));
      }, 'enter'),
      move: s(() => {
        n || (t.dispatchUIEvent(a, 'mousemove', l), this.modifySelecting(t));
      }, 'move'),
    };
  }
  down(t, r, n) {
    const o = this.buttons.down(r);
    if (o === void 0) return;
    const i = this.getTarget(t);
    this.buttonDownTarget[o] = i;
    const a = this.getEventInit('mousedown', r.button),
      l = dr(i);
    (!n && (l || t.dispatchUIEvent(i, 'mousedown', a)) && (this.startSelecting(t, a.detail), $r(i)),
      !l &&
        nl(r.button) === 2 &&
        t.dispatchUIEvent(i, 'contextmenu', this.getEventInit('contextmenu', r.button)));
  }
  up(t, r, n) {
    const o = this.buttons.up(r);
    if (o === void 0) return;
    const i = this.getTarget(t);
    if (!dr(i)) {
      if (!n) {
        const l = this.getEventInit('mouseup', r.button);
        (t.dispatchUIEvent(i, 'mouseup', l), this.endSelecting());
      }
      const a = ho(this.buttonDownTarget[o], i)[2][0];
      if (a) {
        const l = this.getEventInit('click', r.button);
        l.detail &&
          (t.dispatchUIEvent(a, l.button === 0 ? 'click' : 'auxclick', l),
          l.button === 0 &&
            l.detail === 2 &&
            t.dispatchUIEvent(a, 'dblclick', {
              ...this.getEventInit('dblclick', r.button),
              detail: l.detail,
            }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(t, r) {
    const n = { ...this.position.coords };
    return (
      (n.button = nl(r)),
      (n.buttons = this.buttons.getButtons()),
      t === 'mousedown'
        ? (n.detail = this.clickCount.getOnDown(n.button))
        : t === 'mouseup'
          ? (n.detail = this.clickCount.getOnUp(n.button))
          : (t === 'click' || t === 'auxclick') &&
            (n.detail = this.clickCount.incOnClick(n.button)),
      n
    );
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  startSelecting(t, r) {
    var n, o;
    this.selecting = GO({
      document: t.config.document,
      target: this.getTarget(t),
      node: (n = this.position.caret) === null || n === void 0 ? void 0 : n.node,
      offset: (o = this.position.caret) === null || o === void 0 ? void 0 : o.offset,
      clickCount: r,
    });
  }
  modifySelecting(t) {
    var r, n;
    this.selecting &&
      KO(this.selecting, {
        document: t.config.document,
        target: this.getTarget(t),
        node: (r = this.position.caret) === null || r === void 0 ? void 0 : r.node,
        offset: (n = this.position.caret) === null || n === void 0 ? void 0 : n.offset,
      });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    (Fr(this, 'position', {}),
      Fr(this, 'buttons', new VO()),
      Fr(this, 'selecting', void 0),
      Fr(this, 'buttonDownTarget', {}),
      Fr(
        this,
        'clickCount',
        new (class {
          incOnClick(t) {
            const r = this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
            return (
              (this.count = this.count[t] === void 0 ? {} : { [t]: Number(this.count[t]) + 1 }),
              r
            );
          }
          getOnDown(t) {
            var r;
            this.down = { [t]: (r = this.count[t]) !== null && r !== void 0 ? r : 0 };
            var n;
            return (
              (this.count = { [t]: (n = this.count[t]) !== null && n !== void 0 ? n : 0 }),
              Number(this.count[t]) + 1
            );
          }
          getOnUp(t) {
            return this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
          }
          reset() {
            this.count = {};
          }
          constructor() {
            (Fr(this, 'down', {}), Fr(this, 'count', {}));
          }
        })(),
      ));
  }
};
s(YO, 'Mouse');
var qU = YO;
function hi(e, t) {
  var r;
  return ((r = Ah(e, t)) === null || r === void 0 ? void 0 : r.pointerEvents) !== 'none';
}
s(hi, 'hasPointerEvents');
function XO(e) {
  const t = jt(e);
  for (let r = e, n = []; r?.ownerDocument; r = r.parentElement) {
    n.push(r);
    const o = t.getComputedStyle(r).pointerEvents;
    if (o && !['inherit', 'unset'].includes(o)) return { pointerEvents: o, tree: n };
  }
}
s(XO, 'closestPointerEventsDeclaration');
var Nb = Symbol('Last check for pointer-events');
function Ah(e, t) {
  const r = t[Nb];
  if (
    !(
      e.config.pointerEventsCheck !== pa.Never &&
      (!r ||
        (ip(e.config.pointerEventsCheck, pa.EachApiCall) && r[Nt.Call] !== js(e, Nt.Call)) ||
        (ip(e.config.pointerEventsCheck, pa.EachTrigger) && r[Nt.Trigger] !== js(e, Nt.Trigger)))
    )
  )
    return r?.result;
  const o = XO(t);
  return ((t[Nb] = { [Nt.Call]: js(e, Nt.Call), [Nt.Trigger]: js(e, Nt.Trigger), result: o }), o);
}
s(Ah, 'checkPointerEvents');
function ao(e, t) {
  const r = Ah(e, t);
  if (r?.pointerEvents === 'none')
    throw new Error(
      [
        `Unable to perform pointer interaction as the element ${r.tree.length > 1 ? 'inherits' : 'has'} \`pointer-events: none\`:`,
        '',
        QO(r.tree),
      ].join(`
`),
    );
}
s(ao, 'assertPointerEvents');
function QO(e) {
  return e
    .reverse()
    .map((t, r) =>
      [
        ''.padEnd(r),
        t.tagName,
        t.id && `#${t.id}`,
        t.hasAttribute('data-testid') && `(testId=${t.getAttribute('data-testid')})`,
        ZO(t),
        e.length > 1 && r === 0 && '  <-- This element declared `pointer-events: none`',
        e.length > 1 && r === e.length - 1 && '  <-- Asserted pointer events here',
      ]
        .filter(Boolean)
        .join(''),
    ).join(`
`);
}
s(QO, 'printTree');
function ZO(e) {
  var t;
  let r;
  if (e.hasAttribute('aria-label')) r = e.getAttribute('aria-label');
  else if (e.hasAttribute('aria-labelledby')) {
    var n, o;
    r =
      (o = e.ownerDocument.getElementById(e.getAttribute('aria-labelledby'))) === null ||
      o === void 0 ||
      (n = o.textContent) === null ||
      n === void 0
        ? void 0
        : n.trim();
  } else if (
    he(e, ['button', 'input', 'meter', 'output', 'progress', 'select', 'textarea']) &&
    !((t = e.labels) === null || t === void 0) &&
    t.length
  )
    r = Array.from(e.labels)
      .map((a) => {
        var l;
        return (l = a.textContent) === null || l === void 0 ? void 0 : l.trim();
      })
      .join('|');
  else if (he(e, 'button')) {
    var i;
    r = (i = e.textContent) === null || i === void 0 ? void 0 : i.trim();
  }
  return (
    (r = r?.replace(/\n/g, '  ')),
    Number(r?.length) > 30 && (r = `${r?.substring(0, 29)}`),
    r ? `(label=${r})` : ''
  );
}
s(ZO, 'getLabelDescr');
function ip(e, t) {
  return (e & t) > 0;
}
s(ip, 'hasBitFlag');
function or(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(or, '_define_property');
var eC = class {
  init(t) {
    const r = this.getTarget(t),
      [, n] = ho(null, r),
      o = this.getEventInit();
    return (
      ao(t, r),
      t.dispatchUIEvent(r, 'pointerover', o),
      n.forEach((i) => t.dispatchUIEvent(i, 'pointerenter', o)),
      this
    );
  }
  move(t, r) {
    const n = this.position,
      o = this.getTarget(t);
    if (((this.position = r), !_h(n, r))) return;
    const i = this.getTarget(t),
      a = this.getEventInit(-1),
      [l, d] = ho(o, i);
    return {
      leave: s(() => {
        hi(t, o) &&
          o !== i &&
          (t.dispatchUIEvent(o, 'pointerout', a),
          l.forEach((u) => t.dispatchUIEvent(u, 'pointerleave', a)));
      }, 'leave'),
      enter: s(() => {
        (ao(t, i),
          o !== i &&
            (t.dispatchUIEvent(i, 'pointerover', a),
            d.forEach((u) => t.dispatchUIEvent(u, 'pointerenter', a))));
      }, 'enter'),
      move: s(() => {
        t.dispatchUIEvent(i, 'pointermove', a);
      }, 'move'),
    };
  }
  down(t, r = 0) {
    if (this.isDown) return;
    const n = this.getTarget(t);
    (ao(t, n),
      (this.isDown = !0),
      (this.isPrevented = !t.dispatchUIEvent(n, 'pointerdown', this.getEventInit(r))));
  }
  up(t, r = 0) {
    if (!this.isDown) return;
    const n = this.getTarget(t);
    (ao(t, n),
      (this.isPrevented = !1),
      (this.isDown = !1),
      t.dispatchUIEvent(n, 'pointerup', this.getEventInit(r)));
  }
  release(t) {
    const r = this.getTarget(t),
      [n] = ho(r, null),
      o = this.getEventInit();
    (hi(t, r) &&
      (t.dispatchUIEvent(r, 'pointerout', o),
      n.forEach((i) => t.dispatchUIEvent(i, 'pointerleave', o))),
      (this.isCancelled = !0));
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  getEventInit(t) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: nl(t),
      buttons: this.buttons.getButtons(),
    };
  }
  constructor({ pointerId: t, pointerType: r, isPrimary: n }, o) {
    (or(this, 'pointerId', void 0),
      or(this, 'pointerType', void 0),
      or(this, 'isPrimary', void 0),
      or(this, 'buttons', void 0),
      or(this, 'isMultitouch', !1),
      or(this, 'isCancelled', !1),
      or(this, 'isDown', !1),
      or(this, 'isPrevented', !1),
      or(this, 'position', {}),
      (this.pointerId = t),
      (this.pointerType = r),
      (this.isPrimary = n),
      (this.isMultitouch = !n),
      (this.buttons = o));
  }
};
s(eC, 'Pointer');
var MU = eC;
function Sr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(Sr, '_define_property');
var tC = class {
  isKeyPressed(t) {
    return this.devices.get(t.pointerType).isPressed(t);
  }
  async press(t, r, n) {
    (this.devices.get(r.pointerType).addPressed(r), this.buttons.down(r));
    const o = this.getPointerName(r),
      i =
        r.pointerType === 'touch'
          ? this.pointers.new(o, r.pointerType, this.buttons)
          : this.pointers.get(o);
    ((i.position = n),
      i.pointerType !== 'touch' && (this.mouse.position = n),
      i.pointerType === 'touch' && i.init(t),
      i.down(t, r.button),
      i.pointerType !== 'touch' && this.mouse.down(t, r, i.isPrevented));
  }
  async move(t, r, n) {
    const o = this.pointers.get(r),
      i = o.move(t, n),
      a = o.pointerType === 'touch' ? void 0 : this.mouse.move(t, n, o.isPrevented);
    (i?.leave(), a?.leave(), i?.enter(), a?.enter(), i?.move(), a?.move());
  }
  async release(t, r, n) {
    const o = this.devices.get(r.pointerType);
    (o.removePressed(r), this.buttons.up(r));
    const i = this.pointers.get(this.getPointerName(r)),
      a = i.isPrevented;
    if (
      ((i.position = n),
      i.pointerType !== 'touch' && (this.mouse.position = n),
      o.countPressed === 0 && i.up(t, r.button),
      i.pointerType === 'touch' && i.release(t),
      i.pointerType === 'touch' && !i.isMultitouch)
    ) {
      const l = this.mouse.move(t, n, a);
      (l?.leave(), l?.enter(), l?.move(), this.mouse.down(t, r, a));
    }
    if (!i.isMultitouch) {
      const l = this.mouse.move(t, n, a);
      (l?.leave(), l?.enter(), l?.move(), this.mouse.up(t, r, a));
    }
  }
  getPointerName(t) {
    return t.pointerType === 'touch' ? t.name : t.pointerType;
  }
  getPreviousPosition(t) {
    return this.pointers.has(t) ? this.pointers.get(t).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(t) {
    var r;
    return (r = this.mouse.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  setMousePosition(t) {
    ((this.mouse.position = t), (this.pointers.get('mouse').position = t));
  }
  constructor(t) {
    (Sr(this, 'system', void 0),
      Sr(this, 'mouse', void 0),
      Sr(this, 'buttons', void 0),
      Sr(
        this,
        'devices',
        new (class {
          get(r) {
            var n, o, i;
            return (i = (n = this.registry)[(o = r)]) !== null && i !== void 0
              ? i
              : (n[o] = new $U());
          }
          constructor() {
            Sr(this, 'registry', {});
          }
        })(),
      ),
      Sr(
        this,
        'pointers',
        new (class {
          new(r, n, o) {
            const i =
              n !== 'touch' ||
              !Object.values(this.registry).some(
                (a) => a.pointerType === 'touch' && !a.isCancelled,
              );
            return (
              i ||
                Object.values(this.registry).forEach((a) => {
                  a.pointerType === n && !a.isCancelled && (a.isMultitouch = !0);
                }),
              (this.registry[r] = new MU(
                { pointerId: this.nextId++, pointerType: n, isPrimary: i },
                o,
              )),
              this.registry[r]
            );
          }
          get(r) {
            if (!this.has(r))
              throw new Error(`Trying to access pointer "${r}" which does not exist.`);
            return this.registry[r];
          }
          has(r) {
            return r in this.registry;
          }
          constructor() {
            (Sr(this, 'registry', {}), Sr(this, 'nextId', 1));
          }
        })(),
      ),
      (this.system = t),
      (this.buttons = new VO()),
      (this.mouse = new qU()),
      this.pointers.new('mouse', 'mouse', this.buttons));
  }
};
s(tC, 'PointerHost');
var jU = tC;
function ap(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
s(ap, '_define_property');
var rC = class {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock,
    };
  }
  constructor() {
    (ap(this, 'keyboard', new CU(this)), ap(this, 'pointer', new jU(this)));
  }
};
s(rC, 'System');
var nC = rC;
async function oC(e) {
  const t = [];
  return (
    this.config.skipHover || t.push({ target: e }),
    t.push({ keys: '[MouseLeft]', target: e }),
    this.pointer(t)
  );
}
s(oC, 'click');
async function sC(e) {
  return this.pointer([{ target: e }, '[MouseLeft][MouseLeft]']);
}
s(sC, 'dblClick');
async function iC(e) {
  return this.pointer([{ target: e }, '[MouseLeft][MouseLeft][MouseLeft]']);
}
s(iC, 'tripleClick');
async function aC(e) {
  return this.pointer({ target: e });
}
s(aC, 'hover');
async function lC(e) {
  return (
    ao(this, this.system.pointer.getMouseTarget(this)),
    this.pointer({ target: e.ownerDocument.body })
  );
}
s(lC, 'unhover');
async function cC({ shift: e } = {}) {
  return this.keyboard(
    e === !0 ? '{Shift>}{Tab}{/Shift}' : e === !1 ? '[/ShiftLeft][/ShiftRight]{Tab}' : '{Tab}',
  );
}
s(cC, 'tab');
var Rh = (function (e) {
  return ((e['{'] = '}'), (e['['] = ']'), e);
})(Rh || {});
function Ph(e, t) {
  let r = 0;
  const n = e[r] in Rh ? e[r] : '';
  r += n.length;
  const i = new RegExp(`^\\${n}{2}`).test(e) ? '' : n;
  return { type: i, ...(i === '' ? uC(e, r, t) : dC(e, r, i, t)) };
}
s(Ph, 'readNextDescriptor');
function uC(e, t, r) {
  const n = e[t];
  return (
    xh(n, e, t, r),
    (t += n.length),
    { consumedLength: t, descriptor: n, releasePrevious: !1, releaseSelf: !0, repeat: 1 }
  );
}
s(uC, 'readPrintableChar');
function dC(e, t, r, n) {
  var o, i;
  const a = e[t] === '/' ? '/' : '';
  t += a.length;
  const l = r === '{' && e[t] === '\\';
  t += Number(l);
  const d = l
    ? e[t]
    : (o = e.slice(t).match(r === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || o === void 0
      ? void 0
      : o[0];
  (xh(d, e, t, n), (t += d.length));
  var u;
  const p =
    (u = (i = e.slice(t).match(/^>\d+/)) === null || i === void 0 ? void 0 : i[0]) !== null &&
    u !== void 0
      ? u
      : '';
  t += p.length;
  const f = e[t] === '/' || (!p && e[t] === '>') ? e[t] : '';
  t += f.length;
  const m = Rh[r],
    h = e[t] === m ? m : '';
  if (!h)
    throw new Error(
      Oh(
        [!p && 'repeat modifier', !f && 'release modifier', `"${m}"`].filter(Boolean).join(' or '),
        e[t],
        e,
        n,
      ),
    );
  return (
    (t += h.length),
    {
      consumedLength: t,
      descriptor: d,
      releasePrevious: !!a,
      repeat: p ? Math.max(Number(p.substr(1)), 1) : 1,
      releaseSelf: pC(f, p),
    }
  );
}
s(dC, 'readTag');
function xh(e, t, r, n) {
  if (!e) throw new Error(Oh('key descriptor', t[r], t, n));
}
s(xh, 'assertDescriptor');
function pC(e, t) {
  if (e) return e === '/';
  if (t) return !1;
}
s(pC, 'hasReleaseSelf');
function Oh(e, t, r, n) {
  return `Expected ${e} but found "${t ?? ''}" in "${r}"
    See ${n === 'pointer' ? 'https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen' : 'https://testing-library.com/docs/user-event/keyboard'}
    for more information about how userEvent parses your input.`;
}
s(Oh, 'getErrorMessage');
function fC(e, t) {
  const r = [];
  do {
    const {
      type: o,
      descriptor: i,
      consumedLength: a,
      releasePrevious: l,
      releaseSelf: d = !0,
      repeat: u,
    } = Ph(t, 'keyboard');
    var n;
    const p =
      (n = e.find((f) => {
        if (o === '[') {
          var m;
          return (
            ((m = f.code) === null || m === void 0 ? void 0 : m.toLowerCase()) === i.toLowerCase()
          );
        } else if (o === '{') {
          var h;
          return (
            ((h = f.key) === null || h === void 0 ? void 0 : h.toLowerCase()) === i.toLowerCase()
          );
        }
        return f.key === i;
      })) !== null && n !== void 0
        ? n
        : { key: 'Unknown', code: 'Unknown', [o === '[' ? 'code' : 'key']: i };
    (r.push({ keyDef: p, releasePrevious: l, releaseSelf: d, repeat: u }), (t = t.slice(a)));
  } while (t);
  return r;
}
s(fC, 'parseKeyDef');
async function mC(e) {
  const t = fC(this.config.keyboardMap, e);
  for (let r = 0; r < t.length; r++) (await kn(this.config), await yC(this, t[r]));
}
s(mC, 'keyboard');
async function yC(e, { keyDef: t, releasePrevious: r, releaseSelf: n, repeat: o }) {
  const { system: i } = e;
  if ((i.keyboard.isKeyPressed(t) && (await i.keyboard.keyup(e, t)), !r)) {
    for (let a = 1; a <= o; a++) (await i.keyboard.keydown(e, t), a < o && (await kn(e.config)));
    n && (await i.keyboard.keyup(e, t));
  }
}
s(yC, 'keyboardAction');
async function hC(e) {
  for (const t of e.system.keyboard.getPressedKeys()) await e.system.keyboard.keyup(e, t);
}
s(hC, 'releaseAllKeys');
function Ch(e) {
  const t = Zt(e)
      ? { 'text/plain': gC(e) }
      : { 'text/plain': String(e.ownerDocument.getSelection()) },
    r = $c(jt(e));
  for (const n in t) t[n] && r.setData(n, t[n]);
  return r;
}
s(Ch, 'copySelection');
function gC(e) {
  const t = jo(e);
  return er(e).substring(t.startOffset, t.endOffset);
}
s(gC, 'readSelectedValueFromInput');
async function bC() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : e.body,
    n = Ch(r);
  if (n.items.length !== 0)
    return (
      this.dispatchUIEvent(r, 'copy', { clipboardData: n }) &&
        this.config.writeToClipboard &&
        (await lh(e, n)),
      n
    );
}
s(bC, 'copy');
async function vC() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : e.body,
    n = Ch(r);
  if (n.items.length !== 0)
    return (
      this.dispatchUIEvent(r, 'cut', { clipboardData: n }) &&
        this.config.writeToClipboard &&
        (await lh(r.ownerDocument, n)),
      n
    );
}
s(vC, 'cut');
async function TC(e) {
  const t = this.config.document;
  var r;
  const n = (r = t.activeElement) !== null && r !== void 0 ? r : t.body;
  var o;
  const i =
    (o = typeof e == 'string' ? EC(t, e) : e) !== null && o !== void 0
      ? o
      : await Jx(t).catch(() => {
          throw new Error(
            '`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.',
          );
        });
  this.dispatchUIEvent(n, 'paste', { clipboardData: i });
}
s(TC, 'paste');
function EC(e, t) {
  const r = $c(jt(e));
  return (r.setData('text', t), r);
}
s(EC, 'getClipboardDataFromString');
function lp(e, t) {
  const r = [];
  do {
    const {
        descriptor: n,
        consumedLength: o,
        releasePrevious: i,
        releaseSelf: a = !0,
      } = Ph(t, 'pointer'),
      l = e.find((d) => d.name === n);
    (l && r.push({ keyDef: l, releasePrevious: i, releaseSelf: a }), (t = t.slice(o)));
  } while (t);
  return r;
}
s(lp, 'parseKeyDef');
async function wC(e) {
  const { pointerMap: t } = this.config,
    r = [];
  (Array.isArray(e) ? e : [e]).forEach((n) => {
    typeof n == 'string'
      ? r.push(...lp(t, n))
      : 'keys' in n
        ? r.push(...lp(t, n.keys).map((o) => ({ ...n, ...o })))
        : r.push(n);
  });
  for (let n = 0; n < r.length; n++) (await kn(this.config), await SC(this, r[n]));
  this.system.pointer.resetClickCount();
}
s(wC, 'pointer');
async function SC(e, t) {
  var r, n;
  const o =
      'pointerName' in t && t.pointerName
        ? t.pointerName
        : 'keyDef' in t
          ? e.system.pointer.getPointerName(t.keyDef)
          : 'mouse',
    i = e.system.pointer.getPreviousPosition(o);
  var a, l, d, u;
  const p = {
    target: (a = t.target) !== null && a !== void 0 ? a : _C(e, i),
    coords: (l = t.coords) !== null && l !== void 0 ? l : i?.coords,
    caret: {
      node:
        (d = t.node) !== null && d !== void 0
          ? d
          : cp(t) || i == null || (r = i.caret) === null || r === void 0
            ? void 0
            : r.node,
      offset:
        (u = t.offset) !== null && u !== void 0
          ? u
          : cp(t) || i == null || (n = i.caret) === null || n === void 0
            ? void 0
            : n.offset,
    },
  };
  'keyDef' in t
    ? (e.system.pointer.isKeyPressed(t.keyDef) &&
        (io(e, Nt.Trigger), await e.system.pointer.release(e, t.keyDef, p)),
      t.releasePrevious ||
        (io(e, Nt.Trigger),
        await e.system.pointer.press(e, t.keyDef, p),
        t.releaseSelf && (io(e, Nt.Trigger), await e.system.pointer.release(e, t.keyDef, p))))
    : (io(e, Nt.Trigger), await e.system.pointer.move(e, o, p));
}
s(SC, 'pointerAction');
function cp(e) {
  var t, r;
  return !!((r = (t = e.target) !== null && t !== void 0 ? t : e.node) !== null && r !== void 0
    ? r
    : e.offset !== void 0);
}
s(cp, 'hasCaretPosition');
function _C(e, t) {
  if (!t) throw new Error('This pointer has no previous position. Provide a target property!');
  var r;
  return (r = t.target) !== null && r !== void 0 ? r : e.config.document.body;
}
s(_C, 'getPrevTarget');
async function AC(e) {
  if (!qn(e) || dr(e)) throw new Error('clear()` is only supported on editable elements.');
  if (($r(e), e.ownerDocument.activeElement !== e))
    throw new Error('The element to be cleared could not be focused.');
  if ((gh(e), !_O(e))) throw new Error('The element content to be cleared could not be selected.');
  jn(this, e, '', 'deleteContentBackward');
}
s(AC, 'clear');
async function RC(e, t) {
  return Ih.call(this, !0, e, t);
}
s(RC, 'selectOptions');
async function PC(e, t) {
  return Ih.call(this, !1, e, t);
}
s(PC, 'deselectOptions');
async function Ih(e, t, r) {
  if (!e && !t.multiple)
    throw Ee().getElementError(
      'Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.',
      t,
    );
  const n = Array.isArray(r) ? r : [r],
    o = Array.from(t.querySelectorAll('option, [role="option"]')),
    i = n
      .map((l) => {
        if (typeof l != 'string' && o.includes(l)) return l;
        {
          const d = o.find((u) => u.value === l || u.innerHTML === l);
          if (d) return d;
          throw Ee().getElementError(`Value "${String(l)}" not found in options`, t);
        }
      })
      .filter((l) => !dr(l));
  if (dr(t) || !i.length) return;
  const a = s((l) => {
    ((l.selected = e),
      this.dispatchUIEvent(t, 'input', { bubbles: !0, cancelable: !1, composed: !0 }),
      this.dispatchUIEvent(t, 'change'));
  }, 'selectOption');
  if (he(t, 'select'))
    if (t.multiple)
      for (const l of i) {
        const d = this.config.pointerEventsCheck === 0 ? !0 : hi(this, l);
        (d &&
          (this.dispatchUIEvent(l, 'pointerover'),
          this.dispatchUIEvent(t, 'pointerenter'),
          this.dispatchUIEvent(l, 'mouseover'),
          this.dispatchUIEvent(t, 'mouseenter'),
          this.dispatchUIEvent(l, 'pointermove'),
          this.dispatchUIEvent(l, 'mousemove'),
          this.dispatchUIEvent(l, 'pointerdown'),
          this.dispatchUIEvent(l, 'mousedown')),
          $r(t),
          d && (this.dispatchUIEvent(l, 'pointerup'), this.dispatchUIEvent(l, 'mouseup')),
          a(l),
          d && this.dispatchUIEvent(l, 'click'),
          await kn(this.config));
      }
    else if (i.length === 1) {
      const l = this.config.pointerEventsCheck === 0 ? !0 : hi(this, t);
      (l ? await this.click(t) : $r(t),
        a(i[0]),
        l &&
          (this.dispatchUIEvent(t, 'pointerover'),
          this.dispatchUIEvent(t, 'pointerenter'),
          this.dispatchUIEvent(t, 'mouseover'),
          this.dispatchUIEvent(t, 'mouseenter'),
          this.dispatchUIEvent(t, 'pointerup'),
          this.dispatchUIEvent(t, 'mouseup'),
          this.dispatchUIEvent(t, 'click')),
        await kn(this.config));
    } else throw Ee().getElementError('Cannot select multiple options on a non-multiple select', t);
  else if (t.getAttribute('role') === 'listbox')
    for (const l of i) (await this.click(l), await this.unhover(l));
  else
    throw Ee().getElementError(
      'Cannot select options on elements that are neither select nor listbox elements',
      t,
    );
}
s(Ih, 'selectOptionsBase');
async function xC(
  e,
  t,
  {
    skipClick: r = this.config.skipClick,
    skipAutoClose: n = this.config.skipAutoClose,
    initialSelectionStart: o,
    initialSelectionEnd: i,
  } = {},
) {
  e.disabled ||
    (r || (await this.click(e)),
    o !== void 0 && so(e, o, i ?? o),
    await this.keyboard(t),
    n || (await hC(this)));
}
s(xC, 'type');
var $b = Symbol('files and value properties are mocked');
function fa(e, t, r) {
  r ? Object.defineProperty(e, t, r) : delete e[t];
}
s(fa, 'restoreProperty');
function OC(e, t) {
  var r;
  (r = e[$b]) === null || r === void 0 || r.restore();
  const n = Object.getOwnPropertyDescriptor(e, 'type'),
    o = Object.getOwnPropertyDescriptor(e, 'value'),
    i = Object.getOwnPropertyDescriptor(e, 'files');
  function a() {
    (fa(e, 'type', n), fa(e, 'value', o), fa(e, 'files', i));
  }
  (s(a, 'restore'),
    (e[$b] = { restore: a }),
    Object.defineProperties(e, {
      files: { configurable: !0, get: s(() => t, 'get') },
      value: {
        configurable: !0,
        get: s(() => (t.length ? `C:\\fakepath\\${t[0].name}` : ''), 'get'),
        set(l) {
          if (l === '') a();
          else {
            var d;
            o == null || (d = o.set) === null || d === void 0 || d.call(e, l);
          }
        },
      },
      type: {
        configurable: !0,
        get: s(() => 'file', 'get'),
        set(l) {
          l !== 'file' && (a(), (e.type = l));
        },
      },
    }));
}
s(OC, 'setFiles');
async function CC(e, t) {
  const r = he(e, 'label') ? e.control : e;
  if (!r || !he(r, 'input', { type: 'file' }))
    throw new TypeError(
      `The ${r === e ? 'given' : 'associated'} ${r?.tagName} element does not accept file uploads`,
    );
  if (dr(e)) return;
  const n = (Array.isArray(t) ? t : [t])
      .filter((i) => !this.config.applyAccept || IC(i, r.accept))
      .slice(0, r.multiple ? void 0 : 1),
    o = s(() => {
      var i;
      (n.length === ((i = r.files) === null || i === void 0 ? void 0 : i.length) &&
        n.every((a, l) => {
          var d;
          return a === ((d = r.files) === null || d === void 0 ? void 0 : d.item(l));
        })) ||
        (OC(r, Nc(jt(e), n)), this.dispatchUIEvent(r, 'input'), this.dispatchUIEvent(r, 'change'));
    }, 'fileDialog');
  (r.addEventListener('fileDialog', o),
    await this.click(e),
    r.removeEventListener('fileDialog', o));
}
s(CC, 'upload');
function ks(e) {
  return e.toLowerCase().replace(/(\.|\/)jpg\b/g, '$1jpeg');
}
s(ks, 'normalize');
function IC(e, t) {
  if (!t) return !0;
  const r = ['audio/*', 'image/*', 'video/*'];
  return ks(t)
    .trim()
    .split(/\s*,\s*/)
    .some((n) =>
      n.startsWith('.')
        ? ks(e.name).endsWith(n)
        : r.includes(n)
          ? ks(e.type).startsWith(n.replace('*', ''))
          : ks(e.type) === n,
    );
}
s(IC, 'isAcceptableFile');
var qb = {
  click: oC,
  dblClick: sC,
  tripleClick: iC,
  hover: aC,
  unhover: lC,
  tab: cC,
  keyboard: mC,
  copy: bC,
  cut: vC,
  paste: TC,
  pointer: wC,
  clear: AC,
  deselectOptions: PC,
  selectOptions: RC,
  type: xC,
  upload: CC,
};
function NC(e) {
  return Ee().asyncWrapper(e);
}
s(NC, 'wrapAsync');
var $C = {
    applyAccept: !0,
    autoModify: !0,
    delay: 0,
    document: globalThis.document,
    keyboardMap: IU,
    pointerMap: NU,
    pointerEventsCheck: pa.EachApiCall,
    skipAutoClose: !1,
    skipClick: !1,
    skipHover: !1,
    writeToClipboard: !1,
    advanceTimers: s(() => Promise.resolve(), 'advanceTimers'),
  },
  kU = { ...$C, writeToClipboard: !0 };
function Nh(e = {}, t = kU, r) {
  const n = kC(e, r, t);
  return { ...t, ...e, document: n };
}
s(Nh, 'createConfig');
function qC(e = {}) {
  const t = Nh(e);
  (wh(t.document), Eh(jt(t.document).HTMLElement));
  var r;
  const n = (r = t.document.defaultView) !== null && r !== void 0 ? r : globalThis.window;
  return (Lx(n), Dc(t).api);
}
s(qC, 'setupMain');
function mt({ keyboardState: e, pointerState: t, ...r } = {}, n) {
  const o = Nh(r, $C, n);
  (wh(o.document), Eh(jt(o.document).HTMLElement));
  var i;
  const a = (i = t ?? e) !== null && i !== void 0 ? i : new nC();
  return { api: Dc(o, a).api, system: a };
}
s(mt, 'setupDirect');
function MC(e) {
  return Dc({ ...this.config, ...e }, this.system).api;
}
s(MC, 'setupSub');
function jC(e, t) {
  function r(...n) {
    return (io(e, Nt.Call), NC(() => t.apply(e, n).then(async (o) => (await kn(e.config), o))));
  }
  return (s(r, 'method'), Object.defineProperty(r, 'name', { get: s(() => t.name, 'get') }), r);
}
s(jC, 'wrapAndBindImpl');
function Dc(e, t = new nC()) {
  const r = {};
  return (
    Object.assign(r, {
      config: e,
      dispatchEvent: Th.bind(r),
      dispatchUIEvent: qO.bind(r),
      system: t,
      levelRefs: {},
      ...qb,
    }),
    {
      instance: r,
      api: {
        ...Object.fromEntries(Object.entries(qb).map(([n, o]) => [n, jC(r, o)])),
        setup: MC.bind(r),
      },
    }
  );
}
s(Dc, 'createInstance');
function kC(e, t, r) {
  var n, o;
  return (o = (n = e.document) !== null && n !== void 0 ? n : t && LO(t)) !== null && o !== void 0
    ? o
    : r.document;
}
s(kC, 'getDocument');
var DC = {};
Rt(DC, {
  clear: () => LC,
  click: () => FC,
  copy: () => BC,
  cut: () => JC,
  dblClick: () => UC,
  deselectOptions: () => VC,
  hover: () => HC,
  keyboard: () => zC,
  paste: () => WC,
  pointer: () => GC,
  selectOptions: () => KC,
  tab: () => eI,
  tripleClick: () => YC,
  type: () => XC,
  unhover: () => QC,
  upload: () => ZC,
});
function LC(e) {
  return mt().api.clear(e);
}
s(LC, 'clear');
function FC(e, t = {}) {
  return mt(t, e).api.click(e);
}
s(FC, 'click');
function BC(e = {}) {
  return mt(e).api.copy();
}
s(BC, 'copy');
function JC(e = {}) {
  return mt(e).api.cut();
}
s(JC, 'cut');
function UC(e, t = {}) {
  return mt(t).api.dblClick(e);
}
s(UC, 'dblClick');
function VC(e, t, r = {}) {
  return mt(r).api.deselectOptions(e, t);
}
s(VC, 'deselectOptions');
function HC(e, t = {}) {
  return mt(t).api.hover(e);
}
s(HC, 'hover');
async function zC(e, t = {}) {
  const { api: r, system: n } = mt(t);
  return r.keyboard(e).then(() => n);
}
s(zC, 'keyboard');
async function GC(e, t = {}) {
  const { api: r, system: n } = mt(t);
  return r.pointer(e).then(() => n);
}
s(GC, 'pointer');
function WC(e, t) {
  return mt(t).api.paste(e);
}
s(WC, 'paste');
function KC(e, t, r = {}) {
  return mt(r).api.selectOptions(e, t);
}
s(KC, 'selectOptions');
function YC(e, t = {}) {
  return mt(t).api.tripleClick(e);
}
s(YC, 'tripleClick');
function XC(e, t, r = {}) {
  return mt(r, e).api.type(e, t, r);
}
s(XC, 'type');
function QC(e, t = {}) {
  const { api: r, system: n } = mt(t);
  return (n.pointer.setMousePosition({ target: e }), r.unhover(e));
}
s(QC, 'unhover');
function ZC(e, t, r = {}) {
  return mt(r).api.upload(e, t);
}
s(ZC, 'upload');
function eI(e = {}) {
  return mt().api.tab(e);
}
s(eI, 'tab');
var tI = { ...DC, setup: qC },
  up = Fo(
    { ...pR },
    {
      getKeys: s((e) => Object.keys(e).filter((t) => t !== 'eventWrapper'), 'getKeys'),
      intercept: s(
        (e, t) => t[0] === 'fireEvent' || e.startsWith('find') || e.startsWith('waitFor'),
        'intercept',
      ),
    },
  );
up.screen = new Proxy(up.screen, {
  get(e, t, r) {
    return (
      typeof window < 'u' &&
        globalThis.location?.href?.includes('viewMode=docs') &&
        Ve.warn(ve`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `),
      Reflect.get(e, t, r)
    );
  },
});
var {
    buildQueries: DU,
    configure: LU,
    createEvent: FU,
    fireEvent: BU,
    findAllByAltText: JU,
    findAllByDisplayValue: UU,
    findAllByLabelText: VU,
    findAllByPlaceholderText: HU,
    findAllByRole: zU,
    findAllByTestId: GU,
    findAllByText: WU,
    findAllByTitle: KU,
    findByAltText: YU,
    findByDisplayValue: XU,
    findByLabelText: QU,
    findByPlaceholderText: ZU,
    findByRole: eV,
    findByTestId: tV,
    findByText: rV,
    findByTitle: nV,
    getAllByAltText: oV,
    getAllByDisplayValue: sV,
    getAllByLabelText: iV,
    getAllByPlaceholderText: aV,
    getAllByRole: lV,
    getAllByTestId: cV,
    getAllByText: uV,
    getAllByTitle: dV,
    getByAltText: pV,
    getByDisplayValue: fV,
    getByLabelText: mV,
    getByPlaceholderText: yV,
    getByRole: hV,
    getByTestId: gV,
    getByText: bV,
    getByTitle: vV,
    getConfig: TV,
    getDefaultNormalizer: EV,
    getElementError: wV,
    getNodeText: SV,
    getQueriesForElement: _V,
    getRoles: AV,
    getSuggestedQuery: RV,
    isInaccessible: PV,
    logDOM: xV,
    logRoles: OV,
    prettyDOM: CV,
    queries: IV,
    queryAllByAltText: NV,
    queryAllByAttribute: $V,
    queryAllByDisplayValue: qV,
    queryAllByLabelText: MV,
    queryAllByPlaceholderText: jV,
    queryAllByRole: kV,
    queryAllByTestId: DV,
    queryAllByText: LV,
    queryAllByTitle: FV,
    queryByAltText: BV,
    queryByAttribute: JV,
    queryByDisplayValue: UV,
    queryByLabelText: VV,
    queryByPlaceholderText: HV,
    queryByRole: zV,
    queryByTestId: GV,
    queryByText: WV,
    queryByTitle: KV,
    queryHelpers: YV,
    screen: XV,
    waitFor: QV,
    waitForElementToBeRemoved: ZV,
    within: rI,
    prettyFormat: eH,
  } = up,
  nI = tI,
  { userEvent: tH } = Fo(
    { userEvent: tI },
    {
      intercept: !0,
      getKeys: s((e) => Object.keys(e).filter((t) => t !== 'eventWrapper'), 'getKeys'),
    },
  ),
  { expect: rH } = Fo(
    { expect: cR },
    {
      getKeys: s((e, t) => {
        if ('constructor' in e && e.constructor === M) {
          const r = ['assert', '__methods', '__flags', '_obj'],
            n = Object.keys(Object.getPrototypeOf(e)).filter((o) => !r.includes(o));
          return t > 2 ? n : [...n, 'not'];
        }
        return 'any' in e ? Object.keys(e).filter((r) => r !== 'any') : Object.keys(e);
      }, 'getKeys'),
      mutate: !0,
      intercept: s((e) => e !== 'expect', 'intercept'),
    },
  ),
  nH = { mock: s(() => {}, 'mock') },
  Mb = !1,
  oH = s((e) => {
    const { parameters: t } = e;
    t?.actions?.disable ||
      Mb ||
      (Oy((r, n) => {
        const o = r.getMockName();
        o !== 'spy' &&
          o !== 'vi.fn()' &&
          (!/^next\/.*::/.test(o) ||
            [
              'next/router::useRouter()',
              'next/navigation::useRouter()',
              'next/navigation::redirect',
              'next/cache::',
              'next/headers::cookies().set',
              'next/headers::cookies().delete',
              'next/headers::headers().set',
              'next/headers::headers().delete',
            ].some((i) => o.startsWith(i))) &&
          Yo(o)(n);
      }),
      (Mb = !0));
  }, 'logActionsWhenMockCalled'),
  sH = [oH],
  jb = s(() => ({ ...Jw, ...Vw }), 'default'),
  sl = 'backgrounds',
  iH = { light: { name: 'light', value: '#F8F8F8' }, dark: { name: 'dark', value: '#333' } },
  { document: Yt } = globalThis,
  aH = s(
    () =>
      globalThis?.matchMedia
        ? !!globalThis.matchMedia('(prefers-reduced-motion: reduce)')?.matches
        : !1,
    'isReduceMotionEnabled',
  ),
  kb = s((e) => {
    (Array.isArray(e) ? e : [e]).forEach(lH);
  }, 'clearStyles'),
  lH = s((e) => {
    if (!Yt) return;
    const t = Yt.getElementById(e);
    t && t.parentElement && t.parentElement.removeChild(t);
  }, 'clearStyle'),
  cH = s((e, t) => {
    if (!Yt) return;
    const r = Yt.getElementById(e);
    if (r) r.innerHTML !== t && (r.innerHTML = t);
    else {
      const n = Yt.createElement('style');
      (n.setAttribute('id', e), (n.innerHTML = t), Yt.head.appendChild(n));
    }
  }, 'addGridStyle'),
  uH = s((e, t, r) => {
    if (!Yt) return;
    const n = Yt.getElementById(e);
    if (n) n.innerHTML !== t && (n.innerHTML = t);
    else {
      const o = Yt.createElement('style');
      (o.setAttribute('id', e), (o.innerHTML = t));
      const i = `addon-backgrounds-grid${r ? `-docs-${r}` : ''}`,
        a = Yt.getElementById(i);
      a ? a.parentElement?.insertBefore(o, a) : Yt.head.appendChild(o);
    }
  }, 'addBackgroundStyle'),
  dH = { cellSize: 100, cellAmount: 10, opacity: 0.8 },
  Db = 'addon-backgrounds',
  Lb = 'addon-backgrounds-grid',
  pH = aH() ? '' : 'transition: background-color 0.3s;',
  fH = s((e, t) => {
    const { globals: r = {}, parameters: n = {}, viewMode: o, id: i } = t,
      { options: a = iH, disable: l, grid: d = dH } = n[sl] || {},
      u = r[sl] || {},
      p = typeof u == 'string' ? u : u?.value,
      f = p ? a[p] : void 0,
      m = typeof f == 'string' ? f : f?.value || 'transparent',
      h = typeof u == 'string' ? !1 : u.grid || !1,
      g = !!f && !l,
      v = o === 'docs' ? `#anchor--${i} .docs-story` : '.sb-show-main',
      E = o === 'docs' ? `#anchor--${i} .docs-story` : '.sb-show-main',
      b = n.layout === void 0 || n.layout === 'padded',
      S = o === 'docs' ? 20 : b ? 16 : 0,
      { cellAmount: R, cellSize: I, opacity: $, offsetX: x = S, offsetY: A = S } = d,
      w = o === 'docs' ? `${Db}-docs-${i}` : `${Db}-color`,
      _ = o === 'docs' ? i : null;
    Zr(() => {
      const N = `
    ${v} {
      background: ${m} !important;
      ${pH}
      }`;
      if (!g) {
        kb(w);
        return;
      }
      uH(w, N, _);
    }, [v, w, _, g, m]);
    const j = o === 'docs' ? `${Lb}-docs-${i}` : `${Lb}`;
    return (
      Zr(() => {
        if (!h) {
          kb(j);
          return;
        }
        const N = [
            `${I * R}px ${I * R}px`,
            `${I * R}px ${I * R}px`,
            `${I}px ${I}px`,
            `${I}px ${I}px`,
          ].join(', '),
          V = `
        ${E} {
          background-size: ${N} !important;
          background-position: ${x}px ${A}px, ${x}px ${A}px, ${x}px ${A}px, ${x}px ${A}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${$}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${$}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${$ / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${$ / 2}) 1px, transparent 1px) !important;
        }
      `;
        cH(j, V);
      }, [R, I, E, j, h, x, A, $]),
      e()
    );
  }, 'withBackgroundAndGrid'),
  mH = globalThis.FEATURES?.backgrounds ? [fH] : [],
  yH = { [sl]: { grid: { cellSize: 20, opacity: 0.5, cellAmount: 5 }, disable: !1 } },
  hH = { [sl]: { value: void 0, grid: !1 } },
  Fb = s(() => ({ decorators: mH, parameters: yH, initialGlobals: hH }), 'default'),
  { step: gH } = Fo({ step: s(async (e, t, r) => t(r), 'step') }, { intercept: !0 }),
  Bb = s(() => ({ parameters: { throwPlayFunctionExceptions: !1 }, runStep: gH }), 'default'),
  Lc = 'storybook/highlight',
  bH = `${Lc}/add`,
  vH = `${Lc}/remove`,
  TH = `${Lc}/reset`,
  EH = `${Lc}/scroll-into-view`,
  Jb = 2147483647,
  Ur = 28,
  Ub = {
    chevronLeft: [
      'M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z',
    ],
    chevronRight: [
      'M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z',
    ],
    info: [
      'M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z',
      'M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z',
    ],
    shareAlt: [
      'M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z',
      'M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z',
    ],
  },
  wH = 'svg,path,rect,circle,line,polyline,polygon,ellipse,text'.split(','),
  rt = s((e, t = {}, r) => {
    const n = wH.includes(e)
      ? document.createElementNS('http://www.w3.org/2000/svg', e)
      : document.createElement(e);
    return (
      Object.entries(t).forEach(([o, i]) => {
        /[A-Z]/.test(o)
          ? (o === 'onClick' &&
              (n.addEventListener('click', i),
              n.addEventListener('keydown', (a) => {
                (a.key === 'Enter' || a.key === ' ') && (a.preventDefault(), i());
              })),
            o === 'onMouseEnter' && n.addEventListener('mouseenter', i),
            o === 'onMouseLeave' && n.addEventListener('mouseleave', i))
          : n.setAttribute(o, i);
      }),
      r?.forEach((o) => {
        if (!(o == null || o === !1))
          try {
            n.appendChild(o);
          } catch {
            n.appendChild(document.createTextNode(String(o)));
          }
      }),
      n
    );
  }, 'createElement'),
  Wi = s(
    (e) =>
      Ub[e] &&
      rt(
        'svg',
        { width: '14', height: '14', viewBox: '0 0 14 14', xmlns: 'http://www.w3.org/2000/svg' },
        Ub[e].map((t) =>
          rt('path', {
            fill: 'currentColor',
            'fill-rule': 'evenodd',
            'clip-rule': 'evenodd',
            d: t,
          }),
        ),
      ),
    'createIcon',
  ),
  SH = s((e) => {
    if ('elements' in e) {
      const { elements: n, color: o, style: i } = e;
      return {
        id: void 0,
        priority: 0,
        selectors: n,
        styles: {
          outline: `2px ${i} ${o}`,
          outlineOffset: '2px',
          boxShadow: '0 0 0 6px rgba(255,255,255,0.6)',
        },
        menu: void 0,
      };
    }
    const { menu: t, ...r } = e;
    return {
      id: void 0,
      priority: 0,
      styles: { outline: '2px dashed #029cfd' },
      ...r,
      menu: Array.isArray(t) ? (t.every(Array.isArray) ? t : [t]) : void 0,
    };
  }, 'normalizeOptions'),
  _H = s((e) => e instanceof Function, 'isFunction'),
  Ps = new Map(),
  yn = new Map(),
  Ki = new Map(),
  Tr = s((e) => {
    const t = Symbol();
    return (
      yn.set(t, []),
      Ps.set(t, e),
      {
        get: s(() => Ps.get(t), 'get'),
        set: s((a) => {
          const l = Ps.get(t),
            d = _H(a) ? a(l) : a;
          d !== l &&
            (Ps.set(t, d),
            yn.get(t)?.forEach((u) => {
              (Ki.get(u)?.(), Ki.set(u, u(d)));
            }));
        }, 'set'),
        subscribe: s(
          (a) => (
            yn.get(t)?.push(a),
            () => {
              const l = yn.get(t);
              l &&
                yn.set(
                  t,
                  l.filter((d) => d !== a),
                );
            }
          ),
          'subscribe',
        ),
        teardown: s(() => {
          (yn.get(t)?.forEach((a) => {
            (Ki.get(a)?.(), Ki.delete(a));
          }),
            yn.delete(t),
            Ps.delete(t));
        }, 'teardown'),
      }
    );
  }, 'useStore'),
  Vb = s((e) => {
    const t = document.getElementById('storybook-root'),
      r = new Map();
    for (const n of e) {
      const { priority: o = 0 } = n;
      for (const i of n.selectors) {
        const a = [
          ...document.querySelectorAll(
            `:is(${i}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`,
          ),
          ...(t?.querySelectorAll(i) || []),
        ];
        for (const l of a) {
          const d = r.get(l);
          (!d || d.priority <= o) &&
            r.set(l, {
              ...n,
              priority: o,
              selectors: Array.from(new Set((d?.selectors || []).concat(i))),
            });
        }
      }
    }
    return r;
  }, 'mapElements'),
  AH = s(
    (e) =>
      Array.from(e.entries())
        .map(([t, { selectors: r, styles: n, hoverStyles: o, focusStyles: i, menu: a }]) => {
          const { top: l, left: d, width: u, height: p } = t.getBoundingClientRect(),
            { position: f } = getComputedStyle(t);
          return {
            element: t,
            selectors: r,
            styles: n,
            hoverStyles: o,
            focusStyles: i,
            menu: a,
            top: f === 'fixed' ? l : l + window.scrollY,
            left: f === 'fixed' ? d : d + window.scrollX,
            width: u,
            height: p,
          };
        })
        .sort((t, r) => r.width * r.height - t.width * t.height),
    'mapBoxes',
  ),
  Hb = s((e, t) => {
    const r = e.getBoundingClientRect(),
      { x: n, y: o } = t;
    return (
      r?.top &&
      r?.left &&
      n >= r.left &&
      n <= r.left + r.width &&
      o >= r.top &&
      o <= r.top + r.height
    );
  }, 'isOverMenu'),
  zb = s((e, t, r) => {
    if (!t || !r) return !1;
    let { left: n, top: o, width: i, height: a } = e;
    (a < Ur && ((o = o - Math.round((Ur - a) / 2)), (a = Ur)),
      i < Ur && ((n = n - Math.round((Ur - i) / 2)), (i = Ur)),
      t.style.position === 'fixed' && ((n += window.scrollX), (o += window.scrollY)));
    const { x: l, y: d } = r;
    return l >= n && l <= n + i && d >= o && d <= o + a;
  }, 'isTargeted'),
  RH = s((e, t, r = {}) => {
    const { x: n, y: o } = t,
      { margin: i = 5, topOffset: a = 0, centered: l = !1 } = r,
      { scrollX: d, scrollY: u, innerHeight: p, innerWidth: f } = window,
      m = Math.min(e.style.position === 'fixed' ? o - u : o, p - e.clientHeight - i - a + u),
      h = l ? e.clientWidth / 2 : 0,
      g =
        e.style.position === 'fixed'
          ? Math.max(Math.min(n - d, f - h - i), h + i)
          : Math.max(Math.min(n, f - h - i + d), h + i + d);
    Object.assign(e.style, {
      ...(g !== n && { left: `${g}px` }),
      ...(m !== o && { top: `${m}px` }),
    });
  }, 'keepInViewport'),
  Gb = s((e) => {
    window.HTMLElement.prototype.hasOwnProperty('showPopover') && e.showPopover();
  }, 'showPopover'),
  PH = s((e) => {
    window.HTMLElement.prototype.hasOwnProperty('showPopover') && e.hidePopover();
  }, 'hidePopover'),
  xH = s(
    (e) => ({
      top: e.top,
      left: e.left,
      width: e.width,
      height: e.height,
      selectors: e.selectors,
      element: {
        attributes: Object.fromEntries(
          Array.from(e.element.attributes).map((t) => [t.name, t.value]),
        ),
        localName: e.element.localName,
        tagName: e.element.tagName,
        outerHTML: e.element.outerHTML,
      },
    }),
    'getEventDetails',
  ),
  qe = 'storybook-highlights-menu',
  Wb = 'storybook-highlights-root',
  OH = 'storybook-root',
  CH = s((e) => {
    if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED) return;
    globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
    const { document: t } = globalThis,
      r = Tr([]),
      n = Tr(new Map()),
      o = Tr([]),
      i = Tr(),
      a = Tr(),
      l = Tr([]),
      d = Tr([]),
      u = Tr(),
      p = Tr();
    let f = t.getElementById(Wb);
    (r.subscribe(() => {
      f || ((f = rt('div', { id: Wb })), t.body.appendChild(f));
    }),
      r.subscribe((A) => {
        const w = t.getElementById(OH);
        if (!w) return;
        n.set(Vb(A));
        const _ = new MutationObserver(() => n.set(Vb(A)));
        return (
          _.observe(w, { subtree: !0, childList: !0 }),
          () => {
            _.disconnect();
          }
        );
      }),
      n.subscribe((A) => {
        const w = s(() => requestAnimationFrame(() => o.set(AH(A))), 'updateBoxes'),
          _ = new ResizeObserver(w);
        (_.observe(t.body), Array.from(A.keys()).forEach((N) => _.observe(N)));
        const j = Array.from(t.body.querySelectorAll('*')).filter((N) => {
          const { overflow: V, overflowX: H, overflowY: P } = window.getComputedStyle(N);
          return ['auto', 'scroll'].some((D) => [V, H, P].includes(D));
        });
        return (
          j.forEach((N) => N.addEventListener('scroll', w)),
          () => {
            (_.disconnect(), j.forEach((N) => N.removeEventListener('scroll', w)));
          }
        );
      }),
      n.subscribe((A) => {
        const w = Array.from(A.keys()).filter(({ style: j }) => j.position === 'sticky'),
          _ = s(
            () =>
              requestAnimationFrame(() => {
                o.set((j) =>
                  j.map((N) => {
                    if (w.includes(N.element)) {
                      const { top: V, left: H } = N.element.getBoundingClientRect();
                      return { ...N, top: V + window.scrollY, left: H + window.scrollX };
                    }
                    return N;
                  }),
                );
              }),
            'updateBoxes',
          );
        return (t.addEventListener('scroll', _), () => t.removeEventListener('scroll', _));
      }),
      n.subscribe((A) => {
        l.set((w) => w.filter(({ element: _ }) => A.has(_)));
      }),
      l.subscribe((A) => {
        A.length
          ? (p.set((w) => (A.some((_) => _.element === w?.element) ? w : void 0)),
            u.set((w) => (A.some((_) => _.element === w?.element) ? w : void 0)))
          : (p.set(void 0), u.set(void 0), i.set(void 0));
      }));
    const m = new Map(new Map());
    r.subscribe((A) => {
      (A.forEach(({ keyframes: w }) => {
        if (w) {
          let _ = m.get(w);
          (_ ||
            ((_ = t.createElement('style')),
            _.setAttribute('data-highlight', 'keyframes'),
            m.set(w, _),
            t.head.appendChild(_)),
            (_.innerHTML = w));
        }
      }),
        m.forEach((w, _) => {
          A.some((j) => j.keyframes === _) || (w.remove(), m.delete(_));
        }));
    });
    const h = new Map(new Map());
    (o.subscribe((A) => {
      (A.forEach((w) => {
        let _ = h.get(w.element);
        if (f && !_) {
          const j = {
            popover: 'manual',
            'data-highlight-dimensions': `w${w.width.toFixed(0)}h${w.height.toFixed(0)}`,
            'data-highlight-coordinates': `x${w.left.toFixed(0)}y${w.top.toFixed(0)}`,
          };
          ((_ = f.appendChild(rt('div', j, [rt('div')]))), h.set(w.element, _));
        }
      }),
        h.forEach((w, _) => {
          A.some(({ element: j }) => j === _) || (w.remove(), h.delete(_));
        }));
    }),
      o.subscribe((A) => {
        const w = A.filter((j) => j.menu);
        if (!w.length) return;
        const _ = s((j) => {
          requestAnimationFrame(() => {
            const N = t.getElementById(qe),
              V = { x: j.pageX, y: j.pageY };
            if (N && !Hb(N, V)) {
              const H = w.filter((P) => {
                const D = h.get(P.element);
                return zb(P, D, V);
              });
              (i.set(H.length ? V : void 0), l.set(H));
            }
          });
        }, 'onClick');
        return (t.addEventListener('click', _), () => t.removeEventListener('click', _));
      }));
    const g = s(() => {
      const A = t.getElementById(qe),
        w = a.get();
      !w ||
        (A && Hb(A, w)) ||
        d.set((_) => {
          const j = o.get().filter((P) => {
              const D = h.get(P.element);
              return zb(P, D, w);
            }),
            N = _.filter((P) => j.includes(P)),
            V = j.filter((P) => !_.includes(P)),
            H = _.length - N.length;
          return V.length || H ? [...N, ...V] : _;
        });
    }, 'updateHovered');
    (a.subscribe(g), o.subscribe(g));
    const v = s(() => {
      const A = p.get(),
        w = A ? [A] : l.get(),
        _ = w.length === 1 ? w[0] : u.get(),
        j = i.get() !== void 0;
      o.get().forEach((N) => {
        const V = h.get(N.element);
        if (V) {
          const H = _ === N,
            P = j ? (_ ? H : w.includes(N)) : d.get()?.includes(N);
          (Object.assign(V.style, {
            animation: 'none',
            background: 'transparent',
            border: 'none',
            boxSizing: 'border-box',
            outline: 'none',
            outlineOffset: '0px',
            ...N.styles,
            ...(P ? N.hoverStyles : {}),
            ...(H ? N.focusStyles : {}),
            position: getComputedStyle(N.element).position === 'fixed' ? 'fixed' : 'absolute',
            zIndex: Jb - 10,
            top: `${N.top}px`,
            left: `${N.left}px`,
            width: `${N.width}px`,
            height: `${N.height}px`,
            margin: 0,
            padding: 0,
            cursor: N.menu && P ? 'pointer' : 'default',
            pointerEvents: N.menu ? 'auto' : 'none',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            overflow: 'visible',
          }),
            Object.assign(V.children[0].style, {
              width: '100%',
              height: '100%',
              minHeight: `${Ur}px`,
              minWidth: `${Ur}px`,
              boxSizing: 'content-box',
              padding: V.style.outlineWidth || '0px',
            }),
            Gb(V));
        }
      });
    }, 'updateBoxStyles');
    (o.subscribe(v), l.subscribe(v), d.subscribe(v), u.subscribe(v), p.subscribe(v));
    const E = s(() => {
      if (!f) return;
      let A = t.getElementById(qe);
      if (A) A.innerHTML = '';
      else {
        const N = { id: qe, popover: 'manual' };
        ((A = f.appendChild(rt('div', N))),
          f.appendChild(
            rt('style', {}, [
              `
            #${qe} {
              position: absolute;
              z-index: ${Jb};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${qe} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${qe} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${qe} li {
              padding: 0 4px;
              margin: 0;
            }
            #${qe} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${qe} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${qe} button:focus-visible {
              outline-color: #029CFD;
            }
            #${qe} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${qe} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${qe} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${qe} li > button:hover svg, #${qe} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${qe} .element-list li svg {
              display: none;
            }
            #${qe} li.selectable svg, #${qe} li.selected svg {
              display: block;
            }
            #${qe} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${qe} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${qe} .menu-items, #${qe} .menu-items li {
              padding: 0;
            }
            #${qe} .menu-item {
              display: flex;
            }
            #${qe} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `,
            ]),
          ));
      }
      const w = p.get(),
        _ = w ? [w] : l.get();
      if (
        (_.length &&
          ((A.style.position =
            getComputedStyle(_[0].element).position === 'fixed' ? 'fixed' : 'absolute'),
          A.appendChild(
            rt(
              'ul',
              { class: 'element-list' },
              _.map((N) => {
                const V =
                    _.length > 1 &&
                    !!N.menu?.some((D) =>
                      D.some(
                        (F) => !F.selectors || F.selectors.some((k) => N.selectors.includes(k)),
                      ),
                    ),
                  H = V
                    ? {
                        class: 'selectable',
                        onClick: s(() => p.set(N), 'onClick'),
                        onMouseEnter: s(() => u.set(N), 'onMouseEnter'),
                        onMouseLeave: s(() => u.set(void 0), 'onMouseLeave'),
                      }
                    : w
                      ? { class: 'selected', onClick: s(() => p.set(void 0), 'onClick') }
                      : {},
                  P = V || w;
                return rt('li', H, [
                  rt(P ? 'button' : 'div', P ? { type: 'button' } : {}, [
                    w ? Wi('chevronLeft') : null,
                    rt('code', {}, [N.element.outerHTML]),
                    V ? Wi('chevronRight') : null,
                  ]),
                ]);
              }),
            ),
          )),
        p.get() || l.get().length === 1)
      ) {
        const N = p.get() || l.get()[0],
          V = N.menu?.filter((H) =>
            H.some((P) => !P.selectors || P.selectors.some((D) => N.selectors.includes(D))),
          );
        V?.length &&
          A.appendChild(
            rt(
              'ul',
              { class: 'menu-list' },
              V.map((H) =>
                rt('li', {}, [
                  rt(
                    'ul',
                    { class: 'menu-items' },
                    H.map(
                      ({
                        id: P,
                        title: D,
                        description: F,
                        iconLeft: k,
                        iconRight: K,
                        clickEvent: X,
                      }) => {
                        const se = X && (() => e.emit(X, P, xH(N)));
                        return rt('li', {}, [
                          rt(
                            se ? 'button' : 'div',
                            se
                              ? { class: 'menu-item', type: 'button', onClick: se }
                              : { class: 'menu-item' },
                            [
                              k ? Wi(k) : null,
                              rt('div', { class: 'menu-item-content' }, [
                                rt(F ? 'strong' : 'span', {}, [D]),
                                F && rt('span', {}, [F]),
                              ]),
                              K ? Wi(K) : null,
                            ],
                          ),
                        ]);
                      },
                    ),
                  ),
                ]),
              ),
            ),
          );
      }
      const j = i.get();
      j
        ? (Object.assign(A.style, {
            display: 'block',
            left: `${A.style.position === 'fixed' ? j.x - window.scrollX : j.x}px`,
            top: `${A.style.position === 'fixed' ? j.y - window.scrollY : j.y}px`,
          }),
          Gb(A),
          requestAnimationFrame(() => RH(A, j, { topOffset: 15, centered: !0 })))
        : (PH(A), Object.assign(A.style, { display: 'none' }));
    }, 'renderMenu');
    (l.subscribe(E), p.subscribe(E));
    const b = s((A) => {
        const w = SH(A);
        r.set((_) => {
          const j = w.id ? _.filter((N) => N.id !== w.id) : _;
          return w.selectors?.length ? [...j, w] : j;
        });
      }, 'addHighlight'),
      S = s((A) => {
        A && r.set((w) => w.filter((_) => _.id !== A));
      }, 'removeHighlight'),
      R = s(() => {
        (r.set([]),
          n.set(new Map()),
          o.set([]),
          i.set(void 0),
          a.set(void 0),
          l.set([]),
          d.set([]),
          u.set(void 0),
          p.set(void 0));
      }, 'resetState');
    let I;
    const $ = s((A, w) => {
        const _ = 'scrollIntoView-highlight';
        (clearTimeout(I), S(_));
        const j = t.querySelector(A);
        if (!j) {
          console.warn(`Cannot scroll into view: ${A} not found`);
          return;
        }
        j.scrollIntoView({ behavior: 'smooth', block: 'center', ...w });
        const N = `kf-${Math.random().toString(36).substring(2, 15)}`;
        (r.set((V) => [
          ...V,
          {
            id: _,
            priority: 1e3,
            selectors: [A],
            styles: {
              outline: '2px solid #1EA7FD',
              outlineOffset: '-1px',
              animation: `${N} 3s linear forwards`,
            },
            keyframes: `@keyframes ${N} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`,
          },
        ]),
          (I = setTimeout(() => S(_), 3500)));
      }, 'scrollIntoView'),
      x = s((A) => {
        requestAnimationFrame(() => a.set({ x: A.pageX, y: A.pageY }));
      }, 'onMouseMove');
    (t.body.addEventListener('mousemove', x),
      e.on(bH, b),
      e.on(vH, S),
      e.on(TH, R),
      e.on(EH, $),
      e.on(On, ({ newPhase: A }) => {
        A === 'loading' && R();
      }));
  }, 'useHighlights');
globalThis?.FEATURES?.highlight && Ut?.ready && Ut.ready().then(CH);
var Kb = s(() => ({}), 'default'),
  IH = 'measureEnabled';
function $h() {
  const e = te.document.documentElement,
    t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
s($h, 'getDocumentWidthAndHeight');
function oI() {
  const e = te.document.createElement('canvas');
  e.id = 'storybook-addon-measure';
  const t = e.getContext('2d');
  lr(t != null);
  const { width: r, height: n } = $h();
  return (
    il(e, t, { width: r, height: n }),
    (e.style.position = 'absolute'),
    (e.style.left = '0'),
    (e.style.top = '0'),
    (e.style.zIndex = '2147483647'),
    (e.style.pointerEvents = 'none'),
    te.document.body.appendChild(e),
    { canvas: e, context: t, width: r, height: n }
  );
}
s(oI, 'createCanvas');
function il(e, t, { width: r, height: n }) {
  ((e.style.width = `${r}px`), (e.style.height = `${n}px`));
  const o = te.window.devicePixelRatio;
  ((e.width = Math.floor(r * o)), (e.height = Math.floor(n * o)), t.scale(o, o));
}
s(il, 'setCanvasWidthAndHeight');
var nt = {};
function sI() {
  nt.canvas || (nt = oI());
}
s(sI, 'init');
function qh() {
  nt.context && nt.context.clearRect(0, 0, nt.width ?? 0, nt.height ?? 0);
}
s(qh, 'clear');
function iI(e) {
  (qh(), e(nt.context));
}
s(iI, 'draw');
function aI() {
  (lr(nt.canvas), lr(nt.context), il(nt.canvas, nt.context, { width: 0, height: 0 }));
  const { width: e, height: t } = $h();
  (il(nt.canvas, nt.context, { width: e, height: t }), (nt.width = e), (nt.height = t));
}
s(aI, 'rescale');
function lI() {
  nt.canvas && (qh(), nt.canvas.parentNode?.removeChild(nt.canvas), (nt = {}));
}
s(lI, 'destroy');
var Xn = {
    margin: '#f6b26b',
    border: '#ffe599',
    padding: '#93c47d',
    content: '#6fa8dc',
    text: '#232020',
  },
  Cr = 6;
function dp(e, { x: t, y: r, w: n, h: o, r: i }) {
  ((t = t - n / 2),
    (r = r - o / 2),
    n < 2 * i && (i = n / 2),
    o < 2 * i && (i = o / 2),
    e.beginPath(),
    e.moveTo(t + i, r),
    e.arcTo(t + n, r, t + n, r + o, i),
    e.arcTo(t + n, r + o, t, r + o, i),
    e.arcTo(t, r + o, t, r, i),
    e.arcTo(t, r, t + n, r, i),
    e.closePath());
}
s(dp, 'roundedRect');
function cI(e, { padding: t, border: r, width: n, height: o, top: i, left: a }) {
  const l = n - r.left - r.right - t.left - t.right,
    d = o - t.top - t.bottom - r.top - r.bottom;
  let u = a + r.left + t.left,
    p = i + r.top + t.top;
  return (
    e === 'top'
      ? (u += l / 2)
      : e === 'right'
        ? ((u += l), (p += d / 2))
        : e === 'bottom'
          ? ((u += l / 2), (p += d))
          : e === 'left'
            ? (p += d / 2)
            : e === 'center' && ((u += l / 2), (p += d / 2)),
    { x: u, y: p }
  );
}
s(cI, 'positionCoordinate');
function uI(e, t, { margin: r, border: n, padding: o }, i, a) {
  let l = s((m) => 0, 'shift'),
    d = 0,
    u = 0;
  const p = a ? 1 : 0.5,
    f = a ? i * 2 : 0;
  return (
    e === 'padding'
      ? (l = s((m) => o[m] * p + f, 'shift'))
      : e === 'border'
        ? (l = s((m) => o[m] + n[m] * p + f, 'shift'))
        : e === 'margin' && (l = s((m) => o[m] + n[m] + r[m] * p + f, 'shift')),
    t === 'top'
      ? (u = -l('top'))
      : t === 'right'
        ? (d = l('right'))
        : t === 'bottom'
          ? (u = l('bottom'))
          : t === 'left' && (d = -l('left')),
    { offsetX: d, offsetY: u }
  );
}
s(uI, 'offset');
function dI(e, t) {
  return (
    Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2
  );
}
s(dI, 'collide');
function pI(e, t, r) {
  return (
    e === 'top'
      ? (t.y = r.y - r.h - Cr)
      : e === 'right'
        ? (t.x = r.x + r.w / 2 + Cr + t.w / 2)
        : e === 'bottom'
          ? (t.y = r.y + r.h + Cr)
          : e === 'left' && (t.x = r.x - r.w / 2 - Cr - t.w / 2),
    { x: t.x, y: t.y }
  );
}
s(pI, 'overlapAdjustment');
function Mh(e, t, { x: r, y: n, w: o, h: i }, a) {
  return (
    dp(e, { x: r, y: n, w: o, h: i, r: 3 }),
    (e.fillStyle = `${Xn[t]}dd`),
    e.fill(),
    (e.strokeStyle = Xn[t]),
    e.stroke(),
    (e.fillStyle = Xn.text),
    e.fillText(a, r, n),
    dp(e, { x: r, y: n, w: o, h: i, r: 3 }),
    (e.fillStyle = `${Xn[t]}dd`),
    e.fill(),
    (e.strokeStyle = Xn[t]),
    e.stroke(),
    (e.fillStyle = Xn.text),
    e.fillText(a, r, n),
    { x: r, y: n, w: o, h: i }
  );
}
s(Mh, 'textWithRect');
function jh(e, t) {
  ((e.font = '600 12px monospace'), (e.textBaseline = 'middle'), (e.textAlign = 'center'));
  const r = e.measureText(t),
    n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent,
    o = r.width + Cr * 2,
    i = n + Cr * 2;
  return { w: o, h: i };
}
s(jh, 'configureText');
function fI(e, t, { type: r, position: n = 'center', text: o }, i, a = !1) {
  let { x: l, y: d } = cI(n, t);
  const { offsetX: u, offsetY: p } = uI(r, n, t, Cr + 1, a);
  ((l += u), (d += p));
  const { w: f, h: m } = jh(e, o);
  if (i && dI({ x: l, y: d, w: f, h: m }, i)) {
    const h = pI(n, { x: l, y: d, w: f }, i);
    ((l = h.x), (d = h.y));
  }
  return Mh(e, r, { x: l, y: d, w: f, h: m }, o);
}
s(fI, 'drawLabel');
function mI(e, { w: t, h: r }) {
  const n = t * 0.5 + Cr,
    o = r * 0.5 + Cr;
  return { offsetX: (e.x === 'left' ? -1 : 1) * n, offsetY: (e.y === 'top' ? -1 : 1) * o };
}
s(mI, 'floatingOffset');
function yI(e, t, { type: r, text: n }) {
  const { floatingAlignment: o, extremities: i } = t;
  let a = i[o.x],
    l = i[o.y];
  const { w: d, h: u } = jh(e, n),
    { offsetX: p, offsetY: f } = mI(o, { w: d, h: u });
  return ((a += p), (l += f), Mh(e, r, { x: a, y: l, w: d, h: u }, n));
}
s(yI, 'drawFloatingLabel');
function eo(e, t, r, n) {
  const o = [];
  r.forEach((i, a) => {
    const l = n && i.position === 'center' ? yI(e, t, i) : fI(e, t, i, o[a - 1], n);
    o[a] = l;
  });
}
s(eo, 'drawStack');
function hI(e, t, r, n) {
  const o = r.reduce(
    (i, a) => (
      Object.prototype.hasOwnProperty.call(i, a.position) || (i[a.position] = []),
      i[a.position]?.push(a),
      i
    ),
    {},
  );
  (o.top && eo(e, t, o.top, n),
    o.right && eo(e, t, o.right, n),
    o.bottom && eo(e, t, o.bottom, n),
    o.left && eo(e, t, o.left, n),
    o.center && eo(e, t, o.center, n));
}
s(hI, 'labelStacks');
var Fc = { margin: '#f6b26ba8', border: '#ffe599a8', padding: '#93c47d8c', content: '#6fa8dca8' },
  Yb = 30;
function Ot(e) {
  return parseInt(e.replace('px', ''), 10);
}
s(Ot, 'pxToNumber');
function wn(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
s(wn, 'round');
function Bc(e) {
  return e.filter((t) => t.text !== 0 && t.text !== '0');
}
s(Bc, 'filterZeroValues');
function gI(e) {
  const t = {
      top: te.window.scrollY,
      bottom: te.window.scrollY + te.window.innerHeight,
      left: te.window.scrollX,
      right: te.window.scrollX + te.window.innerWidth,
    },
    r = {
      top: Math.abs(t.top - e.top),
      bottom: Math.abs(t.bottom - e.bottom),
      left: Math.abs(t.left - e.left),
      right: Math.abs(t.right - e.right),
    };
  return { x: r.left > r.right ? 'left' : 'right', y: r.top > r.bottom ? 'top' : 'bottom' };
}
s(gI, 'floatingAlignment');
function bI(e) {
  const t = te.getComputedStyle(e);
  let { top: r, left: n, right: o, bottom: i, width: a, height: l } = e.getBoundingClientRect();
  const {
    marginTop: d,
    marginBottom: u,
    marginLeft: p,
    marginRight: f,
    paddingTop: m,
    paddingBottom: h,
    paddingLeft: g,
    paddingRight: v,
    borderBottomWidth: E,
    borderTopWidth: b,
    borderLeftWidth: S,
    borderRightWidth: R,
  } = t;
  ((r = r + te.window.scrollY),
    (n = n + te.window.scrollX),
    (i = i + te.window.scrollY),
    (o = o + te.window.scrollX));
  const I = { top: Ot(d), bottom: Ot(u), left: Ot(p), right: Ot(f) },
    $ = { top: Ot(m), bottom: Ot(h), left: Ot(g), right: Ot(v) },
    x = { top: Ot(b), bottom: Ot(E), left: Ot(S), right: Ot(R) },
    A = { top: r - I.top, bottom: i + I.bottom, left: n - I.left, right: o + I.right };
  return {
    margin: I,
    padding: $,
    border: x,
    top: r,
    left: n,
    bottom: i,
    right: o,
    width: a,
    height: l,
    extremities: A,
    floatingAlignment: gI(A),
  };
}
s(bI, 'measureElement');
function vI(e, { margin: t, width: r, height: n, top: o, left: i, bottom: a, right: l }) {
  const d = n + t.bottom + t.top;
  ((e.fillStyle = Fc.margin),
    e.fillRect(i, o - t.top, r, t.top),
    e.fillRect(l, o - t.top, t.right, d),
    e.fillRect(i, a, r, t.bottom),
    e.fillRect(i - t.left, o - t.top, t.left, d));
  const u = [
    { type: 'margin', text: wn(t.top), position: 'top' },
    { type: 'margin', text: wn(t.right), position: 'right' },
    { type: 'margin', text: wn(t.bottom), position: 'bottom' },
    { type: 'margin', text: wn(t.left), position: 'left' },
  ];
  return Bc(u);
}
s(vI, 'drawMargin');
function TI(
  e,
  { padding: t, border: r, width: n, height: o, top: i, left: a, bottom: l, right: d },
) {
  const u = n - r.left - r.right,
    p = o - t.top - t.bottom - r.top - r.bottom;
  ((e.fillStyle = Fc.padding),
    e.fillRect(a + r.left, i + r.top, u, t.top),
    e.fillRect(d - t.right - r.right, i + t.top + r.top, t.right, p),
    e.fillRect(a + r.left, l - t.bottom - r.bottom, u, t.bottom),
    e.fillRect(a + r.left, i + t.top + r.top, t.left, p));
  const f = [
    { type: 'padding', text: t.top, position: 'top' },
    { type: 'padding', text: t.right, position: 'right' },
    { type: 'padding', text: t.bottom, position: 'bottom' },
    { type: 'padding', text: t.left, position: 'left' },
  ];
  return Bc(f);
}
s(TI, 'drawPadding');
function EI(e, { border: t, width: r, height: n, top: o, left: i, bottom: a, right: l }) {
  const d = n - t.top - t.bottom;
  ((e.fillStyle = Fc.border),
    e.fillRect(i, o, r, t.top),
    e.fillRect(i, a - t.bottom, r, t.bottom),
    e.fillRect(i, o + t.top, t.left, d),
    e.fillRect(l - t.right, o + t.top, t.right, d));
  const u = [
    { type: 'border', text: t.top, position: 'top' },
    { type: 'border', text: t.right, position: 'right' },
    { type: 'border', text: t.bottom, position: 'bottom' },
    { type: 'border', text: t.left, position: 'left' },
  ];
  return Bc(u);
}
s(EI, 'drawBorder');
function wI(e, { padding: t, border: r, width: n, height: o, top: i, left: a }) {
  const l = n - r.left - r.right - t.left - t.right,
    d = o - t.top - t.bottom - r.top - r.bottom;
  return (
    (e.fillStyle = Fc.content),
    e.fillRect(a + r.left + t.left, i + r.top + t.top, l, d),
    [{ type: 'content', position: 'center', text: `${wn(l)} x ${wn(d)}` }]
  );
}
s(wI, 'drawContent');
function SI(e) {
  return (t) => {
    if (e && t) {
      const r = bI(e),
        n = vI(t, r),
        o = TI(t, r),
        i = EI(t, r),
        a = wI(t, r),
        l = r.width <= Yb * 3 || r.height <= Yb;
      hI(t, r, [...a, ...o, ...i, ...n], l);
    }
  };
}
s(SI, 'drawBoxModel');
function _I(e) {
  iI(SI(e));
}
s(_I, 'drawSelectedElement');
var NH = s((e, t) => {
    const r = te.document.elementFromPoint(e, t),
      n = s((i) => {
        if (i && i.shadowRoot) {
          const a = i.shadowRoot.elementFromPoint(e, t);
          return i.isEqualNode(a) ? i : a.shadowRoot ? n(a) : a;
        }
        return i;
      }, 'crawlShadows');
    return n(r) || r;
  }, 'deepElementFromPoint'),
  Xb,
  Yi = { x: 0, y: 0 };
function pp(e, t) {
  ((Xb = NH(e, t)), _I(Xb));
}
s(pp, 'findAndDrawElement');
var $H = s((e, t) => {
    const { measureEnabled: r } = t.globals || {};
    return (
      Zr(() => {
        if (typeof globalThis.document > 'u') return;
        const n = s((o) => {
          window.requestAnimationFrame(() => {
            (o.stopPropagation(), (Yi.x = o.clientX), (Yi.y = o.clientY));
          });
        }, 'onPointerMove');
        return (
          globalThis.document.addEventListener('pointermove', n),
          () => {
            globalThis.document.removeEventListener('pointermove', n);
          }
        );
      }, []),
      Zr(() => {
        const n = s((i) => {
            window.requestAnimationFrame(() => {
              (i.stopPropagation(), pp(i.clientX, i.clientY));
            });
          }, 'onPointerOver'),
          o = s(() => {
            window.requestAnimationFrame(() => {
              aI();
            });
          }, 'onResize');
        return (
          t.viewMode === 'story' &&
            r &&
            (globalThis.document.addEventListener('pointerover', n),
            sI(),
            globalThis.window.addEventListener('resize', o),
            pp(Yi.x, Yi.y)),
          () => {
            (globalThis.window.removeEventListener('resize', o), lI());
          }
        );
      }, [r, t.viewMode]),
      e()
    );
  }, 'withMeasure'),
  qH = globalThis.FEATURES?.measure ? [$H] : [],
  MH = { [IH]: !1 },
  Qb = s(() => ({ decorators: qH, initialGlobals: MH }), 'default'),
  AI = 'outline',
  Zb = s((e) => {
    (Array.isArray(e) ? e : [e]).forEach(jH);
  }, 'clearStyles'),
  jH = s((e) => {
    const t = typeof e == 'string' ? e : e.join(''),
      r = te.document.getElementById(t);
    r && r.parentElement && r.parentElement.removeChild(r);
  }, 'clearStyle'),
  kH = s((e, t) => {
    const r = te.document.getElementById(e);
    if (r) r.innerHTML !== t && (r.innerHTML = t);
    else {
      const n = te.document.createElement('style');
      (n.setAttribute('id', e), (n.innerHTML = t), te.document.head.appendChild(n));
    }
  }, 'addOutlineStyles');
function RI(e) {
  return ve`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
s(RI, 'outlineCSS');
var DH = s((e, t) => {
    const r = t.globals || {},
      n = [!0, 'true'].includes(r[AI]),
      o = t.viewMode === 'docs',
      i = gf(() => RI(o ? '[data-story-block="true"]' : '.sb-show-main'), [t]);
    return (
      Zr(() => {
        const a = o ? `addon-outline-docs-${t.id}` : 'addon-outline';
        return (
          n ? kH(a, i) : Zb(a),
          () => {
            Zb(a);
          }
        );
      }, [n, i, t]),
      e()
    );
  }, 'withOutline'),
  LH = globalThis.FEATURES?.outline ? [DH] : [],
  FH = { [AI]: !1 },
  ev = s(() => ({ decorators: LH, initialGlobals: FH }), 'default'),
  BH = s(({ parameters: e }) => {
    e?.test?.mockReset === !0
      ? $y()
      : e?.test?.clearMocks === !0
        ? Ny()
        : e?.test?.restoreMocks !== !1 && qy();
  }, 'resetAllMocksLoader'),
  fp = s((e, t = 0, r) => {
    if (t > 5 || e == null) return e;
    if (An(e)) return (r && e.mockName(r), e);
    if (
      typeof e == 'function' &&
      'isAction' in e &&
      e.isAction &&
      !('implicit' in e && e.implicit)
    ) {
      const n = Cy(e);
      return (r && n.mockName(r), n);
    }
    if (Array.isArray(e)) {
      t++;
      for (let n = 0; n < e.length; n++)
        Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = fp(e[n], t));
      return e;
    }
    if (typeof e == 'object' && e.constructor === Object) {
      t++;
      for (const [n, o] of Object.entries(e))
        Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = fp(o, t, n));
      return e;
    }
    return e;
  }, 'traverseArgs'),
  JH = s(({ initialArgs: e }) => {
    fp(e);
  }, 'nameSpiesAndWrapActionsInSpies'),
  tv = !1,
  UH = s(async (e) => {
    globalThis.HTMLElement &&
      e.canvasElement instanceof globalThis.HTMLElement &&
      (e.canvas = rI(e.canvasElement));
    const t = globalThis.window?.navigator?.clipboard;
    if (
      t &&
      ((e.userEvent = Fo(
        { userEvent: nI.setup() },
        {
          intercept: !0,
          getKeys: s((r) => Object.keys(r).filter((n) => n !== 'eventWrapper'), 'getKeys'),
        },
      ).userEvent),
      Object.defineProperty(globalThis.window.navigator, 'clipboard', {
        get: s(() => t, 'get'),
        configurable: !0,
      }),
      !tv)
    ) {
      const r = HTMLElement.prototype.focus;
      let n = HTMLElement.prototype.focus;
      const o = new Set();
      (Object.defineProperties(HTMLElement.prototype, {
        focus: {
          configurable: !0,
          set: s((i) => {
            n = i;
          }, 'set'),
          get() {
            return o.has(this) ? r : (o.add(this), setTimeout(() => o.delete(this), 0), n);
          },
        },
      }),
        (tv = !0));
    }
  }, 'enhanceContext'),
  rv = s(() => ({ loaders: [BH, JH, UH] }), 'default'),
  VH = 'viewport',
  HH = { [VH]: { value: void 0, isRotated: !1 } },
  nv = s(() => ({ initialGlobals: HH }), 'default');
function kh() {
  return [
    (Qb.default ?? Qb)(),
    (Fb.default ?? Fb)(),
    (Kb.default ?? Kb)(),
    (ev.default ?? ev)(),
    (nv.default ?? nv)(),
    (jb.default ?? jb)(),
    (Bb.default ?? Bb)(),
    (rv.default ?? rv)(),
  ];
}
s(kh, 'getCoreAnnotations');
function zH(e) {
  return e;
}
s(zH, 'definePreviewAddon');
function PI(e) {
  return e != null && typeof e == 'object' && '_tag' in e && e?._tag === 'Meta';
}
s(PI, 'isMeta');
function Jc(e) {
  return e != null && typeof e == 'object' && '_tag' in e && e?._tag === 'Story';
}
s(Jc, 'isStory');
function xI(e) {
  return '__children' in e ? e.__children : [];
}
s(xI, 'getStoryChildren');
var OI = s(
    (e) =>
      e
        .toLowerCase()
        .replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '-')
        .replace(/-+/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, ''),
    'sanitize',
  ),
  mp = s((e, t) => {
    const r = OI(e);
    if (r === '') throw new Error(`Invalid ${t} '${e}', must include alphanumeric characters`);
    return r;
  }, 'sanitizeSafe'),
  GH = s((e, t) => `${mp(e, 'kind')}${t ? `--${mp(t, 'name')}` : ''}`, 'toId'),
  WH = s((e, t) => `${e}:${mp(t, 'test')}`, 'toTestId'),
  KH = s((e) => Dw(e), 'storyNameFromExport');
function yp(e, t) {
  return Array.isArray(t) ? t.includes(e) : e.match(t);
}
s(yp, 'matches');
function al(e, { includeStories: t, excludeStories: r }) {
  return e !== '__esModule' && (!t || yp(e, t)) && (!r || !yp(e, r));
}
s(al, 'isExportStory');
var YH = s((...e) => {
  const t = e.reduce((r, n) => (n.startsWith('!') ? r.delete(n.slice(1)) : r.add(n), r), new Set());
  return Array.from(t);
}, 'combineTags');
function hp(e) {
  return Object.getOwnPropertySymbols(e).filter((t) =>
    Object.prototype.propertyIsEnumerable.call(e, t),
  );
}
s(hp, 'getSymbols');
function gp(e) {
  return e == null
    ? e === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(e);
}
s(gp, 'getTag');
var XH = '[object RegExp]',
  QH = '[object String]',
  ZH = '[object Number]',
  e3 = '[object Boolean]',
  ov = '[object Arguments]',
  t3 = '[object Symbol]',
  r3 = '[object Date]',
  n3 = '[object Map]',
  o3 = '[object Set]',
  s3 = '[object Array]',
  i3 = '[object Function]',
  a3 = '[object ArrayBuffer]',
  vu = '[object Object]',
  l3 = '[object Error]',
  c3 = '[object DataView]',
  u3 = '[object Uint8Array]',
  d3 = '[object Uint8ClampedArray]',
  p3 = '[object Uint16Array]',
  f3 = '[object Uint32Array]',
  m3 = '[object BigUint64Array]',
  y3 = '[object Int8Array]',
  h3 = '[object Int16Array]',
  g3 = '[object Int32Array]',
  b3 = '[object BigInt64Array]',
  v3 = '[object Float32Array]',
  T3 = '[object Float64Array]';
function Qt(e) {
  if (!e || typeof e != 'object') return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null
    ? Object.prototype.toString.call(e) === '[object Object]'
    : !1;
}
s(Qt, 'isPlainObject');
function ko(e, t) {
  const r = {},
    n = Object.keys(e);
  for (let o = 0; o < n.length; o++) {
    const i = n[o],
      a = e[i];
    r[i] = t(a, i, e);
  }
  return r;
}
s(ko, 'mapValues');
function CI(e, t) {
  const r = {},
    n = Object.keys(e);
  for (let o = 0; o < n.length; o++) {
    const i = n[o],
      a = e[i];
    t(a, i) && (r[i] = a);
  }
  return r;
}
s(CI, 'pickBy');
var Tu = Ke(zv(), 1);
function II(e, t) {
  return e === t || (Number.isNaN(e) && Number.isNaN(t));
}
s(II, 'eq');
function NI(e, t, r) {
  return lo(e, t, void 0, void 0, void 0, void 0, r);
}
s(NI, 'isEqualWith');
function lo(e, t, r, n, o, i, a) {
  const l = a(e, t, r, n, o, i);
  if (l !== void 0) return l;
  if (typeof e == typeof t)
    switch (typeof e) {
      case 'bigint':
      case 'string':
      case 'boolean':
      case 'symbol':
      case 'undefined':
        return e === t;
      case 'number':
        return e === t || Object.is(e, t);
      case 'function':
        return e === t;
      case 'object':
        return go(e, t, i, a);
    }
  return go(e, t, i, a);
}
s(lo, 'isEqualWithImpl');
function go(e, t, r, n) {
  if (Object.is(e, t)) return !0;
  let o = gp(e),
    i = gp(t);
  if ((o === ov && (o = vu), i === ov && (i = vu), o !== i)) return !1;
  switch (o) {
    case QH:
      return e.toString() === t.toString();
    case ZH: {
      const d = e.valueOf(),
        u = t.valueOf();
      return II(d, u);
    }
    case e3:
    case r3:
    case t3:
      return Object.is(e.valueOf(), t.valueOf());
    case XH:
      return e.source === t.source && e.flags === t.flags;
    case i3:
      return e === t;
  }
  r = r ?? new Map();
  const a = r.get(e),
    l = r.get(t);
  if (a != null && l != null) return a === t;
  (r.set(e, t), r.set(t, e));
  try {
    switch (o) {
      case n3: {
        if (e.size !== t.size) return !1;
        for (const [d, u] of e.entries())
          if (!t.has(d) || !lo(u, t.get(d), d, e, t, r, n)) return !1;
        return !0;
      }
      case o3: {
        if (e.size !== t.size) return !1;
        const d = Array.from(e.values()),
          u = Array.from(t.values());
        for (let p = 0; p < d.length; p++) {
          const f = d[p],
            m = u.findIndex((h) => lo(f, h, void 0, e, t, r, n));
          if (m === -1) return !1;
          u.splice(m, 1);
        }
        return !0;
      }
      case s3:
      case u3:
      case d3:
      case p3:
      case f3:
      case m3:
      case y3:
      case h3:
      case g3:
      case b3:
      case v3:
      case T3: {
        if (
          (typeof Buffer < 'u' && Buffer.isBuffer(e) !== Buffer.isBuffer(t)) ||
          e.length !== t.length
        )
          return !1;
        for (let d = 0; d < e.length; d++) if (!lo(e[d], t[d], d, e, t, r, n)) return !1;
        return !0;
      }
      case a3:
        return e.byteLength !== t.byteLength ? !1 : go(new Uint8Array(e), new Uint8Array(t), r, n);
      case c3:
        return e.byteLength !== t.byteLength || e.byteOffset !== t.byteOffset
          ? !1
          : go(new Uint8Array(e), new Uint8Array(t), r, n);
      case l3:
        return e.name === t.name && e.message === t.message;
      case vu: {
        if (!(go(e.constructor, t.constructor, r, n) || (Qt(e) && Qt(t)))) return !1;
        const u = [...Object.keys(e), ...hp(e)],
          p = [...Object.keys(t), ...hp(t)];
        if (u.length !== p.length) return !1;
        for (let f = 0; f < u.length; f++) {
          const m = u[f],
            h = e[m];
          if (!Object.hasOwn(t, m)) return !1;
          const g = t[m];
          if (!lo(h, g, m, e, t, r, n)) return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    (r.delete(e), r.delete(t));
  }
}
s(go, 'areObjectsEqual');
function $I() {}
s($I, 'noop');
function qI(e, t) {
  return NI(e, t, $I);
}
s(qI, 'isEqual');
var gn = Symbol('incompatible'),
  bp = s((e, t) => {
    const r = t.type;
    if (e == null || !r || t.mapping) return e;
    switch (r.name) {
      case 'string':
        return String(e);
      case 'enum':
        return e;
      case 'number':
        return Number(e);
      case 'boolean':
        return String(e) === 'true';
      case 'array':
        return !r.value || !Array.isArray(e)
          ? gn
          : e.reduce((n, o, i) => {
              const a = bp(o, { type: r.value });
              return (a !== gn && (n[i] = a), n);
            }, new Array(e.length));
      case 'object':
        return typeof e == 'string' || typeof e == 'number'
          ? e
          : !r.value || typeof e != 'object'
            ? gn
            : Object.entries(e).reduce((n, [o, i]) => {
                const a = bp(i, { type: r.value[o] });
                return a === gn ? n : Object.assign(n, { [o]: a });
              }, {});
      case 'other': {
        const n = typeof e == 'string' || typeof e == 'number' || typeof e == 'boolean';
        return r.value === 'ReactNode' && n ? e : gn;
      }
      default:
        return gn;
    }
  }, 'map'),
  E3 = s(
    (e, t) =>
      Object.entries(e).reduce((r, [n, o]) => {
        if (!t[n]) return r;
        const i = bp(o, t[n]);
        return i === gn ? r : Object.assign(r, { [n]: i });
      }, {}),
    'mapArgsToTypes',
  ),
  ll = s(
    (e, t) =>
      Array.isArray(e) && Array.isArray(t)
        ? t.reduce((r, n, o) => ((r[o] = ll(e[o], t[o])), r), [...e]).filter((r) => r !== void 0)
        : !Qt(e) || !Qt(t)
          ? t
          : Object.keys({ ...e, ...t }).reduce((r, n) => {
              if (n in t) {
                const o = ll(e[n], t[n]);
                o !== void 0 && (r[n] = o);
              } else r[n] = e[n];
              return r;
            }, {}),
    'combineArgs',
  ),
  w3 = s(
    (e, t) =>
      Object.entries(t).reduce((r, [n, { options: o }]) => {
        function i() {
          return (n in e && (r[n] = e[n]), r);
        }
        if ((s(i, 'allowArg'), !o)) return i();
        if (!Array.isArray(o))
          return (
            Ve.error(ve`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `),
            i()
          );
        if (o.some((f) => f && ['object', 'function'].includes(typeof f)))
          return (
            Ve.error(ve`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `),
            i()
          );
        const a = Array.isArray(e[n]),
          l = a && e[n].findIndex((f) => !o.includes(f)),
          d = a && l === -1;
        if (e[n] === void 0 || o.includes(e[n]) || d) return i();
        const u = a ? `${n}[${l}]` : n,
          p = o.map((f) => (typeof f == 'string' ? `'${f}'` : String(f))).join(', ');
        return (Ve.warn(`Received illegal value for '${u}'. Supported options: ${p}`), r);
      }, {}),
    'validateOptions',
  ),
  Ks = Symbol('Deeply equal'),
  cl = s((e, t) => {
    if (typeof e != typeof t) return t;
    if (qI(e, t)) return Ks;
    if (Array.isArray(e) && Array.isArray(t)) {
      const r = t.reduce((n, o, i) => {
        const a = cl(e[i], o);
        return (a !== Ks && (n[i] = a), n);
      }, new Array(t.length));
      return t.length >= e.length ? r : r.concat(new Array(e.length - t.length).fill(void 0));
    }
    return Qt(e) && Qt(t)
      ? Object.keys({ ...e, ...t }).reduce((r, n) => {
          const o = cl(e?.[n], t?.[n]);
          return o === Ks ? r : Object.assign(r, { [n]: o });
        }, {})
      : t;
  }, 'deepDiff'),
  MI = 'UNTARGETED';
function jI({ args: e, argTypes: t }) {
  const r = {};
  return (
    Object.entries(e).forEach(([n, o]) => {
      const { target: i = MI } = t[n] || {};
      ((r[i] = r[i] || {}), (r[i][n] = o));
    }),
    r
  );
}
s(jI, 'groupArgsByTarget');
function kI(e) {
  return (Object.keys(e).forEach((t) => e[t] === void 0 && delete e[t]), e);
}
s(kI, 'deleteUndefined');
var DI = class {
  constructor() {
    ((this.initialArgsByStoryId = {}), (this.argsByStoryId = {}));
  }
  get(t) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    return this.argsByStoryId[t];
  }
  setInitial(t) {
    if (!this.initialArgsByStoryId[t.id])
      ((this.initialArgsByStoryId[t.id] = t.initialArgs),
        (this.argsByStoryId[t.id] = t.initialArgs));
    else if (this.initialArgsByStoryId[t.id] !== t.initialArgs) {
      const r = cl(this.initialArgsByStoryId[t.id], this.argsByStoryId[t.id]);
      ((this.initialArgsByStoryId[t.id] = t.initialArgs),
        (this.argsByStoryId[t.id] = t.initialArgs),
        r !== Ks && this.updateFromDelta(t, r));
    }
  }
  updateFromDelta(t, r) {
    const n = w3(r, t.argTypes);
    this.argsByStoryId[t.id] = ll(this.argsByStoryId[t.id], n);
  }
  updateFromPersisted(t, r) {
    const n = E3(r, t.argTypes);
    return this.updateFromDelta(t, n);
  }
  update(t, r) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    this.argsByStoryId[t] = kI({ ...this.argsByStoryId[t], ...r });
  }
};
s(DI, 'ArgsStore');
var S3 = DI,
  LI = s(
    (e = {}) =>
      Object.entries(e).reduce(
        (t, [r, { defaultValue: n }]) => (typeof n < 'u' && (t[r] = n), t),
        {},
      ),
    'getValuesFromArgTypes',
  ),
  FI = class {
    constructor({ globals: t = {}, globalTypes: r = {} }) {
      this.set({ globals: t, globalTypes: r });
    }
    set({ globals: t = {}, globalTypes: r = {} }) {
      const n = this.initialGlobals && cl(this.initialGlobals, this.globals);
      this.allowedGlobalNames = new Set([...Object.keys(t), ...Object.keys(r)]);
      const o = LI(r);
      ((this.initialGlobals = { ...o, ...t }),
        (this.globals = this.initialGlobals),
        n && n !== Ks && this.updateFromPersisted(n));
    }
    filterAllowedGlobals(t) {
      return Object.entries(t).reduce(
        (r, [n, o]) => (
          this.allowedGlobalNames.has(n)
            ? (r[n] = o)
            : ke.warn(
                `Attempted to set a global (${n}) that is not defined in initial globals or globalTypes`,
              ),
          r
        ),
        {},
      );
    }
    updateFromPersisted(t) {
      const r = this.filterAllowedGlobals(t);
      this.globals = { ...this.globals, ...r };
    }
    get() {
      return this.globals;
    }
    update(t) {
      this.globals = { ...this.globals, ...this.filterAllowedGlobals(t) };
      for (const r in t) t[r] === void 0 && (this.globals[r] = this.initialGlobals[r]);
    }
  };
s(FI, 'GlobalsStore');
var _3 = FI,
  A3 = Ke(zv(), 1),
  R3 = (0, A3.default)(1)((e) =>
    Object.values(e).reduce((t, r) => ((t[r.importPath] = t[r.importPath] || r), t), {}),
  ),
  BI = class {
    constructor({ entries: t } = { v: 5, entries: {} }) {
      this.entries = t;
    }
    entryFromSpecifier(t) {
      const r = Object.values(this.entries);
      if (t === '*') return r[0];
      if (typeof t == 'string')
        return this.entries[t] ? this.entries[t] : r.find((i) => i.id.startsWith(t));
      const { name: n, title: o } = t;
      return r.find((i) => i.name === n && i.title === o);
    }
    storyIdToEntry(t) {
      const r = this.entries[t];
      if (!r) throw new VE({ storyId: t });
      return r;
    }
    importPathToEntry(t) {
      return R3(this.entries)[t];
    }
  };
s(BI, 'StoryIndexStore');
var P3 = BI,
  x3 = s((e) => (typeof e == 'string' ? { name: e } : e), 'normalizeType'),
  O3 = s((e) => (typeof e == 'string' ? { type: e } : e), 'normalizeControl'),
  C3 = s((e, t) => {
    const { type: r, control: n, ...o } = e,
      i = { name: t, ...o };
    return (
      r && (i.type = x3(r)),
      n ? (i.control = O3(n)) : n === !1 && (i.control = { disable: !0 }),
      i
    );
  }, 'normalizeInputType'),
  ul = s((e) => ko(e, C3), 'normalizeInputTypes'),
  Ne = s((e) => (Array.isArray(e) ? e : e ? [e] : []), 'normalizeArrays'),
  I3 = ve`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function bo(e, t, r) {
  const n = t,
    o = typeof t == 'function' ? t : null,
    { story: i } = n;
  i && (ke.debug('deprecated story', i), Qp(I3));
  const a = KH(e),
    l = (typeof n != 'function' && n.name) || n.storyName || i?.name || a,
    d = [...Ne(n.decorators), ...Ne(i?.decorators)],
    u = { ...i?.parameters, ...n.parameters },
    p = { ...i?.args, ...n.args },
    f = { ...i?.argTypes, ...n.argTypes },
    m = [...Ne(n.loaders), ...Ne(i?.loaders)],
    h = [...Ne(n.beforeEach), ...Ne(i?.beforeEach)],
    g = [...Ne(n.afterEach), ...Ne(i?.afterEach)],
    { render: v, play: E, tags: b = [], globals: S = {} } = n,
    R = u.__id || GH(r.id, a);
  return {
    moduleExport: t,
    id: R,
    name: l,
    tags: b,
    decorators: d,
    parameters: u,
    args: p,
    argTypes: ul(f),
    loaders: m,
    beforeEach: h,
    afterEach: g,
    globals: S,
    ...(v && { render: v }),
    ...(o && { userStoryFn: o }),
    ...(E && { play: E }),
  };
}
s(bo, 'normalizeStory');
function dl(e, t = e.title, r) {
  const { id: n, argTypes: o } = e;
  return {
    id: OI(n || t),
    ...e,
    title: t,
    ...(o && { argTypes: ul(o) }),
    parameters: { fileName: r, ...e.parameters },
  };
}
s(dl, 'normalizeComponentAnnotations');
var N3 = s((e) => {
    const { globals: t, globalTypes: r } = e;
    (t || r) &&
      ke.error(
        'Global args/argTypes can only be set globally',
        JSON.stringify({ globals: t, globalTypes: r }),
      );
  }, 'checkGlobals'),
  $3 = s((e) => {
    const { options: t } = e;
    t?.storySort && ke.error('The storySort option parameter can only be set globally');
  }, 'checkStorySort'),
  Xi = s((e) => {
    e && (N3(e), $3(e));
  }, 'checkDisallowedParameters');
function JI(e, t, r) {
  const { default: n, __namedExportsOrder: o, ...i } = e,
    a = Object.values(i)[0];
  if (Jc(a)) {
    const u = dl(a.meta.input, r, t);
    Xi(u.parameters);
    const p = { meta: u, stories: {}, moduleExports: e };
    return (
      Object.keys(i).forEach((f) => {
        if (al(f, u)) {
          const m = i[f],
            h = bo(f, m.input, u);
          (Xi(h.parameters),
            (p.stories[h.id] = h),
            xI(m).forEach((g) => {
              var b;
              const v = g.input.name,
                E = WH(h.id, v);
              ((b = g.input).parameters ?? (b.parameters = {}),
                (g.input.parameters.__id = E),
                (p.stories[E] = bo(v, g.input, u)));
            }));
        }
      }),
      (p.projectAnnotations = a.meta.preview.composed),
      p
    );
  }
  const l = dl(n, r, t);
  Xi(l.parameters);
  const d = { meta: l, stories: {}, moduleExports: e };
  return (
    Object.keys(i).forEach((u) => {
      if (al(u, l)) {
        const p = bo(u, i[u], l);
        (Xi(p.parameters), (d.stories[p.id] = p));
      }
    }),
    d
  );
}
s(JI, 'processCSFFile');
function Dh(e, t, r) {
  const n = r(e);
  return (o) => t(n, o);
}
s(Dh, 'decorateStory');
function Lh({
  componentId: e,
  title: t,
  kind: r,
  id: n,
  name: o,
  story: i,
  parameters: a,
  initialArgs: l,
  argTypes: d,
  ...u
} = {}) {
  return u;
}
s(Lh, 'sanitizeStoryContextUpdate');
function Fh(e, t) {
  const r = {},
    n = s(
      (i) => (a) => {
        if (!r.value) throw new Error('Decorated function called without init');
        return ((r.value = { ...r.value, ...Lh(a) }), i(r.value));
      },
      'bindWithContext',
    ),
    o = t.reduce((i, a) => Dh(i, a, n), e);
  return (i) => ((r.value = i), o(i));
}
s(Fh, 'defaultDecorateStory');
var Dn = s((...e) => {
  const t = {},
    r = e.filter(Boolean),
    n = r.reduce(
      (o, i) => (
        Object.entries(i).forEach(([a, l]) => {
          const d = o[a];
          Array.isArray(l) || typeof d > 'u'
            ? (o[a] = l)
            : Qt(l) && Qt(d)
              ? (t[a] = !0)
              : typeof l < 'u' && (o[a] = l);
        }),
        o
      ),
      {},
    );
  return (
    Object.keys(t).forEach((o) => {
      const i = r
        .filter(Boolean)
        .map((a) => a[o])
        .filter((a) => typeof a < 'u');
      i.every((a) => Qt(a)) ? (n[o] = Dn(...i)) : (n[o] = i[i.length - 1]);
    }),
    n
  );
}, 'combineParameters');
function Uc(e, t, r) {
  const { moduleExport: n, id: o, name: i } = e || {},
    a = Jh(e, t, r),
    l = s(async (x) => {
      const A = {};
      for (const w of [Ne(r.loaders), Ne(t.loaders), Ne(e.loaders)]) {
        if (x.abortSignal.aborted) return A;
        const _ = await Promise.all(w.map((j) => j(x)));
        Object.assign(A, ..._);
      }
      return A;
    }, 'applyLoaders'),
    d = s(async (x) => {
      const A = new Array();
      for (const w of [...Ne(r.beforeEach), ...Ne(t.beforeEach), ...Ne(e.beforeEach)]) {
        if (x.abortSignal.aborted) return A;
        const _ = await w(x);
        _ && A.push(_);
      }
      return A;
    }, 'applyBeforeEach'),
    u = s(async (x) => {
      const A = [...Ne(r.afterEach), ...Ne(t.afterEach), ...Ne(e.afterEach)].reverse();
      for (const w of A) {
        if (x.abortSignal.aborted) return;
        await w(x);
      }
    }, 'applyAfterEach'),
    p = s((x) => x.originalStoryFn(x.args, x), 'undecoratedStoryFn'),
    { applyDecorators: f = Fh, runStep: m } = r,
    h = [...Ne(e?.decorators), ...Ne(t?.decorators), ...Ne(r?.decorators)],
    g = e?.userStoryFn || e?.render || t.render || r.render,
    v = xw(f)(p, h),
    E = s((x) => v(x), 'unboundStoryFn'),
    b = e?.play ?? t?.play,
    S = Fw(b);
  if (!g && !S) throw new pw({ id: o });
  const R = s((x) => async () => (await x.renderToCanvas(), x.canvas), 'defaultMount'),
    I = e.mount ?? t.mount ?? r.mount ?? R,
    $ = r.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a,
    moduleExport: n,
    id: o,
    name: i,
    story: i,
    originalStoryFn: g,
    undecoratedStoryFn: p,
    unboundStoryFn: E,
    applyLoaders: l,
    applyBeforeEach: d,
    applyAfterEach: u,
    playFunction: b,
    runStep: m,
    mount: I,
    testingLibraryRender: $,
    renderToCanvas: r.renderToCanvas,
    usesMount: S,
  };
}
s(Uc, 'prepareStory');
function Bh(e, t, r) {
  return { ...Jh(void 0, e, t), moduleExport: r };
}
s(Bh, 'prepareMeta');
function Jh(e, t, r) {
  const n = ['dev', 'test'],
    o = te.DOCS_OPTIONS?.autodocs === !0 ? ['autodocs'] : [],
    i = e?.tags?.includes('test-fn') ? ['!autodocs'] : [],
    a = YH(...n, ...o, ...(r.tags ?? []), ...(t.tags ?? []), ...i, ...(e?.tags ?? [])),
    l = Dn(r.parameters, t.parameters, e?.parameters),
    { argTypesEnhancers: d = [], argsEnhancers: u = [] } = r,
    p = Dn(r.argTypes, t.argTypes, e?.argTypes);
  if (e) {
    const S = e?.userStoryFn || e?.render || t.render || r.render;
    l.__isArgsStory = S && S.length > 0;
  }
  const f = { ...r.args, ...t.args, ...e?.args },
    m = { ...t.globals, ...e?.globals },
    h = {
      componentId: t.id,
      title: t.title,
      kind: t.title,
      id: e?.id || t.id,
      name: e?.name || '__meta',
      story: e?.name || '__meta',
      component: t.component,
      subcomponents: t.subcomponents,
      tags: a,
      parameters: l,
      initialArgs: f,
      argTypes: p,
      storyGlobals: m,
    };
  h.argTypes = d.reduce((S, R) => R({ ...h, argTypes: S }), h.argTypes);
  const g = { ...f };
  h.initialArgs = [...u].reduce((S, R) => ({ ...S, ...R({ ...h, initialArgs: S }) }), g);
  const { name: v, story: E, ...b } = h;
  return b;
}
s(Jh, 'preparePartialAnnotations');
function Uh(e) {
  const { args: t } = e;
  let r = { ...e, allArgs: void 0, argsByTarget: void 0 };
  if (te.FEATURES?.argTypeTargetsV7) {
    const i = jI(e);
    r = { ...e, allArgs: e.args, argsByTarget: i, args: i[MI] || {} };
  }
  const n = Object.entries(r.args).reduce((i, [a, l]) => {
      if (!r.argTypes[a]?.mapping) return ((i[a] = l), i);
      const d = s((u) => {
        const p = r.argTypes[a].mapping;
        return p && u in p ? p[u] : u;
      }, 'mappingFn');
      return ((i[a] = Array.isArray(l) ? l.map(d) : d(l)), i);
    }, {}),
    o = Object.entries(n).reduce((i, [a, l]) => {
      const d = r.argTypes[a] || {};
      return (JL(d, n, r.globals) && (i[a] = l), i);
    }, {});
  return { ...r, unmappedArgs: t, args: o };
}
s(Uh, 'prepareContext');
var vp = s((e, t, r) => {
    const n = typeof e;
    switch (n) {
      case 'boolean':
      case 'string':
      case 'number':
      case 'function':
      case 'symbol':
        return { name: n };
    }
    return e
      ? r.has(e)
        ? (ke.warn(ve`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `),
          { name: 'other', value: 'cyclic object' })
        : (r.add(e),
          Array.isArray(e)
            ? {
                name: 'array',
                value: e.length > 0 ? vp(e[0], t, new Set(r)) : { name: 'other', value: 'unknown' },
              }
            : { name: 'object', value: ko(e, (i) => vp(i, t, new Set(r))) })
      : { name: 'object', value: {} };
  }, 'inferType'),
  UI = s((e) => {
    const { id: t, argTypes: r = {}, initialArgs: n = {} } = e,
      o = ko(n, (a, l) => ({ name: l, type: vp(a, `${t}.${l}`, new Set()) })),
      i = ko(r, (a, l) => ({ name: l }));
    return Dn(o, i, r);
  }, 'inferArgTypes');
UI.secondPass = !0;
var sv = s((e, t) => (Array.isArray(t) ? t.includes(e) : e.match(t)), 'matches'),
  VI = s(
    (e, t, r) =>
      !t && !r
        ? e
        : e &&
          CI(e, (n, o) => {
            const i = n.name || o.toString();
            return !!(!t || sv(i, t)) && (!r || !sv(i, r));
          }),
    'filterArgTypes',
  ),
  q3 = s((e, t, r) => {
    const { type: n, options: o } = e;
    if (n) {
      if (r.color && r.color.test(t)) {
        const i = n.name;
        if (i === 'string') return { control: { type: 'color' } };
        i !== 'enum' &&
          ke.warn(
            `Addon controls: Control of type color only supports string, received "${i}" instead`,
          );
      }
      if (r.date && r.date.test(t)) return { control: { type: 'date' } };
      switch (n.name) {
        case 'array':
          return { control: { type: 'object' } };
        case 'boolean':
          return { control: { type: 'boolean' } };
        case 'string':
          return { control: { type: 'text' } };
        case 'number':
          return { control: { type: 'number' } };
        case 'enum': {
          const { value: i } = n;
          return { control: { type: i?.length <= 5 ? 'radio' : 'select' }, options: i };
        }
        case 'function':
        case 'symbol':
          return null;
        default:
          return { control: { type: o ? 'select' : 'object' } };
      }
    }
  }, 'inferControl'),
  Vh = s((e) => {
    const {
      argTypes: t,
      parameters: {
        __isArgsStory: r,
        controls: { include: n = null, exclude: o = null, matchers: i = {} } = {},
      },
    } = e;
    if (!r) return t;
    const a = VI(t, n, o),
      l = ko(a, (d, u) => d?.type && q3(d, u.toString(), i));
    return Dn(l, a);
  }, 'inferControls');
Vh.secondPass = !0;
function gi({
  argTypes: e,
  globalTypes: t,
  argTypesEnhancers: r,
  decorators: n,
  loaders: o,
  beforeEach: i,
  afterEach: a,
  initialGlobals: l,
  ...d
}) {
  return {
    ...(e && { argTypes: ul(e) }),
    ...(t && { globalTypes: ul(t) }),
    decorators: Ne(n),
    loaders: Ne(o),
    beforeEach: Ne(i),
    afterEach: Ne(a),
    argTypesEnhancers: [...(r || []), UI, Vh],
    initialGlobals: l,
    ...d,
  };
}
s(gi, 'normalizeProjectAnnotations');
var M3 = s(
  (e) => async () => {
    const t = [];
    for (const r of e) {
      const n = await r();
      n && t.unshift(n);
    }
    return async () => {
      for (const r of t) await r();
    };
  },
  'composeBeforeAllHooks',
);
function Hh(e) {
  return async (t, r, n) => {
    await e.reduceRight(
      (i, a) => async () => a(t, i, n),
      async () => r(n),
    )();
  };
}
s(Hh, 'composeStepRunners');
function Do(e, t) {
  return e.map((r) => r.default?.[t] ?? r[t]).filter(Boolean);
}
s(Do, 'getField');
function _r(e, t, r = {}) {
  return Do(e, t).reduce((n, o) => {
    const i = Ne(o);
    return r.reverseFileOrder ? [...i, ...n] : [...n, ...i];
  }, []);
}
s(_r, 'getArrayField');
function Ds(e, t) {
  return Object.assign({}, ...Do(e, t));
}
s(Ds, 'getObjectField');
function to(e, t) {
  return Do(e, t).pop();
}
s(to, 'getSingletonField');
function Ln(e) {
  const t = _r(e, 'argTypesEnhancers'),
    r = Do(e, 'runStep'),
    n = _r(e, 'beforeAll');
  return {
    parameters: Dn(...Do(e, 'parameters')),
    decorators: _r(e, 'decorators', {
      reverseFileOrder: !(te.FEATURES?.legacyDecoratorFileOrder ?? !1),
    }),
    args: Ds(e, 'args'),
    argsEnhancers: _r(e, 'argsEnhancers'),
    argTypes: Ds(e, 'argTypes'),
    argTypesEnhancers: [...t.filter((o) => !o.secondPass), ...t.filter((o) => o.secondPass)],
    initialGlobals: Ds(e, 'initialGlobals'),
    globalTypes: Ds(e, 'globalTypes'),
    loaders: _r(e, 'loaders'),
    beforeAll: M3(n),
    beforeEach: _r(e, 'beforeEach'),
    afterEach: _r(e, 'afterEach'),
    render: to(e, 'render'),
    renderToCanvas: to(e, 'renderToCanvas'),
    applyDecorators: to(e, 'applyDecorators'),
    runStep: Hh(r),
    tags: _r(e, 'tags'),
    mount: to(e, 'mount'),
    testingLibraryRender: to(e, 'testingLibraryRender'),
  };
}
s(Ln, 'composeConfigs');
var j3 = 5e3;
function zh() {
  try {
    return (
      !!globalThis.__vitest_browser__ ||
      !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return !1;
  }
}
s(zh, 'isTestEnvironment');
function Vc(e = !0) {
  if (!('document' in globalThis && 'createElement' in globalThis.document)) return () => {};
  const t = document.createElement('style');
  ((t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`),
    document.head.appendChild(t));
  const r = document.createElement('style');
  return (
    (r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? 'reverse' : 'normal'} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`),
    document.head.appendChild(r),
    document.body.clientHeight,
    document.head.removeChild(t),
    () => {
      r.parentNode?.removeChild(r);
    }
  );
}
s(Vc, 'pauseAnimations');
async function Hc(e) {
  if (
    !(
      'document' in globalThis &&
      'getAnimations' in globalThis.document &&
      'querySelectorAll' in globalThis.document
    )
  )
    return;
  let t = !1;
  await Promise.race([
    new Promise((r) => {
      setTimeout(() => {
        const n = [globalThis.document, ...Gh(globalThis.document)],
          o = s(async () => {
            if (t || e?.aborted) return;
            const i = n
              .flatMap((a) => a?.getAnimations?.() || [])
              .filter((a) => a.playState === 'running' && !HI(a));
            i.length > 0 && (await Promise.all(i.map((a) => a.finished)), await o());
          }, 'checkAnimationsFinished');
        o().then(r);
      }, 100);
    }),
    new Promise((r) =>
      setTimeout(() => {
        ((t = !0), r(void 0));
      }, j3),
    ),
  ]);
}
s(Hc, 'waitForAnimations');
function Gh(e) {
  return [e, ...e.querySelectorAll('*')].reduce(
    (t, r) => ('shadowRoot' in r && r.shadowRoot && t.push(r.shadowRoot, ...Gh(r.shadowRoot)), t),
    [],
  );
}
s(Gh, 'getShadowRoots');
function HI(e) {
  if (e instanceof CSSAnimation && e.effect instanceof KeyframeEffect && e.effect.target) {
    const t = getComputedStyle(e.effect.target, e.effect.pseudoElement),
      r = t.animationName?.split(', ').indexOf(e.animationName);
    return t.animationIterationCount.split(', ')[r] === 'infinite';
  }
  return !1;
}
s(HI, 'isInfiniteAnimation');
var zI = class {
  constructor() {
    this.reports = [];
  }
  async addReport(t) {
    this.reports.push(t);
  }
};
s(zI, 'ReporterAPI');
var Wh = zI;
function Kh(e, t, r) {
  return Jc(e)
    ? { story: e.input, meta: e.meta.input, preview: e.meta.preview.composed }
    : { story: e, meta: PI(t) ? t.input : t, preview: r };
}
s(Kh, 'getCsfFactoryAnnotations');
function GI(e) {
  globalThis.defaultProjectAnnotations = e;
}
s(GI, 'setDefaultProjectAnnotations');
var k3 = 'ComposedStory',
  D3 = 'Unnamed Story';
function WI(e) {
  return e ? Ln([e]) : {};
}
s(WI, 'extractAnnotation');
function KI(e) {
  const t = Array.isArray(e) ? e : [e];
  return (
    (globalThis.globalProjectAnnotations = Ln([
      ...kh(),
      globalThis.defaultProjectAnnotations ?? {},
      Ln(t.map(WI)),
    ])),
    globalThis.globalProjectAnnotations ?? {}
  );
}
s(KI, 'setProjectAnnotations');
var Vr = [];
function Yh(e, t, r, n, o) {
  if (e === void 0) throw new Error('Expected a story but received undefined.');
  t.title = t.title ?? k3;
  const i = dl(t),
    a = o || e.storyName || e.story?.name || e.name || D3,
    l = bo(a, e, i),
    d = gi(Ln([n ?? globalThis.globalProjectAnnotations ?? {}, r ?? {}])),
    u = Uc(l, i, d),
    f = { ...LI(d.globalTypes), ...d.initialGlobals, ...u.storyGlobals },
    m = new Wh(),
    h = s(() => {
      const R = Uh({
        hooks: new mf(),
        globals: f,
        args: { ...u.initialArgs },
        viewMode: 'story',
        reporting: m,
        loaded: {},
        abortSignal: new AbortController().signal,
        step: s((I, $) => u.runStep(I, $, R), 'step'),
        canvasElement: null,
        canvas: {},
        userEvent: {},
        globalTypes: d.globalTypes,
        ...u,
        context: null,
        mount: null,
      });
      return (
        (R.parameters.__isPortableStory = !0),
        (R.context = R),
        u.renderToCanvas &&
          (R.renderToCanvas = async () => {
            const I = await u.renderToCanvas?.(
              {
                componentId: u.componentId,
                title: u.title,
                id: u.id,
                name: u.name,
                tags: u.tags,
                showMain: s(() => {}, 'showMain'),
                showError: s(($) => {
                  throw new Error(`${$.title}
${$.description}`);
                }, 'showError'),
                showException: s(($) => {
                  throw $;
                }, 'showException'),
                forceRemount: !0,
                storyContext: R,
                storyFn: s(() => u.unboundStoryFn(R), 'storyFn'),
                unboundStoryFn: u.unboundStoryFn,
              },
              R.canvasElement,
            );
            I && Vr.push(I);
          }),
        (R.mount = u.mount(R)),
        R
      );
    }, 'initializeContext');
  let g;
  const v = s(async (R) => {
      const I = h();
      return (
        I.canvasElement ?? (I.canvasElement = globalThis?.document?.body),
        g && (I.loaded = g.loaded),
        Object.assign(I, R),
        u.playFunction(I)
      );
    }, 'play'),
    E = s((R) => {
      const I = h();
      return (Object.assign(I, R), QI(u, I));
    }, 'run'),
    b = u.playFunction ? v : void 0;
  return Object.assign(
    s(function (I) {
      const $ = h();
      return (
        g && ($.loaded = g.loaded),
        ($.args = { ...$.initialArgs, ...I }),
        u.unboundStoryFn($)
      );
    }, 'storyFn'),
    {
      id: u.id,
      storyName: a,
      load: s(async () => {
        for (const I of [...Vr].reverse()) await I();
        Vr.length = 0;
        const R = h();
        ((R.loaded = await u.applyLoaders(R)),
          Vr.push(...(await u.applyBeforeEach(R)).filter(Boolean)),
          (g = R));
      }, 'load'),
      globals: f,
      args: u.initialArgs,
      parameters: u.parameters,
      argTypes: u.argTypes,
      play: b,
      run: E,
      reporting: m,
      tags: u.tags,
    },
  );
}
s(Yh, 'composeStory');
var L3 = s((e, t, r, n) => Yh(e, t, r, {}, n), 'defaultComposeStory');
function YI(e, t, r = L3) {
  const { default: n, __esModule: o, __namedExportsOrder: i, ...a } = e;
  let l = n;
  return Object.entries(a).reduce((u, [p, f]) => {
    const { story: m, meta: h } = Kh(f);
    return (!l && h && (l = h), al(p, l) ? Object.assign(u, { [p]: r(m, l, t, p) }) : u);
  }, {});
}
s(YI, 'composeStories');
function XI(e) {
  return e.extend({
    mount: s(async ({ mount: t, page: r }, n) => {
      await n(async (o, ...i) => {
        if (!('__pw_type' in o) || ('__pw_type' in o && o.__pw_type !== 'jsx'))
          throw new Error(ve`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        const { props: a, ...l } = o;
        await r.evaluate(async (u) => {
          const p = await globalThis.__pwUnwrapObject?.(u);
          return ('__pw_type' in p ? p.type : p)?.load?.();
        }, l);
        const d = await t(o, ...i);
        return (
          await r.evaluate(async (u) => {
            const p = await globalThis.__pwUnwrapObject?.(u),
              f = '__pw_type' in p ? p.type : p,
              m = document.querySelector('#root');
            return f?.play?.({ canvasElement: m });
          }, l),
          d
        );
      });
    }, 'mount'),
  });
}
s(XI, 'createPlaywrightTest');
async function QI(e, t) {
  for (const i of [...Vr].reverse()) await i();
  if (((Vr.length = 0), !t.canvasElement)) {
    const i = document.createElement('div');
    (globalThis?.document?.body?.appendChild(i),
      (t.canvasElement = i),
      Vr.push(() => {
        globalThis?.document?.body?.contains(i) && globalThis?.document?.body?.removeChild(i);
      }));
  }
  if (((t.loaded = await e.applyLoaders(t)), t.abortSignal.aborted)) return;
  Vr.push(...(await e.applyBeforeEach(t)).filter(Boolean));
  const r = e.playFunction,
    n = e.usesMount;
  if ((n || (await t.mount()), t.abortSignal.aborted)) return;
  r &&
    (n ||
      (t.mount = async () => {
        throw new pf({ playFunction: r.toString() });
      }),
    await r(t));
  let o;
  (zh() ? (o = Vc()) : await Hc(t.abortSignal), await e.applyAfterEach(t), await o?.());
}
s(QI, 'runStory');
var iv = 1e3,
  F3 = 1e4,
  ZI = class {
    constructor(t, r, n) {
      ((this.importFn = r),
        (this.storyIndex = new P3(t)),
        (this.projectAnnotations = gi(Ln([...kh(), n]))));
      const { initialGlobals: o, globalTypes: i } = this.projectAnnotations;
      ((this.args = new S3()),
        (this.userGlobals = new _3({ globals: o, globalTypes: i })),
        (this.hooks = {}),
        (this.cleanupCallbacks = {}),
        (this.processCSFFileWithCache = (0, Tu.default)(iv)(JI)),
        (this.prepareMetaWithCache = (0, Tu.default)(iv)(Bh)),
        (this.prepareStoryWithCache = (0, Tu.default)(F3)(Uc)));
    }
    setProjectAnnotations(t) {
      this.projectAnnotations = gi(t);
      const { initialGlobals: r, globalTypes: n } = t;
      this.userGlobals.set({ globals: r, globalTypes: n });
    }
    async onStoriesChanged({ importFn: t, storyIndex: r }) {
      (t && (this.importFn = t),
        r && (this.storyIndex.entries = r.entries),
        this.cachedCSFFiles && (await this.cacheAllCSFFiles()));
    }
    async storyIdToEntry(t) {
      return this.storyIndex.storyIdToEntry(t);
    }
    async loadCSFFileByStoryId(t) {
      const { importPath: r, title: n } = this.storyIndex.storyIdToEntry(t),
        o = await this.importFn(r);
      return this.processCSFFileWithCache(o, r, n);
    }
    async loadAllCSFFiles() {
      const t = {};
      return (
        Object.entries(this.storyIndex.entries).forEach(([n, { importPath: o }]) => {
          t[o] = n;
        }),
        (
          await Promise.all(
            Object.entries(t).map(async ([n, o]) => ({
              importPath: n,
              csfFile: await this.loadCSFFileByStoryId(o),
            })),
          )
        ).reduce((n, { importPath: o, csfFile: i }) => ((n[o] = i), n), {})
      );
    }
    async cacheAllCSFFiles() {
      this.cachedCSFFiles = await this.loadAllCSFFiles();
    }
    preparedMetaFromCSFFile({ csfFile: t }) {
      const r = t.meta;
      return this.prepareMetaWithCache(r, this.projectAnnotations, t.moduleExports.default);
    }
    async loadStory({ storyId: t }) {
      const r = await this.loadCSFFileByStoryId(t);
      return this.storyFromCSFFile({ storyId: t, csfFile: r });
    }
    storyFromCSFFile({ storyId: t, csfFile: r }) {
      const n = r.stories[t];
      if (!n) throw new aw({ storyId: t });
      const o = r.meta,
        i = this.prepareStoryWithCache(n, o, r.projectAnnotations ?? this.projectAnnotations);
      return (this.args.setInitial(i), (this.hooks[i.id] = this.hooks[i.id] || new mf()), i);
    }
    componentStoriesFromCSFFile({ csfFile: t }) {
      return Object.keys(this.storyIndex.entries)
        .filter((r) => !!t.stories[r])
        .map((r) => this.storyFromCSFFile({ storyId: r, csfFile: t }));
    }
    async loadEntry(t) {
      const r = await this.storyIdToEntry(t),
        n = r.type === 'docs' ? r.storiesImports : [],
        [o, ...i] = await Promise.all([
          this.importFn(r.importPath),
          ...n.map((a) => {
            const l = this.storyIndex.importPathToEntry(a);
            return this.loadCSFFileByStoryId(l.id);
          }),
        ]);
      return { entryExports: o, csfFiles: i };
    }
    getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
      const n = this.userGlobals.get(),
        { initialGlobals: o } = this.userGlobals,
        i = new Wh();
      return Uh({
        ...t,
        args: r ? t.initialArgs : this.args.get(t.id),
        initialGlobals: o,
        globalTypes: this.projectAnnotations.globalTypes,
        userGlobals: n,
        reporting: i,
        globals: { ...n, ...t.storyGlobals },
        hooks: this.hooks[t.id],
      });
    }
    addCleanupCallbacks(t, ...r) {
      this.cleanupCallbacks[t.id] = (this.cleanupCallbacks[t.id] || []).concat(r);
    }
    async cleanupStory(t) {
      this.hooks[t.id].clean();
      const r = this.cleanupCallbacks[t.id];
      if (r) for (const n of [...r].reverse()) await n();
      delete this.cleanupCallbacks[t.id];
    }
    extract(t = { includeDocsOnly: !1 }) {
      const { cachedCSFFiles: r } = this;
      if ((console.log('extract: extracting stories', r), !r)) throw new WE();
      const n = Object.entries(this.storyIndex.entries).reduce((o, [i, a]) => {
        if (a.type === 'docs') return o;
        const l = r[a.importPath],
          d = this.storyFromCSFFile({ storyId: i, csfFile: l });
        return (
          (!t.includeDocsOnly && d.parameters.docsOnly) ||
            (o[i] = Object.entries(d).reduce(
              (u, [p, f]) =>
                p === 'story' && a.subtype === 'test'
                  ? { ...u, story: a.parentName }
                  : p === 'moduleExport' || typeof f == 'function'
                    ? u
                    : Array.isArray(f)
                      ? Object.assign(u, { [p]: f.slice().sort() })
                      : Object.assign(u, { [p]: f }),
              {
                args: d.initialArgs,
                globals: {
                  ...this.userGlobals.initialGlobals,
                  ...this.userGlobals.globals,
                  ...d.storyGlobals,
                },
                storyId: a.parent ? a.parent : i,
              },
            )),
          o
        );
      }, {});
      return (console.log('extract: stories', n), n);
    }
  };
s(ZI, 'StoryStore');
var eN = ZI;
function tN(e) {
  return e.startsWith('\\\\?\\') ? e : e.replace(/\\/g, '/');
}
s(tN, 'slash');
var B3 = s((e) => {
  if (e.length === 0) return e;
  const t = e[e.length - 1],
    r = t?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, '');
  if (e.length === 1) return [r];
  const n = e[e.length - 2];
  return r && n && r.toLowerCase() === n.toLowerCase()
    ? [...e.slice(0, -2), r]
    : r && (/^(story|stories)([.][^.]+)$/i.test(t) || /^index$/i.test(r))
      ? e.slice(0, -1)
      : [...e.slice(0, -1), r];
}, 'sanitize');
function Tp(e) {
  return e
    .flatMap((t) => t.split('/'))
    .filter(Boolean)
    .join('/');
}
s(Tp, 'pathJoin');
var rN = s((e, t, r) => {
    const { directory: n, importPathMatcher: o, titlePrefix: i = '' } = t || {};
    typeof e == 'number' &&
      Ve.warn(ve`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
    const a = tN(String(e));
    if (o.exec(a)) {
      if (!r) {
        const l = a.replace(n, '');
        let d = Tp([i, l]).split('/');
        return ((d = B3(d)), d.join('/'));
      }
      return i ? Tp([i, r]) : r;
    }
  }, 'userOrAutoTitleFromSpecifier'),
  J3 = s((e, t, r) => {
    for (let n = 0; n < t.length; n += 1) {
      const o = rN(e, t[n], r);
      if (o) return o;
    }
    return r || void 0;
  }, 'userOrAutoTitle'),
  av = /\s*\/\s*/,
  U3 = s(
    (e = {}) =>
      (t, r) => {
        if (t.title === r.title && !e.includeNames) return 0;
        const n = e.method || 'configure';
        let o = e.order || [];
        const i = t.title.trim().split(av),
          a = r.title.trim().split(av);
        e.includeNames && (i.push(t.name), a.push(r.name));
        let l = 0;
        for (; i[l] || a[l]; ) {
          if (!i[l]) return -1;
          if (!a[l]) return 1;
          const d = i[l],
            u = a[l];
          if (d !== u) {
            let f = o.indexOf(d),
              m = o.indexOf(u);
            const h = o.indexOf('*');
            return f !== -1 || m !== -1
              ? (f === -1 && (h !== -1 ? (f = h) : (f = o.length)),
                m === -1 && (h !== -1 ? (m = h) : (m = o.length)),
                f - m)
              : n === 'configure'
                ? 0
                : d.localeCompare(u, e.locales ? e.locales : void 0, {
                    numeric: !0,
                    sensitivity: 'accent',
                  });
          }
          let p = o.indexOf(d);
          (p === -1 && (p = o.indexOf('*')),
            (o = p !== -1 && Array.isArray(o[p + 1]) ? o[p + 1] : []),
            (l += 1));
        }
        return 0;
      },
    'storySort',
  ),
  V3 = s((e, t, r) => {
    if (t) {
      let n;
      (typeof t == 'function' ? (n = t) : (n = U3(t)), e.sort(n));
    } else e.sort((n, o) => r.indexOf(n.importPath) - r.indexOf(o.importPath));
    return e;
  }, 'sortStoriesCommon'),
  H3 = s((e, t, r) => {
    try {
      return V3(e, t, r);
    } catch (n) {
      throw new Error(ve`
    Error sorting stories with sort parameter ${t}:

    > ${n.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
    }
  }, 'sortStoriesV7'),
  zc = new Error('prepareAborted'),
  { AbortController: lv } = globalThis;
function Ep(e) {
  try {
    const { name: t = 'Error', message: r = String(e), stack: n } = e;
    return { name: t, message: r, stack: n };
  } catch {
    return { name: 'Error', message: String(e) };
  }
}
s(Ep, 'serializeError');
var nN = class {
  constructor(t, r, n, o, i, a, l = { autoplay: !0, forceInitialArgs: !1 }, d) {
    ((this.channel = t),
      (this.store = r),
      (this.renderToScreen = n),
      (this.callbacks = o),
      (this.id = i),
      (this.viewMode = a),
      (this.renderOptions = l),
      (this.type = 'story'),
      (this.notYetRendered = !0),
      (this.rerenderEnqueued = !1),
      (this.disableKeyListeners = !1),
      (this.teardownRender = s(() => {}, 'teardownRender')),
      (this.torndown = !1),
      (this.abortController = new lv()),
      (this.renderId = Date.now()),
      d && ((this.story = d), (this.phase = 'preparing')));
  }
  async runPhase(t, r, n) {
    ((this.phase = r),
      this.channel.emit(On, { newPhase: this.phase, renderId: this.renderId, storyId: this.id }),
      n && (await n(), this.checkIfAborted(t)));
  }
  checkIfAborted(t) {
    return (
      t.aborted &&
        !['finished', 'aborted', 'errored'].includes(this.phase) &&
        ((this.phase = 'aborted'),
        this.channel.emit(On, { newPhase: this.phase, renderId: this.renderId, storyId: this.id })),
      t.aborted
    );
  }
  async prepare() {
    if (
      (await this.runPhase(this.abortController.signal, 'preparing', async () => {
        this.story = await this.store.loadStory({ storyId: this.id });
      }),
      this.abortController.signal.aborted)
    )
      throw (await this.store.cleanupStory(this.story), zc);
  }
  isEqual(t) {
    return !!(this.id === t.id && this.story && this.story === t.story);
  }
  isPreparing() {
    return ['preparing'].includes(this.phase);
  }
  isPending() {
    return ['loading', 'beforeEach', 'rendering', 'playing', 'afterEach'].includes(this.phase);
  }
  async renderToElement(t) {
    return ((this.canvasElement = t), this.render({ initial: !0, forceRemount: !0 }));
  }
  storyContext() {
    if (!this.story) throw new Error('Cannot call storyContext before preparing');
    const { forceInitialArgs: t } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: t });
  }
  async render({ initial: t = !1, forceRemount: r = !1 } = {}) {
    const { canvasElement: n } = this;
    if (!this.story) throw new Error('cannot render when not prepared');
    const o = this.story;
    if (!n) throw new Error('cannot render when canvasElement is unset');
    const {
      id: i,
      componentId: a,
      title: l,
      name: d,
      tags: u,
      applyLoaders: p,
      applyBeforeEach: f,
      applyAfterEach: m,
      unboundStoryFn: h,
      playFunction: g,
      runStep: v,
    } = o;
    r && !t && (this.cancelRender(), (this.abortController = new lv()));
    const E = this.abortController.signal;
    let b = !1;
    const S = o.usesMount;
    try {
      const R = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: E,
        canvasElement: n,
        loaded: {},
        step: s((H, P) => v(H, P, R), 'step'),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: s(async () => {
          const H = await this.renderToScreen(I, n);
          ((this.teardownRender = H || (() => {})), (b = !0));
        }, 'renderToCanvas'),
        mount: s(async (...H) => {
          this.callbacks.showStoryDuringRender?.();
          let P = null;
          return (
            await this.runPhase(E, 'rendering', async () => {
              P = await o.mount(R)(...H);
            }),
            S && (await this.runPhase(E, 'playing')),
            P
          );
        }, 'mount'),
      };
      R.context = R;
      const I = {
        componentId: a,
        title: l,
        kind: l,
        id: i,
        name: d,
        story: d,
        tags: u,
        ...this.callbacks,
        showError: s((H) => ((this.phase = 'errored'), this.callbacks.showError(H)), 'showError'),
        showException: s(
          (H) => ((this.phase = 'errored'), this.callbacks.showException(H)),
          'showException',
        ),
        forceRemount: r || this.notYetRendered,
        storyContext: R,
        storyFn: s(() => h(R), 'storyFn'),
        unboundStoryFn: h,
      };
      if (
        (await this.runPhase(E, 'loading', async () => {
          R.loaded = await p(R);
        }),
        E.aborted)
      )
        return;
      const $ = await f(R);
      if (
        (this.store.addCleanupCallbacks(o, ...$),
        this.checkIfAborted(E) ||
          (!b && !S && (await R.mount()), (this.notYetRendered = !1), E.aborted))
      )
        return;
      const x = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0,
        A = new Set(),
        w = s((H) => {
          H.error && A.add(H.error);
        }, 'onError'),
        _ = s((H) => {
          H.reason && A.add(H.reason);
        }, 'onUnhandledRejection');
      if (this.renderOptions.autoplay && r && g && this.phase !== 'errored') {
        (window?.addEventListener?.('error', w),
          window?.addEventListener?.('unhandledrejection', _),
          (this.disableKeyListeners = !0));
        try {
          if (
            (S
              ? await g(R)
              : ((R.mount = async () => {
                  throw new pf({ playFunction: g.toString() });
                }),
                await this.runPhase(E, 'playing', async () => g(R))),
            !b)
          )
            throw new mw();
          (this.checkIfAborted(E),
            !x && A.size > 0
              ? await this.runPhase(E, 'errored')
              : await this.runPhase(E, 'played'));
        } catch (H) {
          if (
            (this.callbacks.showStoryDuringRender?.(),
            await this.runPhase(E, 'errored', async () => {
              this.channel.emit(nT, Ep(H));
            }),
            this.story.parameters.throwPlayFunctionExceptions !== !1)
          )
            throw H;
          console.error(H);
        }
        if (
          (!x && A.size > 0 && this.channel.emit(oT, Array.from(A).map(Ep)),
          (this.disableKeyListeners = !1),
          window?.removeEventListener?.('unhandledrejection', _),
          window?.removeEventListener?.('error', w),
          E.aborted)
        )
          return;
      }
      (await this.runPhase(E, 'completing', async () => {
        zh() ? this.store.addCleanupCallbacks(o, Vc()) : await Hc(E);
      }),
        await this.runPhase(E, 'completed', async () => {
          this.channel.emit(Ta, i);
        }),
        this.phase !== 'errored' &&
          (await this.runPhase(E, 'afterEach', async () => {
            await m(R);
          })));
      const j = !x && A.size > 0,
        N = R.reporting.reports.some((H) => H.status === 'failed'),
        V = j || N;
      await this.runPhase(E, 'finished', async () =>
        this.channel.emit(Cu, {
          storyId: i,
          status: V ? 'error' : 'success',
          reporters: R.reporting.reports,
        }),
      );
    } catch (R) {
      ((this.phase = 'errored'),
        this.callbacks.showException(R),
        await this.runPhase(E, 'finished', async () =>
          this.channel.emit(Cu, { storyId: i, status: 'error', reporters: [] }),
        ));
    }
    this.rerenderEnqueued && ((this.rerenderEnqueued = !1), this.render());
  }
  async rerender() {
    if (this.isPending() && this.phase !== 'playing') this.rerenderEnqueued = !0;
    else return this.render();
  }
  async remount() {
    return (await this.teardown(), this.render({ forceRemount: !0 }));
  }
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === 'playing' &&
      (this.abortController.abort(), this.runPhase(this.abortController.signal, 'aborted'));
  }
  async teardown() {
    ((this.torndown = !0),
      this.cancelRender(),
      this.story && (await this.store.cleanupStory(this.story)));
    for (let t = 0; t < 3; t += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((r) => setTimeout(r, 0));
    }
    (window?.location?.reload?.(), await new Promise(() => {}));
  }
};
s(nN, 'StoryRender');
var wp = nN,
  { fetch: z3 } = te,
  G3 = './index.json',
  oN = class {
    constructor(t, r, n = Ut.getChannel(), o = !0) {
      ((this.importFn = t),
        (this.getProjectAnnotations = r),
        (this.channel = n),
        (this.storyRenders = []),
        (this.storeInitializationPromise = new Promise((i, a) => {
          ((this.resolveStoreInitializationPromise = i),
            (this.rejectStoreInitializationPromise = a));
        })),
        o && this.initialize());
    }
    get storyStore() {
      return new Proxy(
        {},
        {
          get: s((t, r) => {
            if (this.storyStoreValue)
              return (
                Qp('Accessing the Story Store is deprecated and will be removed in 9.0'),
                this.storyStoreValue[r]
              );
            throw new cw();
          }, 'get'),
        },
      );
    }
    async initialize() {
      this.setupListeners();
      try {
        const t = await this.getProjectAnnotationsOrRenderError();
        (await this.runBeforeAllHook(t), await this.initializeWithProjectAnnotations(t));
        const r = globalThis?.navigator?.userAgent;
        await this.channel.emit(iT, { userAgent: r });
      } catch (t) {
        this.rejectStoreInitializationPromise(t);
      }
    }
    ready() {
      return this.storeInitializationPromise;
    }
    setupListeners() {
      (this.channel.on(pT, this.onStoryIndexChanged.bind(this)),
        this.channel.on(Yp, this.onUpdateGlobals.bind(this)),
        this.channel.on(Xp, this.onUpdateArgs.bind(this)),
        this.channel.on(TT, this.onRequestArgTypesInfo.bind(this)),
        this.channel.on(Wp, this.onResetArgs.bind(this)),
        this.channel.on(Gp, this.onForceReRender.bind(this)),
        this.channel.on(va, this.onForceRemount.bind(this)),
        this.channel.on(gT, this.onStoryHotUpdated.bind(this)));
    }
    async getProjectAnnotationsOrRenderError() {
      try {
        const t = await this.getProjectAnnotations();
        if (((this.renderToCanvas = t.renderToCanvas), !this.renderToCanvas)) throw new YE();
        return t;
      } catch (t) {
        throw (this.renderPreviewEntryError('Error reading preview.js:', t), t);
      }
    }
    async initializeWithProjectAnnotations(t) {
      this.projectAnnotationsBeforeInitialization = t;
      try {
        const r = await this.getStoryIndexFromServer();
        return this.initializeWithStoryIndex(r);
      } catch (r) {
        throw (this.renderPreviewEntryError('Error loading story index:', r), r);
      }
    }
    async runBeforeAllHook(t) {
      try {
        (await this.beforeAllCleanup?.(), (this.beforeAllCleanup = await t.beforeAll?.()));
      } catch (r) {
        throw (this.renderPreviewEntryError('Error in beforeAll hook:', r), r);
      }
    }
    async getStoryIndexFromServer() {
      const t = await z3(G3);
      if (t.status === 200) return t.json();
      throw new ZE({ text: await t.text() });
    }
    initializeWithStoryIndex(t) {
      if (!this.projectAnnotationsBeforeInitialization)
        throw new Error('Cannot call initializeWithStoryIndex until project annotations resolve');
      ((this.storyStoreValue = new eN(
        t,
        this.importFn,
        this.projectAnnotationsBeforeInitialization,
      )),
        delete this.projectAnnotationsBeforeInitialization,
        this.setInitialGlobals(),
        this.resolveStoreInitializationPromise());
    }
    async setInitialGlobals() {
      this.emitGlobals();
    }
    emitGlobals() {
      if (!this.storyStoreValue) throw new It({ methodName: 'emitGlobals' });
      const t = {
        globals: this.storyStoreValue.userGlobals.get() || {},
        globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {},
      };
      this.channel.emit(lT, t);
    }
    async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
      (delete this.previewEntryError, (this.getProjectAnnotations = t));
      const r = await this.getProjectAnnotationsOrRenderError();
      if ((await this.runBeforeAllHook(r), !this.storyStoreValue)) {
        await this.initializeWithProjectAnnotations(r);
        return;
      }
      (this.storyStoreValue.setProjectAnnotations(r), this.emitGlobals());
    }
    async onStoryIndexChanged() {
      if (
        (delete this.previewEntryError,
        !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      )
        try {
          const t = await this.getStoryIndexFromServer();
          if (this.projectAnnotationsBeforeInitialization) {
            this.initializeWithStoryIndex(t);
            return;
          }
          await this.onStoriesChanged({ storyIndex: t });
        } catch (t) {
          throw (this.renderPreviewEntryError('Error loading story index:', t), t);
        }
    }
    async onStoriesChanged({ importFn: t, storyIndex: r }) {
      if (!this.storyStoreValue) throw new It({ methodName: 'onStoriesChanged' });
      await this.storyStoreValue.onStoriesChanged({ importFn: t, storyIndex: r });
    }
    async onUpdateGlobals({ globals: t, currentStory: r }) {
      if ((this.storyStoreValue || (await this.storeInitializationPromise), !this.storyStoreValue))
        throw new It({ methodName: 'onUpdateGlobals' });
      if ((this.storyStoreValue.userGlobals.update(t), r)) {
        const {
          initialGlobals: n,
          storyGlobals: o,
          userGlobals: i,
          globals: a,
        } = this.storyStoreValue.getStoryContext(r);
        this.channel.emit(Xs, { initialGlobals: n, userGlobals: i, storyGlobals: o, globals: a });
      } else {
        const { initialGlobals: n, globals: o } = this.storyStoreValue.userGlobals;
        this.channel.emit(Xs, { initialGlobals: n, userGlobals: o, storyGlobals: {}, globals: o });
      }
      await Promise.all(this.storyRenders.map((n) => n.rerender()));
    }
    async onUpdateArgs({ storyId: t, updatedArgs: r }) {
      if (!this.storyStoreValue) throw new It({ methodName: 'onUpdateArgs' });
      (this.storyStoreValue.args.update(t, r),
        await Promise.all(
          this.storyRenders
            .filter((n) => n.id === t && !n.renderOptions.forceInitialArgs)
            .map((n) => (n.story && n.story.usesMount ? n.remount() : n.rerender())),
        ),
        this.channel.emit(cT, { storyId: t, args: this.storyStoreValue.args.get(t) }));
    }
    async onRequestArgTypesInfo({ id: t, payload: r }) {
      try {
        await this.storeInitializationPromise;
        const n = await this.storyStoreValue?.loadStory(r);
        this.channel.emit(Iu, {
          id: t,
          success: !0,
          payload: { argTypes: n?.argTypes || {} },
          error: null,
        });
      } catch (n) {
        this.channel.emit(Iu, { id: t, success: !1, error: n?.message });
      }
    }
    async onResetArgs({ storyId: t, argNames: r }) {
      if (!this.storyStoreValue) throw new It({ methodName: 'onResetArgs' });
      const o =
          this.storyRenders.find((l) => l.id === t)?.story ||
          (await this.storyStoreValue.loadStory({ storyId: t })),
        a = (
          r || [
            ...new Set([
              ...Object.keys(o.initialArgs),
              ...Object.keys(this.storyStoreValue.args.get(t)),
            ]),
          ]
        ).reduce((l, d) => ((l[d] = o.initialArgs[d]), l), {});
      await this.onUpdateArgs({ storyId: t, updatedArgs: a });
    }
    async onForceReRender() {
      await Promise.all(this.storyRenders.map((t) => t.rerender()));
    }
    async onForceRemount({ storyId: t }) {
      await Promise.all(this.storyRenders.filter((r) => r.id === t).map((r) => r.remount()));
    }
    async onStoryHotUpdated() {
      await Promise.all(this.storyRenders.map((t) => t.cancelPlayFunction()));
    }
    renderStoryToElement(t, r, n, o) {
      if (!this.renderToCanvas || !this.storyStoreValue)
        throw new It({ methodName: 'renderStoryToElement' });
      const i = new wp(
        this.channel,
        this.storyStoreValue,
        this.renderToCanvas,
        n,
        t.id,
        'docs',
        o,
        t,
      );
      return (
        i.renderToElement(r),
        this.storyRenders.push(i),
        async () => {
          await this.teardownRender(i);
        }
      );
    }
    async teardownRender(t, { viewModeChanged: r } = {}) {
      ((this.storyRenders = this.storyRenders.filter((n) => n !== t)),
        await t?.teardown?.({ viewModeChanged: r }));
    }
    async loadStory({ storyId: t }) {
      if (!this.storyStoreValue) throw new It({ methodName: 'loadStory' });
      return this.storyStoreValue.loadStory({ storyId: t });
    }
    getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
      if (!this.storyStoreValue) throw new It({ methodName: 'getStoryContext' });
      return this.storyStoreValue.getStoryContext(t, { forceInitialArgs: r });
    }
    async extract(t) {
      if (!this.storyStoreValue) throw new It({ methodName: 'extract' });
      if (this.previewEntryError) throw this.previewEntryError;
      return (await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(t));
    }
    renderPreviewEntryError(t, r) {
      ((this.previewEntryError = r), ke.error(t), ke.error(r), this.channel.emit(tT, r));
    }
  };
s(oN, 'Preview');
var sN = oN,
  iN = class {
    constructor(t, r, n, o) {
      ((this.channel = t),
        (this.store = r),
        (this.renderStoryToElement = n),
        (this.storyIdByName = s((i) => {
          const a = this.nameToStoryId.get(i);
          if (a) return a;
          throw new Error(`No story found with that name: ${i}`);
        }, 'storyIdByName')),
        (this.componentStories = s(() => this.componentStoriesValue, 'componentStories')),
        (this.componentStoriesFromCSFFile = s(
          (i) => this.store.componentStoriesFromCSFFile({ csfFile: i }),
          'componentStoriesFromCSFFile',
        )),
        (this.storyById = s((i) => {
          if (!i) {
            if (!this.primaryStory)
              throw new Error(
                'No primary story defined for docs entry. Did you forget to use `<Meta>`?',
              );
            return this.primaryStory;
          }
          const a = this.storyIdToCSFFile.get(i);
          if (!a) throw new Error(`Called \`storyById\` for story that was never loaded: ${i}`);
          return this.store.storyFromCSFFile({ storyId: i, csfFile: a });
        }, 'storyById')),
        (this.getStoryContext = s(
          (i) => ({ ...this.store.getStoryContext(i), loaded: {}, viewMode: 'docs' }),
          'getStoryContext',
        )),
        (this.loadStory = s((i) => this.store.loadStory({ storyId: i }), 'loadStory')),
        (this.componentStoriesValue = []),
        (this.storyIdToCSFFile = new Map()),
        (this.exportToStory = new Map()),
        (this.exportsToCSFFile = new Map()),
        (this.nameToStoryId = new Map()),
        (this.attachedCSFFiles = new Set()),
        o.forEach((i, a) => {
          this.referenceCSFFile(i);
        }));
    }
    referenceCSFFile(t) {
      (this.exportsToCSFFile.set(t.moduleExports, t),
        this.exportsToCSFFile.set(t.moduleExports.default, t),
        this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
          const o = t.stories[n.id];
          (this.storyIdToCSFFile.set(o.id, t), this.exportToStory.set(o.moduleExport, n));
        }));
    }
    attachCSFFile(t) {
      if (!this.exportsToCSFFile.has(t.moduleExports))
        throw new Error('Cannot attach a CSF file that has not been referenced');
      if (this.attachedCSFFiles.has(t)) return;
      (this.attachedCSFFiles.add(t),
        this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
          (this.nameToStoryId.set(n.name, n.id),
            this.componentStoriesValue.push(n),
            this.primaryStory || (this.primaryStory = n));
        }));
    }
    referenceMeta(t, r) {
      const n = this.resolveModuleExport(t);
      if (n.type !== 'meta')
        throw new Error(
          '<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?',
        );
      r && this.attachCSFFile(n.csfFile);
    }
    get projectAnnotations() {
      const { projectAnnotations: t } = this.store;
      if (!t)
        throw new Error(
          "Can't get projectAnnotations from DocsContext before they are initialized",
        );
      return t;
    }
    resolveAttachedModuleExportType(t) {
      if (t === 'story') {
        if (!this.primaryStory)
          throw new Error(
            'No primary story attached to this docs file, did you forget to use <Meta of={} />?',
          );
        return { type: 'story', story: this.primaryStory };
      }
      if (this.attachedCSFFiles.size === 0)
        throw new Error(
          'No CSF file attached to this docs file, did you forget to use <Meta of={} />?',
        );
      const r = Array.from(this.attachedCSFFiles)[0];
      if (t === 'meta') return { type: 'meta', csfFile: r };
      const { component: n } = r.meta;
      if (!n)
        throw new Error(
          'Attached CSF file does not defined a component, did you forget to export one?',
        );
      return { type: 'component', component: n };
    }
    resolveModuleExport(t) {
      const r = this.exportsToCSFFile.get(t);
      if (r) return { type: 'meta', csfFile: r };
      const n = this.exportToStory.get(Jc(t) ? t.input : t);
      return n ? { type: 'story', story: n } : { type: 'component', component: t };
    }
    resolveOf(t, r = []) {
      let n;
      if (['component', 'meta', 'story'].includes(t)) {
        const o = t;
        n = this.resolveAttachedModuleExportType(o);
      } else n = this.resolveModuleExport(t);
      if (r.length && !r.includes(n.type)) {
        const o = n.type === 'component' ? 'component or unknown' : n.type;
        throw new Error(ve`Invalid value passed to the 'of' prop. The value was resolved to a '${o}' type but the only types for this block are: ${r.join(', ')}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
      }
      switch (n.type) {
        case 'component':
          return { ...n, projectAnnotations: this.projectAnnotations };
        case 'meta':
          return { ...n, preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: n.csfFile }) };
        case 'story':
        default:
          return n;
      }
    }
  };
s(iN, 'DocsContext');
var Xh = iN,
  aN = class {
    constructor(t, r, n, o) {
      ((this.channel = t),
        (this.store = r),
        (this.entry = n),
        (this.callbacks = o),
        (this.type = 'docs'),
        (this.subtype = 'csf'),
        (this.torndown = !1),
        (this.disableKeyListeners = !1),
        (this.preparing = !1),
        (this.id = n.id),
        (this.renderId = Date.now()));
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
      if (this.torndown) throw zc;
      const { importPath: n, title: o } = this.entry,
        i = this.store.processCSFFileWithCache(t, n, o),
        a = Object.keys(i.stories)[0];
      ((this.story = this.store.storyFromCSFFile({ storyId: a, csfFile: i })),
        (this.csfFiles = [i, ...r]),
        (this.preparing = !1));
    }
    isEqual(t) {
      return !!(this.id === t.id && this.story && this.story === t.story);
    }
    docsContext(t) {
      if (!this.csfFiles) throw new Error('Cannot render docs before preparing');
      const r = new Xh(this.channel, this.store, t, this.csfFiles);
      return (this.csfFiles.forEach((n) => r.attachCSFFile(n)), r);
    }
    async renderToElement(t, r) {
      if (!this.story || !this.csfFiles) throw new Error('Cannot render docs before preparing');
      const n = this.docsContext(r),
        { docs: o } = this.story.parameters || {};
      if (!o)
        throw new Error(
          'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed',
        );
      const i = await o.renderer(),
        { render: a } = i,
        l = s(async () => {
          try {
            (await a(n, o, t), this.channel.emit(zp, this.id));
          } catch (d) {
            this.callbacks.showException(d);
          }
        }, 'renderDocs');
      return (
        (this.rerender = async () => l()),
        (this.teardownRender = async ({ viewModeChanged: d }) => {
          !d || !t || i.unmount(t);
        }),
        l()
      );
    }
    async teardown({ viewModeChanged: t } = {}) {
      (this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0));
    }
  };
s(aN, 'CsfDocsRender');
var cv = aN,
  lN = class {
    constructor(t, r, n, o) {
      ((this.channel = t),
        (this.store = r),
        (this.entry = n),
        (this.callbacks = o),
        (this.type = 'docs'),
        (this.subtype = 'mdx'),
        (this.torndown = !1),
        (this.disableKeyListeners = !1),
        (this.preparing = !1),
        (this.id = n.id),
        (this.renderId = Date.now()));
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
      if (this.torndown) throw zc;
      ((this.csfFiles = r), (this.exports = t), (this.preparing = !1));
    }
    isEqual(t) {
      return !!(this.id === t.id && this.exports && this.exports === t.exports);
    }
    docsContext(t) {
      if (!this.csfFiles) throw new Error('Cannot render docs before preparing');
      return new Xh(this.channel, this.store, t, this.csfFiles);
    }
    async renderToElement(t, r) {
      if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
        throw new Error('Cannot render docs before preparing');
      const n = this.docsContext(r),
        { docs: o } = this.store.projectAnnotations.parameters ?? {};
      if (!o)
        throw new Error(
          'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed',
        );
      const i = { ...o, page: this.exports.default },
        a = await o.renderer(),
        { render: l } = a,
        d = s(async () => {
          try {
            (await l(n, i, t), this.channel.emit(zp, this.id));
          } catch (u) {
            this.callbacks.showException(u);
          }
        }, 'renderDocs');
      return (
        (this.rerender = async () => d()),
        (this.teardownRender = async ({ viewModeChanged: u } = {}) => {
          !u || !t || (a.unmount(t), (this.torndown = !0));
        }),
        d()
      );
    }
    async teardown({ viewModeChanged: t } = {}) {
      (this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0));
    }
  };
s(lN, 'MdxDocsRender');
var uv = lN,
  W3 = globalThis;
function cN(e) {
  const t = (e.composedPath && e.composedPath()[0]) || e.target;
  return /input|textarea/i.test(t.tagName) || t.getAttribute('contenteditable') !== null;
}
s(cN, 'focusInInput');
var uN = 'attached-mdx',
  K3 = 'unattached-mdx';
function dN({ tags: e }) {
  return e?.includes(K3) || e?.includes(uN);
}
s(dN, 'isMdxEntry');
function ma(e) {
  return e.type === 'story';
}
s(ma, 'isStoryRender');
function pN(e) {
  return e.type === 'docs';
}
s(pN, 'isDocsRender');
function fN(e) {
  return pN(e) && e.subtype === 'csf';
}
s(fN, 'isCsfDocsRender');
var mN = class extends sN {
  constructor(t, r, n, o) {
    (super(t, r, void 0, !1),
      (this.importFn = t),
      (this.getProjectAnnotations = r),
      (this.selectionStore = n),
      (this.view = o),
      this.initialize());
  }
  setupListeners() {
    (super.setupListeners(),
      (W3.onkeydown = this.onKeydown.bind(this)),
      this.channel.on(Kp, this.onSetCurrentStory.bind(this)),
      this.channel.on(bT, this.onUpdateQueryParams.bind(this)),
      this.channel.on(sT, this.onPreloadStories.bind(this)));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue) throw new It({ methodName: 'setInitialGlobals' });
    const { globals: t } = this.selectionStore.selectionSpecifier || {};
    (t && this.storyStoreValue.userGlobals.updateFromPersisted(t), this.emitGlobals());
  }
  async initializeWithStoryIndex(t) {
    return (await super.initializeWithStoryIndex(t), this.selectSpecifiedStory());
  }
  async selectSpecifiedStory() {
    if (!this.storyStoreValue) throw new It({ methodName: 'selectSpecifiedStory' });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    const { storySpecifier: t, args: r } = this.selectionStore.selectionSpecifier,
      n = this.storyStoreValue.storyIndex.entryFromSpecifier(t);
    if (!n) {
      t === '*'
        ? this.renderStoryLoadingException(t, new nw())
        : this.renderStoryLoadingException(t, new sw({ storySpecifier: t.toString() }));
      return;
    }
    const { id: o, type: i } = n;
    (this.selectionStore.setSelection({ storyId: o, viewMode: i }),
      this.channel.emit(mT, this.selectionStore.selection),
      this.channel.emit(xu, this.selectionStore.selection),
      await this.renderSelection({ persistedArgs: r }));
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
    (await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: t }),
      this.selectionStore.selection && this.renderSelection());
  }
  async onStoriesChanged({ importFn: t, storyIndex: r }) {
    (await super.onStoriesChanged({ importFn: t, storyIndex: r }),
      this.selectionStore.selection
        ? await this.renderSelection()
        : await this.selectSpecifiedStory());
  }
  onKeydown(t) {
    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !cN(t)) {
      const { altKey: r, ctrlKey: n, metaKey: o, shiftKey: i, key: a, code: l, keyCode: d } = t;
      this.channel.emit(aT, {
        event: { altKey: r, ctrlKey: n, metaKey: o, shiftKey: i, key: a, code: l, keyCode: d },
      });
    }
  }
  async onSetCurrentStory(t) {
    (this.selectionStore.setSelection({ viewMode: 'story', ...t }),
      await this.storeInitializationPromise,
      this.channel.emit(xu, this.selectionStore.selection),
      this.renderSelection());
  }
  onUpdateQueryParams(t) {
    this.selectionStore.setQueryParams(t);
  }
  async onUpdateGlobals({ globals: t }) {
    const r = (this.currentRender instanceof wp && this.currentRender.story) || void 0;
    (super.onUpdateGlobals({ globals: t, currentStory: r }),
      (this.currentRender instanceof uv || this.currentRender instanceof cv) &&
        (await this.currentRender.rerender?.()));
  }
  async onUpdateArgs({ storyId: t, updatedArgs: r }) {
    super.onUpdateArgs({ storyId: t, updatedArgs: r });
  }
  async onPreloadStories({ ids: t }) {
    (await this.storeInitializationPromise,
      this.storyStoreValue &&
        (await Promise.allSettled(t.map((r) => this.storyStoreValue?.loadEntry(r)))));
  }
  async renderSelection({ persistedArgs: t } = {}) {
    const { renderToCanvas: r } = this;
    if (!this.storyStoreValue || !r) throw new It({ methodName: 'renderSelection' });
    const { selection: n } = this.selectionStore;
    if (!n) throw new Error('Cannot call renderSelection as no selection was made');
    const { storyId: o } = n;
    let i;
    try {
      i = await this.storyStoreValue.storyIdToEntry(o);
    } catch (m) {
      (this.currentRender && (await this.teardownRender(this.currentRender)),
        this.renderStoryLoadingException(o, m));
      return;
    }
    const a = this.currentSelection?.storyId !== o,
      l = this.currentRender?.type !== i.type;
    (i.type === 'story'
      ? this.view.showPreparingStory({ immediate: l })
      : this.view.showPreparingDocs({ immediate: l }),
      this.currentRender?.isPreparing() && (await this.teardownRender(this.currentRender)));
    let d;
    i.type === 'story'
      ? (d = new wp(this.channel, this.storyStoreValue, r, this.mainStoryCallbacks(o), o, 'story'))
      : dN(i)
        ? (d = new uv(this.channel, this.storyStoreValue, i, this.mainStoryCallbacks(o)))
        : (d = new cv(this.channel, this.storyStoreValue, i, this.mainStoryCallbacks(o)));
    const u = this.currentSelection;
    this.currentSelection = n;
    const p = this.currentRender;
    this.currentRender = d;
    try {
      await d.prepare();
    } catch (m) {
      (p && (await this.teardownRender(p)), m !== zc && this.renderStoryLoadingException(o, m));
      return;
    }
    const f = !a && p && !d.isEqual(p);
    if (
      (t && ma(d) && (lr(!!d.story), this.storyStoreValue.args.updateFromPersisted(d.story, t)),
      p && !p.torndown && !a && !f && !l)
    ) {
      ((this.currentRender = p), this.channel.emit(hT, o), this.view.showMain());
      return;
    }
    if (
      (p && (await this.teardownRender(p, { viewModeChanged: l })),
      u && (a || l) && this.channel.emit(uT, o),
      ma(d))
    ) {
      lr(!!d.story);
      const {
        parameters: m,
        initialArgs: h,
        argTypes: g,
        unmappedArgs: v,
        initialGlobals: E,
        userGlobals: b,
        storyGlobals: S,
        globals: R,
      } = this.storyStoreValue.getStoryContext(d.story);
      (this.channel.emit(fT, { id: o, parameters: m, initialArgs: h, argTypes: g, args: v }),
        this.channel.emit(Xs, { userGlobals: b, storyGlobals: S, globals: R, initialGlobals: E }));
    } else {
      let { parameters: m } = this.storyStoreValue.projectAnnotations;
      const { initialGlobals: h, globals: g } = this.storyStoreValue.userGlobals;
      if (
        (this.channel.emit(Xs, { globals: g, initialGlobals: h, storyGlobals: {}, userGlobals: g }),
        fN(d) || d.entry.tags?.includes(uN))
      ) {
        if (!d.csfFiles) throw new tw({ storyId: o });
        ({ parameters: m } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: d.csfFiles[0],
        }));
      }
      this.channel.emit(rT, { id: o, parameters: m });
    }
    ma(d)
      ? (lr(!!d.story),
        this.storyRenders.push(d),
        this.currentRender.renderToElement(this.view.prepareForStory(d.story)))
      : this.currentRender.renderToElement(
          this.view.prepareForDocs(),
          this.renderStoryToElement.bind(this),
        );
  }
  async teardownRender(t, { viewModeChanged: r = !1 } = {}) {
    ((this.storyRenders = this.storyRenders.filter((n) => n !== t)),
      await t?.teardown?.({ viewModeChanged: r }));
  }
  mainStoryCallbacks(t) {
    return {
      showStoryDuringRender: s(() => this.view.showStoryDuringRender(), 'showStoryDuringRender'),
      showMain: s(() => this.view.showMain(), 'showMain'),
      showError: s((r) => this.renderError(t, r), 'showError'),
      showException: s((r) => this.renderException(t, r), 'showException'),
    };
  }
  renderPreviewEntryError(t, r) {
    (super.renderPreviewEntryError(t, r), this.view.showErrorDisplay(r));
  }
  renderMissingStory() {
    (this.view.showNoPreview(), this.channel.emit(Ou));
  }
  renderStoryLoadingException(t, r) {
    (ke.error(r), this.view.showErrorDisplay(r), this.channel.emit(Ou, t));
  }
  renderException(t, r) {
    const { name: n = 'Error', message: o = String(r), stack: i } = r,
      a = this.currentRender?.renderId;
    (this.channel.emit(yT, { name: n, message: o, stack: i }),
      this.channel.emit(On, { newPhase: 'errored', renderId: a, storyId: t }),
      this.view.showErrorDisplay(r),
      ke.error(`Error rendering story '${t}':`),
      ke.error(r));
  }
  renderError(t, { title: r, description: n }) {
    const o = this.currentRender?.renderId;
    (this.channel.emit(dT, { title: r, description: n }),
      this.channel.emit(On, { newPhase: 'errored', renderId: o, storyId: t }),
      this.view.showErrorDisplay({ message: r, stack: n }),
      ke.error(`Error rendering story ${r}: ${n}`));
  }
};
s(mN, 'PreviewWithSelection');
var yN = mN,
  Sp = Ke(Up(), 1),
  Y3 = Ke(Up(), 1),
  dv = /^[a-zA-Z0-9 _-]*$/,
  hN = /^-?[0-9]+(\.[0-9]+)?$/,
  X3 = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i,
  gN =
    /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i,
  _p = s(
    (e = '', t) =>
      e === null || e === '' || !dv.test(e)
        ? !1
        : t == null || t instanceof Date || typeof t == 'number' || typeof t == 'boolean'
          ? !0
          : typeof t == 'string'
            ? dv.test(t) || hN.test(t) || X3.test(t) || gN.test(t)
            : Array.isArray(t)
              ? t.every((r) => _p(e, r))
              : Qt(t)
                ? Object.entries(t).every(([r, n]) => _p(r, n))
                : !1,
    'validateArgs',
  ),
  Q3 = {
    delimiter: ';',
    nesting: !0,
    arrayRepeat: !0,
    arrayRepeatSyntax: 'bracket',
    nestingSyntax: 'js',
    valueDeserializer(e) {
      if (e.startsWith('!')) {
        if (e === '!undefined') return;
        if (e === '!null') return null;
        if (e === '!true') return !0;
        if (e === '!false') return !1;
        if (e.startsWith('!date(') && e.endsWith(')'))
          return new Date(e.replaceAll(' ', '+').slice(6, -1));
        if (e.startsWith('!hex(') && e.endsWith(')')) return `#${e.slice(5, -1)}`;
        const t = e.slice(1).match(gN);
        if (t)
          return e.startsWith('!rgba') || e.startsWith('!RGBA')
            ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})`
            : e.startsWith('!hsla') || e.startsWith('!HSLA')
              ? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})`
              : e.startsWith('!rgb') || e.startsWith('!RGB')
                ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})`
                : `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`;
      }
      return hN.test(e) ? Number(e) : e;
    },
  },
  pv = s((e) => {
    const t = e.split(';').map((r) => r.replace('=', '~').replace(':', '='));
    return Object.entries((0, Y3.parse)(t.join(';'), Q3)).reduce(
      (r, [n, o]) =>
        _p(n, o)
          ? Object.assign(r, { [n]: o })
          : (Ve.warn(ve`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `),
            r),
      {},
    );
  }, 'parseArgsParam'),
  { history: bN, document: Kr } = te;
function vN(e) {
  const t = (e || '').match(/^\/story\/(.+)/);
  if (!t) throw new Error(`Invalid path '${e}',  must start with '/story/'`);
  return t[1];
}
s(vN, 'pathToId');
var TN = s(({ selection: e, extraParams: t }) => {
    const r = Kr?.location.search.slice(1),
      { path: n, selectedKind: o, selectedStory: i, ...a } = (0, Sp.parse)(r);
    return `?${(0, Sp.stringify)({ ...a, ...t, ...(e && { id: e.storyId, viewMode: e.viewMode }) })}`;
  }, 'getQueryString'),
  Z3 = s((e) => {
    if (!e) return;
    const t = TN({ selection: e }),
      { hash: r = '' } = Kr.location;
    ((Kr.title = e.storyId), bN.replaceState({}, '', `${Kr.location.pathname}${t}${r}`));
  }, 'setPath'),
  ez = s((e) => e != null && typeof e == 'object' && Array.isArray(e) === !1, 'isObject'),
  Ys = s((e) => {
    if (e !== void 0) {
      if (typeof e == 'string') return e;
      if (Array.isArray(e)) return Ys(e[0]);
      if (ez(e)) return Ys(Object.values(e).filter(Boolean));
    }
  }, 'getFirstString'),
  tz = s(() => {
    if (typeof Kr < 'u') {
      const e = Kr.location.search.slice(1),
        t = (0, Sp.parse)(e),
        r = typeof t.args == 'string' ? pv(t.args) : void 0,
        n = typeof t.globals == 'string' ? pv(t.globals) : void 0;
      let o = Ys(t.viewMode);
      (typeof o != 'string' || !o.match(/docs|story/)) && (o = 'story');
      const i = Ys(t.path),
        a = i ? vN(i) : Ys(t.id);
      if (a) return { storySpecifier: a, args: r, globals: n, viewMode: o };
    }
    return null;
  }, 'getSelectionSpecifierFromPath'),
  EN = class {
    constructor() {
      this.selectionSpecifier = tz();
    }
    setSelection(t) {
      ((this.selection = t), Z3(this.selection));
    }
    setQueryParams(t) {
      const r = TN({ extraParams: t }),
        { hash: n = '' } = Kr.location;
      bN.replaceState({}, '', `${Kr.location.pathname}${r}${n}`);
    }
  };
s(EN, 'UrlStore');
var wN = EN,
  rz = Ke(R1(), 1),
  nz = Ke(Up(), 1),
  { document: vt } = te,
  fv = 100,
  SN = ((e) => (
    (e.MAIN = 'MAIN'),
    (e.NOPREVIEW = 'NOPREVIEW'),
    (e.PREPARING_STORY = 'PREPARING_STORY'),
    (e.PREPARING_DOCS = 'PREPARING_DOCS'),
    (e.ERROR = 'ERROR'),
    e
  ))(SN || {}),
  Eu = {
    PREPARING_STORY: 'sb-show-preparing-story',
    PREPARING_DOCS: 'sb-show-preparing-docs',
    MAIN: 'sb-show-main',
    NOPREVIEW: 'sb-show-nopreview',
    ERROR: 'sb-show-errordisplay',
  },
  wu = { centered: 'sb-main-centered', fullscreen: 'sb-main-fullscreen', padded: 'sb-main-padded' },
  mv = new rz.default({ escapeXML: !0 }),
  _N = class {
    constructor() {
      if (((this.testing = !1), typeof vt < 'u')) {
        const { __SPECIAL_TEST_PARAMETER__: t } = (0, nz.parse)(vt.location.search.slice(1));
        switch (t) {
          case 'preparing-story': {
            (this.showPreparingStory(), (this.testing = !0));
            break;
          }
          case 'preparing-docs': {
            (this.showPreparingDocs(), (this.testing = !0));
            break;
          }
        }
      }
    }
    prepareForStory(t) {
      return (
        this.showStory(),
        this.applyLayout(t.parameters.layout),
        (vt.documentElement.scrollTop = 0),
        (vt.documentElement.scrollLeft = 0),
        this.storyRoot()
      );
    }
    storyRoot() {
      return vt.getElementById('storybook-root');
    }
    prepareForDocs() {
      return (
        this.showMain(),
        this.showDocs(),
        this.applyLayout('fullscreen'),
        (vt.documentElement.scrollTop = 0),
        (vt.documentElement.scrollLeft = 0),
        this.docsRoot()
      );
    }
    docsRoot() {
      return vt.getElementById('storybook-docs');
    }
    applyLayout(t = 'padded') {
      if (t === 'none') {
        (vt.body.classList.remove(this.currentLayoutClass), (this.currentLayoutClass = null));
        return;
      }
      this.checkIfLayoutExists(t);
      const r = wu[t];
      (vt.body.classList.remove(this.currentLayoutClass),
        vt.body.classList.add(r),
        (this.currentLayoutClass = r));
    }
    checkIfLayoutExists(t) {
      wu[t] ||
        ke.warn(ve`
          The desired layout: ${t} is not a valid option.
          The possible options are: ${Object.keys(wu).join(', ')}, none.
        `);
    }
    showMode(t) {
      (clearTimeout(this.preparingTimeout),
        Object.keys(SN).forEach((r) => {
          r === t ? vt.body.classList.add(Eu[r]) : vt.body.classList.remove(Eu[r]);
        }));
    }
    showErrorDisplay({ message: t = '', stack: r = '' }) {
      let n = t,
        o = r;
      const i = t.split(`
`);
      (i.length > 1 &&
        (([n] = i),
        (o = i
          .slice(1)
          .join(
            `
`,
          )
          .replace(/^\n/, ''))),
        (vt.getElementById('error-message').innerHTML = mv.toHtml(n)),
        (vt.getElementById('error-stack').innerHTML = mv.toHtml(o)),
        this.showMode('ERROR'));
    }
    showNoPreview() {
      this.testing ||
        (this.showMode('NOPREVIEW'),
        this.storyRoot()?.setAttribute('hidden', 'true'),
        this.docsRoot()?.setAttribute('hidden', 'true'));
    }
    showPreparingStory({ immediate: t = !1 } = {}) {
      (clearTimeout(this.preparingTimeout),
        t
          ? this.showMode('PREPARING_STORY')
          : (this.preparingTimeout = setTimeout(() => this.showMode('PREPARING_STORY'), fv)));
    }
    showPreparingDocs({ immediate: t = !1 } = {}) {
      (clearTimeout(this.preparingTimeout),
        t
          ? this.showMode('PREPARING_DOCS')
          : (this.preparingTimeout = setTimeout(() => this.showMode('PREPARING_DOCS'), fv)));
    }
    showMain() {
      this.showMode('MAIN');
    }
    showDocs() {
      (this.storyRoot().setAttribute('hidden', 'true'), this.docsRoot().removeAttribute('hidden'));
    }
    showStory() {
      (this.docsRoot().setAttribute('hidden', 'true'), this.storyRoot().removeAttribute('hidden'));
    }
    showStoryDuringRender() {
      vt.body.classList.add(Eu.MAIN);
    }
  };
s(_N, 'WebView');
var AN = _N,
  RN = class extends yN {
    constructor(t, r) {
      (super(t, r, new wN(), new AN()),
        (this.importFn = t),
        (this.getProjectAnnotations = r),
        (te.__STORYBOOK_PREVIEW__ = this));
    }
  };
s(RN, 'PreviewWeb');
var oz = RN,
  { document: Pn } = te,
  sz = [
    'application/javascript',
    'application/ecmascript',
    'application/x-ecmascript',
    'application/x-javascript',
    'text/ecmascript',
    'text/javascript',
    'text/javascript1.0',
    'text/javascript1.1',
    'text/javascript1.2',
    'text/javascript1.3',
    'text/javascript1.4',
    'text/javascript1.5',
    'text/jscript',
    'text/livescript',
    'text/x-ecmascript',
    'text/x-javascript',
    'module',
  ],
  iz = 'script',
  yv = 'scripts-root';
function pl() {
  const e = Pn.createEvent('Event');
  (e.initEvent('DOMContentLoaded', !0, !0), Pn.dispatchEvent(e));
}
s(pl, 'simulateDOMContentLoaded');
function PN(e, t, r) {
  const n = Pn.createElement('script');
  ((n.type = e.type === 'module' ? 'module' : 'text/javascript'),
    e.src ? ((n.onload = t), (n.onerror = t), (n.src = e.src)) : (n.textContent = e.innerText),
    r ? r.appendChild(n) : Pn.head.appendChild(n),
    e.parentNode.removeChild(e),
    e.src || t());
}
s(PN, 'insertScript');
function Qh(e, t, r = 0) {
  e[r](() => {
    (r++, r === e.length ? t() : Qh(e, t, r));
  });
}
s(Qh, 'insertScriptsSequentially');
function xN(e) {
  let t = Pn.getElementById(yv);
  t ? (t.innerHTML = '') : ((t = Pn.createElement('div')), (t.id = yv), Pn.body.appendChild(t));
  const r = Array.from(e.querySelectorAll(iz));
  if (r.length) {
    const n = [];
    (r.forEach((o) => {
      const i = o.getAttribute('type');
      (!i || sz.includes(i)) && n.push((a) => PN(o, a, t));
    }),
      n.length && Qh(n, pl, void 0));
  } else pl();
}
s(xN, 'simulatePageLoad');
var Su;
(function (e) {
  ((e.start = '/**'), (e.nostart = '/***'), (e.delim = '*'), (e.end = '*/'));
})((Su = Su || (Su = {})));
function ON(e) {
  return (
    e.start +
    e.delimiter +
    e.postDelimiter +
    e.tag +
    e.postTag +
    e.type +
    e.postType +
    e.name +
    e.postName +
    e.description +
    e.end +
    e.lineEnd
  );
}
s(ON, 'join');
function az() {
  return (e) =>
    e.source.map(({ tokens: t }) => ON(t)).join(`
`);
}
s(az, 'getStringifier');
var lz = Ke(P1(), 1),
  Kn = (0, lz.stringifyRules)(),
  cz = Kn.JsdocTypeObject;
Kn.JsdocTypeAny = () => 'any';
Kn.JsdocTypeObject = (e, t) => `(${cz(e, t)})`;
Kn.JsdocTypeOptional = (e, t) => t(e.element);
Kn.JsdocTypeNullable = (e, t) => t(e.element);
Kn.JsdocTypeNotNullable = (e, t) => t(e.element);
Kn.JsdocTypeUnion = (e, t) => e.elements.map(t).join('|');
var uz = 'storybook/docs',
  dz = `${uz}/snippet-rendered`;
async function CN(e, t) {
  const r = t.parameters?.docs?.source?.transform,
    { id: n, unmappedArgs: o } = t,
    i = r && e ? r?.(e, t) : e,
    a = i ? await i : void 0;
  Ut.getChannel().emit(dz, { id: n, source: a, args: o });
}
s(CN, 'emitTransformCode');
var bi = { depth: 10, clearOnStoryChange: !0, limit: 50 },
  pz = s((e = {}) => {
    Object.assign(bi, e);
  }, 'configureActions'),
  IN = s((e, t) => {
    const r = Object.getPrototypeOf(e);
    return !r || t(r) ? r : IN(r, t);
  }, 'findProto'),
  fz = s(
    (e) =>
      !!(
        typeof e == 'object' &&
        e &&
        IN(e, (t) => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) &&
        typeof e.persist == 'function'
      ),
    'isReactSyntheticEvent',
  ),
  mz = s((e) => {
    if (fz(e)) {
      const t = Object.create(e.constructor.prototype, Object.getOwnPropertyDescriptors(e));
      t.persist();
      const r = Object.getOwnPropertyDescriptor(t, 'view'),
        n = r?.value;
      return (
        typeof n == 'object' &&
          n?.constructor.name === 'Window' &&
          Object.defineProperty(t, 'view', { ...r, value: Object.create(n.constructor.prototype) }),
        t
      );
    }
    return e;
  }, 'serializeArg');
function Yo(e, t = {}) {
  const r = { ...bi, ...t },
    n = s(function (...i) {
      if (t.implicit) {
        const h = (
          '__STORYBOOK_PREVIEW__' in te ? te.__STORYBOOK_PREVIEW__ : void 0
        )?.storyRenders.find((g) => g.phase === 'playing' || g.phase === 'rendering');
        if (h) {
          const g = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8,
            v = new zE({ phase: h.phase, name: e, deprecated: g });
          if (g) console.warn(v);
          else throw v;
        }
      }
      const a = Ut.getChannel(),
        l = Date.now().toString(36) + Math.random().toString(36).substring(2),
        d = 5,
        u = i.map(mz),
        p = i.length > 1 ? u : u[0],
        f = {
          id: l,
          count: 0,
          data: { name: e, args: p },
          options: { ...r, maxDepth: d + (r.depth || 3) },
        };
      a.emit(_w, f);
    }, 'actionHandler');
  return ((n.isAction = !0), (n.implicit = t.implicit), n);
}
s(Yo, 'action');
var yz = s((...e) => {
    let t = bi,
      r = e;
    (r.length === 1 && Array.isArray(r[0]) && ([r] = r),
      r.length !== 1 && typeof r[r.length - 1] != 'string' && (t = { ...bi, ...r.pop() }));
    let n = r[0];
    (r.length !== 1 || typeof n == 'string') &&
      ((n = {}),
      r.forEach((i) => {
        n[i] = i;
      }));
    const o = {};
    return (
      Object.keys(n).forEach((i) => {
        o[i] = Yo(n[i], t);
      }),
      o
    );
  }, 'actions'),
  hz = {
    '@storybook/global': ET,
    'storybook/test': Hw,
    'storybook/actions': Sw,
    'storybook/preview-api': Mu,
    'storybook/internal/channels': ST,
    'storybook/internal/client-logger': AT,
    'storybook/internal/core-events': Vp,
    'storybook/internal/types': Ew,
    'storybook/internal/preview-errors': LE,
    'storybook/internal/preview-api': Mu,
  };
async function NN() {
  const e = new URL(window.location.href);
  if (e.searchParams.get('navigator') !== 'true' || globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__)
    return;
  globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__ = !0;
  const t = await (await fetch('/index.json')).json(),
    r = e.searchParams.get('id');
  if (!r) {
    const n = Object.values(t.entries)[0];
    n &&
      (e.searchParams.set('id', n.id),
      e.searchParams.set('viewMode', n.type),
      (window.location.href = e.toString()));
    return;
  }
  gz(t, r);
}
s(NN, 'maybeSetupPreviewNavigator');
var gz = s(async (e, t) => {
    const r = { entries: {} };
    for (const l of Object.values(e.entries)) {
      const d = l.title.split('/');
      let u = r;
      for (const p of d)
        (u.entries || (u.entries = {}),
          u.entries[p]
            ? t === l.id && (u.entries[p].isActive = !0)
            : (u.entries[p] = { title: p, isActive: t === l.id, entries: {} }),
          (u = u.entries[p]));
      (u.entries || (u.entries = {}),
        (u.entries[l.name] = {
          id: l.id,
          name: l.name,
          href: `?id=${l.id}&viewMode=${l.type}&navigator=true`,
          isActive: t === l.id,
        }));
    }
    const n = s((l) => {
        if ('entries' in l && 'title' in l) {
          const u = l;
          return `
      <li class="sb-navigator-branch">
        <details${u.isActive ? ' open' : ''}>
          <summary class="sb-navigator-title">
            ${u.title}
          </summary>
          <ul class="sb-navigator-entries" aria-label="${u.title}">
            ${Object.values(u.entries).map(n).join('')}
          </ul>
        </details>
      </li>
      `;
        }
        const d = l;
        return `
      <li class="sb-navigator-story-item">
        <a href="${d.href}" 
           class="sb-navigator-story-link${d.isActive ? ' active' : ''}" 
           aria-current="${d.isActive ? 'location' : 'false'}">${d.name}</a>
      </li>
    `;
      }, 'createHtmlForNode'),
      o = Object.values(r.entries).map(n).join(''),
      i = document.createElement('nav');
    ((i.id = 'sb-navigator-container'),
      i.setAttribute('role', 'navigation'),
      i.setAttribute('aria-label', 'Story navigation'),
      (i.innerHTML = `
    <ul class="sb-navigator-list">${o}</ul>
  `),
      document.body.insertBefore(i, document.body.firstChild));
    const a = document.createElement('style');
    ((a.id = 'sb-navigator-style'),
      (a.textContent = `
    body {
      display: grid !important;
      grid-template-columns: 300px 1fr;
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      margin: 0;

      --text-color: rgb(46, 52, 56);
      --bg-color: rgb(246, 249, 252);

      @media (prefers-color-scheme: dark) {
        --text-color: rgb(201, 205, 207);
        --bg-color: rgb(34, 36, 37);
      }
    }
    #storybook-root, #storybook-docs {
      overflow-y: auto;
      max-height: 100vh;
      max-width: 100%;
    }
    #sb-navigator-container, #sb-navigator-container * {
      box-sizing: border-box;
    }
    #sb-navigator-container {
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid #eee;
        padding: 1rem;
        font-size: 14px;
        color: var(--text-color);
        background-color: var(--bg-color);
        align-self: start;
        z-index: 1000;
    }
    .sb-main-padded #sb-navigator-container {
      margin: -1rem 1rem -1rem -1rem;
    }
    .sb-navigator-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    .sb-navigator-branch {
      list-style-type: none;
    }
    .sb-navigator-item {
      margin-bottom: 15px;
    }
    .sb-navigator-title {
      color: var(--text-color);
      text-decoration: none;
      padding-block: 5px;
      cursor: pointer;
    }
    .sb-navigator-entries {
      padding-left: 15px;
    }
    .sb-navigator-story-item {
      margin-bottom: 8px;
      margin-left: 8px;
    }
    .sb-navigator-story-link {
      color: var(--text-color);
    }
    .sb-navigator-story-link.active {
      font-weight: bold;
      color: rgb(2, 156, 253);
    }
  `),
      document.head.appendChild(a),
      i
        .querySelector('.sb-navigator-story-link.active')
        ?.closest('details')
        ?.scrollIntoView({ block: 'center' }));
  }, 'setupPreviewNavigator'),
  bz = Ke(x1(), 1),
  _u;
function $N() {
  return (_u || (_u = new bz.default(te.navigator?.userAgent).getBrowserInfo()), _u);
}
s($N, 'getBrowserInfo');
function qN(e) {
  return ((e.browserInfo = $N()), e);
}
s(qN, 'prepareForTelemetry');
function MN(e) {
  const t = e.error || e;
  t.fromStorybook && te.sendTelemetryError(t);
}
s(MN, 'errorListener');
function jN({ reason: e }) {
  e.fromStorybook && te.sendTelemetryError(e);
}
s(jN, 'unhandledRejectionListener');
function Zh() {
  (tk.forEach((e) => {
    te[wT[e]] = hz[e];
  }),
    (te.sendTelemetryError = (e) => {
      te.__STORYBOOK_ADDONS_CHANNEL__.emit(vT, qN(e));
    }),
    te.addEventListener('error', MN),
    te.addEventListener('unhandledrejection', jN),
    NN());
}
s(Zh, 'setup');
Zh();
const { createBrowserChannel: vz } = __STORYBOOK_MODULE_CHANNELS__,
  { addons: Tz } = __STORYBOOK_MODULE_PREVIEW_API__,
  eg = vz({ page: 'preview' });
Tz.setChannel(eg);
window.__STORYBOOK_ADDONS_CHANNEL__ = eg;
window.CONFIG_TYPE === 'DEVELOPMENT' && (window.__STORYBOOK_SERVER_CHANNEL__ = eg);
var Ez = Object.create,
  tg = Object.defineProperty,
  wz = Object.getOwnPropertyDescriptor,
  kN = Object.getOwnPropertyNames,
  Sz = Object.getPrototypeOf,
  _z = Object.prototype.hasOwnProperty,
  O = (e, t) => tg(e, 'name', { value: t, configurable: !0 }),
  Az = (e, t) =>
    function () {
      return (t || (0, e[kN(e)[0]])((t = { exports: {} }).exports, t), t.exports);
    },
  Rz = (e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let o of kN(t))
        !_z.call(e, o) &&
          o !== r &&
          tg(e, o, { get: () => t[o], enumerable: !(n = wz(t, o)) || n.enumerable });
    return e;
  },
  Pz = (e, t, r) => (
    (r = e != null ? Ez(Sz(e)) : {}),
    Rz(tg(r, 'default', { value: e, enumerable: !0 }), e)
  );
function ya(e) {
  if (!e || typeof e != 'object') return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null
    ? Object.prototype.toString.call(e) === '[object Object]'
    : !1;
}
O(ya, 'isPlainObject');
function xz(e) {
  return e == null || (typeof e != 'object' && typeof e != 'function');
}
O(xz, 'isPrimitive');
function Oz(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
O(Oz, 'isTypedArray');
function Cz(e) {
  return Object.getOwnPropertySymbols(e).filter((t) =>
    Object.prototype.propertyIsEnumerable.call(e, t),
  );
}
O(Cz, 'getSymbols');
function Iz(e) {
  return e == null
    ? e === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(e);
}
O(Iz, 'getTag');
var Nz = Az({
  '../node_modules/jsdoc-type-pratt-parser/dist/index.js'(e, t) {
    (function (r, n) {
      typeof e == 'object' && typeof t < 'u'
        ? n(e)
        : typeof define == 'function' && define.amd
          ? define(['exports'], n)
          : ((r = typeof globalThis < 'u' ? globalThis : r || self), n((r.jtpp = {})));
    })(e, function (r) {
      function n(c) {
        return c.text !== void 0 && c.text !== ''
          ? `'${c.type}' with value '${c.text}'`
          : `'${c.type}'`;
      }
      O(n, 'tokenToString');
      const o = class DN extends Error {
        constructor(y) {
          (super(`No parslet found for token: ${n(y)}`),
            (this.token = y),
            Object.setPrototypeOf(this, DN.prototype));
        }
        getToken() {
          return this.token;
        }
      };
      O(o, 'NoParsletFoundError');
      let i = o;
      const a = class LN extends Error {
        constructor(y) {
          (super(`The parsing ended early. The next token was: ${n(y)}`),
            (this.token = y),
            Object.setPrototypeOf(this, LN.prototype));
        }
        getToken() {
          return this.token;
        }
      };
      O(a, 'EarlyEndOfParseError');
      let l = a;
      const d = class FN extends Error {
        constructor(y, T) {
          let C = `Unexpected type: '${y.type}'.`;
          (T !== void 0 && (C += ` Message: ${T}`),
            super(C),
            Object.setPrototypeOf(this, FN.prototype));
        }
      };
      O(d, 'UnexpectedTypeError');
      let u = d;
      function p(c) {
        return (y) => (y.startsWith(c) ? { type: c, text: c } : null);
      }
      O(p, 'makePunctuationRule');
      function f(c) {
        let y = 0,
          T;
        const C = c[0];
        let L = !1;
        if (C !== "'" && C !== '"') return null;
        for (; y < c.length; ) {
          if ((y++, (T = c[y]), !L && T === C)) {
            y++;
            break;
          }
          L = !L && T === '\\';
        }
        if (T !== C) throw new Error('Unterminated String');
        return c.slice(0, y);
      }
      O(f, 'getQuoted');
      const m = new RegExp(
          '[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
          'u',
        ),
        h = new RegExp(
          '[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
          'u',
        );
      function g(c) {
        let y = c[0];
        if (!m.test(y)) return null;
        let T = 1;
        do {
          if (((y = c[T]), !h.test(y))) break;
          T++;
        } while (T < c.length);
        return c.slice(0, T);
      }
      O(g, 'getIdentifier');
      const v = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function E(c) {
        var y, T;
        return (T = (y = v.exec(c)) === null || y === void 0 ? void 0 : y[0]) !== null &&
          T !== void 0
          ? T
          : null;
      }
      O(E, 'getNumber');
      const b = O((c) => {
        const y = g(c);
        return y == null ? null : { type: 'Identifier', text: y };
      }, 'identifierRule');
      function S(c) {
        return (y) => {
          if (!y.startsWith(c)) return null;
          const T = y[c.length];
          return T !== void 0 && h.test(T) ? null : { type: c, text: c };
        };
      }
      O(S, 'makeKeyWordRule');
      const R = O((c) => {
          const y = f(c);
          return y == null ? null : { type: 'StringValue', text: y };
        }, 'stringValueRule'),
        I = O((c) => (c.length > 0 ? null : { type: 'EOF', text: '' }), 'eofRule'),
        $ = O((c) => {
          const y = E(c);
          return y === null ? null : { type: 'Number', text: y };
        }, 'numberRule'),
        x = [
          I,
          p('=>'),
          p('('),
          p(')'),
          p('{'),
          p('}'),
          p('['),
          p(']'),
          p('|'),
          p('&'),
          p('<'),
          p('>'),
          p(','),
          p(';'),
          p('*'),
          p('?'),
          p('!'),
          p('='),
          p(':'),
          p('...'),
          p('.'),
          p('#'),
          p('~'),
          p('/'),
          p('@'),
          S('undefined'),
          S('null'),
          S('function'),
          S('this'),
          S('new'),
          S('module'),
          S('event'),
          S('extends'),
          S('external'),
          S('infer'),
          S('typeof'),
          S('keyof'),
          S('readonly'),
          S('import'),
          S('is'),
          S('in'),
          S('asserts'),
          $,
          b,
          R,
        ],
        A = /^\s*\n\s*/,
        w = class ha {
          static create(y) {
            const T = this.read(y);
            y = T.text;
            const C = this.read(y);
            return ((y = C.text), new ha(y, void 0, T.token, C.token));
          }
          constructor(y, T, C, L) {
            ((this.text = ''),
              (this.text = y),
              (this.previous = T),
              (this.current = C),
              (this.next = L));
          }
          static read(y, T = !1) {
            ((T = T || A.test(y)), (y = y.trim()));
            for (const C of x) {
              const L = C(y);
              if (L !== null) {
                const G = Object.assign(Object.assign({}, L), { startOfLine: T });
                return ((y = y.slice(G.text.length)), { text: y, token: G });
              }
            }
            throw new Error('Unexpected Token ' + y);
          }
          advance() {
            const y = ha.read(this.text);
            return new ha(y.text, this.current, this.next, y.token);
          }
        };
      O(w, 'Lexer');
      let _ = w;
      function j(c) {
        if (c === void 0) throw new Error('Unexpected undefined');
        if (
          c.type === 'JsdocTypeKeyValue' ||
          c.type === 'JsdocTypeParameterList' ||
          c.type === 'JsdocTypeProperty' ||
          c.type === 'JsdocTypeReadonlyProperty' ||
          c.type === 'JsdocTypeObjectField' ||
          c.type === 'JsdocTypeJsdocObjectField' ||
          c.type === 'JsdocTypeIndexSignature' ||
          c.type === 'JsdocTypeMappedType' ||
          c.type === 'JsdocTypeTypeParameter'
        )
          throw new u(c);
        return c;
      }
      O(j, 'assertRootResult');
      function N(c) {
        return c.type === 'JsdocTypeKeyValue' ? H(c) : j(c);
      }
      O(N, 'assertPlainKeyValueOrRootResult');
      function V(c) {
        return c.type === 'JsdocTypeName' ? c : H(c);
      }
      O(V, 'assertPlainKeyValueOrNameResult');
      function H(c) {
        if (c.type !== 'JsdocTypeKeyValue') throw new u(c);
        return c;
      }
      O(H, 'assertPlainKeyValueResult');
      function P(c) {
        var y;
        if (c.type === 'JsdocTypeVariadic') {
          if (((y = c.element) === null || y === void 0 ? void 0 : y.type) === 'JsdocTypeName')
            return c;
          throw new u(c);
        }
        if (c.type !== 'JsdocTypeNumber' && c.type !== 'JsdocTypeName') throw new u(c);
        return c;
      }
      O(P, 'assertNumberOrVariadicNameResult');
      function D(c) {
        if (
          c.type === 'JsdocTypeTuple' ||
          (c.type === 'JsdocTypeGeneric' && c.meta.brackets === 'square')
        )
          return c;
        throw new u(c);
      }
      O(D, 'assertArrayOrTupleResult');
      function F(c) {
        return c.type === 'JsdocTypeIndexSignature' || c.type === 'JsdocTypeMappedType';
      }
      O(F, 'isSquaredProperty');
      var k;
      (function (c) {
        ((c[(c.ALL = 0)] = 'ALL'),
          (c[(c.PARAMETER_LIST = 1)] = 'PARAMETER_LIST'),
          (c[(c.OBJECT = 2)] = 'OBJECT'),
          (c[(c.KEY_VALUE = 3)] = 'KEY_VALUE'),
          (c[(c.INDEX_BRACKETS = 4)] = 'INDEX_BRACKETS'),
          (c[(c.UNION = 5)] = 'UNION'),
          (c[(c.INTERSECTION = 6)] = 'INTERSECTION'),
          (c[(c.PREFIX = 7)] = 'PREFIX'),
          (c[(c.INFIX = 8)] = 'INFIX'),
          (c[(c.TUPLE = 9)] = 'TUPLE'),
          (c[(c.SYMBOL = 10)] = 'SYMBOL'),
          (c[(c.OPTIONAL = 11)] = 'OPTIONAL'),
          (c[(c.NULLABLE = 12)] = 'NULLABLE'),
          (c[(c.KEY_OF_TYPE_OF = 13)] = 'KEY_OF_TYPE_OF'),
          (c[(c.FUNCTION = 14)] = 'FUNCTION'),
          (c[(c.ARROW = 15)] = 'ARROW'),
          (c[(c.ARRAY_BRACKETS = 16)] = 'ARRAY_BRACKETS'),
          (c[(c.GENERIC = 17)] = 'GENERIC'),
          (c[(c.NAME_PATH = 18)] = 'NAME_PATH'),
          (c[(c.PARENTHESIS = 19)] = 'PARENTHESIS'),
          (c[(c.SPECIAL_TYPES = 20)] = 'SPECIAL_TYPES'));
      })(k || (k = {}));
      const K = class {
        constructor(y, T, C) {
          ((this.grammar = y),
            typeof T == 'string' ? (this._lexer = _.create(T)) : (this._lexer = T),
            (this.baseParser = C));
        }
        get lexer() {
          return this._lexer;
        }
        parse() {
          const y = this.parseType(k.ALL);
          if (this.lexer.current.type !== 'EOF') throw new l(this.lexer.current);
          return y;
        }
        parseType(y) {
          return j(this.parseIntermediateType(y));
        }
        parseIntermediateType(y) {
          const T = this.tryParslets(null, y);
          if (T === null) throw new i(this.lexer.current);
          return this.parseInfixIntermediateType(T, y);
        }
        parseInfixIntermediateType(y, T) {
          let C = this.tryParslets(y, T);
          for (; C !== null; ) ((y = C), (C = this.tryParslets(y, T)));
          return y;
        }
        tryParslets(y, T) {
          for (const C of this.grammar) {
            const L = C(this, T, y);
            if (L !== null) return L;
          }
          return null;
        }
        consume(y) {
          return (
            Array.isArray(y) || (y = [y]),
            y.includes(this.lexer.current.type) ? ((this._lexer = this.lexer.advance()), !0) : !1
          );
        }
        acceptLexerState(y) {
          this._lexer = y.lexer;
        }
      };
      O(K, 'Parser');
      let X = K;
      function se(c) {
        return c === '}' || c === 'EOF' || c === '|' || c === ',' || c === ')' || c === '>';
      }
      O(se, 'isQuestionMarkUnknownType');
      const ie = O((c, y, T) => {
        const C = c.lexer.current.type,
          L = c.lexer.next.type;
        return (T == null && C === '?' && !se(L)) || (T != null && C === '?')
          ? (c.consume('?'),
            T == null
              ? {
                  type: 'JsdocTypeNullable',
                  element: c.parseType(k.NULLABLE),
                  meta: { position: 'prefix' },
                }
              : { type: 'JsdocTypeNullable', element: j(T), meta: { position: 'suffix' } })
          : null;
      }, 'nullableParslet');
      function W(c) {
        const y = O((T, C, L) => {
          const G = T.lexer.current.type,
            Z = T.lexer.next.type;
          if (L === null) {
            if ('parsePrefix' in c && c.accept(G, Z)) return c.parsePrefix(T);
          } else if ('parseInfix' in c && c.precedence > C && c.accept(G, Z))
            return c.parseInfix(T, L);
          return null;
        }, 'parslet');
        return (Object.defineProperty(y, 'name', { value: c.name }), y);
      }
      O(W, 'composeParslet');
      const ae = W({
          name: 'optionalParslet',
          accept: O((c) => c === '=', 'accept'),
          precedence: k.OPTIONAL,
          parsePrefix: O(
            (c) => (
              c.consume('='),
              {
                type: 'JsdocTypeOptional',
                element: c.parseType(k.OPTIONAL),
                meta: { position: 'prefix' },
              }
            ),
            'parsePrefix',
          ),
          parseInfix: O(
            (c, y) => (
              c.consume('='),
              { type: 'JsdocTypeOptional', element: j(y), meta: { position: 'suffix' } }
            ),
            'parseInfix',
          ),
        }),
        be = W({
          name: 'numberParslet',
          accept: O((c) => c === 'Number', 'accept'),
          parsePrefix: O((c) => {
            const y = parseFloat(c.lexer.current.text);
            return (c.consume('Number'), { type: 'JsdocTypeNumber', value: y });
          }, 'parsePrefix'),
        }),
        ue = W({
          name: 'parenthesisParslet',
          accept: O((c) => c === '(', 'accept'),
          parsePrefix: O((c) => {
            if ((c.consume('('), c.consume(')')))
              return { type: 'JsdocTypeParameterList', elements: [] };
            const y = c.parseIntermediateType(k.ALL);
            if (!c.consume(')')) throw new Error('Unterminated parenthesis');
            return y.type === 'JsdocTypeParameterList'
              ? y
              : y.type === 'JsdocTypeKeyValue'
                ? { type: 'JsdocTypeParameterList', elements: [y] }
                : { type: 'JsdocTypeParenthesis', element: j(y) };
          }, 'parsePrefix'),
        }),
        ee = W({
          name: 'specialTypesParslet',
          accept: O(
            (c, y) => (c === '?' && se(y)) || c === 'null' || c === 'undefined' || c === '*',
            'accept',
          ),
          parsePrefix: O((c) => {
            if (c.consume('null')) return { type: 'JsdocTypeNull' };
            if (c.consume('undefined')) return { type: 'JsdocTypeUndefined' };
            if (c.consume('*')) return { type: 'JsdocTypeAny' };
            if (c.consume('?')) return { type: 'JsdocTypeUnknown' };
            throw new Error('Unacceptable token: ' + c.lexer.current.text);
          }, 'parsePrefix'),
        }),
        Pe = W({
          name: 'notNullableParslet',
          accept: O((c) => c === '!', 'accept'),
          precedence: k.NULLABLE,
          parsePrefix: O(
            (c) => (
              c.consume('!'),
              {
                type: 'JsdocTypeNotNullable',
                element: c.parseType(k.NULLABLE),
                meta: { position: 'prefix' },
              }
            ),
            'parsePrefix',
          ),
          parseInfix: O(
            (c, y) => (
              c.consume('!'),
              { type: 'JsdocTypeNotNullable', element: j(y), meta: { position: 'suffix' } }
            ),
            'parseInfix',
          ),
        });
      function xe({ allowTrailingComma: c }) {
        return W({
          name: 'parameterListParslet',
          accept: O((y) => y === ',', 'accept'),
          precedence: k.PARAMETER_LIST,
          parseInfix: O((y, T) => {
            const C = [N(T)];
            y.consume(',');
            do
              try {
                const L = y.parseIntermediateType(k.PARAMETER_LIST);
                C.push(N(L));
              } catch (L) {
                if (L instanceof i) break;
                throw L;
              }
            while (y.consume(','));
            if (C.length > 0 && C.slice(0, -1).some((L) => L.type === 'JsdocTypeVariadic'))
              throw new Error('Only the last parameter may be a rest parameter');
            return { type: 'JsdocTypeParameterList', elements: C };
          }, 'parseInfix'),
        });
      }
      O(xe, 'createParameterListParslet');
      const He = W({
          name: 'genericParslet',
          accept: O((c, y) => c === '<' || (c === '.' && y === '<'), 'accept'),
          precedence: k.GENERIC,
          parseInfix: O((c, y) => {
            const T = c.consume('.');
            c.consume('<');
            const C = [];
            let L = !1;
            if (c.consume('infer')) {
              L = !0;
              const G = c.parseIntermediateType(k.SYMBOL);
              if (G.type !== 'JsdocTypeName')
                throw new u(G, 'A typescript asserts always has to have a name on the left side.');
              C.push(G);
            } else
              do C.push(c.parseType(k.PARAMETER_LIST));
              while (c.consume(','));
            if (!c.consume('>')) throw new Error('Unterminated generic parameter list');
            return Object.assign(
              Object.assign(
                { type: 'JsdocTypeGeneric', left: j(y), elements: C },
                L ? { infer: !0 } : {},
              ),
              { meta: { brackets: 'angle', dot: T } },
            );
          }, 'parseInfix'),
        }),
        Xe = W({
          name: 'unionParslet',
          accept: O((c) => c === '|', 'accept'),
          precedence: k.UNION,
          parseInfix: O((c, y) => {
            c.consume('|');
            const T = [];
            do T.push(c.parseType(k.UNION));
            while (c.consume('|'));
            return { type: 'JsdocTypeUnion', elements: [j(y), ...T] };
          }, 'parseInfix'),
        }),
        J = [ie, ae, be, ue, ee, Pe, xe({ allowTrailingComma: !0 }), He, Xe, ae];
      function Q({ allowSquareBracketsOnAnyType: c, allowJsdocNamePaths: y, pathGrammar: T }) {
        return O(function (L, G, Z) {
          if (Z == null || G >= k.NAME_PATH) return null;
          const ce = L.lexer.current.type,
            _e = L.lexer.next.type;
          if (
            !(
              (ce === '.' && _e !== '<') ||
              (ce === '[' && (c || Z.type === 'JsdocTypeName')) ||
              (y && (ce === '~' || ce === '#'))
            )
          )
            return null;
          let $e,
            br = !1;
          L.consume('.')
            ? ($e = 'property')
            : L.consume('[')
              ? (($e = 'property-brackets'), (br = !0))
              : L.consume('~')
                ? ($e = 'inner')
                : (L.consume('#'), ($e = 'instance'));
          const Es = T !== null ? new X(T, L.lexer, L) : L,
            et = Es.parseIntermediateType(k.NAME_PATH);
          L.acceptLexerState(Es);
          let Gt;
          switch (et.type) {
            case 'JsdocTypeName':
              Gt = { type: 'JsdocTypeProperty', value: et.value, meta: { quote: void 0 } };
              break;
            case 'JsdocTypeNumber':
              Gt = {
                type: 'JsdocTypeProperty',
                value: et.value.toString(10),
                meta: { quote: void 0 },
              };
              break;
            case 'JsdocTypeStringValue':
              Gt = { type: 'JsdocTypeProperty', value: et.value, meta: { quote: et.meta.quote } };
              break;
            case 'JsdocTypeSpecialNamePath':
              if (et.specialType === 'event') Gt = et;
              else
                throw new u(
                  et,
                  "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'",
                );
              break;
            default:
              throw new u(
                et,
                "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'",
              );
          }
          if (br && !L.consume(']')) {
            const ws = L.lexer.current;
            throw new Error(
              `Unterminated square brackets. Next token is '${ws.type}' with text '${ws.text}'`,
            );
          }
          return { type: 'JsdocTypeNamePath', left: j(Z), right: Gt, pathType: $e };
        }, 'namePathParslet');
      }
      O(Q, 'createNamePathParslet');
      function re({ allowedAdditionalTokens: c }) {
        return W({
          name: 'nameParslet',
          accept: O(
            (y) => y === 'Identifier' || y === 'this' || y === 'new' || c.includes(y),
            'accept',
          ),
          parsePrefix: O((y) => {
            const { type: T, text: C } = y.lexer.current;
            return (y.consume(T), { type: 'JsdocTypeName', value: C });
          }, 'parsePrefix'),
        });
      }
      O(re, 'createNameParslet');
      const oe = W({
        name: 'stringValueParslet',
        accept: O((c) => c === 'StringValue', 'accept'),
        parsePrefix: O((c) => {
          const y = c.lexer.current.text;
          return (
            c.consume('StringValue'),
            {
              type: 'JsdocTypeStringValue',
              value: y.slice(1, -1),
              meta: { quote: y[0] === "'" ? 'single' : 'double' },
            }
          );
        }, 'parsePrefix'),
      });
      function ne({ pathGrammar: c, allowedTypes: y }) {
        return W({
          name: 'specialNamePathParslet',
          accept: O((T) => y.includes(T), 'accept'),
          parsePrefix: O((T) => {
            const C = T.lexer.current.type;
            if ((T.consume(C), !T.consume(':'))) return { type: 'JsdocTypeName', value: C };
            let L,
              G = T.lexer.current;
            if (T.consume('StringValue'))
              L = {
                type: 'JsdocTypeSpecialNamePath',
                value: G.text.slice(1, -1),
                specialType: C,
                meta: { quote: G.text[0] === "'" ? 'single' : 'double' },
              };
            else {
              let _e = '';
              const Te = ['Identifier', '@', '/'];
              for (; Te.some(($e) => T.consume($e)); ) ((_e += G.text), (G = T.lexer.current));
              L = {
                type: 'JsdocTypeSpecialNamePath',
                value: _e,
                specialType: C,
                meta: { quote: void 0 },
              };
            }
            const Z = new X(c, T.lexer, T),
              ce = Z.parseInfixIntermediateType(L, k.ALL);
            return (T.acceptLexerState(Z), j(ce));
          }, 'parsePrefix'),
        });
      }
      O(ne, 'createSpecialNamePathParslet');
      const de = [
          re({ allowedAdditionalTokens: ['external', 'module'] }),
          oe,
          be,
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: null }),
        ],
        ye = [...de, ne({ allowedTypes: ['event'], pathGrammar: de })];
      function pe(c) {
        let y;
        if (c.type === 'JsdocTypeParameterList') y = c.elements;
        else if (c.type === 'JsdocTypeParenthesis') y = [c.element];
        else throw new u(c);
        return y.map((T) => N(T));
      }
      O(pe, 'getParameters');
      function Fe(c) {
        const y = pe(c);
        if (y.some((T) => T.type === 'JsdocTypeKeyValue'))
          throw new Error('No parameter should be named');
        return y;
      }
      O(Fe, 'getUnnamedParameters');
      function it({
        allowNamedParameters: c,
        allowNoReturnType: y,
        allowWithoutParenthesis: T,
        allowNewAsFunctionKeyword: C,
      }) {
        return W({
          name: 'functionParslet',
          accept: O((L, G) => L === 'function' || (C && L === 'new' && G === '('), 'accept'),
          parsePrefix: O((L) => {
            const G = L.consume('new');
            L.consume('function');
            const Z = L.lexer.current.type === '(';
            if (!Z) {
              if (!T) throw new Error('function is missing parameter list');
              return { type: 'JsdocTypeName', value: 'function' };
            }
            let ce = {
              type: 'JsdocTypeFunction',
              parameters: [],
              arrow: !1,
              constructor: G,
              parenthesis: Z,
            };
            const _e = L.parseIntermediateType(k.FUNCTION);
            if (c === void 0) ce.parameters = Fe(_e);
            else {
              if (G && _e.type === 'JsdocTypeFunction' && _e.arrow)
                return ((ce = _e), (ce.constructor = !0), ce);
              ce.parameters = pe(_e);
              for (const Te of ce.parameters)
                if (Te.type === 'JsdocTypeKeyValue' && !c.includes(Te.key))
                  throw new Error(
                    `only allowed named parameters are ${c.join(', ')} but got ${Te.type}`,
                  );
            }
            if (L.consume(':')) ce.returnType = L.parseType(k.PREFIX);
            else if (!y) throw new Error('function is missing return type');
            return ce;
          }, 'parsePrefix'),
        });
      }
      O(it, 'createFunctionParslet');
      function yt({ allowPostfix: c, allowEnclosingBrackets: y }) {
        return W({
          name: 'variadicParslet',
          accept: O((T) => T === '...', 'accept'),
          precedence: k.PREFIX,
          parsePrefix: O((T) => {
            T.consume('...');
            const C = y && T.consume('[');
            try {
              const L = T.parseType(k.PREFIX);
              if (C && !T.consume(']')) throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: 'JsdocTypeVariadic',
                element: j(L),
                meta: { position: 'prefix', squareBrackets: C },
              };
            } catch (L) {
              if (L instanceof i) {
                if (C) throw new Error('Empty square brackets for variadic are not allowed.');
                return {
                  type: 'JsdocTypeVariadic',
                  meta: { position: void 0, squareBrackets: !1 },
                };
              } else throw L;
            }
          }, 'parsePrefix'),
          parseInfix: c
            ? (T, C) => (
                T.consume('...'),
                {
                  type: 'JsdocTypeVariadic',
                  element: j(C),
                  meta: { position: 'suffix', squareBrackets: !1 },
                }
              )
            : void 0,
        });
      }
      O(yt, 'createVariadicParslet');
      const Pt = W({
          name: 'symbolParslet',
          accept: O((c) => c === '(', 'accept'),
          precedence: k.SYMBOL,
          parseInfix: O((c, y) => {
            if (y.type !== 'JsdocTypeName')
              throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
            c.consume('(');
            const T = { type: 'JsdocTypeSymbol', value: y.value };
            if (!c.consume(')')) {
              const C = c.parseIntermediateType(k.SYMBOL);
              if (((T.element = P(C)), !c.consume(')')))
                throw new Error('Symbol does not end after value');
            }
            return T;
          }, 'parseInfix'),
        }),
        at = W({
          name: 'arrayBracketsParslet',
          precedence: k.ARRAY_BRACKETS,
          accept: O((c, y) => c === '[' && y === ']', 'accept'),
          parseInfix: O(
            (c, y) => (
              c.consume('['),
              c.consume(']'),
              {
                type: 'JsdocTypeGeneric',
                left: { type: 'JsdocTypeName', value: 'Array' },
                elements: [j(y)],
                meta: { brackets: 'square', dot: !1 },
              }
            ),
            'parseInfix',
          ),
        });
      function ht({ objectFieldGrammar: c, allowKeyTypes: y }) {
        return W({
          name: 'objectParslet',
          accept: O((T) => T === '{', 'accept'),
          parsePrefix: O((T) => {
            T.consume('{');
            const C = { type: 'JsdocTypeObject', meta: { separator: 'comma' }, elements: [] };
            if (!T.consume('}')) {
              let L;
              const G = new X(c, T.lexer, T);
              for (;;) {
                G.acceptLexerState(T);
                let Z = G.parseIntermediateType(k.OBJECT);
                (T.acceptLexerState(G),
                  Z === void 0 && y && (Z = T.parseIntermediateType(k.OBJECT)));
                let ce = !1;
                if (
                  (Z.type === 'JsdocTypeNullable' && ((ce = !0), (Z = Z.element)),
                  Z.type === 'JsdocTypeNumber' ||
                    Z.type === 'JsdocTypeName' ||
                    Z.type === 'JsdocTypeStringValue')
                ) {
                  let Te;
                  (Z.type === 'JsdocTypeStringValue' && (Te = Z.meta.quote),
                    C.elements.push({
                      type: 'JsdocTypeObjectField',
                      key: Z.value.toString(),
                      right: void 0,
                      optional: ce,
                      readonly: !1,
                      meta: { quote: Te },
                    }));
                } else if (
                  Z.type === 'JsdocTypeObjectField' ||
                  Z.type === 'JsdocTypeJsdocObjectField'
                )
                  C.elements.push(Z);
                else throw new u(Z);
                if (T.lexer.current.startOfLine)
                  ((L = 'linebreak'), T.consume(',') || T.consume(';'));
                else if (T.consume(',')) L = 'comma';
                else if (T.consume(';')) L = 'semicolon';
                else break;
                if (T.lexer.current.type === '}') break;
              }
              if (
                ((C.meta.separator = L ?? 'comma'),
                L === 'linebreak' && (C.meta.propertyIndent = '  '),
                !T.consume('}'))
              )
                throw new Error("Unterminated record type. Missing '}'");
            }
            return C;
          }, 'parsePrefix'),
        });
      }
      O(ht, 'createObjectParslet');
      function gt({
        allowSquaredProperties: c,
        allowKeyTypes: y,
        allowReadonly: T,
        allowOptional: C,
      }) {
        return W({
          name: 'objectFieldParslet',
          precedence: k.KEY_VALUE,
          accept: O((L) => L === ':', 'accept'),
          parseInfix: O((L, G) => {
            var Z;
            let ce = !1,
              _e = !1;
            (C && G.type === 'JsdocTypeNullable' && ((ce = !0), (G = G.element)),
              T && G.type === 'JsdocTypeReadonlyProperty' && ((_e = !0), (G = G.element)));
            const Te = (Z = L.baseParser) !== null && Z !== void 0 ? Z : L;
            if (
              (Te.acceptLexerState(L),
              G.type === 'JsdocTypeNumber' ||
                G.type === 'JsdocTypeName' ||
                G.type === 'JsdocTypeStringValue' ||
                F(G))
            ) {
              if (F(G) && !c) throw new u(G);
              Te.consume(':');
              let $e;
              G.type === 'JsdocTypeStringValue' && ($e = G.meta.quote);
              const br = Te.parseType(k.KEY_VALUE);
              return (
                L.acceptLexerState(Te),
                {
                  type: 'JsdocTypeObjectField',
                  key: F(G) ? G : G.value.toString(),
                  right: br,
                  optional: ce,
                  readonly: _e,
                  meta: { quote: $e },
                }
              );
            } else {
              if (!y) throw new u(G);
              Te.consume(':');
              const $e = Te.parseType(k.KEY_VALUE);
              return (
                L.acceptLexerState(Te),
                { type: 'JsdocTypeJsdocObjectField', left: j(G), right: $e }
              );
            }
          }, 'parseInfix'),
        });
      }
      O(gt, 'createObjectFieldParslet');
      function bt({ allowOptional: c, allowVariadic: y }) {
        return W({
          name: 'keyValueParslet',
          precedence: k.KEY_VALUE,
          accept: O((T) => T === ':', 'accept'),
          parseInfix: O((T, C) => {
            let L = !1,
              G = !1;
            if (
              (c && C.type === 'JsdocTypeNullable' && ((L = !0), (C = C.element)),
              y &&
                C.type === 'JsdocTypeVariadic' &&
                C.element !== void 0 &&
                ((G = !0), (C = C.element)),
              C.type !== 'JsdocTypeName')
            )
              throw new u(C);
            T.consume(':');
            const Z = T.parseType(k.KEY_VALUE);
            return { type: 'JsdocTypeKeyValue', key: C.value, right: Z, optional: L, variadic: G };
          }, 'parseInfix'),
        });
      }
      O(bt, 'createKeyValueParslet');
      const un = [
          ...J,
          it({
            allowWithoutParenthesis: !0,
            allowNamedParameters: ['this', 'new'],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1,
          }),
          oe,
          ne({ allowedTypes: ['module', 'external', 'event'], pathGrammar: ye }),
          yt({ allowEnclosingBrackets: !0, allowPostfix: !0 }),
          re({ allowedAdditionalTokens: ['keyof'] }),
          Pt,
          at,
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
        ],
        Qo = [
          ...un,
          ht({
            objectFieldGrammar: [
              re({ allowedAdditionalTokens: ['typeof', 'module', 'in'] }),
              gt({
                allowSquaredProperties: !1,
                allowKeyTypes: !0,
                allowOptional: !1,
                allowReadonly: !1,
              }),
              ...un,
            ],
            allowKeyTypes: !0,
          }),
          bt({ allowOptional: !0, allowVariadic: !0 }),
        ],
        dn = W({
          name: 'typeOfParslet',
          accept: O((c) => c === 'typeof', 'accept'),
          parsePrefix: O(
            (c) => (
              c.consume('typeof'),
              { type: 'JsdocTypeTypeof', element: c.parseType(k.KEY_OF_TYPE_OF) }
            ),
            'parsePrefix',
          ),
        }),
        Zo = [
          re({ allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'] }),
          ie,
          ae,
          oe,
          be,
          gt({
            allowSquaredProperties: !1,
            allowKeyTypes: !1,
            allowOptional: !1,
            allowReadonly: !1,
          }),
        ],
        es = [
          ...J,
          ht({ allowKeyTypes: !1, objectFieldGrammar: Zo }),
          re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
          dn,
          it({
            allowWithoutParenthesis: !1,
            allowNamedParameters: ['this', 'new'],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1,
          }),
          yt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
          re({ allowedAdditionalTokens: ['keyof'] }),
          ne({ allowedTypes: ['module'], pathGrammar: ye }),
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
          bt({ allowOptional: !1, allowVariadic: !1 }),
          Pt,
        ],
        ts = W({
          name: 'assertsParslet',
          accept: O((c) => c === 'asserts', 'accept'),
          parsePrefix: O((c) => {
            c.consume('asserts');
            const y = c.parseIntermediateType(k.SYMBOL);
            if (y.type !== 'JsdocTypeName')
              throw new u(y, 'A typescript asserts always has to have a name on the left side.');
            return c.consume('is')
              ? { type: 'JsdocTypeAsserts', left: y, right: j(c.parseIntermediateType(k.INFIX)) }
              : { type: 'JsdocTypeAssertsPlain', element: y };
          }, 'parsePrefix'),
        });
      function pn({ allowQuestionMark: c }) {
        return W({
          name: 'tupleParslet',
          accept: O((y) => y === '[', 'accept'),
          parsePrefix: O((y) => {
            y.consume('[');
            const T = { type: 'JsdocTypeTuple', elements: [] };
            if (y.consume(']')) return T;
            const C = y.parseIntermediateType(k.ALL);
            if (
              (C.type === 'JsdocTypeParameterList'
                ? C.elements[0].type === 'JsdocTypeKeyValue'
                  ? (T.elements = C.elements.map(H))
                  : (T.elements = C.elements.map(j))
                : C.type === 'JsdocTypeKeyValue'
                  ? (T.elements = [H(C)])
                  : (T.elements = [j(C)]),
              !y.consume(']'))
            )
              throw new Error("Unterminated '['");
            if (T.elements.some((L) => L.type === 'JsdocTypeUnknown'))
              throw new Error('Question mark in tuple not allowed');
            return T;
          }, 'parsePrefix'),
        });
      }
      O(pn, 'createTupleParslet');
      const rs = W({
          name: 'keyOfParslet',
          accept: O((c) => c === 'keyof', 'accept'),
          parsePrefix: O(
            (c) => (
              c.consume('keyof'),
              { type: 'JsdocTypeKeyof', element: j(c.parseType(k.KEY_OF_TYPE_OF)) }
            ),
            'parsePrefix',
          ),
        }),
        ns = W({
          name: 'importParslet',
          accept: O((c) => c === 'import', 'accept'),
          parsePrefix: O((c) => {
            if ((c.consume('import'), !c.consume('(')))
              throw new Error('Missing parenthesis after import keyword');
            const y = c.parseType(k.PREFIX);
            if (y.type !== 'JsdocTypeStringValue')
              throw new Error('Only string values are allowed as paths for imports');
            if (!c.consume(')'))
              throw new Error('Missing closing parenthesis after import keyword');
            return { type: 'JsdocTypeImport', element: y };
          }, 'parsePrefix'),
        }),
        os = W({
          name: 'readonlyPropertyParslet',
          accept: O((c) => c === 'readonly', 'accept'),
          parsePrefix: O(
            (c) => (
              c.consume('readonly'),
              { type: 'JsdocTypeReadonlyProperty', element: c.parseIntermediateType(k.KEY_VALUE) }
            ),
            'parsePrefix',
          ),
        }),
        ss = W({
          name: 'arrowFunctionParslet',
          precedence: k.ARROW,
          accept: O((c) => c === '=>', 'accept'),
          parseInfix: O(
            (c, y) => (
              c.consume('=>'),
              {
                type: 'JsdocTypeFunction',
                parameters: pe(y).map(V),
                arrow: !0,
                constructor: !1,
                parenthesis: !0,
                returnType: c.parseType(k.OBJECT),
              }
            ),
            'parseInfix',
          ),
        }),
        is = W({
          name: 'genericArrowFunctionParslet',
          accept: O((c) => c === '<', 'accept'),
          parsePrefix: O((c) => {
            const y = [];
            c.consume('<');
            do {
              let C,
                L = c.parseIntermediateType(k.SYMBOL);
              if (
                (L.type === 'JsdocTypeOptional' && ((L = L.element), (C = c.parseType(k.SYMBOL))),
                L.type !== 'JsdocTypeName')
              )
                throw new u(L);
              let G;
              c.consume('extends') &&
                ((G = c.parseType(k.SYMBOL)),
                G.type === 'JsdocTypeOptional' && ((G = G.element), (C = c.parseType(k.SYMBOL))));
              const Z = { type: 'JsdocTypeTypeParameter', name: L };
              if (
                (G !== void 0 && (Z.constraint = G),
                C !== void 0 && (Z.defaultValue = C),
                y.push(Z),
                c.consume('>'))
              )
                break;
            } while (c.consume(','));
            const T = c.parseIntermediateType(k.SYMBOL);
            return ((T.typeParameters = y), T);
          }, 'parsePrefix'),
        }),
        as = W({
          name: 'intersectionParslet',
          accept: O((c) => c === '&', 'accept'),
          precedence: k.INTERSECTION,
          parseInfix: O((c, y) => {
            c.consume('&');
            const T = [];
            do T.push(c.parseType(k.INTERSECTION));
            while (c.consume('&'));
            return { type: 'JsdocTypeIntersection', elements: [j(y), ...T] };
          }, 'parseInfix'),
        }),
        ls = W({
          name: 'predicateParslet',
          precedence: k.INFIX,
          accept: O((c) => c === 'is', 'accept'),
          parseInfix: O((c, y) => {
            if (y.type !== 'JsdocTypeName')
              throw new u(y, 'A typescript predicate always has to have a name on the left side.');
            return (
              c.consume('is'),
              { type: 'JsdocTypePredicate', left: y, right: j(c.parseIntermediateType(k.INFIX)) }
            );
          }, 'parseInfix'),
        }),
        cs = W({
          name: 'objectSquareBracketPropertyParslet',
          accept: O((c) => c === '[', 'accept'),
          parsePrefix: O((c) => {
            if (c.baseParser === void 0) throw new Error('Only allowed inside object grammar');
            c.consume('[');
            const y = c.lexer.current.text;
            c.consume('Identifier');
            let T;
            if (c.consume(':')) {
              const C = c.baseParser;
              (C.acceptLexerState(c),
                (T = {
                  type: 'JsdocTypeIndexSignature',
                  key: y,
                  right: C.parseType(k.INDEX_BRACKETS),
                }),
                c.acceptLexerState(C));
            } else if (c.consume('in')) {
              const C = c.baseParser;
              (C.acceptLexerState(c),
                (T = { type: 'JsdocTypeMappedType', key: y, right: C.parseType(k.ARRAY_BRACKETS) }),
                c.acceptLexerState(C));
            } else throw new Error("Missing ':' or 'in' inside square bracketed property.");
            if (!c.consume(']')) throw new Error('Unterminated square brackets');
            return T;
          }, 'parsePrefix'),
        }),
        us = W({
          name: 'readonlyArrayParslet',
          accept: O((c) => c === 'readonly', 'accept'),
          parsePrefix: O(
            (c) => (
              c.consume('readonly'),
              { type: 'JsdocTypeReadonlyArray', element: D(c.parseIntermediateType(k.ALL)) }
            ),
            'parsePrefix',
          ),
        }),
        ds = W({
          name: 'conditionalParslet',
          precedence: k.INFIX,
          accept: O((c) => c === 'extends', 'accept'),
          parseInfix: O((c, y) => {
            c.consume('extends');
            const T = c.parseType(k.KEY_OF_TYPE_OF).element,
              C = c.parseType(k.INFIX);
            return (
              c.consume(':'),
              {
                type: 'JsdocTypeConditional',
                checksType: j(y),
                extendsType: T,
                trueType: C,
                falseType: c.parseType(k.INFIX),
              }
            );
          }, 'parseInfix'),
        }),
        ps = [
          os,
          re({ allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'] }),
          ie,
          ae,
          oe,
          be,
          gt({
            allowSquaredProperties: !0,
            allowKeyTypes: !1,
            allowOptional: !0,
            allowReadonly: !0,
          }),
          cs,
        ],
        fs = [
          ...J,
          ht({ allowKeyTypes: !1, objectFieldGrammar: ps }),
          us,
          dn,
          rs,
          ns,
          oe,
          it({
            allowWithoutParenthesis: !0,
            allowNoReturnType: !1,
            allowNamedParameters: ['this', 'new', 'args'],
            allowNewAsFunctionKeyword: !0,
          }),
          pn({ allowQuestionMark: !1 }),
          yt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
          ts,
          ds,
          re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
          ne({ allowedTypes: ['module'], pathGrammar: ye }),
          at,
          ss,
          is,
          Q({ allowSquareBracketsOnAnyType: !0, allowJsdocNamePaths: !1, pathGrammar: ye }),
          as,
          ls,
          bt({ allowVariadic: !0, allowOptional: !0 }),
        ];
      function yr(c, y) {
        switch (y) {
          case 'closure':
            return new X(es, c).parse();
          case 'jsdoc':
            return new X(Qo, c).parse();
          case 'typescript':
            return new X(fs, c).parse();
        }
      }
      O(yr, 'parse');
      function fn(c, y = ['typescript', 'closure', 'jsdoc']) {
        let T;
        for (const C of y)
          try {
            return yr(c, C);
          } catch (L) {
            T = L;
          }
        throw T;
      }
      O(fn, 'tryParse');
      function Y(c, y) {
        const T = c[y.type];
        if (T === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${y.type}.`);
        return T(y, (C) => Y(c, C));
      }
      O(Y, 'transform');
      function le(c) {
        throw new Error(
          'This transform is not available. Are you trying the correct parsing mode?',
        );
      }
      O(le, 'notAvailableTransform');
      function kt(c) {
        const y = { params: [] };
        for (const T of c.parameters)
          T.type === 'JsdocTypeKeyValue'
            ? T.key === 'this'
              ? (y.this = T.right)
              : T.key === 'new'
                ? (y.new = T.right)
                : y.params.push(T)
            : y.params.push(T);
        return y;
      }
      O(kt, 'extractSpecialParams');
      function zt(c, y, T) {
        return c === 'prefix' ? T + y : y + T;
      }
      O(zt, 'applyPosition');
      function Qe(c, y) {
        switch (y) {
          case 'double':
            return `"${c}"`;
          case 'single':
            return `'${c}'`;
          case void 0:
            return c;
        }
      }
      O(Qe, 'quote');
      function mn() {
        return {
          JsdocTypeParenthesis: O(
            (c, y) => `(${c.element !== void 0 ? y(c.element) : ''})`,
            'JsdocTypeParenthesis',
          ),
          JsdocTypeKeyof: O((c, y) => `keyof ${y(c.element)}`, 'JsdocTypeKeyof'),
          JsdocTypeFunction: O((c, y) => {
            var T;
            if (c.arrow) {
              if (c.returnType === void 0) throw new Error('Arrow function needs a return type.');
              let C = `${c.typeParameters !== void 0 ? `<${(T = c.typeParameters.map(y).join(', ')) !== null && T !== void 0 ? T : ''}>` : ''}(${c.parameters.map(y).join(', ')}) => ${y(c.returnType)}`;
              return (c.constructor && (C = 'new ' + C), C);
            } else {
              let C = c.constructor ? 'new' : 'function';
              return (
                c.parenthesis &&
                  ((C += `(${c.parameters.map(y).join(', ')})`),
                  c.returnType !== void 0 && (C += `: ${y(c.returnType)}`)),
                C
              );
            }
          }, 'JsdocTypeFunction'),
          JsdocTypeName: O((c) => c.value, 'JsdocTypeName'),
          JsdocTypeTuple: O((c, y) => `[${c.elements.map(y).join(', ')}]`, 'JsdocTypeTuple'),
          JsdocTypeVariadic: O(
            (c, y) =>
              c.meta.position === void 0 ? '...' : zt(c.meta.position, y(c.element), '...'),
            'JsdocTypeVariadic',
          ),
          JsdocTypeNamePath: O((c, y) => {
            const T = y(c.left),
              C = y(c.right);
            switch (c.pathType) {
              case 'inner':
                return `${T}~${C}`;
              case 'instance':
                return `${T}#${C}`;
              case 'property':
                return `${T}.${C}`;
              case 'property-brackets':
                return `${T}[${C}]`;
            }
          }, 'JsdocTypeNamePath'),
          JsdocTypeStringValue: O((c) => Qe(c.value, c.meta.quote), 'JsdocTypeStringValue'),
          JsdocTypeAny: O(() => '*', 'JsdocTypeAny'),
          JsdocTypeGeneric: O((c, y) => {
            if (c.meta.brackets === 'square') {
              const T = c.elements[0],
                C = y(T);
              return T.type === 'JsdocTypeUnion' || T.type === 'JsdocTypeIntersection'
                ? `(${C})[]`
                : `${C}[]`;
            } else
              return `${y(c.left)}${c.meta.dot ? '.' : ''}<${c.infer === !0 ? 'infer ' : ''}${c.elements.map(y).join(', ')}>`;
          }, 'JsdocTypeGeneric'),
          JsdocTypeImport: O((c, y) => `import(${y(c.element)})`, 'JsdocTypeImport'),
          JsdocTypeObjectField: O((c, y) => {
            let T = '';
            return (
              c.readonly && (T += 'readonly '),
              typeof c.key == 'string' ? (T += Qe(c.key, c.meta.quote)) : (T += y(c.key)),
              c.optional && (T += '?'),
              c.right === void 0 ? T : T + `: ${y(c.right)}`
            );
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: O(
            (c, y) => `${y(c.left)}: ${y(c.right)}`,
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeKeyValue: O((c, y) => {
            let T = c.key;
            return (
              c.optional && (T += '?'),
              c.variadic && (T = '...' + T),
              c.right === void 0 ? T : T + `: ${y(c.right)}`
            );
          }, 'JsdocTypeKeyValue'),
          JsdocTypeSpecialNamePath: O(
            (c) => `${c.specialType}:${Qe(c.value, c.meta.quote)}`,
            'JsdocTypeSpecialNamePath',
          ),
          JsdocTypeNotNullable: O(
            (c, y) => zt(c.meta.position, y(c.element), '!'),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeNull: O(() => 'null', 'JsdocTypeNull'),
          JsdocTypeNullable: O(
            (c, y) => zt(c.meta.position, y(c.element), '?'),
            'JsdocTypeNullable',
          ),
          JsdocTypeNumber: O((c) => c.value.toString(), 'JsdocTypeNumber'),
          JsdocTypeObject: O((c, y) => {
            var T, C;
            return `{${
              (c.meta.separator === 'linebreak' && c.elements.length > 1
                ? `
` + ((T = c.meta.propertyIndent) !== null && T !== void 0 ? T : '')
                : '') +
              c.elements.map(y).join(
                c.meta.separator === 'comma'
                  ? ', '
                  : c.meta.separator === 'linebreak'
                    ? `
` + ((C = c.meta.propertyIndent) !== null && C !== void 0 ? C : '')
                    : '; ',
              ) +
              (c.meta.separator === 'linebreak' && c.elements.length > 1
                ? `
`
                : '')
            }}`;
          }, 'JsdocTypeObject'),
          JsdocTypeOptional: O(
            (c, y) => zt(c.meta.position, y(c.element), '='),
            'JsdocTypeOptional',
          ),
          JsdocTypeSymbol: O(
            (c, y) => `${c.value}(${c.element !== void 0 ? y(c.element) : ''})`,
            'JsdocTypeSymbol',
          ),
          JsdocTypeTypeof: O((c, y) => `typeof ${y(c.element)}`, 'JsdocTypeTypeof'),
          JsdocTypeUndefined: O(() => 'undefined', 'JsdocTypeUndefined'),
          JsdocTypeUnion: O((c, y) => c.elements.map(y).join(' | '), 'JsdocTypeUnion'),
          JsdocTypeUnknown: O(() => '?', 'JsdocTypeUnknown'),
          JsdocTypeIntersection: O(
            (c, y) => c.elements.map(y).join(' & '),
            'JsdocTypeIntersection',
          ),
          JsdocTypeProperty: O((c) => Qe(c.value, c.meta.quote), 'JsdocTypeProperty'),
          JsdocTypePredicate: O((c, y) => `${y(c.left)} is ${y(c.right)}`, 'JsdocTypePredicate'),
          JsdocTypeIndexSignature: O(
            (c, y) => `[${c.key}: ${y(c.right)}]`,
            'JsdocTypeIndexSignature',
          ),
          JsdocTypeMappedType: O((c, y) => `[${c.key} in ${y(c.right)}]`, 'JsdocTypeMappedType'),
          JsdocTypeAsserts: O(
            (c, y) => `asserts ${y(c.left)} is ${y(c.right)}`,
            'JsdocTypeAsserts',
          ),
          JsdocTypeReadonlyArray: O((c, y) => `readonly ${y(c.element)}`, 'JsdocTypeReadonlyArray'),
          JsdocTypeAssertsPlain: O((c, y) => `asserts ${y(c.element)}`, 'JsdocTypeAssertsPlain'),
          JsdocTypeConditional: O(
            (c, y) =>
              `${y(c.checksType)} extends ${y(c.extendsType)} ? ${y(c.trueType)} : ${y(c.falseType)}`,
            'JsdocTypeConditional',
          ),
          JsdocTypeTypeParameter: O(
            (c, y) =>
              `${y(c.name)}${c.constraint !== void 0 ? ` extends ${y(c.constraint)}` : ''}${c.defaultValue !== void 0 ? ` = ${y(c.defaultValue)}` : ''}`,
            'JsdocTypeTypeParameter',
          ),
        };
      }
      O(mn, 'stringifyRules');
      const Kc = mn();
      function ms(c) {
        return Y(Kc, c);
      }
      O(ms, 'stringify');
      const Yc = [
        'null',
        'true',
        'false',
        'break',
        'case',
        'catch',
        'class',
        'const',
        'continue',
        'debugger',
        'default',
        'delete',
        'do',
        'else',
        'export',
        'extends',
        'finally',
        'for',
        'function',
        'if',
        'import',
        'in',
        'instanceof',
        'new',
        'return',
        'super',
        'switch',
        'this',
        'throw',
        'try',
        'typeof',
        'var',
        'void',
        'while',
        'with',
        'yield',
      ];
      function Ze(c) {
        const y = { type: 'NameExpression', name: c };
        return (Yc.includes(c) && (y.reservedWord = !0), y);
      }
      O(Ze, 'makeName');
      const Xc = {
        JsdocTypeOptional: O((c, y) => {
          const T = y(c.element);
          return ((T.optional = !0), T);
        }, 'JsdocTypeOptional'),
        JsdocTypeNullable: O((c, y) => {
          const T = y(c.element);
          return ((T.nullable = !0), T);
        }, 'JsdocTypeNullable'),
        JsdocTypeNotNullable: O((c, y) => {
          const T = y(c.element);
          return ((T.nullable = !1), T);
        }, 'JsdocTypeNotNullable'),
        JsdocTypeVariadic: O((c, y) => {
          if (c.element === void 0)
            throw new Error('dots without value are not allowed in catharsis mode');
          const T = y(c.element);
          return ((T.repeatable = !0), T);
        }, 'JsdocTypeVariadic'),
        JsdocTypeAny: O(() => ({ type: 'AllLiteral' }), 'JsdocTypeAny'),
        JsdocTypeNull: O(() => ({ type: 'NullLiteral' }), 'JsdocTypeNull'),
        JsdocTypeStringValue: O((c) => Ze(Qe(c.value, c.meta.quote)), 'JsdocTypeStringValue'),
        JsdocTypeUndefined: O(() => ({ type: 'UndefinedLiteral' }), 'JsdocTypeUndefined'),
        JsdocTypeUnknown: O(() => ({ type: 'UnknownLiteral' }), 'JsdocTypeUnknown'),
        JsdocTypeFunction: O((c, y) => {
          const T = kt(c),
            C = { type: 'FunctionType', params: T.params.map(y) };
          return (
            T.this !== void 0 && (C.this = y(T.this)),
            T.new !== void 0 && (C.new = y(T.new)),
            c.returnType !== void 0 && (C.result = y(c.returnType)),
            C
          );
        }, 'JsdocTypeFunction'),
        JsdocTypeGeneric: O(
          (c, y) => ({
            type: 'TypeApplication',
            applications: c.elements.map((T) => y(T)),
            expression: y(c.left),
          }),
          'JsdocTypeGeneric',
        ),
        JsdocTypeSpecialNamePath: O(
          (c) => Ze(c.specialType + ':' + Qe(c.value, c.meta.quote)),
          'JsdocTypeSpecialNamePath',
        ),
        JsdocTypeName: O(
          (c) => (c.value !== 'function' ? Ze(c.value) : { type: 'FunctionType', params: [] }),
          'JsdocTypeName',
        ),
        JsdocTypeNumber: O((c) => Ze(c.value.toString()), 'JsdocTypeNumber'),
        JsdocTypeObject: O((c, y) => {
          const T = { type: 'RecordType', fields: [] };
          for (const C of c.elements)
            C.type !== 'JsdocTypeObjectField' && C.type !== 'JsdocTypeJsdocObjectField'
              ? T.fields.push({ type: 'FieldType', key: y(C), value: void 0 })
              : T.fields.push(y(C));
          return T;
        }, 'JsdocTypeObject'),
        JsdocTypeObjectField: O((c, y) => {
          if (typeof c.key != 'string')
            throw new Error('Index signatures and mapped types are not supported');
          return {
            type: 'FieldType',
            key: Ze(Qe(c.key, c.meta.quote)),
            value: c.right === void 0 ? void 0 : y(c.right),
          };
        }, 'JsdocTypeObjectField'),
        JsdocTypeJsdocObjectField: O(
          (c, y) => ({ type: 'FieldType', key: y(c.left), value: y(c.right) }),
          'JsdocTypeJsdocObjectField',
        ),
        JsdocTypeUnion: O(
          (c, y) => ({ type: 'TypeUnion', elements: c.elements.map((T) => y(T)) }),
          'JsdocTypeUnion',
        ),
        JsdocTypeKeyValue: O(
          (c, y) => ({
            type: 'FieldType',
            key: Ze(c.key),
            value: c.right === void 0 ? void 0 : y(c.right),
          }),
          'JsdocTypeKeyValue',
        ),
        JsdocTypeNamePath: O((c, y) => {
          const T = y(c.left);
          let C;
          c.right.type === 'JsdocTypeSpecialNamePath'
            ? (C = y(c.right).name)
            : (C = Qe(c.right.value, c.right.meta.quote));
          const L = c.pathType === 'inner' ? '~' : c.pathType === 'instance' ? '#' : '.';
          return Ze(`${T.name}${L}${C}`);
        }, 'JsdocTypeNamePath'),
        JsdocTypeSymbol: O((c) => {
          let y = '',
            T = c.element,
            C = !1;
          return (
            T?.type === 'JsdocTypeVariadic' &&
              (T.meta.position === 'prefix' ? (y = '...') : (C = !0), (T = T.element)),
            T?.type === 'JsdocTypeName'
              ? (y += T.value)
              : T?.type === 'JsdocTypeNumber' && (y += T.value.toString()),
            C && (y += '...'),
            Ze(`${c.value}(${y})`)
          );
        }, 'JsdocTypeSymbol'),
        JsdocTypeParenthesis: O((c, y) => y(j(c.element)), 'JsdocTypeParenthesis'),
        JsdocTypeMappedType: le,
        JsdocTypeIndexSignature: le,
        JsdocTypeImport: le,
        JsdocTypeKeyof: le,
        JsdocTypeTuple: le,
        JsdocTypeTypeof: le,
        JsdocTypeIntersection: le,
        JsdocTypeProperty: le,
        JsdocTypePredicate: le,
        JsdocTypeAsserts: le,
        JsdocTypeReadonlyArray: le,
        JsdocTypeAssertsPlain: le,
        JsdocTypeConditional: le,
        JsdocTypeTypeParameter: le,
      };
      function ys(c) {
        return Y(Xc, c);
      }
      O(ys, 'catharsisTransform');
      function lt(c) {
        switch (c) {
          case void 0:
            return 'none';
          case 'single':
            return 'single';
          case 'double':
            return 'double';
        }
      }
      O(lt, 'getQuoteStyle');
      function hs(c) {
        switch (c) {
          case 'inner':
            return 'INNER_MEMBER';
          case 'instance':
            return 'INSTANCE_MEMBER';
          case 'property':
            return 'MEMBER';
          case 'property-brackets':
            return 'MEMBER';
        }
      }
      O(hs, 'getMemberType');
      function hr(c, y) {
        return y.length === 2
          ? { type: c, left: y[0], right: y[1] }
          : { type: c, left: y[0], right: hr(c, y.slice(1)) };
      }
      O(hr, 'nestResults');
      const Qc = {
        JsdocTypeOptional: O(
          (c, y) => ({
            type: 'OPTIONAL',
            value: y(c.element),
            meta: {
              syntax: c.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN',
            },
          }),
          'JsdocTypeOptional',
        ),
        JsdocTypeNullable: O(
          (c, y) => ({
            type: 'NULLABLE',
            value: y(c.element),
            meta: {
              syntax:
                c.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK',
            },
          }),
          'JsdocTypeNullable',
        ),
        JsdocTypeNotNullable: O(
          (c, y) => ({
            type: 'NOT_NULLABLE',
            value: y(c.element),
            meta: { syntax: c.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG' },
          }),
          'JsdocTypeNotNullable',
        ),
        JsdocTypeVariadic: O((c, y) => {
          const T = {
            type: 'VARIADIC',
            meta: {
              syntax:
                c.meta.position === 'prefix'
                  ? 'PREFIX_DOTS'
                  : c.meta.position === 'suffix'
                    ? 'SUFFIX_DOTS'
                    : 'ONLY_DOTS',
            },
          };
          return (c.element !== void 0 && (T.value = y(c.element)), T);
        }, 'JsdocTypeVariadic'),
        JsdocTypeName: O((c) => ({ type: 'NAME', name: c.value }), 'JsdocTypeName'),
        JsdocTypeTypeof: O(
          (c, y) => ({ type: 'TYPE_QUERY', name: y(c.element) }),
          'JsdocTypeTypeof',
        ),
        JsdocTypeTuple: O(
          (c, y) => ({ type: 'TUPLE', entries: c.elements.map(y) }),
          'JsdocTypeTuple',
        ),
        JsdocTypeKeyof: O((c, y) => ({ type: 'KEY_QUERY', value: y(c.element) }), 'JsdocTypeKeyof'),
        JsdocTypeImport: O(
          (c) => ({
            type: 'IMPORT',
            path: {
              type: 'STRING_VALUE',
              quoteStyle: lt(c.element.meta.quote),
              string: c.element.value,
            },
          }),
          'JsdocTypeImport',
        ),
        JsdocTypeUndefined: O(() => ({ type: 'NAME', name: 'undefined' }), 'JsdocTypeUndefined'),
        JsdocTypeAny: O(() => ({ type: 'ANY' }), 'JsdocTypeAny'),
        JsdocTypeFunction: O((c, y) => {
          const T = kt(c),
            C = {
              type: c.arrow ? 'ARROW' : 'FUNCTION',
              params: T.params.map((L) => {
                if (L.type === 'JsdocTypeKeyValue') {
                  if (L.right === void 0)
                    throw new Error(
                      "Function parameter without ':' is not expected to be 'KEY_VALUE'",
                    );
                  return { type: 'NAMED_PARAMETER', name: L.key, typeName: y(L.right) };
                } else return y(L);
              }),
              new: null,
              returns: null,
            };
          return (
            T.this !== void 0 ? (C.this = y(T.this)) : c.arrow || (C.this = null),
            T.new !== void 0 && (C.new = y(T.new)),
            c.returnType !== void 0 && (C.returns = y(c.returnType)),
            C
          );
        }, 'JsdocTypeFunction'),
        JsdocTypeGeneric: O((c, y) => {
          const T = {
            type: 'GENERIC',
            subject: y(c.left),
            objects: c.elements.map(y),
            meta: {
              syntax:
                c.meta.brackets === 'square'
                  ? 'SQUARE_BRACKET'
                  : c.meta.dot
                    ? 'ANGLE_BRACKET_WITH_DOT'
                    : 'ANGLE_BRACKET',
            },
          };
          return (
            c.meta.brackets === 'square' &&
              c.elements[0].type === 'JsdocTypeFunction' &&
              !c.elements[0].parenthesis &&
              (T.objects[0] = { type: 'NAME', name: 'function' }),
            T
          );
        }, 'JsdocTypeGeneric'),
        JsdocTypeObjectField: O((c, y) => {
          if (typeof c.key != 'string')
            throw new Error('Index signatures and mapped types are not supported');
          if (c.right === void 0)
            return {
              type: 'RECORD_ENTRY',
              key: c.key,
              quoteStyle: lt(c.meta.quote),
              value: null,
              readonly: !1,
            };
          let T = y(c.right);
          return (
            c.optional &&
              (T = { type: 'OPTIONAL', value: T, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
            {
              type: 'RECORD_ENTRY',
              key: c.key.toString(),
              quoteStyle: lt(c.meta.quote),
              value: T,
              readonly: !1,
            }
          );
        }, 'JsdocTypeObjectField'),
        JsdocTypeJsdocObjectField: O(() => {
          throw new Error('Keys may not be typed in jsdoctypeparser.');
        }, 'JsdocTypeJsdocObjectField'),
        JsdocTypeKeyValue: O((c, y) => {
          if (c.right === void 0)
            return {
              type: 'RECORD_ENTRY',
              key: c.key,
              quoteStyle: 'none',
              value: null,
              readonly: !1,
            };
          let T = y(c.right);
          return (
            c.optional &&
              (T = { type: 'OPTIONAL', value: T, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
            { type: 'RECORD_ENTRY', key: c.key, quoteStyle: 'none', value: T, readonly: !1 }
          );
        }, 'JsdocTypeKeyValue'),
        JsdocTypeObject: O((c, y) => {
          const T = [];
          for (const C of c.elements)
            (C.type === 'JsdocTypeObjectField' || C.type === 'JsdocTypeJsdocObjectField') &&
              T.push(y(C));
          return { type: 'RECORD', entries: T };
        }, 'JsdocTypeObject'),
        JsdocTypeSpecialNamePath: O((c) => {
          if (c.specialType !== 'module')
            throw new Error(
              `jsdoctypeparser does not support type ${c.specialType} at this point.`,
            );
          return {
            type: 'MODULE',
            value: { type: 'FILE_PATH', quoteStyle: lt(c.meta.quote), path: c.value },
          };
        }, 'JsdocTypeSpecialNamePath'),
        JsdocTypeNamePath: O((c, y) => {
          let T = !1,
            C,
            L;
          c.right.type === 'JsdocTypeSpecialNamePath' && c.right.specialType === 'event'
            ? ((T = !0), (C = c.right.value), (L = lt(c.right.meta.quote)))
            : ((C = c.right.value), (L = lt(c.right.meta.quote)));
          const G = {
            type: hs(c.pathType),
            owner: y(c.left),
            name: C,
            quoteStyle: L,
            hasEventPrefix: T,
          };
          if (G.owner.type === 'MODULE') {
            const Z = G.owner;
            return ((G.owner = G.owner.value), (Z.value = G), Z);
          } else return G;
        }, 'JsdocTypeNamePath'),
        JsdocTypeUnion: O((c, y) => hr('UNION', c.elements.map(y)), 'JsdocTypeUnion'),
        JsdocTypeParenthesis: O(
          (c, y) => ({ type: 'PARENTHESIS', value: y(j(c.element)) }),
          'JsdocTypeParenthesis',
        ),
        JsdocTypeNull: O(() => ({ type: 'NAME', name: 'null' }), 'JsdocTypeNull'),
        JsdocTypeUnknown: O(() => ({ type: 'UNKNOWN' }), 'JsdocTypeUnknown'),
        JsdocTypeStringValue: O(
          (c) => ({ type: 'STRING_VALUE', quoteStyle: lt(c.meta.quote), string: c.value }),
          'JsdocTypeStringValue',
        ),
        JsdocTypeIntersection: O(
          (c, y) => hr('INTERSECTION', c.elements.map(y)),
          'JsdocTypeIntersection',
        ),
        JsdocTypeNumber: O(
          (c) => ({ type: 'NUMBER_VALUE', number: c.value.toString() }),
          'JsdocTypeNumber',
        ),
        JsdocTypeSymbol: le,
        JsdocTypeProperty: le,
        JsdocTypePredicate: le,
        JsdocTypeMappedType: le,
        JsdocTypeIndexSignature: le,
        JsdocTypeAsserts: le,
        JsdocTypeReadonlyArray: le,
        JsdocTypeAssertsPlain: le,
        JsdocTypeConditional: le,
        JsdocTypeTypeParameter: le,
      };
      function gs(c) {
        return Y(Qc, c);
      }
      O(gs, 'jtpTransform');
      function bs() {
        return {
          JsdocTypeIntersection: O(
            (c, y) => ({ type: 'JsdocTypeIntersection', elements: c.elements.map(y) }),
            'JsdocTypeIntersection',
          ),
          JsdocTypeGeneric: O(
            (c, y) => ({
              type: 'JsdocTypeGeneric',
              left: y(c.left),
              elements: c.elements.map(y),
              meta: { dot: c.meta.dot, brackets: c.meta.brackets },
            }),
            'JsdocTypeGeneric',
          ),
          JsdocTypeNullable: O((c) => c, 'JsdocTypeNullable'),
          JsdocTypeUnion: O(
            (c, y) => ({ type: 'JsdocTypeUnion', elements: c.elements.map(y) }),
            'JsdocTypeUnion',
          ),
          JsdocTypeUnknown: O((c) => c, 'JsdocTypeUnknown'),
          JsdocTypeUndefined: O((c) => c, 'JsdocTypeUndefined'),
          JsdocTypeTypeof: O(
            (c, y) => ({ type: 'JsdocTypeTypeof', element: y(c.element) }),
            'JsdocTypeTypeof',
          ),
          JsdocTypeSymbol: O((c, y) => {
            const T = { type: 'JsdocTypeSymbol', value: c.value };
            return (c.element !== void 0 && (T.element = y(c.element)), T);
          }, 'JsdocTypeSymbol'),
          JsdocTypeOptional: O(
            (c, y) => ({
              type: 'JsdocTypeOptional',
              element: y(c.element),
              meta: { position: c.meta.position },
            }),
            'JsdocTypeOptional',
          ),
          JsdocTypeObject: O(
            (c, y) => ({
              type: 'JsdocTypeObject',
              meta: { separator: 'comma' },
              elements: c.elements.map(y),
            }),
            'JsdocTypeObject',
          ),
          JsdocTypeNumber: O((c) => c, 'JsdocTypeNumber'),
          JsdocTypeNull: O((c) => c, 'JsdocTypeNull'),
          JsdocTypeNotNullable: O(
            (c, y) => ({
              type: 'JsdocTypeNotNullable',
              element: y(c.element),
              meta: { position: c.meta.position },
            }),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeSpecialNamePath: O((c) => c, 'JsdocTypeSpecialNamePath'),
          JsdocTypeObjectField: O(
            (c, y) => ({
              type: 'JsdocTypeObjectField',
              key: c.key,
              right: c.right === void 0 ? void 0 : y(c.right),
              optional: c.optional,
              readonly: c.readonly,
              meta: c.meta,
            }),
            'JsdocTypeObjectField',
          ),
          JsdocTypeJsdocObjectField: O(
            (c, y) => ({ type: 'JsdocTypeJsdocObjectField', left: y(c.left), right: y(c.right) }),
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeKeyValue: O(
            (c, y) => ({
              type: 'JsdocTypeKeyValue',
              key: c.key,
              right: c.right === void 0 ? void 0 : y(c.right),
              optional: c.optional,
              variadic: c.variadic,
            }),
            'JsdocTypeKeyValue',
          ),
          JsdocTypeImport: O(
            (c, y) => ({ type: 'JsdocTypeImport', element: y(c.element) }),
            'JsdocTypeImport',
          ),
          JsdocTypeAny: O((c) => c, 'JsdocTypeAny'),
          JsdocTypeStringValue: O((c) => c, 'JsdocTypeStringValue'),
          JsdocTypeNamePath: O((c) => c, 'JsdocTypeNamePath'),
          JsdocTypeVariadic: O((c, y) => {
            const T = {
              type: 'JsdocTypeVariadic',
              meta: { position: c.meta.position, squareBrackets: c.meta.squareBrackets },
            };
            return (c.element !== void 0 && (T.element = y(c.element)), T);
          }, 'JsdocTypeVariadic'),
          JsdocTypeTuple: O(
            (c, y) => ({ type: 'JsdocTypeTuple', elements: c.elements.map(y) }),
            'JsdocTypeTuple',
          ),
          JsdocTypeName: O((c) => c, 'JsdocTypeName'),
          JsdocTypeFunction: O((c, y) => {
            const T = {
              type: 'JsdocTypeFunction',
              arrow: c.arrow,
              parameters: c.parameters.map(y),
              constructor: c.constructor,
              parenthesis: c.parenthesis,
            };
            return (c.returnType !== void 0 && (T.returnType = y(c.returnType)), T);
          }, 'JsdocTypeFunction'),
          JsdocTypeKeyof: O(
            (c, y) => ({ type: 'JsdocTypeKeyof', element: y(c.element) }),
            'JsdocTypeKeyof',
          ),
          JsdocTypeParenthesis: O(
            (c, y) => ({ type: 'JsdocTypeParenthesis', element: y(c.element) }),
            'JsdocTypeParenthesis',
          ),
          JsdocTypeProperty: O((c) => c, 'JsdocTypeProperty'),
          JsdocTypePredicate: O(
            (c, y) => ({ type: 'JsdocTypePredicate', left: y(c.left), right: y(c.right) }),
            'JsdocTypePredicate',
          ),
          JsdocTypeIndexSignature: O(
            (c, y) => ({ type: 'JsdocTypeIndexSignature', key: c.key, right: y(c.right) }),
            'JsdocTypeIndexSignature',
          ),
          JsdocTypeMappedType: O(
            (c, y) => ({ type: 'JsdocTypeMappedType', key: c.key, right: y(c.right) }),
            'JsdocTypeMappedType',
          ),
          JsdocTypeAsserts: O(
            (c, y) => ({ type: 'JsdocTypeAsserts', left: y(c.left), right: y(c.right) }),
            'JsdocTypeAsserts',
          ),
          JsdocTypeReadonlyArray: O(
            (c, y) => ({ type: 'JsdocTypeReadonlyArray', element: y(c.element) }),
            'JsdocTypeReadonlyArray',
          ),
          JsdocTypeAssertsPlain: O(
            (c, y) => ({ type: 'JsdocTypeAssertsPlain', element: y(c.element) }),
            'JsdocTypeAssertsPlain',
          ),
          JsdocTypeConditional: O(
            (c, y) => ({
              type: 'JsdocTypeConditional',
              checksType: y(c.checksType),
              extendsType: y(c.extendsType),
              trueType: y(c.trueType),
              falseType: y(c.falseType),
            }),
            'JsdocTypeConditional',
          ),
          JsdocTypeTypeParameter: O(
            (c, y) => ({
              type: 'JsdocTypeTypeParameter',
              name: y(c.name),
              constraint: c.constraint !== void 0 ? y(c.constraint) : void 0,
              defaultValue: c.defaultValue !== void 0 ? y(c.defaultValue) : void 0,
            }),
            'JsdocTypeTypeParameter',
          ),
        };
      }
      O(bs, 'identityTransformRules');
      const vs = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ['parameters', 'returnType'],
        JsdocTypeGeneric: ['left', 'elements'],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ['right'],
        JsdocTypeIntersection: ['elements'],
        JsdocTypeKeyof: ['element'],
        JsdocTypeKeyValue: ['right'],
        JsdocTypeMappedType: ['right'],
        JsdocTypeName: [],
        JsdocTypeNamePath: ['left', 'right'],
        JsdocTypeNotNullable: ['element'],
        JsdocTypeNull: [],
        JsdocTypeNullable: ['element'],
        JsdocTypeNumber: [],
        JsdocTypeObject: ['elements'],
        JsdocTypeObjectField: ['right'],
        JsdocTypeJsdocObjectField: ['left', 'right'],
        JsdocTypeOptional: ['element'],
        JsdocTypeParenthesis: ['element'],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ['element'],
        JsdocTypeTuple: ['elements'],
        JsdocTypeTypeof: ['element'],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ['elements'],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ['element'],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ['left', 'right'],
        JsdocTypeAsserts: ['left', 'right'],
        JsdocTypeReadonlyArray: ['element'],
        JsdocTypeAssertsPlain: ['element'],
        JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],
        JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue'],
      };
      function gr(c, y, T, C, L) {
        C?.(c, y, T);
        const G = vs[c.type];
        for (const Z of G) {
          const ce = c[Z];
          if (ce !== void 0)
            if (Array.isArray(ce)) for (const _e of ce) gr(_e, c, Z, C, L);
            else gr(ce, c, Z, C, L);
        }
        L?.(c, y, T);
      }
      O(gr, '_traverse');
      function Ts(c, y, T) {
        gr(c, void 0, void 0, y, T);
      }
      (O(Ts, 'traverse'),
        (r.catharsisTransform = ys),
        (r.identityTransformRules = bs),
        (r.jtpTransform = gs),
        (r.parse = yr),
        (r.stringify = ms),
        (r.stringifyRules = mn),
        (r.transform = Y),
        (r.traverse = Ts),
        (r.tryParse = fn),
        (r.visitorKeys = vs));
    });
  },
});
const { UnknownArgTypesError: LK } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__,
  { UnknownArgTypesError: FK } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
var $z = ['null', 'undefined'];
function Gc(e) {
  return $z.some((t) => t === e);
}
O(Gc, 'isDefaultValueBlacklisted');
var qz = O((e) => {
  if (!e) return '';
  if (typeof e == 'string') return e;
  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);
}, 'str');
function rg(e) {
  return !!e.__docgenInfo;
}
O(rg, 'hasDocgen');
function Mz(e) {
  return e != null && Object.keys(e).length > 0;
}
O(Mz, 'isValidDocgenSection');
function jz(e, t) {
  return rg(e) ? e.__docgenInfo[t] : null;
}
O(jz, 'getDocgenSection');
function BN(e) {
  return rg(e) ? qz(e.__docgenInfo.description) : '';
}
O(BN, 'getDocgenDescription');
var Yr;
(function (e) {
  ((e.start = '/**'), (e.nostart = '/***'), (e.delim = '*'), (e.end = '*/'));
})((Yr = Yr || (Yr = {})));
function JN(e) {
  return /^\s+$/.test(e);
}
O(JN, 'isSpace');
function UN(e) {
  const t = e.match(/\r+$/);
  return t == null ? ['', e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];
}
O(UN, 'splitCR');
function xn(e) {
  const t = e.match(/^\s+/);
  return t == null ? ['', e] : [e.slice(0, t[0].length), e.slice(t[0].length)];
}
O(xn, 'splitSpace');
function VN(e) {
  return e.split(/\n/);
}
O(VN, 'splitLines');
function HN(e = {}) {
  return Object.assign(
    { tag: '', name: '', type: '', optional: !1, description: '', problems: [], source: [] },
    e,
  );
}
O(HN, 'seedSpec');
function zN(e = {}) {
  return Object.assign(
    {
      start: '',
      delimiter: '',
      postDelimiter: '',
      tag: '',
      postTag: '',
      name: '',
      postName: '',
      type: '',
      postType: '',
      description: '',
      end: '',
      lineEnd: '',
    },
    e,
  );
}
O(zN, 'seedTokens');
var kz = /^@\S+/;
function GN({ fence: e = '```' } = {}) {
  const t = WN(e),
    r = O((n, o) => (t(n) ? !o : o), 'toggleFence');
  return O(function (o) {
    const i = [[]];
    let a = !1;
    for (const l of o)
      (kz.test(l.tokens.description) && !a ? i.push([l]) : i[i.length - 1].push(l),
        (a = r(l.tokens.description, a)));
    return i;
  }, 'parseBlock');
}
O(GN, 'getParser');
function WN(e) {
  return typeof e == 'string' ? (t) => t.split(e).length % 2 === 0 : e;
}
O(WN, 'getFencer');
function KN({ startLine: e = 0, markers: t = Yr } = {}) {
  let r = null,
    n = e;
  return O(function (i) {
    let a = i;
    const l = zN();
    if (
      (([l.lineEnd, a] = UN(a)),
      ([l.start, a] = xn(a)),
      r === null &&
        a.startsWith(t.start) &&
        !a.startsWith(t.nostart) &&
        ((r = []),
        (l.delimiter = a.slice(0, t.start.length)),
        (a = a.slice(t.start.length)),
        ([l.postDelimiter, a] = xn(a))),
      r === null)
    )
      return (n++, null);
    const d = a.trimRight().endsWith(t.end);
    if (
      (l.delimiter === '' &&
        a.startsWith(t.delim) &&
        !a.startsWith(t.end) &&
        ((l.delimiter = t.delim), (a = a.slice(t.delim.length)), ([l.postDelimiter, a] = xn(a))),
      d)
    ) {
      const u = a.trimRight();
      ((l.end = a.slice(u.length - t.end.length)), (a = u.slice(0, -t.end.length)));
    }
    if (((l.description = a), r.push({ number: n, source: i, tokens: l }), n++, d)) {
      const u = r.slice();
      return ((r = null), u);
    }
    return null;
  }, 'parseSource');
}
O(KN, 'getParser');
function YN({ tokenizers: e }) {
  return O(function (r) {
    var n;
    let o = HN({ source: r });
    for (const i of e)
      if (
        ((o = i(o)),
        !((n = o.problems[o.problems.length - 1]) === null || n === void 0) && n.critical)
      )
        break;
    return o;
  }, 'parseSpec');
}
O(YN, 'getParser');
function XN() {
  return (e) => {
    const { tokens: t } = e.source[0],
      r = t.description.match(/\s*(@(\S+))(\s*)/);
    return r === null
      ? (e.problems.push({
          code: 'spec:tag:prefix',
          message: 'tag should start with "@" symbol',
          line: e.source[0].number,
          critical: !0,
        }),
        e)
      : ((t.tag = r[1]),
        (t.postTag = r[3]),
        (t.description = t.description.slice(r[0].length)),
        (e.tag = r[2]),
        e);
  };
}
O(XN, 'tagTokenizer');
function QN(e = 'compact') {
  const t = ZN(e);
  return (r) => {
    let n = 0,
      o = [];
    for (const [l, { tokens: d }] of r.source.entries()) {
      let u = '';
      if (l === 0 && d.description[0] !== '{') return r;
      for (const p of d.description)
        if ((p === '{' && n++, p === '}' && n--, (u += p), n === 0)) break;
      if ((o.push([d, u]), n === 0)) break;
    }
    if (n !== 0)
      return (
        r.problems.push({
          code: 'spec:type:unpaired-curlies',
          message: 'unpaired curlies',
          line: r.source[0].number,
          critical: !0,
        }),
        r
      );
    const i = [],
      a = o[0][0].postDelimiter.length;
    for (const [l, [d, u]] of o.entries())
      ((d.type = u),
        l > 0 &&
          ((d.type = d.postDelimiter.slice(a) + u),
          (d.postDelimiter = d.postDelimiter.slice(0, a))),
        ([d.postType, d.description] = xn(d.description.slice(u.length))),
        i.push(d.type));
    return (
      (i[0] = i[0].slice(1)),
      (i[i.length - 1] = i[i.length - 1].slice(0, -1)),
      (r.type = t(i)),
      r
    );
  };
}
O(QN, 'typeTokenizer');
var Dz = O((e) => e.trim(), 'trim');
function ZN(e) {
  return e === 'compact'
    ? (t) => t.map(Dz).join('')
    : e === 'preserve'
      ? (t) =>
          t.join(`
`)
      : e;
}
O(ZN, 'getJoiner');
var Lz = O((e) => e && e.startsWith('"') && e.endsWith('"'), 'isQuoted');
function e$() {
  const e = O((t, { tokens: r }, n) => (r.type === '' ? t : n), 'typeEnd');
  return (t) => {
    const { tokens: r } = t.source[t.source.reduce(e, 0)],
      n = r.description.trimLeft(),
      o = n.split('"');
    if (o.length > 1 && o[0] === '' && o.length % 2 === 1)
      return (
        (t.name = o[1]),
        (r.name = `"${o[1]}"`),
        ([r.postName, r.description] = xn(n.slice(r.name.length))),
        t
      );
    let i = 0,
      a = '',
      l = !1,
      d;
    for (const p of n) {
      if (i === 0 && JN(p)) break;
      (p === '[' && i++, p === ']' && i--, (a += p));
    }
    if (i !== 0)
      return (
        t.problems.push({
          code: 'spec:name:unpaired-brackets',
          message: 'unpaired brackets',
          line: t.source[0].number,
          critical: !0,
        }),
        t
      );
    const u = a;
    if (a[0] === '[' && a[a.length - 1] === ']') {
      ((l = !0), (a = a.slice(1, -1)));
      const p = a.split('=');
      if (((a = p[0].trim()), p[1] !== void 0 && (d = p.slice(1).join('=').trim()), a === ''))
        return (
          t.problems.push({
            code: 'spec:name:empty-name',
            message: 'empty name',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
      if (d === '')
        return (
          t.problems.push({
            code: 'spec:name:empty-default',
            message: 'empty default value',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
      if (!Lz(d) && /=(?!>)/.test(d))
        return (
          t.problems.push({
            code: 'spec:name:invalid-default',
            message: 'invalid default value syntax',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
    }
    return (
      (t.optional = l),
      (t.name = a),
      (r.name = u),
      d !== void 0 && (t.default = d),
      ([r.postName, r.description] = xn(n.slice(r.name.length))),
      t
    );
  };
}
O(e$, 'nameTokenizer');
function t$(e = 'compact', t = Yr) {
  const r = ng(e);
  return (n) => ((n.description = r(n.source, t)), n);
}
O(t$, 'descriptionTokenizer');
function ng(e) {
  return e === 'compact' ? r$ : e === 'preserve' ? n$ : e;
}
O(ng, 'getJoiner');
function r$(e, t = Yr) {
  return e
    .map(({ tokens: { description: r } }) => r.trim())
    .filter((r) => r !== '')
    .join(' ');
}
O(r$, 'compactJoiner');
var Fz = O((e, { tokens: t }, r) => (t.type === '' ? e : r), 'lineNo'),
  Bz = O(
    ({ tokens: e }) => (e.delimiter === '' ? e.start : e.postDelimiter.slice(1)) + e.description,
    'getDescription',
  );
function n$(e, t = Yr) {
  if (e.length === 0) return '';
  e[0].tokens.description === '' && e[0].tokens.delimiter === t.start && (e = e.slice(1));
  const r = e[e.length - 1];
  return (
    r !== void 0 &&
      r.tokens.description === '' &&
      r.tokens.end.endsWith(t.end) &&
      (e = e.slice(0, -1)),
    (e = e.slice(e.reduce(Fz, 0))),
    e.map(Bz).join(`
`)
  );
}
O(n$, 'preserveJoiner');
function o$({
  startLine: e = 0,
  fence: t = '```',
  spacing: r = 'compact',
  markers: n = Yr,
  tokenizers: o = [XN(), QN(r), e$(), t$(r)],
} = {}) {
  if (e < 0 || e % 1 > 0) throw new Error('Invalid startLine');
  const i = KN({ startLine: e, markers: n }),
    a = GN({ fence: t }),
    l = YN({ tokenizers: o }),
    d = ng(r);
  return function (u) {
    const p = [];
    for (const f of VN(u)) {
      const m = i(f);
      if (m === null) continue;
      const h = a(m),
        g = h.slice(1).map(l);
      p.push({
        description: d(h[0], n),
        tags: g,
        source: m,
        problems: g.reduce((v, E) => v.concat(E.problems), []),
      });
    }
    return p;
  };
}
O(o$, 'getParser');
function s$(e) {
  return (
    e.start +
    e.delimiter +
    e.postDelimiter +
    e.tag +
    e.postTag +
    e.type +
    e.postType +
    e.name +
    e.postName +
    e.description +
    e.end +
    e.lineEnd
  );
}
O(s$, 'join');
function Jz() {
  return (e) =>
    e.source.map(({ tokens: t }) => s$(t)).join(`
`);
}
O(Jz, 'getStringifier');
function i$(e, t = {}) {
  return o$(t)(e);
}
O(i$, 'parse');
var og = Pz(Nz());
function a$(e) {
  return e != null && e.includes('@');
}
O(a$, 'containsJsDoc');
function l$(e) {
  const n =
      `/**
` +
      (e ?? '')
        .split(
          `
`,
        )
        .map((i) => ` * ${i}`).join(`
`) +
      `
*/`,
    o = i$(n, { spacing: 'preserve' });
  if (!o || o.length === 0) throw new Error('Cannot parse JSDoc tags.');
  return o[0];
}
O(l$, 'parse');
var Uz = { tags: ['param', 'arg', 'argument', 'returns', 'ignore', 'deprecated'] },
  Vz = O((e, t = Uz) => {
    if (!a$(e)) return { includesJsDoc: !1, ignore: !1 };
    const r = l$(e),
      n = c$(r, t.tags);
    return n.ignore
      ? { includesJsDoc: !0, ignore: !0 }
      : { includesJsDoc: !0, ignore: !1, description: r.description.trim(), extractedTags: n };
  }, 'parseJsDoc');
function c$(e, t) {
  const r = { params: null, deprecated: null, returns: null, ignore: !1 };
  for (const n of e.tags)
    if (!(t !== void 0 && !t.includes(n.tag)))
      if (n.tag === 'ignore') {
        r.ignore = !0;
        break;
      } else
        switch (n.tag) {
          case 'param':
          case 'arg':
          case 'argument': {
            const o = d$(n);
            o != null && (r.params == null && (r.params = []), r.params.push(o));
            break;
          }
          case 'deprecated': {
            const o = p$(n);
            o != null && (r.deprecated = o);
            break;
          }
          case 'returns': {
            const o = f$(n);
            o != null && (r.returns = o);
            break;
          }
        }
  return r;
}
O(c$, 'extractJsDocTags');
function u$(e) {
  return e.replace(/[\.-]$/, '');
}
O(u$, 'normaliseParamName');
function d$(e) {
  if (!e.name || e.name === '-') return null;
  const t = ag(e.type);
  return {
    name: e.name,
    type: t,
    description: ig(e.description),
    getPrettyName: O(() => u$(e.name), 'getPrettyName'),
    getTypeName: O(() => (t ? lg(t) : null), 'getTypeName'),
  };
}
O(d$, 'extractParam');
function p$(e) {
  return e.name ? sg(e.name, e.description) : null;
}
O(p$, 'extractDeprecated');
function sg(e, t) {
  const r = e === '' ? t : `${e} ${t}`;
  return ig(r);
}
O(sg, 'joinNameAndDescription');
function ig(e) {
  const t = e.replace(/^- /g, '').trim();
  return t === '' ? null : t;
}
O(ig, 'normaliseDescription');
function f$(e) {
  const t = ag(e.type);
  return t
    ? {
        type: t,
        description: sg(e.name, e.description),
        getTypeName: O(() => lg(t), 'getTypeName'),
      }
    : null;
}
O(f$, 'extractReturns');
var cn = (0, og.stringifyRules)(),
  Hz = cn.JsdocTypeObject;
cn.JsdocTypeAny = () => 'any';
cn.JsdocTypeObject = (e, t) => `(${Hz(e, t)})`;
cn.JsdocTypeOptional = (e, t) => t(e.element);
cn.JsdocTypeNullable = (e, t) => t(e.element);
cn.JsdocTypeNotNullable = (e, t) => t(e.element);
cn.JsdocTypeUnion = (e, t) => e.elements.map(t).join('|');
function ag(e) {
  try {
    return (0, og.parse)(e, 'typescript');
  } catch {
    return null;
  }
}
O(ag, 'extractType');
function lg(e) {
  return (0, og.transform)(cn, e);
}
O(lg, 'extractTypeName');
var zz = 90,
  Gz = 50;
function cg(e) {
  return e.length > zz;
}
O(cg, 'isTooLongForTypeSummary');
function m$(e) {
  return e.length > Gz;
}
O(m$, 'isTooLongForDefaultValueSummary');
function st(e, t) {
  return e === t ? { summary: e } : { summary: e, detail: t };
}
O(st, 'createSummaryValue');
function Wz(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!Gc(r)) return m$(r) ? st(t?.name, r) : st(r);
  }
  return null;
}
O(Wz, 'createDefaultValue');
function ug({ name: e, value: t, elements: r, raw: n }) {
  return t ?? (r != null ? r.map(ug).join(' | ') : (n ?? e));
}
O(ug, 'generateUnionElement');
function y$({ name: e, raw: t, elements: r }) {
  return r != null ? st(r.map(ug).join(' | ')) : t != null ? st(t.replace(/^\|\s*/, '')) : st(e);
}
O(y$, 'generateUnion');
function h$({ type: e, raw: t }) {
  return t != null ? st(t) : st(e);
}
O(h$, 'generateFuncSignature');
function g$({ type: e, raw: t }) {
  return t != null ? (cg(t) ? st(e, t) : st(t)) : st(e);
}
O(g$, 'generateObjectSignature');
function b$(e) {
  const { type: t } = e;
  return t === 'object' ? g$(e) : h$(e);
}
O(b$, 'generateSignature');
function v$({ name: e, raw: t }) {
  return t != null ? (cg(t) ? st(e, t) : st(t)) : st(e);
}
O(v$, 'generateDefault');
function Kz(e) {
  if (e == null) return null;
  switch (e.name) {
    case 'union':
      return y$(e);
    case 'signature':
      return b$(e);
    default:
      return v$(e);
  }
}
O(Kz, 'createType');
function Yz({ defaultValue: e }) {
  if (e != null) {
    const { value: t } = e;
    if (!Gc(t)) return st(t);
  }
  return null;
}
O(Yz, 'createDefaultValue');
function Xz({ tsType: e, required: t }) {
  if (e == null) return null;
  let r = e.name;
  return (
    t || (r = r.replace(' | undefined', '')),
    st(['Array', 'Record', 'signature'].includes(e.name) ? e.raw : r)
  );
}
O(Xz, 'createType');
function T$(e) {
  return e != null ? st(e.name) : null;
}
O(T$, 'createType');
function E$(e) {
  const { computed: t, func: r } = e;
  return typeof t > 'u' && typeof r > 'u';
}
O(E$, 'isReactDocgenTypescript');
function w$(e) {
  return e
    ? e.name === 'string'
      ? !0
      : e.name === 'enum'
        ? Array.isArray(e.value) &&
          e.value.every(
            ({ value: t }) => typeof t == 'string' && t[0] === '"' && t[t.length - 1] === '"',
          )
        : !1
    : !1;
}
O(w$, 'isStringValued');
function S$(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!Gc(r)) return E$(e) && w$(t) ? st(JSON.stringify(r)) : st(r);
  }
  return null;
}
O(S$, 'createDefaultValue');
function Qz(e, t, r) {
  const { description: n, required: o, defaultValue: i } = r;
  return { name: e, type: T$(t), required: o, description: n, defaultValue: S$(i, t) };
}
O(Qz, 'createBasicPropDef');
function Zz(e, t) {
  if (t?.includesJsDoc) {
    const { description: r, extractedTags: n } = t;
    r != null && (e.description = t.description);
    const o = {
      ...n,
      params: n?.params?.map((i) => ({ name: i.getPrettyName(), description: i.description })),
    };
    Object.values(o).filter(Boolean).length > 0 && (e.jsDocTags = o);
  }
  return e;
}
O(Zz, 'applyJsDocResult');
function eG(e, t, r, n) {
  const o = Vz(t.description);
  return o.includesJsDoc && o.ignore
    ? null
    : { propDef: n(e, t, o), jsDocTags: o.extractedTags, docgenInfo: t, typeSystem: r };
}
O(eG, 'extractProp');
function tG(e) {
  return e != null ? BN(e) : '';
}
O(tG, 'extractComponentDescription');
var _$ = O((...e) => {
    const t = {},
      r = e.filter(Boolean),
      n = r.reduce(
        (o, i) => (
          Object.entries(i).forEach(([a, l]) => {
            const d = o[a];
            Array.isArray(l) || typeof d > 'u'
              ? (o[a] = l)
              : ya(l) && ya(d)
                ? (t[a] = !0)
                : typeof l < 'u' && (o[a] = l);
          }),
          o
        ),
        {},
      );
    return (
      Object.keys(t).forEach((o) => {
        const i = r
          .filter(Boolean)
          .map((a) => a[o])
          .filter((a) => typeof a < 'u');
        i.every((a) => ya(a)) ? (n[o] = _$(...i)) : (n[o] = i[i.length - 1]);
      }),
      n
    );
  }, 'combineParameters'),
  A$ = O((e) => {
    const {
        component: t,
        argTypes: r,
        parameters: { docs: n = {} },
      } = e,
      { extractArgTypes: o } = n;
    if (!o || !t) return r;
    const i = o(t);
    return i ? _$(i, r) : r;
  }, 'enhanceArgTypes');
const rG = 'modulepreload',
  nG = function (e, t) {
    return new URL(e, t).href;
  },
  hv = {},
  bn = function (t, r, n) {
    let o = Promise.resolve();
    if (r && r.length > 0) {
      let u = function (p) {
        return Promise.all(
          p.map((f) =>
            Promise.resolve(f).then(
              (m) => ({ status: 'fulfilled', value: m }),
              (m) => ({ status: 'rejected', reason: m }),
            ),
          ),
        );
      };
      const a = document.getElementsByTagName('link'),
        l = document.querySelector('meta[property=csp-nonce]'),
        d = l?.nonce || l?.getAttribute('nonce');
      o = u(
        r.map((p) => {
          if (((p = nG(p, n)), p in hv)) return;
          hv[p] = !0;
          const f = p.endsWith('.css'),
            m = f ? '[rel="stylesheet"]' : '';
          if (n)
            for (let g = a.length - 1; g >= 0; g--) {
              const v = a[g];
              if (v.href === p && (!f || v.rel === 'stylesheet')) return;
            }
          else if (document.querySelector(`link[href="${p}"]${m}`)) return;
          const h = document.createElement('link');
          if (
            ((h.rel = f ? 'stylesheet' : rG),
            f || (h.as = 'script'),
            (h.crossOrigin = ''),
            (h.href = p),
            d && h.setAttribute('nonce', d),
            document.head.appendChild(h),
            f)
          )
            return new Promise((g, v) => {
              (h.addEventListener('load', g),
                h.addEventListener('error', () => v(new Error(`Unable to preload CSS for ${p}`))));
            });
        }),
      );
    }
    function i(a) {
      const l = new Event('vite:preloadError', { cancelable: !0 });
      if (((l.payload = a), window.dispatchEvent(l), !l.defaultPrevented)) throw a;
    }
    return o.then((a) => {
      for (const l of a || []) l.status === 'rejected' && i(l.reason);
      return t().catch(i);
    });
  },
  oG = {
    './src/components/badge/badge.stories.tsx': () =>
      bn(() => import('./badge.stories-DUekZ21X.js'), [], import.meta.url),
    './src/components/button/button.stories.tsx': () =>
      bn(() => import('./button.stories-B2frilgI.js'), [], import.meta.url),
    './src/components/image/image.stories.tsx': () =>
      bn(() => import('./image.stories-CAZ9pY8A.js'), [], import.meta.url),
    './src/components/section/section.stories.tsx': () =>
      bn(() => import('./section.stories-B7pvsyer.js'), [], import.meta.url),
    './src/components/typography/typography.stories.tsx': () =>
      bn(() => import('./typography.stories-DZW3qyuF.js'), [], import.meta.url),
    './src/components/wrapper/wrapper.stories.tsx': () =>
      bn(() => import('./wrapper.stories-BreOltLX.js'), [], import.meta.url),
  };
async function sG(e) {
  return await oG[e]();
}
var ze = {
    allRenderFn: !1,
    element: !0,
    event: !0,
    hasRenderFn: !0,
    hostListener: !0,
    hostListenerTargetWindow: !0,
    hostListenerTargetDocument: !0,
    hostListenerTargetBody: !0,
    hostListenerTargetParent: !1,
    hostListenerTarget: !0,
    member: !0,
    method: !0,
    mode: !0,
    observeAttribute: !0,
    prop: !0,
    propMutable: !0,
    reflect: !0,
    scoped: !0,
    shadowDom: !0,
    slot: !0,
    cssAnnotations: !0,
    state: !0,
    style: !0,
    formAssociated: !1,
    svg: !0,
    updatable: !0,
    vdomAttribute: !0,
    vdomXlink: !0,
    vdomClass: !0,
    vdomFunctional: !0,
    vdomKey: !0,
    vdomListener: !0,
    vdomRef: !0,
    vdomPropOrAttr: !0,
    vdomRender: !0,
    vdomStyle: !0,
    vdomText: !0,
    propChangeCallback: !0,
    taskQueue: !0,
    hotModuleReplacement: !1,
    isDebug: !1,
    isDev: !1,
    isTesting: !1,
    hydrateServerSide: !1,
    hydrateClientSide: !1,
    lifecycleDOMEvents: !1,
    lazyLoad: !1,
    profile: !1,
    slotRelocation: !0,
    appendChildSlotFix: !1,
    cloneNodeFix: !1,
    hydratedAttribute: !1,
    hydratedClass: !0,
    scriptDataOpts: !1,
    scopedSlotTextContentFix: !1,
    shadowDomShim: !1,
    slotChildNodesFix: !1,
    invisiblePrehydration: !0,
    propBoolean: !0,
    propNumber: !0,
    propString: !0,
    constructableCSS: !0,
    devTools: !1,
    shadowDelegatesFocus: !0,
    initializeNextTick: !1,
    asyncLoading: !0,
    asyncQueue: !1,
    transformTagName: !1,
    attachStyles: !0,
    experimentalSlotFixes: !1,
  },
  iG = 'app',
  aG = Object.defineProperty,
  lG = (e, t) => {
    for (var r in t) aG(e, r, { get: t[r], enumerable: !0 });
  },
  cG = 'http://www.w3.org/2000/svg',
  uG = 'http://www.w3.org/1999/xhtml',
  dG = (e, t) => {
    var r;
    const n = t.$cmpMeta$;
    Object.entries((r = n.$members$) != null ? r : {}).map(([i, [a]]) => {
      if (a & 31 || a & 32) {
        const l = e[i],
          d = pG(Object.getPrototypeOf(e), i) || Object.getOwnPropertyDescriptor(e, i);
        (d &&
          Object.defineProperty(e, i, {
            get() {
              return d.get.call(this);
            },
            set(u) {
              d.set.call(this, u);
            },
            configurable: !0,
            enumerable: !0,
          }),
          (e[i] = t.$instanceValues$.has(i) ? t.$instanceValues$.get(i) : l));
      }
    });
  };
function pG(e, t) {
  for (; e; ) {
    const r = Object.getOwnPropertyDescriptor(e, t);
    if (r?.get) return r;
    e = Object.getPrototypeOf(e);
  }
}
var Fn = (e) => {
    if (e.__stencil__getHostRef) return e.__stencil__getHostRef();
  },
  fG = (e, t) => {
    const r = {
      $flags$: 0,
      $hostElement$: e,
      $cmpMeta$: t,
      $instanceValues$: new Map(),
      $serializerValues$: new Map(),
    };
    ((r.$onReadyPromise$ = new Promise((o) => (r.$onReadyResolve$ = o))),
      (e['s-p'] = []),
      (e['s-rc'] = []));
    const n = r;
    return ((e.__stencil__getHostRef = () => n), t.$flags$ & 512 && ze.state && dG(e, r), n);
  },
  gv = (e, t) => t in e,
  Vi = (e, t) => (0, console.error)(e, t),
  fl = new Map(),
  mG = [],
  yG = 'slot-fb{display:contents}slot-fb[hidden]{display:none}',
  bv = 'http://www.w3.org/1999/xlink',
  Ge = typeof window < 'u' ? window : {},
  BK = Ge.HTMLElement || class {},
  Et = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (e) => e(),
    raf: (e) => requestAnimationFrame(e),
    ael: (e, t, r, n) => e.addEventListener(t, r, n),
    rel: (e, t, r, n) => e.removeEventListener(t, r, n),
    ce: (e, t) => new CustomEvent(e, t),
  },
  hG = (e) => Promise.resolve(e),
  dg = (() => {
    try {
      return (new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == 'function');
    } catch {}
    return !1;
  })(),
  Ap = dg
    ? !!Ge.document &&
      Object.getOwnPropertyDescriptor(Ge.document.adoptedStyleSheets, 'length').writable
    : !1,
  Rp = !1,
  vv = [],
  R$ = [],
  gG = (e, t) => (r) => {
    (e.push(r), Rp || ((Rp = !0), t && Et.$flags$ & 4 ? pg(Pp) : Et.raf(Pp)));
  },
  Tv = (e) => {
    for (let t = 0; t < e.length; t++)
      try {
        e[t](performance.now());
      } catch (r) {
        Vi(r);
      }
    e.length = 0;
  },
  Pp = () => {
    (Tv(vv), Tv(R$), (Rp = vv.length > 0) && Et.raf(Pp));
  },
  pg = (e) => hG().then(e),
  bG = gG(R$, !0),
  vG = (e) => e != null && e !== void 0,
  fg = (e) => ((e = typeof e), e === 'object' || e === 'function');
function TG(e) {
  var t, r, n;
  return (n =
    (r = (t = e.head) == null ? void 0 : t.querySelector('meta[name="csp-nonce"]')) == null
      ? void 0
      : r.getAttribute('content')) != null
    ? n
    : void 0;
}
var EG = (e) => e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
  wG = {};
lG(wG, { err: () => P$, map: () => SG, ok: () => xp, unwrap: () => _G, unwrapErr: () => AG });
var xp = (e) => ({ isOk: !0, isErr: !1, value: e }),
  P$ = (e) => ({ isOk: !1, isErr: !0, value: e });
function SG(e, t) {
  if (e.isOk) {
    const r = t(e.value);
    return r instanceof Promise ? r.then((n) => xp(n)) : xp(r);
  }
  if (e.isErr) {
    const r = e.value;
    return P$(r);
  }
  throw 'should never get here';
}
var _G = (e) => {
    if (e.isOk) return e.value;
    throw e.value;
  },
  AG = (e) => {
    if (e.isErr) return e.value;
    throw e.value;
  };
var xs;
function RG(e) {
  var t;
  const r = this.attachShadow({ mode: 'open', delegatesFocus: !!(e.$flags$ & 16) });
  (xs === void 0 && (xs = (t = void 0) != null ? t : null),
    xs &&
      (Ap
        ? r.adoptedStyleSheets.push(xs)
        : (r.adoptedStyleSheets = [...r.adoptedStyleSheets, xs])));
}
var x$ = (e) => {
    const t = wv(e, 'childNodes');
    e.tagName &&
      e.tagName.includes('-') &&
      e['s-cr'] &&
      e.tagName !== 'SLOT-FB' &&
      O$(t, e.tagName).forEach((n) => {
        n.nodeType === 1 &&
          n.tagName === 'SLOT-FB' &&
          (xG(n, mg(n), !1).length ? (n.hidden = !0) : (n.hidden = !1));
      });
    let r = 0;
    for (r = 0; r < t.length; r++) {
      const n = t[r];
      n.nodeType === 1 && wv(n, 'childNodes').length && x$(n);
    }
  },
  PG = (e) => {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r]['s-nr'] || void 0;
      n && n.isConnected && t.push(n);
    }
    return t;
  };
function O$(e, t, r) {
  let n = 0,
    o = [],
    i;
  for (; n < e.length; n++)
    ((i = e[n]),
      i['s-sr'] && (!t || i['s-hn'] === t) && r === void 0 && o.push(i),
      (o = [...o, ...O$(i.childNodes, t, r)]));
  return o;
}
var xG = (e, t, r = !0) => {
    const n = [];
    ((r && e['s-sr']) || !e['s-sr']) && n.push(e);
    let o = e;
    for (; (o = o.nextSibling); ) mg(o) === t && (r || !o['s-sr']) && n.push(o);
    return n;
  },
  Ev = (e, t) =>
    e.nodeType === 1
      ? (e.getAttribute('slot') === null && t === '') || e.getAttribute('slot') === t
      : e['s-sn'] === t
        ? !0
        : t === '',
  mg = (e) =>
    typeof e['s-sn'] == 'string'
      ? e['s-sn']
      : (e.nodeType === 1 && e.getAttribute('slot')) || void 0;
function OG(e) {
  if (e.assignedElements || e.assignedNodes || !e['s-sr']) return;
  const t = (r) =>
    function (n) {
      const o = [],
        i = this['s-sn'];
      n?.flatten &&
        console.error(`
          Flattening is not supported for Stencil non-shadow slots.
          You can use \`.childNodes\` to nested slot fallback content.
          If you have a particular use case, please open an issue on the Stencil repo.
        `);
      const a = this['s-cr'].parentElement;
      return (
        (a.__childNodes ? a.childNodes : PG(a.childNodes)).forEach((d) => {
          i === mg(d) && o.push(d);
        }),
        r ? o.filter((d) => d.nodeType === 1) : o
      );
    }.bind(e);
  ((e.assignedElements = t(!0)), (e.assignedNodes = t(!1)));
}
function wv(e, t) {
  if ('__' + t in e) {
    const r = e['__' + t];
    return typeof r != 'function' ? r : r.bind(e);
  } else return typeof e[t] != 'function' ? e[t] : e[t].bind(e);
}
var Bn =
    (e, t = '') =>
    () => {},
  co = new WeakMap(),
  CG = (e, t, r) => {
    let n = fl.get(e);
    (dg && r
      ? ((n = n || new CSSStyleSheet()), typeof n == 'string' ? (n = t) : n.replaceSync(t))
      : (n = t),
      fl.set(e, n));
  },
  IG = (e, t, r) => {
    var n;
    const o = C$(t, r),
      i = fl.get(o);
    if (!Ge.document) return o;
    if (((e = e.nodeType === 11 ? e : Ge.document), i))
      if (typeof i == 'string') {
        e = e.head || e;
        let a = co.get(e),
          l;
        if ((a || co.set(e, (a = new Set())), !a.has(o))) {
          {
            ((l = Ge.document.createElement('style')), (l.innerHTML = i));
            const d = (n = Et.$nonce$) != null ? n : TG(Ge.document);
            if ((d != null && l.setAttribute('nonce', d), !(t.$flags$ & 1)))
              if (e.nodeName === 'HEAD') {
                const u = e.querySelectorAll('link[rel=preconnect]'),
                  p = u.length > 0 ? u[u.length - 1].nextSibling : e.querySelector('style');
                e.insertBefore(l, p?.parentNode === e ? p : null);
              } else if ('host' in e)
                if (dg) {
                  const u = new CSSStyleSheet();
                  (u.replaceSync(i),
                    Ap
                      ? e.adoptedStyleSheets.unshift(u)
                      : (e.adoptedStyleSheets = [u, ...e.adoptedStyleSheets]));
                } else {
                  const u = e.querySelector('style');
                  u ? (u.innerHTML = i + u.innerHTML) : e.prepend(l);
                }
              else e.append(l);
            t.$flags$ & 1 && e.insertBefore(l, null);
          }
          (t.$flags$ & 4 && (l.innerHTML += yG), a && a.add(o));
        }
      } else
        e.adoptedStyleSheets.includes(i) ||
          (Ap
            ? e.adoptedStyleSheets.push(i)
            : (e.adoptedStyleSheets = [...e.adoptedStyleSheets, i]));
    return o;
  },
  NG = (e) => {
    const t = e.$cmpMeta$,
      r = e.$hostElement$,
      n = t.$flags$,
      o = Bn('attachStyles', t.$tagName$),
      i = IG(r.shadowRoot ? r.shadowRoot : r.getRootNode(), t, e.$modeName$);
    (n & 10 && ((r['s-sc'] = i), r.classList.add(i + '-h')), o());
  },
  C$ = (e, t) => 'sc-' + (t && e.$flags$ & 32 ? e.$tagName$ + '-' + t : e.$tagName$),
  ml = (e, t, ...r) => {
    let n = null,
      o = null,
      i = null,
      a = !1,
      l = !1;
    const d = [],
      u = (f) => {
        for (let m = 0; m < f.length; m++)
          ((n = f[m]),
            Array.isArray(n)
              ? u(n)
              : n != null &&
                typeof n != 'boolean' &&
                ((a = typeof e != 'function' && !fg(n)) && (n = String(n)),
                a && l ? (d[d.length - 1].$text$ += n) : d.push(a ? yl(null, n) : n),
                (l = a)));
      };
    if ((u(r), t)) {
      (t.key && (o = t.key), t.name && (i = t.name));
      {
        const f = t.className || t.class;
        f &&
          (t.class =
            typeof f != 'object'
              ? f
              : Object.keys(f)
                  .filter((m) => f[m])
                  .join(' '));
      }
    }
    if (typeof e == 'function') return e(t === null ? {} : t, d, MG);
    const p = yl(e, null);
    return ((p.$attrs$ = t), d.length > 0 && (p.$children$ = d), (p.$key$ = o), (p.$name$ = i), p);
  },
  yl = (e, t) => {
    const r = { $flags$: 0, $tag$: e, $text$: t, $elm$: null, $children$: null };
    return ((r.$attrs$ = null), (r.$key$ = null), (r.$name$ = null), r);
  },
  $G = {},
  qG = (e) => e && e.$tag$ === $G,
  MG = { forEach: (e, t) => e.map(Sv).forEach(t), map: (e, t) => e.map(Sv).map(t).map(jG) },
  Sv = (e) => ({
    vattrs: e.$attrs$,
    vchildren: e.$children$,
    vkey: e.$key$,
    vname: e.$name$,
    vtag: e.$tag$,
    vtext: e.$text$,
  }),
  jG = (e) => {
    if (typeof e.vtag == 'function') {
      const r = { ...e.vattrs };
      return (
        e.vkey && (r.key = e.vkey),
        e.vname && (r.name = e.vname),
        ml(e.vtag, r, ...(e.vchildren || []))
      );
    }
    const t = yl(e.vtag, e.vtext);
    return (
      (t.$attrs$ = e.vattrs),
      (t.$children$ = e.vchildren),
      (t.$key$ = e.vkey),
      (t.$name$ = e.vname),
      t
    );
  },
  yg = (e) => {
    const t = EG(e);
    return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`, 'g');
  };
yg('::slotted');
yg(':host');
yg(':host-context');
var kG = (e) => mG.map((t) => t(e)).find((t) => !!t),
  I$ = (e, t, r) =>
    e != null && !fg(e)
      ? t & 4
        ? e === 'false'
          ? !1
          : e === '' || !!e
        : t & 2
          ? typeof e == 'string'
            ? parseFloat(e)
            : typeof e == 'number'
              ? e
              : NaN
          : t & 1
            ? String(e)
            : e
      : e,
  DG = (e) => e,
  JK = (e, t, r) => {
    const n = DG(e);
    return { emit: (o) => N$(n, t, { bubbles: !0, composed: !0, cancelable: !0, detail: o }) };
  },
  N$ = (e, t, r) => {
    const n = Et.ce(t, r);
    return (e.dispatchEvent(n), n);
  },
  _v = (e, t, r, n, o, i, a) => {
    if (r === n) return;
    let l = gv(e, t),
      d = t.toLowerCase();
    if (t === 'class') {
      const u = e.classList,
        p = Av(r);
      let f = Av(n);
      (u.remove(...p.filter((m) => m && !f.includes(m))),
        u.add(...f.filter((m) => m && !p.includes(m))));
    } else if (t === 'style') {
      for (const u in r)
        (!n || n[u] == null) && (u.includes('-') ? e.style.removeProperty(u) : (e.style[u] = ''));
      for (const u in n)
        (!r || n[u] !== r[u]) &&
          (u.includes('-') ? e.style.setProperty(u, n[u]) : (e.style[u] = n[u]));
    } else if (t !== 'key')
      if (t === 'ref') n && n(e);
      else if (!e.__lookupSetter__(t) && t[0] === 'o' && t[1] === 'n') {
        if (
          (t[2] === '-' ? (t = t.slice(3)) : gv(Ge, d) ? (t = d.slice(2)) : (t = d[2] + t.slice(3)),
          r || n)
        ) {
          const u = t.endsWith($$);
          ((t = t.replace(FG, '')), r && Et.rel(e, t, r, u), n && Et.ael(e, t, n, u));
        }
      } else {
        const u = fg(n);
        if ((l || (u && n !== null)) && !o)
          try {
            if (e.tagName.includes('-')) e[t] !== n && (e[t] = n);
            else {
              const f = n ?? '';
              t === 'list'
                ? (l = !1)
                : (r == null || e[t] != f) &&
                  (typeof e.__lookupSetter__(t) == 'function' ? (e[t] = f) : e.setAttribute(t, f));
            }
          } catch {}
        let p = !1;
        (d !== (d = d.replace(/^xlink\:?/, '')) && ((t = d), (p = !0)),
          n == null || n === !1
            ? (n !== !1 || e.getAttribute(t) === '') &&
              (p ? e.removeAttributeNS(bv, t) : e.removeAttribute(t))
            : (!l || i & 4 || o) &&
              !u &&
              e.nodeType === 1 &&
              ((n = n === !0 ? '' : n), p ? e.setAttributeNS(bv, t, n) : e.setAttribute(t, n)));
      }
  },
  LG = /\s/,
  Av = (e) => (
    typeof e == 'object' && e && 'baseVal' in e && (e = e.baseVal),
    !e || typeof e != 'string' ? [] : e.split(LG)
  ),
  $$ = 'Capture',
  FG = new RegExp($$ + '$'),
  Op = (e, t, r, n) => {
    const o = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$,
      i = (e && e.$attrs$) || {},
      a = t.$attrs$ || {};
    for (const l of Rv(Object.keys(i))) l in a || _v(o, l, i[l], void 0, r, t.$flags$);
    for (const l of Rv(Object.keys(a))) _v(o, l, i[l], a[l], r, t.$flags$);
  };
function Rv(e) {
  return e.includes('ref') ? [...e.filter((t) => t !== 'ref'), 'ref'] : e;
}
var ga,
  hl,
  vi,
  Cp = !1,
  gl = !1,
  hg = !1,
  St = !1,
  bl = (e, t, r) => {
    var n;
    const o = t.$children$[r];
    let i = 0,
      a,
      l,
      d;
    if (
      (Cp || ((hg = !0), o.$tag$ === 'slot' && (o.$flags$ |= o.$children$ ? 2 : 1)),
      o.$text$ !== null)
    )
      a = o.$elm$ = Ge.document.createTextNode(o.$text$);
    else if (o.$flags$ & 1) ((a = o.$elm$ = Ge.document.createTextNode('')), Op(null, o, St));
    else {
      if ((St || (St = o.$tag$ === 'svg'), !Ge.document))
        throw new Error(
          "You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.",
        );
      if (
        ((a = o.$elm$ =
          Ge.document.createElementNS(
            St ? cG : uG,
            !Cp && ze.slotRelocation && o.$flags$ & 2 ? 'slot-fb' : o.$tag$,
          )),
        St && o.$tag$ === 'foreignObject' && (St = !1),
        Op(null, o, St),
        vG(ga) && a['s-si'] !== ga && a.classList.add((a['s-si'] = ga)),
        o.$children$)
      )
        for (i = 0; i < o.$children$.length; ++i) ((l = bl(e, o, i)), l && a.appendChild(l));
      o.$tag$ === 'svg' ? (St = !1) : a.tagName === 'foreignObject' && (St = !0);
    }
    return (
      (a['s-hn'] = vi),
      o.$flags$ & 3 &&
        ((a['s-sr'] = !0),
        (a['s-cr'] = hl),
        (a['s-sn'] = o.$name$ || ''),
        (a['s-rf'] = (n = o.$attrs$) == null ? void 0 : n.ref),
        OG(a),
        (d = e && e.$children$ && e.$children$[r]),
        d && d.$tag$ === o.$tag$ && e.$elm$ && Ti(e.$elm$, !1),
        D$(hl, a, t.$elm$, e?.$elm$)),
      a
    );
  },
  Ti = (e, t) => {
    Et.$flags$ |= 1;
    const r = Array.from(e.__childNodes || e.childNodes);
    e['s-sr'] && ze.experimentalSlotFixes;
    for (let n = r.length - 1; n >= 0; n--) {
      const o = r[n];
      (o['s-hn'] !== vi &&
        o['s-ol'] &&
        (Xr(Ei(o).parentNode, o, Ei(o)),
        o['s-ol'].remove(),
        (o['s-ol'] = void 0),
        (o['s-sh'] = void 0),
        (hg = !0)),
        t && Ti(o, t));
    }
    Et.$flags$ &= -2;
  },
  q$ = (e, t, r, n, o, i) => {
    let a = (e['s-cr'] && e['s-cr'].parentNode) || e,
      l;
    for (a.shadowRoot && a.tagName === vi && (a = a.shadowRoot); o <= i; ++o)
      n[o] && ((l = bl(null, r, o)), l && ((n[o].$elm$ = l), Xr(a, l, Ei(t))));
  },
  M$ = (e, t, r) => {
    for (let n = t; n <= r; ++n) {
      const o = e[n];
      if (o) {
        const i = o.$elm$;
        (k$(o), i && ((gl = !0), i['s-ol'] ? i['s-ol'].remove() : Ti(i, !0), i.remove()));
      }
    }
  },
  BG = (e, t, r, n, o = !1) => {
    let i = 0,
      a = 0,
      l = 0,
      d = 0,
      u = t.length - 1,
      p = t[0],
      f = t[u],
      m = n.length - 1,
      h = n[0],
      g = n[m],
      v,
      E;
    for (; i <= u && a <= m; )
      if (p == null) p = t[++i];
      else if (f == null) f = t[--u];
      else if (h == null) h = n[++a];
      else if (g == null) g = n[--m];
      else if (Qi(p, h, o)) (ro(p, h, o), (p = t[++i]), (h = n[++a]));
      else if (Qi(f, g, o)) (ro(f, g, o), (f = t[--u]), (g = n[--m]));
      else if (Qi(p, g, o))
        ((p.$tag$ === 'slot' || g.$tag$ === 'slot') && Ti(p.$elm$.parentNode, !1),
          ro(p, g, o),
          Xr(e, p.$elm$, f.$elm$.nextSibling),
          (p = t[++i]),
          (g = n[--m]));
      else if (Qi(f, h, o))
        ((p.$tag$ === 'slot' || g.$tag$ === 'slot') && Ti(f.$elm$.parentNode, !1),
          ro(f, h, o),
          Xr(e, f.$elm$, p.$elm$),
          (f = t[--u]),
          (h = n[++a]));
      else {
        for (l = -1, d = i; d <= u; ++d)
          if (t[d] && t[d].$key$ !== null && t[d].$key$ === h.$key$) {
            l = d;
            break;
          }
        (l >= 0
          ? ((E = t[l]),
            E.$tag$ !== h.$tag$
              ? (v = bl(t && t[a], r, l))
              : (ro(E, h, o), (t[l] = void 0), (v = E.$elm$)),
            (h = n[++a]))
          : ((v = bl(t && t[a], r, a)), (h = n[++a])),
          v && Xr(Ei(p.$elm$).parentNode, v, Ei(p.$elm$)));
      }
    i > u ? q$(e, n[m + 1] == null ? null : n[m + 1].$elm$, r, n, a, m) : a > m && M$(t, i, u);
  },
  Qi = (e, t, r = !1) =>
    e.$tag$ === t.$tag$
      ? e.$tag$ === 'slot'
        ? e.$name$ === t.$name$
        : r
          ? (r && !e.$key$ && t.$key$ && (e.$key$ = t.$key$), !0)
          : e.$key$ === t.$key$
      : !1,
  Ei = (e) => (e && e['s-ol']) || e,
  ro = (e, t, r = !1) => {
    const n = (t.$elm$ = e.$elm$),
      o = e.$children$,
      i = t.$children$,
      a = t.$tag$,
      l = t.$text$;
    let d;
    l === null
      ? ((St = a === 'svg' ? !0 : a === 'foreignObject' ? !1 : St),
        Op(e, t, St),
        o !== null && i !== null
          ? BG(n, o, t, i, r)
          : i !== null
            ? (e.$text$ !== null && (n.textContent = ''), q$(n, null, t, i, 0, i.length - 1))
            : !r && ze.updatable && o !== null && M$(o, 0, o.length - 1),
        St && a === 'svg' && (St = !1))
      : (d = n['s-cr'])
        ? (d.parentNode.textContent = l)
        : e.$text$ !== l && (n.data = l);
  },
  Pr = [],
  j$ = (e) => {
    let t, r, n;
    const o = e.__childNodes || e.childNodes;
    for (const i of o) {
      if (i['s-sr'] && (t = i['s-cr']) && t.parentNode) {
        r = t.parentNode.__childNodes || t.parentNode.childNodes;
        const a = i['s-sn'];
        for (n = r.length - 1; n >= 0; n--)
          if (((t = r[n]), !t['s-cn'] && !t['s-nr'] && t['s-hn'] !== i['s-hn']))
            if (Ev(t, a)) {
              let l = Pr.find((d) => d.$nodeToRelocate$ === t);
              ((gl = !0),
                (t['s-sn'] = t['s-sn'] || a),
                l
                  ? ((l.$nodeToRelocate$['s-sh'] = i['s-hn']), (l.$slotRefNode$ = i))
                  : ((t['s-sh'] = i['s-hn']), Pr.push({ $slotRefNode$: i, $nodeToRelocate$: t })),
                t['s-sr'] &&
                  Pr.map((d) => {
                    Ev(d.$nodeToRelocate$, t['s-sn']) &&
                      ((l = Pr.find((u) => u.$nodeToRelocate$ === t)),
                      l && !d.$slotRefNode$ && (d.$slotRefNode$ = l.$slotRefNode$));
                  }));
            } else Pr.some((l) => l.$nodeToRelocate$ === t) || Pr.push({ $nodeToRelocate$: t });
      }
      i.nodeType === 1 && j$(i);
    }
  },
  k$ = (e) => {
    (e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(k$));
  },
  Xr = (e, t, r) => (
    typeof t['s-sn'] == 'string' && t['s-sr'] && t['s-cr'] && D$(t['s-cr'], t, e, t.parentElement),
    e?.insertBefore(t, r)
  );
function D$(e, t, r, n) {
  var o, i;
  let a;
  if (
    e &&
    typeof t['s-sn'] == 'string' &&
    t['s-sr'] &&
    e.parentNode &&
    e.parentNode['s-sc'] &&
    (a = t['s-si'] || e.parentNode['s-sc'])
  ) {
    const l = t['s-sn'],
      d = t['s-hn'];
    if (
      ((o = r.classList) == null || o.add(a + '-s'),
      n && (i = n.classList) != null && i.contains(a + '-s'))
    ) {
      let u = (n.__childNodes || n.childNodes)[0],
        p = !1;
      for (; u; ) {
        if (u['s-sn'] !== l && u['s-hn'] === d && u['s-sr']) {
          p = !0;
          break;
        }
        u = u.nextSibling;
      }
      p || n.classList.remove(a + '-s');
    }
  }
}
var L$ = (e, t, r = !1) => {
    var n, o, i, a, l;
    const d = e.$hostElement$,
      u = e.$cmpMeta$,
      p = e.$vnode$ || yl(null, null),
      m = qG(t) ? t : ml(null, null, t);
    if (
      ((vi = d.tagName),
      u.$attrsToReflect$ &&
        ((m.$attrs$ = m.$attrs$ || {}),
        u.$attrsToReflect$.forEach(([h, g]) => {
          ze.serializer && e.$serializerValues$.has(h)
            ? (m.$attrs$[g] = e.$serializerValues$.get(h))
            : (m.$attrs$[g] = d[h]);
        })),
      r && m.$attrs$)
    )
      for (const h of Object.keys(m.$attrs$))
        d.hasAttribute(h) && !['key', 'ref', 'style', 'class'].includes(h) && (m.$attrs$[h] = d[h]);
    ((m.$tag$ = null),
      (m.$flags$ |= 4),
      (e.$vnode$ = m),
      (m.$elm$ = p.$elm$ = d.shadowRoot || d),
      (ga = d['s-sc']),
      (Cp = !!(u.$flags$ & 1) && !(u.$flags$ & 128)),
      (hl = d['s-cr']),
      (gl = !1),
      ro(p, m, r));
    {
      if (((Et.$flags$ |= 1), hg)) {
        j$(m.$elm$);
        for (const h of Pr) {
          const g = h.$nodeToRelocate$;
          if (!g['s-ol'] && Ge.document) {
            const v = Ge.document.createTextNode('');
            ((v['s-nr'] = g), Xr(g.parentNode, (g['s-ol'] = v), g));
          }
        }
        for (const h of Pr) {
          const g = h.$nodeToRelocate$,
            v = h.$slotRefNode$;
          if (v) {
            const E = v.parentNode;
            let b = v.nextSibling;
            {
              let I = (n = g['s-ol']) == null ? void 0 : n.previousSibling;
              for (; I; ) {
                let $ = (o = I['s-nr']) != null ? o : null;
                if ($ && $['s-sn'] === g['s-sn'] && E === ($.__parentNode || $.parentNode)) {
                  for ($ = $.nextSibling; $ === g || $?.['s-sr']; ) $ = $?.nextSibling;
                  if (!$ || !$['s-nr']) {
                    b = $;
                    break;
                  }
                }
                I = I.previousSibling;
              }
            }
            const S = g.__parentNode || g.parentNode,
              R = g.__nextSibling || g.nextSibling;
            (((!b && E !== S) || R !== b) &&
              g !== b &&
              (!g['s-hn'] && g['s-ol'] && (g['s-hn'] = g['s-ol'].parentNode.nodeName),
              Xr(E, g, b),
              g.nodeType === 1 &&
                g.tagName !== 'SLOT-FB' &&
                (g.hidden = (i = g['s-ih']) != null ? i : !1)),
              g && typeof v['s-rf'] == 'function' && v['s-rf'](v));
          } else
            g.nodeType === 1 &&
              (r && (g['s-ih'] = (a = g.hidden) != null ? a : !1), (g.hidden = !0));
        }
      }
      (gl && x$(m.$elm$), (Et.$flags$ &= -2), (Pr.length = 0));
    }
    if (ze.experimentalScopedSlotChanges && u.$flags$ & 2) {
      const h = m.$elm$.__childNodes || m.$elm$.childNodes;
      for (const g of h)
        g['s-hn'] !== vi &&
          !g['s-sh'] &&
          (r && g['s-ih'] == null && (g['s-ih'] = (l = g.hidden) != null ? l : !1),
          (g.hidden = !0));
    }
    hl = void 0;
  },
  F$ = (e, t) => {
    if (t && !e.$onRenderResolve$ && t['s-p']) {
      const r = t['s-p'].push(
        new Promise(
          (n) =>
            (e.$onRenderResolve$ = () => {
              (t['s-p'].splice(r - 1, 1), n());
            }),
        ),
      );
    }
  },
  gg = (e, t) => {
    if (((e.$flags$ |= 16), e.$flags$ & 4)) {
      e.$flags$ |= 512;
      return;
    }
    F$(e, e.$ancestorComponent$);
    const r = () => JG(e, t);
    if (t) {
      queueMicrotask(() => {
        r();
      });
      return;
    }
    return bG(r);
  },
  JG = (e, t) => {
    const r = e.$hostElement$,
      n = Bn('scheduleUpdate', e.$cmpMeta$.$tagName$),
      o = r;
    if (!o)
      throw new Error(
        `Can't render component <${r.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`,
      );
    let i;
    return (
      t
        ? (i = vo(o, 'componentWillLoad', void 0, r))
        : (i = vo(o, 'componentWillUpdate', void 0, r)),
      (i = Pv(i, () => vo(o, 'componentWillRender', void 0, r))),
      n(),
      Pv(i, () => VG(e, o, t))
    );
  },
  Pv = (e, t) =>
    UG(e)
      ? e.then(t).catch((r) => {
          (console.error(r), t());
        })
      : t(),
  UG = (e) => e instanceof Promise || (e && e.then && typeof e.then == 'function'),
  VG = async (e, t, r) => {
    var n;
    const o = e.$hostElement$,
      i = Bn('update', e.$cmpMeta$.$tagName$),
      a = o['s-rc'];
    r && NG(e);
    const l = Bn('render', e.$cmpMeta$.$tagName$);
    (HG(e, t, o, r), a && (a.map((d) => d()), (o['s-rc'] = void 0)), l(), i());
    {
      const d = (n = o['s-p']) != null ? n : [],
        u = () => zG(e);
      d.length === 0 ? u() : (Promise.all(d).then(u), (e.$flags$ |= 4), (d.length = 0));
    }
  },
  xv = null,
  HG = (e, t, r, n) => {
    try {
      ((xv = t),
        (t = t.render && t.render()),
        (e.$flags$ &= -17),
        (e.$flags$ |= 2),
        (ze.hasRenderFn || ze.reflect) &&
          (ze.vdomRender || ze.reflect) &&
          (ze.hydrateServerSide || L$(e, t, n)));
    } catch (d) {
      Vi(d, e.$hostElement$);
    }
    return ((xv = null), null);
  },
  zG = (e) => {
    const t = e.$cmpMeta$.$tagName$,
      r = e.$hostElement$,
      n = Bn('postUpdate', t),
      o = r,
      i = e.$ancestorComponent$;
    (vo(o, 'componentDidRender', void 0, r),
      e.$flags$ & 64
        ? (vo(o, 'componentDidUpdate', void 0, r), n())
        : ((e.$flags$ |= 64),
          WG(r),
          vo(o, 'componentDidLoad', void 0, r),
          n(),
          e.$onReadyResolve$(r),
          i || GG()),
      e.$onRenderResolve$ && (e.$onRenderResolve$(), (e.$onRenderResolve$ = void 0)),
      e.$flags$ & 512 && pg(() => gg(e, !1)),
      (e.$flags$ &= -517));
  },
  GG = (e) => {
    pg(() => N$(Ge, 'appload', { detail: { namespace: iG } }));
  },
  vo = (e, t, r, n) => {
    if (e && e[t])
      try {
        return e[t](r);
      } catch (o) {
        Vi(o, n);
      }
  },
  WG = (e) => {
    var t;
    return e.classList.add((t = ze.hydratedSelectorName) != null ? t : 'hydrated');
  },
  KG = (e, t) => Fn(e).$instanceValues$.get(t),
  Ov = (e, t, r, n) => {
    const o = Fn(e);
    if (!o || (ze.serializer && o.$serializerValues$.has(t) && o.$serializerValues$.get(t) === r))
      return;
    const i = e,
      a = o.$instanceValues$.get(t),
      l = o.$flags$,
      d = i;
    r = I$(r, n.$members$[t][0]);
    const u = Number.isNaN(a) && Number.isNaN(r);
    if (r !== a && !u) {
      if (
        (o.$instanceValues$.set(t, r),
        ze.serializer &&
          ze.reflect &&
          n.$attrsToReflect$ &&
          d &&
          n.$serializers$ &&
          n.$serializers$[t])
      ) {
        let f = r;
        for (const m of n.$serializers$[t]) f = d[m](f, t);
        o.$serializerValues$.set(t, f);
      }
      {
        if (n.$watchers$ && l & 128) {
          const f = n.$watchers$[t];
          f &&
            f.map((m) => {
              try {
                d[m](r, a, t);
              } catch (h) {
                Vi(h, i);
              }
            });
        }
        if ((l & 18) === 2) {
          if (d.componentShouldUpdate && d.componentShouldUpdate(r, a, t) === !1) return;
          gg(o, !1);
        }
      }
    }
  },
  YG = (e, t, r) => {
    var n, o;
    const i = e.prototype;
    if (t.$members$ || ze.propChangeCallback) {
      (e.watchers && !t.$watchers$ && (t.$watchers$ = e.watchers),
        e.deserializers && !t.$deserializers$ && (t.$deserializers$ = e.deserializers),
        e.serializers && !t.$serializers$ && (t.$serializers$ = e.serializers));
      const a = Object.entries((n = t.$members$) != null ? n : {});
      a.map(([l, [d]]) => {
        if (d & 31 || d & 32) {
          const { get: u, set: p } = Object.getOwnPropertyDescriptor(i, l) || {};
          (u && (t.$members$[l][0] |= 2048),
            p && (t.$members$[l][0] |= 4096),
            Object.defineProperty(i, l, {
              get() {
                return u ? u.apply(this) : KG(this, l);
              },
              configurable: !0,
              enumerable: !0,
            }),
            Object.defineProperty(i, l, {
              set(f) {
                const m = Fn(this);
                if (m) {
                  if (p) {
                    (typeof (d & 32 ? this[l] : m.$hostElement$[l]) > 'u' &&
                      m.$instanceValues$.get(l) &&
                      (f = m.$instanceValues$.get(l)),
                      p.apply(this, [I$(f, d)]),
                      (f = d & 32 ? this[l] : m.$hostElement$[l]),
                      Ov(this, l, f, t));
                    return;
                  }
                  {
                    Ov(this, l, f, t);
                    return;
                  }
                }
              },
            }));
        }
      });
      {
        const l = new Map();
        ((i.attributeChangedCallback = function (d, u, p) {
          Et.jmp(() => {
            var f;
            const m = l.get(d),
              h = Fn(this);
            if (ze.serializer && h.$serializerValues$.has(m) && h.$serializerValues$.get(m) === p)
              return;
            if (
              (this.hasOwnProperty(m) && ze.lazyLoad,
              ze.deserializer && t.$deserializers$ && t.$deserializers$[m])
            ) {
              const E = (b, S) => {
                const R = S?.[b](p, m);
                R !== this[m] && (this[m] = R);
              };
              for (const b of t.$deserializers$[m]) E(b, this);
              return;
            } else {
              if (i.hasOwnProperty(m) && typeof this[m] == 'number' && this[m] == p) return;
              if (m == null) {
                const E = h?.$flags$;
                if (h && E && !(E & 8) && E & 128 && p !== u) {
                  const S = this,
                    R = (f = t.$watchers$) == null ? void 0 : f[d];
                  R?.forEach((I) => {
                    S[I] != null && S[I].call(S, p, u, d);
                  });
                }
                return;
              }
            }
            const g = a.find(([E]) => E === m);
            g && g[1][0] & 4 && (p = !(p === null || p === 'false'));
            const v = Object.getOwnPropertyDescriptor(i, m);
            p != this[m] && (!v.get || v.set) && (this[m] = p);
          });
        }),
          (e.observedAttributes = Array.from(
            new Set([
              ...Object.keys((o = t.$watchers$) != null ? o : {}),
              ...a
                .filter(([d, u]) => u[0] & 31)
                .map(([d, u]) => {
                  var p;
                  const f = u[1] || d;
                  return (
                    l.set(f, d),
                    u[0] & 512 && ((p = t.$attrsToReflect$) == null || p.push([d, f])),
                    f
                  );
                }),
            ]),
          )));
      }
    }
    return e;
  },
  XG = async (e, t, r, n) => {
    let o;
    if ((t.$flags$ & 32) === 0) {
      ((t.$flags$ |= 32), r.$lazyBundleId$);
      {
        o = e.constructor;
        const l = e.localName;
        customElements.whenDefined(l).then(() => (t.$flags$ |= 128));
      }
      if (o && o.style) {
        let l;
        typeof o.style == 'string'
          ? (l = o.style)
          : typeof o.style != 'string' &&
            ((t.$modeName$ = kG(e)), t.$modeName$ && (l = o.style[t.$modeName$]));
        const d = C$(r, t.$modeName$);
        if (!fl.has(d)) {
          const u = Bn('registerStyles', r.$tagName$);
          (CG(d, l, !!(r.$flags$ & 1)), u());
        }
      }
    }
    const i = t.$ancestorComponent$,
      a = () => gg(t, !0);
    i && i['s-rc'] ? i['s-rc'].push(a) : a();
  },
  Cv = (e, t) => {},
  QG = (e) => {
    if ((Et.$flags$ & 1) === 0) {
      const t = Fn(e);
      if (!t) return;
      const r = t.$cmpMeta$,
        n = Bn('connectedCallback', r.$tagName$);
      if (t.$flags$ & 1)
        (B$(e, t, r.$listeners$),
          t?.$lazyInstance$
            ? Cv(t.$lazyInstance$)
            : t?.$onReadyPromise$ && t.$onReadyPromise$.then(() => Cv(t.$lazyInstance$)));
      else {
        ((t.$flags$ |= 1), r.$flags$ & 12 && ZG(e));
        {
          let o = e;
          for (; (o = o.parentNode || o.host); )
            if (o['s-p']) {
              F$(t, (t.$ancestorComponent$ = o));
              break;
            }
        }
        (r.$members$ &&
          Object.entries(r.$members$).map(([o, [i]]) => {
            if (i & 31 && o in e && e[o] !== Object.prototype[o]) {
              const a = e[o];
              (delete e[o], (e[o] = a));
            }
          }),
          XG(e, t, r));
      }
      n();
    }
  },
  ZG = (e) => {
    if (!Ge.document) return;
    const t = (e['s-cr'] = Ge.document.createComment(''));
    ((t['s-cn'] = !0), Xr(e, t, e.firstChild));
  },
  eW = async (e) => {
    if ((Et.$flags$ & 1) === 0) {
      const t = Fn(e);
      t?.$rmListeners$ && (t.$rmListeners$.map((r) => r()), (t.$rmListeners$ = void 0));
    }
    (co.has(e) && co.delete(e), e.shadowRoot && co.has(e.shadowRoot) && co.delete(e.shadowRoot));
  },
  UK = (e, t) => {
    const r = { $flags$: t[0], $tagName$: t[1] };
    ((r.$members$ = t[2]),
      (r.$listeners$ = t[3]),
      (r.$watchers$ = e.$watchers$),
      (r.$deserializers$ = e.$deserializers$),
      (r.$serializers$ = e.$serializers$),
      (r.$attrsToReflect$ = []),
      !(r.$flags$ & 1) && r.$flags$ & 256);
    const n = e.prototype.connectedCallback,
      o = e.prototype.disconnectedCallback;
    return (
      Object.assign(e.prototype, {
        __hasHostListenerAttached: !1,
        __registerHost() {
          fG(this, r);
        },
        connectedCallback() {
          if (!this.__hasHostListenerAttached) {
            const i = Fn(this);
            if (!i) return;
            (B$(this, i, r.$listeners$), (this.__hasHostListenerAttached = !0));
          }
          (QG(this), n && n.call(this));
        },
        disconnectedCallback() {
          (eW(this), o && o.call(this));
        },
        __attachShadow() {
          if (!this.shadowRoot) RG.call(this, r);
          else if (this.shadowRoot.mode !== 'open')
            throw new Error(
              `Unable to re-use existing shadow root for ${r.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`,
            );
        },
      }),
      (e.is = r.$tagName$),
      YG(e, r)
    );
  },
  B$ = (e, t, r, n) => {
    r &&
      Ge.document &&
      r.map(([o, i, a]) => {
        const l = rW(Ge.document, e, o),
          d = tW(t, a),
          u = nW(o);
        (Et.ael(l, i, d, u),
          (t.$rmListeners$ = t.$rmListeners$ || []).push(() => Et.rel(l, i, d, u)));
      });
  },
  tW = (e, t) => (r) => {
    var n;
    try {
      ze.lazyLoad || e.$hostElement$[t](r);
    } catch (o) {
      Vi(o, e.$hostElement$);
    }
  },
  rW = (e, t, r) => (r & 4 ? e : r & 8 ? Ge : r & 16 ? e.body : t),
  nW = (e) => (e & 2) !== 0;
function oW(e, t) {
  const n = { $cmpMeta$: { $flags$: 0, $tagName$: t.tagName }, $hostElement$: t };
  L$(n, e);
}
const { simulatePageLoad: sW } = __STORYBOOK_MODULE_PREVIEW_API__;
var iW = Object.defineProperty,
  aW = (e, t) => {
    for (var r in t) iW(e, r, { get: t[r], enumerable: !0 });
  };
const J$ = (e, t) => {
  const { component: r, parameters: n } = t;
  if (Array.isArray(r))
    throw new Error(
      'If your story does not contain a render function, you must provide a component property!',
    );
  if (typeof r == 'string' && !customElements.get(r))
    throw new Error(
      'Stencil component not found. If you are not lazy loading your components with `defineCustomElements()` in preview.ts, pass a constructor value for component in your story `component: MyComponent`',
    );
  if (typeof r != 'string' && !customElements.getName(r))
    throw new Error(
      "Stencil component not found. If you are lazy loading your components with `defineCustomElements()` in preview.ts, pass a string value for component in your story `component: 'my-component'`",
    );
  const o = typeof r == 'string' ? r : customElements.getName(r),
    i = Object.entries(n.slots || []).map(([l, d]) => {
      const u = l === 'default' ? void 0 : l,
        p =
          typeof d == 'string'
            ? ml(void 0, { slot: u }, d)
            : { ...d, $attrs$: { ...d.$attrs$, slot: u } };
      return ((p.$tag$ = p.$tag$ || (u ? 'span' : null)), p.$tag$ ? p : p.$children$);
    }),
    a = `${o}`;
  return ml(a, { ...e }, i);
};
function U$({ storyFn: e, showMain: t, storyContext: r }, n) {
  const o = e();
  (t(),
    r.component &&
      r.component.is &&
      !customElements.get(r.component.is) &&
      customElements.define(r.component.is, r.component),
    n.firstChild && n.removeChild(n.firstChild));
  const i = document.createElement('div');
  (n.appendChild(i), oW(o, i), sW(i));
}
var lW = {};
aW(lW, {
  argTypesEnhancers: () => H$,
  parameters: () => V$,
  render: () => J$,
  renderToCanvas: () => U$,
});
const V$ = { renderer: 'stencil' },
  H$ = [A$],
  cW = Object.freeze(
    Object.defineProperty(
      { __proto__: null, argTypesEnhancers: H$, parameters: V$, render: J$, renderToCanvas: U$ },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  { global: Ip } = __STORYBOOK_MODULE_GLOBAL__,
  { setDefaultProjectAnnotations: VK, setProjectAnnotations: HK } =
    __STORYBOOK_MODULE_PREVIEW_API__;
function uW(e) {
  if (!e) return !1;
  if (typeof e == 'string') return !0;
  throw new Error('Provided component needs to be a string. e.g. component: "my-element"');
}
function dW(e) {
  if (!e) return !1;
  if (e.components && Array.isArray(e.components)) return !0;
  throw new Error(
    'You need to setup valid meta data in your stencil.config.js via docs-json output target.',
  );
}
function pW(e) {
  Ip.__STORYBOOK_CUSTOM_ELEMENTS_MANIFEST__ = e;
}
function z$() {
  return Ip.__STORYBOOK_CUSTOM_ELEMENTS__ || Ip.__STORYBOOK_CUSTOM_ELEMENTS_MANIFEST__;
}
const { logger: fW } = __STORYBOOK_MODULE_CLIENT_LOGGER__,
  mW = (e) => {
    const t = ['string', 'number', 'boolean', 'symbol'];
    return e.type.toLowerCase() in t
      ? { name: e.type.toLowerCase(), raw: e.type, required: e.required }
      : /^\(.*\)\s*=>\s*.*$/.test(e.type)
        ? { name: 'function', raw: e.type, required: e.required }
        : { name: 'other', value: e.type, raw: e.type, required: e.required };
  },
  G$ = (e) =>
    e.values.filter((t) => ['string', 'number'].includes(t.type)).map(({ value: t }) => t),
  yW = (e) => {
    switch (e.type) {
      case 'string':
      case 'string | undefined':
        return { type: 'text' };
      case 'number':
      case 'number | undefined':
        return { type: 'number' };
      case 'boolean':
      case 'boolean | undefined':
        return { type: 'boolean' };
      case 'Date':
      case 'Date | string':
        return { type: 'date' };
      case 'function':
      case 'function | undefined':
      case 'void':
      case 'void | undefined':
        return null;
      default:
        const t = G$(e);
        return t.length === 0
          ? { type: 'object' }
          : t.length < 5
            ? { type: 'radio' }
            : { type: 'select' };
    }
  },
  Wc = (e, t) => {
    if (!t || t.length === 0) return e;
    const r = [],
      n = [],
      o = t.filter((d) => d.name === 'deprecated');
    o.length > 0 &&
      o.forEach((d) => {
        d.text ? n.push(`** DEPRECATED:** ${d.text}`) : n.push('** DEPRECATED**');
      });
    const i = t.filter((d) => d.name === 'see');
    if (i.length > 0) {
      const d = i
        .map((u) => {
          const p = u.text?.trim();
          return p ? `[${p}](${p})` : '';
        })
        .filter(Boolean)
        .join(', ');
      d && r.push(`**See:** ${d}`);
    }
    const a = t.filter((d) => d.name === 'since');
    if (a.length > 0) {
      const d = a
        .map((u) => u.text)
        .filter(Boolean)
        .join(', ');
      d && r.push(`**Since:** ${d}`);
    }
    return [...n, e, ...r].filter(Boolean).join(`

`);
  },
  Au = (e, t) =>
    e.reduce(
      (r, n) => (
        (r[n.name] = {
          name: n.name,
          description: Wc(n.docs, n.docsTags),
          control: !1,
          table: { category: t },
        }),
        r
      ),
      {},
    ),
  hW = (e) =>
    e.reduce(
      (t, r) => (
        (t[r.name] = {
          name: r.name,
          description: Wc(r.docs, r.docsTags),
          control: null,
          type: { name: 'function' },
          table: { category: 'methods', type: { summary: r.signature } },
        }),
        t
      ),
      {},
    ),
  gW = (e) =>
    e.reduce((t, r) => {
      let n = r.event
        .replace(/(-|_|:|\.|\s)+(.)?/g, (o, i, a) => (a ? a.toUpperCase() : ''))
        .replace(/^([A-Z])/, (o) => o.toLowerCase());
      return (
        (n = `on${n.charAt(0).toUpperCase() + n.slice(1)}`),
        (t[n] = {
          name: n,
          description: Wc(r.docs, r.docsTags),
          control: null,
          table: { category: 'events', type: { summary: r.detail } },
          type: { name: 'function' },
        }),
        t
      );
    }, {}),
  bW = (e) =>
    e.reduce(
      (t, r) => (
        (t[r.name] = {
          name: r.attr || r.name,
          description: Wc(r.docs, r.docsTags),
          control: yW(r),
          table: {
            category: 'properties',
            type: { summary: r.complexType?.original },
            defaultValue: { summary: r.default },
          },
          options: G$(r),
          type: mW(r),
        }),
        t
      ),
      {},
    ),
  W$ = (e, t) => {
    if (!uW(e) || !dW(t)) return null;
    const r = t.components.find((n) => n.tag.toUpperCase() === e.toUpperCase());
    return (r || fW.warn(`Component not found in custom-elements.json: ${e}`), r);
  },
  vW = (e, t) => {
    const r = W$(e, t);
    return (
      r && {
        ...bW(r.props),
        ...gW(r.events),
        ...hW(r.methods),
        ...Au(r.slots, 'slots'),
        ...Au(r.parts, 'parts'),
        ...Au(r.styles, 'styles'),
      }
    );
  },
  TW = (e) => {
    const t = z$(),
      r = typeof e == 'string' ? e : e?.is;
    return vW(r, t);
  },
  EW = (e) => {
    const t = typeof e == 'string' ? e : e?.is,
      r = W$(t, z$());
    return r && r.docs;
  },
  wW = { docs: { extractArgTypes: TW, extractComponentDescription: EW } },
  SW = [A$],
  _W = Object.freeze(
    Object.defineProperty(
      { __proto__: null, argTypesEnhancers: SW, parameters: wW },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  AW = 'uxbit',
  vl = { hydratedSelectorName: 'hydrated', lazyLoad: !0, propChangeCallback: !0, updatable: !0 };
var RW = Object.defineProperty,
  PW = (e, t) => {
    for (var r in t) RW(e, r, { get: t[r], enumerable: !0 });
  },
  ur = (e) => {
    if (e.__stencil__getHostRef) return e.__stencil__getHostRef();
  },
  xW = (e, t) => {
    const r = {
      $flags$: 0,
      $hostElement$: e,
      $cmpMeta$: t,
      $instanceValues$: new Map(),
      $serializerValues$: new Map(),
    };
    ((r.$onReadyPromise$ = new Promise((o) => (r.$onReadyResolve$ = o))),
      (e['s-p'] = []),
      (e['s-rc'] = []),
      (r.$fetchedCbList$ = []));
    const n = r;
    return ((e.__stencil__getHostRef = () => n), n);
  },
  Iv = (e, t) => t in e,
  Xo = (e, t) => (0, console.error)(e, t),
  Nv = new Map(),
  OW = (e, t, r) => {
    const n = e.$tagName$.replace(/-/g, '_'),
      o = e.$lazyBundleId$;
    if (!o) return;
    const i = Nv.get(o);
    if (i) return i[n];
    return bn(() => import(`./${o}.entry.js`), [], import.meta.url).then(
      (a) => (Nv.set(o, a), a[n]),
      (a) => {
        Xo(a, t.$hostElement$);
      },
    );
  },
  Tl = new Map(),
  CW = '{visibility:hidden}.hydrated{visibility:inherit}',
  K$ = 'slot-fb{display:contents}slot-fb[hidden]{display:none}',
  $v = 'http://www.w3.org/1999/xlink',
  ut = typeof window < 'u' ? window : {},
  ct = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (e) => e(),
    raf: (e) => requestAnimationFrame(e),
    ael: (e, t, r, n) => e.addEventListener(t, r, n),
    rel: (e, t, r, n) => e.removeEventListener(t, r, n),
    ce: (e, t) => new CustomEvent(e, t),
  },
  IW = (e) => Promise.resolve(e),
  bg = (() => {
    try {
      return (new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == 'function');
    } catch {}
    return !1;
  })(),
  Np = bg
    ? !!ut.document &&
      Object.getOwnPropertyDescriptor(ut.document.adoptedStyleSheets, 'length').writable
    : !1,
  $p = !1,
  qv = [],
  Y$ = [],
  NW = (e, t) => (r) => {
    (e.push(r), $p || (($p = !0), ct.$flags$ & 4 ? vg(qp) : ct.raf(qp)));
  },
  Mv = (e) => {
    for (let t = 0; t < e.length; t++)
      try {
        e[t](performance.now());
      } catch (r) {
        Xo(r);
      }
    e.length = 0;
  },
  qp = () => {
    (Mv(qv), Mv(Y$), ($p = qv.length > 0) && ct.raf(qp));
  },
  vg = (e) => IW().then(e),
  $W = NW(Y$),
  Tg = (e) => ((e = typeof e), e === 'object' || e === 'function');
function X$(e) {
  var t, r, n;
  return (n =
    (r = (t = e.head) == null ? void 0 : t.querySelector('meta[name="csp-nonce"]')) == null
      ? void 0
      : r.getAttribute('content')) != null
    ? n
    : void 0;
}
var qW = (e) => e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
  MW = {};
PW(MW, { err: () => Q$, map: () => jW, ok: () => Mp, unwrap: () => kW, unwrapErr: () => DW });
var Mp = (e) => ({ isOk: !0, isErr: !1, value: e }),
  Q$ = (e) => ({ isOk: !1, isErr: !0, value: e });
function jW(e, t) {
  if (e.isOk) {
    const r = t(e.value);
    return r instanceof Promise ? r.then((n) => Mp(n)) : Mp(r);
  }
  if (e.isErr) {
    const r = e.value;
    return Q$(r);
  }
  throw 'should never get here';
}
var kW = (e) => {
    if (e.isOk) return e.value;
    throw e.value;
  },
  DW = (e) => {
    if (e.isErr) return e.value;
    throw e.value;
  };
var Os;
function LW(e) {
  var t;
  const r = this.attachShadow({ mode: 'open' });
  (Os === void 0 && (Os = (t = void 0) != null ? t : null),
    Os &&
      (Np
        ? r.adoptedStyleSheets.push(Os)
        : (r.adoptedStyleSheets = [...r.adoptedStyleSheets, Os])));
}
var qr =
    (e, t = '') =>
    () => {},
  FW = (e, t) => () => {},
  uo = new WeakMap(),
  BW = (e, t, r) => {
    let n = Tl.get(e);
    (bg && r
      ? ((n = n || new CSSStyleSheet()), typeof n == 'string' ? (n = t) : n.replaceSync(t))
      : (n = t),
      Tl.set(e, n));
  },
  JW = (e, t, r) => {
    var n;
    const o = Z$(t),
      i = Tl.get(o);
    if (!ut.document) return o;
    if (((e = e.nodeType === 11 ? e : ut.document), i))
      if (typeof i == 'string') {
        e = e.head || e;
        let a = uo.get(e),
          l;
        if ((a || uo.set(e, (a = new Set())), !a.has(o))) {
          {
            ((l = ut.document.createElement('style')), (l.innerHTML = i));
            const d = (n = ct.$nonce$) != null ? n : X$(ut.document);
            if ((d != null && l.setAttribute('nonce', d), !(t.$flags$ & 1)))
              if (e.nodeName === 'HEAD') {
                const u = e.querySelectorAll('link[rel=preconnect]'),
                  p = u.length > 0 ? u[u.length - 1].nextSibling : e.querySelector('style');
                e.insertBefore(l, p?.parentNode === e ? p : null);
              } else if ('host' in e)
                if (bg) {
                  const u = new CSSStyleSheet();
                  (u.replaceSync(i),
                    Np
                      ? e.adoptedStyleSheets.unshift(u)
                      : (e.adoptedStyleSheets = [u, ...e.adoptedStyleSheets]));
                } else {
                  const u = e.querySelector('style');
                  u ? (u.innerHTML = i + u.innerHTML) : e.prepend(l);
                }
              else e.append(l);
            t.$flags$ & 1 && e.insertBefore(l, null);
          }
          (t.$flags$ & 4 && (l.innerHTML += K$), a && a.add(o));
        }
      } else
        e.adoptedStyleSheets.includes(i) ||
          (Np
            ? e.adoptedStyleSheets.push(i)
            : (e.adoptedStyleSheets = [...e.adoptedStyleSheets, i]));
    return o;
  },
  UW = (e) => {
    const t = e.$cmpMeta$,
      r = e.$hostElement$,
      n = t.$flags$,
      o = qr('attachStyles', t.$tagName$),
      i = JW(r.shadowRoot ? r.shadowRoot : r.getRootNode(), t);
    (n & 10 && ((r['s-sc'] = i), r.classList.add(i + '-h')), o());
  },
  Z$ = (e, t) => 'sc-' + e.$tagName$,
  VW = (e, t, ...r) => {
    let n = null,
      o = null,
      i = !1,
      a = !1;
    const l = [],
      d = (p) => {
        for (let f = 0; f < p.length; f++)
          ((n = p[f]),
            Array.isArray(n)
              ? d(n)
              : n != null &&
                typeof n != 'boolean' &&
                ((i = !Tg(n)) && (n = String(n)),
                i && a ? (l[l.length - 1].$text$ += n) : l.push(i ? jp(null, n) : n),
                (a = i)));
      };
    d(r);
    const u = jp(e, null);
    return ((u.$attrs$ = t), l.length > 0 && (u.$children$ = l), (u.$key$ = o), u);
  },
  jp = (e, t) => {
    const r = { $flags$: 0, $tag$: e, $text$: t, $elm$: null, $children$: null };
    return ((r.$attrs$ = null), (r.$key$ = null), r);
  },
  HW = {},
  zW = (e) => e && e.$tag$ === HW,
  Eg = (e) => {
    const t = qW(e);
    return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`, 'g');
  };
Eg('::slotted');
Eg(':host');
Eg(':host-context');
var kp = (e, t, r) =>
    e != null && !Tg(e)
      ? t & 4
        ? e === 'false'
          ? !1
          : e === '' || !!e
        : t & 2
          ? typeof e == 'string'
            ? parseFloat(e)
            : typeof e == 'number'
              ? e
              : NaN
          : t & 1
            ? String(e)
            : e
      : e,
  GW = (e, t, r) => {
    const n = ct.ce(t, r);
    return (e.dispatchEvent(n), n);
  },
  jv = (e, t, r, n, o, i, a) => {
    if (r === n) return;
    let l = Iv(e, t),
      d = t.toLowerCase();
    if (t === 'class') {
      const u = e.classList,
        p = kv(r);
      let f = kv(n);
      (u.remove(...p.filter((m) => m && !f.includes(m))),
        u.add(...f.filter((m) => m && !p.includes(m))));
    } else if (t === 'style') {
      for (const u in r)
        (!n || n[u] == null) && (u.includes('-') ? e.style.removeProperty(u) : (e.style[u] = ''));
      for (const u in n)
        (!r || n[u] !== r[u]) &&
          (u.includes('-') ? e.style.setProperty(u, n[u]) : (e.style[u] = n[u]));
    } else if (t !== 'key')
      if (t === 'ref') n && n(e);
      else if (!l && t[0] === 'o' && t[1] === 'n') {
        if (
          (t[2] === '-' ? (t = t.slice(3)) : Iv(ut, d) ? (t = d.slice(2)) : (t = d[2] + t.slice(3)),
          r || n)
        ) {
          const u = t.endsWith(eq);
          ((t = t.replace(KW, '')), r && ct.rel(e, t, r, u), n && ct.ael(e, t, n, u));
        }
      } else {
        const u = Tg(n);
        if (l || (u && n !== null))
          try {
            if (e.tagName.includes('-')) e[t] !== n && (e[t] = n);
            else {
              const f = n ?? '';
              t === 'list'
                ? (l = !1)
                : (r == null || e[t] != f) &&
                  (typeof e.__lookupSetter__(t) == 'function' ? (e[t] = f) : e.setAttribute(t, f));
            }
          } catch {}
        let p = !1;
        (d !== (d = d.replace(/^xlink\:?/, '')) && ((t = d), (p = !0)),
          n == null || n === !1
            ? (n !== !1 || e.getAttribute(t) === '') &&
              (p ? e.removeAttributeNS($v, t) : e.removeAttribute(t))
            : (!l || i & 4 || o) &&
              !u &&
              e.nodeType === 1 &&
              ((n = n === !0 ? '' : n), p ? e.setAttributeNS($v, t, n) : e.setAttribute(t, n)));
      }
  },
  WW = /\s/,
  kv = (e) => (
    typeof e == 'object' && e && 'baseVal' in e && (e = e.baseVal),
    !e || typeof e != 'string' ? [] : e.split(WW)
  ),
  eq = 'Capture',
  KW = new RegExp(eq + '$'),
  tq = (e, t, r, n) => {
    const o = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$,
      i = (e && e.$attrs$) || {},
      a = t.$attrs$ || {};
    for (const l of Dv(Object.keys(i))) l in a || jv(o, l, i[l], void 0, r, t.$flags$);
    for (const l of Dv(Object.keys(a))) jv(o, l, i[l], a[l], r, t.$flags$);
  };
function Dv(e) {
  return e.includes('ref') ? [...e.filter((t) => t !== 'ref'), 'ref'] : e;
}
var wg,
  rq = !1,
  El = (e, t, r) => {
    const n = t.$children$[r];
    let o = 0,
      i,
      a;
    if (n.$text$ !== null) i = n.$elm$ = ut.document.createTextNode(n.$text$);
    else {
      if (!ut.document)
        throw new Error(
          "You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.",
        );
      if (((i = n.$elm$ = ut.document.createElement(n.$tag$)), tq(null, n, rq), n.$children$))
        for (o = 0; o < n.$children$.length; ++o) ((a = El(e, n, o)), a && i.appendChild(a));
    }
    return ((i['s-hn'] = wg), i);
  },
  nq = (e, t, r, n, o, i) => {
    let a = e,
      l;
    for (a.shadowRoot && a.tagName === wg && (a = a.shadowRoot); o <= i; ++o)
      n[o] && ((l = El(null, r, o)), l && ((n[o].$elm$ = l), ba(a, l, t)));
  },
  oq = (e, t, r) => {
    for (let n = t; n <= r; ++n) {
      const o = e[n];
      if (o) {
        const i = o.$elm$;
        (sq(o), i && i.remove());
      }
    }
  },
  YW = (e, t, r, n, o = !1) => {
    let i = 0,
      a = 0,
      l = 0,
      d = 0,
      u = t.length - 1,
      p = t[0],
      f = t[u],
      m = n.length - 1,
      h = n[0],
      g = n[m],
      v,
      E;
    for (; i <= u && a <= m; )
      if (p == null) p = t[++i];
      else if (f == null) f = t[--u];
      else if (h == null) h = n[++a];
      else if (g == null) g = n[--m];
      else if (Zi(p, h, o)) (no(p, h, o), (p = t[++i]), (h = n[++a]));
      else if (Zi(f, g, o)) (no(f, g, o), (f = t[--u]), (g = n[--m]));
      else if (Zi(p, g, o))
        (no(p, g, o), ba(e, p.$elm$, f.$elm$.nextSibling), (p = t[++i]), (g = n[--m]));
      else if (Zi(f, h, o)) (no(f, h, o), ba(e, f.$elm$, p.$elm$), (f = t[--u]), (h = n[++a]));
      else {
        for (l = -1, d = i; d <= u; ++d)
          if (t[d] && t[d].$key$ !== null && t[d].$key$ === h.$key$) {
            l = d;
            break;
          }
        (l >= 0
          ? ((E = t[l]),
            E.$tag$ !== h.$tag$
              ? (v = El(t && t[a], r, l))
              : (no(E, h, o), (t[l] = void 0), (v = E.$elm$)),
            (h = n[++a]))
          : ((v = El(t && t[a], r, a)), (h = n[++a])),
          v && ba(p.$elm$.parentNode, v, p.$elm$));
      }
    i > u ? nq(e, n[m + 1] == null ? null : n[m + 1].$elm$, r, n, a, m) : a > m && oq(t, i, u);
  },
  Zi = (e, t, r = !1) =>
    e.$tag$ === t.$tag$
      ? r
        ? (r && !e.$key$ && t.$key$ && (e.$key$ = t.$key$), !0)
        : e.$key$ === t.$key$
      : !1,
  no = (e, t, r = !1) => {
    const n = (t.$elm$ = e.$elm$),
      o = e.$children$,
      i = t.$children$,
      a = t.$text$;
    a === null
      ? (tq(e, t, rq),
        o !== null && i !== null
          ? YW(n, o, t, i, r)
          : i !== null
            ? (e.$text$ !== null && (n.textContent = ''), nq(n, null, t, i, 0, i.length - 1))
            : !r && vl.updatable && o !== null && oq(o, 0, o.length - 1))
      : e.$text$ !== a && (n.data = a);
  },
  sq = (e) => {
    (e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(sq));
  },
  ba = (e, t, r) => e?.insertBefore(t, r),
  XW = (e, t, r = !1) => {
    const n = e.$hostElement$,
      o = e.$cmpMeta$,
      i = e.$vnode$ || jp(null, null),
      l = zW(t) ? t : VW(null, null, t);
    if (
      ((wg = n.tagName),
      o.$attrsToReflect$ &&
        ((l.$attrs$ = l.$attrs$ || {}),
        o.$attrsToReflect$.forEach(([d, u]) => {
          l.$attrs$[u] = n[d];
        })),
      r && l.$attrs$)
    )
      for (const d of Object.keys(l.$attrs$))
        n.hasAttribute(d) && !['key', 'ref', 'style', 'class'].includes(d) && (l.$attrs$[d] = n[d]);
    ((l.$tag$ = null),
      (l.$flags$ |= 4),
      (e.$vnode$ = l),
      (l.$elm$ = i.$elm$ = n.shadowRoot || n),
      no(i, l, r));
  },
  iq = (e, t) => {
    if (t && !e.$onRenderResolve$ && t['s-p']) {
      const r = t['s-p'].push(
        new Promise(
          (n) =>
            (e.$onRenderResolve$ = () => {
              (t['s-p'].splice(r - 1, 1), n());
            }),
        ),
      );
    }
  },
  Sg = (e, t) => {
    if (((e.$flags$ |= 16), e.$flags$ & 4)) {
      e.$flags$ |= 512;
      return;
    }
    iq(e, e.$ancestorComponent$);
    const r = () => QW(e, t);
    if (t) {
      queueMicrotask(() => {
        r();
      });
      return;
    }
    return $W(r);
  },
  QW = (e, t) => {
    const r = e.$hostElement$,
      n = qr('scheduleUpdate', e.$cmpMeta$.$tagName$),
      o = e.$lazyInstance$;
    if (!o)
      throw new Error(
        `Can't render component <${r.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`,
      );
    let i;
    return (
      t
        ? (e.$fetchedCbList$.length && e.$fetchedCbList$.forEach((a) => a(r)),
          (i = Qr(o, 'componentWillLoad', void 0, r)))
        : (i = Qr(o, 'componentWillUpdate', void 0, r)),
      (i = Lv(i, () => Qr(o, 'componentWillRender', void 0, r))),
      n(),
      Lv(i, () => e5(e, o, t))
    );
  },
  Lv = (e, t) =>
    ZW(e)
      ? e.then(t).catch((r) => {
          (console.error(r), t());
        })
      : t(),
  ZW = (e) => e instanceof Promise || (e && e.then && typeof e.then == 'function'),
  e5 = async (e, t, r) => {
    var n;
    const o = e.$hostElement$,
      i = qr('update', e.$cmpMeta$.$tagName$),
      a = o['s-rc'];
    r && UW(e);
    const l = qr('render', e.$cmpMeta$.$tagName$);
    (t5(e, t, o, r), a && (a.map((d) => d()), (o['s-rc'] = void 0)), l(), i());
    {
      const d = (n = o['s-p']) != null ? n : [],
        u = () => r5(e);
      d.length === 0 ? u() : (Promise.all(d).then(u), (e.$flags$ |= 4), (d.length = 0));
    }
  },
  t5 = (e, t, r, n) => {
    try {
      ((t = t.render()), (e.$flags$ &= -17), (e.$flags$ |= 2), XW(e, t, n));
    } catch (o) {
      Xo(o, e.$hostElement$);
    }
    return null;
  },
  r5 = (e) => {
    const t = e.$cmpMeta$.$tagName$,
      r = e.$hostElement$,
      n = qr('postUpdate', t),
      o = e.$lazyInstance$,
      i = e.$ancestorComponent$;
    (Qr(o, 'componentDidRender', void 0, r),
      e.$flags$ & 64
        ? (Qr(o, 'componentDidUpdate', void 0, r), n())
        : ((e.$flags$ |= 64),
          n5(r),
          Qr(o, 'componentDidLoad', void 0, r),
          n(),
          e.$onReadyResolve$(r),
          i || aq()),
      e.$onRenderResolve$ && (e.$onRenderResolve$(), (e.$onRenderResolve$ = void 0)),
      e.$flags$ & 512 && vg(() => Sg(e, !1)),
      (e.$flags$ &= -517));
  },
  aq = (e) => {
    vg(() => GW(ut, 'appload', { detail: { namespace: AW } }));
  },
  Qr = (e, t, r, n) => {
    if (e && e[t])
      try {
        return e[t](r);
      } catch (o) {
        Xo(o, n);
      }
  },
  n5 = (e) => {
    var t;
    return e.classList.add((t = vl.hydratedSelectorName) != null ? t : 'hydrated');
  },
  o5 = (e, t) => ur(e).$instanceValues$.get(t),
  Ru = (e, t, r, n) => {
    const o = ur(e);
    if (!o) return;
    if (!o)
      throw new Error(
        `Couldn't find host element for "${n.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/stenciljs/core/issues/5457).`,
      );
    const i = o.$hostElement$,
      a = o.$instanceValues$.get(t),
      l = o.$flags$,
      d = o.$lazyInstance$;
    r = kp(r, n.$members$[t][0]);
    const u = Number.isNaN(a) && Number.isNaN(r),
      p = r !== a && !u;
    if ((!(l & 8) || a === void 0) && p && (o.$instanceValues$.set(t, r), d)) {
      if (n.$watchers$ && l & 128) {
        const f = n.$watchers$[t];
        f &&
          f.map((m) => {
            try {
              d[m](r, a, t);
            } catch (h) {
              Xo(h, i);
            }
          });
      }
      if ((l & 18) === 2) {
        if (d.componentShouldUpdate && d.componentShouldUpdate(r, a, t) === !1) return;
        Sg(o, !1);
      }
    }
  },
  lq = (e, t, r) => {
    var n, o;
    const i = e.prototype;
    if (t.$members$ || vl.propChangeCallback) {
      (e.watchers && !t.$watchers$ && (t.$watchers$ = e.watchers),
        e.deserializers && !t.$deserializers$ && (t.$deserializers$ = e.deserializers),
        e.serializers && !t.$serializers$ && (t.$serializers$ = e.serializers));
      const a = Object.entries((n = t.$members$) != null ? n : {});
      if (
        (a.map(([l, [d]]) => {
          if (d & 31 || (r & 2 && d & 32)) {
            const { get: u, set: p } = Object.getOwnPropertyDescriptor(i, l) || {};
            (u && (t.$members$[l][0] |= 2048),
              p && (t.$members$[l][0] |= 4096),
              (r & 1 || !u) &&
                Object.defineProperty(i, l, {
                  get() {
                    {
                      if ((t.$members$[l][0] & 2048) === 0) return o5(this, l);
                      const f = ur(this),
                        m = f ? f.$lazyInstance$ : i;
                      return m ? m[l] : void 0;
                    }
                  },
                  configurable: !0,
                  enumerable: !0,
                }),
              Object.defineProperty(i, l, {
                set(f) {
                  const m = ur(this);
                  if (m) {
                    if (p) {
                      (typeof (d & 32 ? this[l] : m.$hostElement$[l]) > 'u' &&
                        m.$instanceValues$.get(l) &&
                        (f = m.$instanceValues$.get(l)),
                        p.apply(this, [kp(f, d)]),
                        (f = d & 32 ? this[l] : m.$hostElement$[l]),
                        Ru(this, l, f, t));
                      return;
                    }
                    {
                      if ((r & 1) === 0 || (t.$members$[l][0] & 4096) === 0) {
                        (Ru(this, l, f, t),
                          r & 1 &&
                            !m.$lazyInstance$ &&
                            m.$fetchedCbList$.push(() => {
                              t.$members$[l][0] & 4096 &&
                                m.$lazyInstance$[l] !== m.$instanceValues$.get(l) &&
                                (m.$lazyInstance$[l] = f);
                            }));
                        return;
                      }
                      const h = () => {
                        const g = m.$lazyInstance$[l];
                        (!m.$instanceValues$.get(l) && g && m.$instanceValues$.set(l, g),
                          (m.$lazyInstance$[l] = kp(f, d)),
                          Ru(this, l, m.$lazyInstance$[l], t));
                      };
                      m.$lazyInstance$
                        ? h()
                        : m.$fetchedCbList$.push(() => {
                            h();
                          });
                    }
                  }
                },
              }));
          }
        }),
        r & 1)
      ) {
        const l = new Map();
        ((i.attributeChangedCallback = function (d, u, p) {
          ct.jmp(() => {
            var f;
            const m = l.get(d),
              h = ur(this);
            if (
              (this.hasOwnProperty(m) && vl.lazyLoad && ((p = this[m]), delete this[m]),
              i.hasOwnProperty(m) && typeof this[m] == 'number' && this[m] == p)
            )
              return;
            if (m == null) {
              const E = h?.$flags$;
              if (h && E && !(E & 8) && E & 128 && p !== u) {
                const b = h.$lazyInstance$,
                  S = (f = t.$watchers$) == null ? void 0 : f[d];
                S?.forEach((R) => {
                  b[R] != null && b[R].call(b, p, u, d);
                });
              }
              return;
            }
            const g = a.find(([E]) => E === m);
            g && g[1][0] & 4 && (p = !(p === null || p === 'false'));
            const v = Object.getOwnPropertyDescriptor(i, m);
            p != this[m] && (!v.get || v.set) && (this[m] = p);
          });
        }),
          (e.observedAttributes = Array.from(
            new Set([
              ...Object.keys((o = t.$watchers$) != null ? o : {}),
              ...a
                .filter(([d, u]) => u[0] & 31)
                .map(([d, u]) => {
                  var p;
                  const f = u[1] || d;
                  return (
                    l.set(f, d),
                    u[0] & 512 && ((p = t.$attrsToReflect$) == null || p.push([d, f])),
                    f
                  );
                }),
            ]),
          )));
      }
    }
    return e;
  },
  s5 = async (e, t, r, n) => {
    let o;
    if ((t.$flags$ & 32) === 0) {
      if (((t.$flags$ |= 32), r.$lazyBundleId$)) {
        const d = OW(r, t);
        if (d && 'then' in d) {
          const p = FW();
          ((o = await d), p());
        } else o = d;
        if (!o) throw new Error(`Constructor for "${r.$tagName$}#${t.$modeName$}" was not found`);
        o.isProxied ||
          ((r.$watchers$ = o.watchers),
          (r.$serializers$ = o.serializers),
          (r.$deserializers$ = o.deserializers),
          lq(o, r, 2),
          (o.isProxied = !0));
        const u = qr('createInstance', r.$tagName$);
        t.$flags$ |= 8;
        try {
          new o(t);
        } catch (p) {
          Xo(p, e);
        }
        ((t.$flags$ &= -9), (t.$flags$ |= 128), u(), Dp(t.$lazyInstance$, e));
      } else {
        o = e.constructor;
        const d = e.localName;
        customElements.whenDefined(d).then(() => (t.$flags$ |= 128));
      }
      if (o && o.style) {
        let d;
        typeof o.style == 'string' && (d = o.style);
        const u = Z$(r);
        if (!Tl.has(u)) {
          const p = qr('registerStyles', r.$tagName$);
          (BW(u, d, !!(r.$flags$ & 1)), p());
        }
      }
    }
    const i = t.$ancestorComponent$,
      a = () => Sg(t, !0);
    i && i['s-rc'] ? i['s-rc'].push(a) : a();
  },
  Dp = (e, t) => {
    Qr(e, 'connectedCallback', void 0, t);
  },
  i5 = (e) => {
    if ((ct.$flags$ & 1) === 0) {
      const t = ur(e);
      if (!t) return;
      const r = t.$cmpMeta$,
        n = qr('connectedCallback', r.$tagName$);
      if (t.$flags$ & 1)
        t?.$lazyInstance$
          ? Dp(t.$lazyInstance$, e)
          : t?.$onReadyPromise$ && t.$onReadyPromise$.then(() => Dp(t.$lazyInstance$, e));
      else {
        t.$flags$ |= 1;
        {
          let o = e;
          for (; (o = o.parentNode || o.host); )
            if (o['s-p']) {
              iq(t, (t.$ancestorComponent$ = o));
              break;
            }
        }
        (r.$members$ &&
          Object.entries(r.$members$).map(([o, [i]]) => {
            if (i & 31 && o in e && e[o] !== Object.prototype[o]) {
              const a = e[o];
              (delete e[o], (e[o] = a));
            }
          }),
          s5(e, t, r));
      }
      n();
    }
  },
  Fv = (e, t) => {
    Qr(e, 'disconnectedCallback', void 0, t || e);
  },
  a5 = async (e) => {
    if ((ct.$flags$ & 1) === 0) {
      const t = ur(e);
      t?.$lazyInstance$
        ? Fv(t.$lazyInstance$, e)
        : t?.$onReadyPromise$ && t.$onReadyPromise$.then(() => Fv(t.$lazyInstance$, e));
    }
    (uo.has(e) && uo.delete(e), e.shadowRoot && uo.has(e.shadowRoot) && uo.delete(e.shadowRoot));
  },
  l5 = (e, t = {}) => {
    var r;
    if (!ut.document) {
      console.warn('Stencil: No document found. Skipping bootstrapping lazy components.');
      return;
    }
    const n = qr(),
      o = [],
      i = t.exclude || [],
      a = ut.customElements,
      l = ut.document.head,
      d = l.querySelector('meta[charset]'),
      u = ut.document.createElement('style'),
      p = [];
    let f,
      m = !0;
    (Object.assign(ct, t),
      (ct.$resourcesUrl$ = new URL(t.resourcesUrl || './', ut.document.baseURI).href));
    let h = !1;
    if (
      (e.map((g) => {
        g[1].map((v) => {
          var E, b, S;
          const R = { $flags$: v[0], $tagName$: v[1], $members$: v[2], $listeners$: v[3] };
          (R.$flags$ & 4 && (h = !0),
            (R.$members$ = v[2]),
            (R.$attrsToReflect$ = []),
            (R.$watchers$ = (E = v[4]) != null ? E : {}),
            (R.$serializers$ = (b = v[5]) != null ? b : {}),
            (R.$deserializers$ = (S = v[6]) != null ? S : {}));
          const I = R.$tagName$,
            $ = class extends HTMLElement {
              constructor(x) {
                if (
                  (super(x),
                  (this.hasRegisteredEventListeners = !1),
                  (x = this),
                  xW(x, R),
                  R.$flags$ & 1)
                ) {
                  if (!x.shadowRoot) LW.call(x, R);
                  else if (x.shadowRoot.mode !== 'open')
                    throw new Error(
                      `Unable to re-use existing shadow root for ${R.$tagName$}! Mode is set to ${x.shadowRoot.mode} but Stencil only supports open shadow roots.`,
                    );
                }
              }
              connectedCallback() {
                ur(this) &&
                  (this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = !0),
                  f && (clearTimeout(f), (f = null)),
                  m ? p.push(this) : ct.jmp(() => i5(this)));
              }
              disconnectedCallback() {
                (ct.jmp(() => a5(this)),
                  ct.raf(() => {
                    var x;
                    const A = ur(this);
                    if (!A) return;
                    const w = p.findIndex((_) => _ === this);
                    (w > -1 && p.splice(w, 1),
                      ((x = A?.$vnode$) == null ? void 0 : x.$elm$) instanceof Node &&
                        !A.$vnode$.$elm$.isConnected &&
                        delete A.$vnode$.$elm$);
                  }));
              }
              componentOnReady() {
                var x;
                return (x = ur(this)) == null ? void 0 : x.$onReadyPromise$;
              }
            };
          ((R.$lazyBundleId$ = g[0]),
            !i.includes(I) && !a.get(I) && (o.push(I), a.define(I, lq($, R, 1))));
        });
      }),
      o.length > 0 &&
        (h && (u.textContent += K$), (u.textContent += o.sort() + CW), u.innerHTML.length))
    ) {
      u.setAttribute('data-styles', '');
      const g = (r = ct.$nonce$) != null ? r : X$(ut.document);
      (g != null && u.setAttribute('nonce', g),
        l.insertBefore(u, d ? d.nextSibling : l.firstChild));
    }
    ((m = !1),
      p.length ? p.map((g) => g.connectedCallback()) : ct.jmp(() => (f = setTimeout(aq, 30))),
      n());
  };
const c5 = () => {},
  u5 = async (e, t) => {
    if (!(typeof window > 'u'))
      return (
        await c5(),
        l5(
          [
            [
              'tinto-button_5',
              [
                [
                  769,
                  'tinto-button',
                  { variant: [513], size: [513], type: [513], disabled: [516], block: [516] },
                ],
                [
                  769,
                  'tinto-image',
                  {
                    src: [513],
                    alt: [513],
                    ratio: [513],
                    fit: [513],
                    position: [513],
                    radius: [513],
                    rounded: [513],
                    border: [513],
                    shadow: [513],
                    background: [513],
                    width: [513],
                    height: [513],
                    loading: [513],
                    priority: [516],
                    placeholder: [513],
                    srcset: [513],
                    sizes: [513],
                    decoding: [513],
                    crossorigin: [513],
                    referrerpolicy: [513],
                    href: [513],
                    target: [513],
                    rel: [513],
                    download: [513],
                    as: [513],
                    disabled: [516],
                    animation: [513],
                    play: [516],
                    rotate: [513],
                    duration: [514],
                    repeat: [520],
                    pauseOnHover: [516, 'pause-on-hover'],
                    startOnViewport: [516, 'start-on-viewport'],
                  },
                  null,
                  {
                    ratio: ['applyFrameStyles'],
                    fit: ['applyFrameStyles'],
                    position: ['applyFrameStyles'],
                    radius: ['applyFrameStyles'],
                    rounded: ['applyFrameStyles'],
                    border: ['applyFrameStyles'],
                    shadow: ['applyFrameStyles'],
                    background: ['applyFrameStyles'],
                    width: ['syncHostBoxSize'],
                    height: ['syncHostBoxSize'],
                    src: ['updateImageAttrs'],
                    alt: ['updateImageAttrs'],
                    srcset: ['updateImageAttrs'],
                    sizes: ['updateImageAttrs'],
                    loading: ['updateImageAttrs'],
                    priority: ['updateImageAttrs'],
                    placeholder: ['updateImageAttrs'],
                    decoding: ['updateImageAttrs'],
                    crossorigin: ['updateImageAttrs'],
                    referrerpolicy: ['updateImageAttrs'],
                    href: ['onStructureChanged'],
                    as: ['onStructureChanged'],
                    target: ['onStructureChanged'],
                    rel: ['onStructureChanged'],
                    download: ['onStructureChanged'],
                    disabled: ['onStructureChanged'],
                    animation: ['applyAnimation'],
                    play: ['applyAnimation'],
                    rotate: ['applyAnimation'],
                    duration: ['applyAnimation'],
                    repeat: ['applyAnimation'],
                    pauseOnHover: ['applyAnimation'],
                    startOnViewport: ['applyAnimation'],
                  },
                ],
                [
                  769,
                  'tinto-section',
                  {
                    direction: [513],
                    wrap: [513],
                    justify: [513],
                    align: [513],
                    gap: [513],
                    maxWidth: [513, 'max-width'],
                    padding: [513],
                    margin: [513],
                    background: [513],
                    color: [513],
                    radius: [513],
                    shadow: [513],
                    center: [516],
                    heightMode: [513, 'height-mode'],
                    scrollable: [516],
                  },
                ],
                [
                  769,
                  'tinto-typography',
                  {
                    variant: [513],
                    as: [513],
                    font: [513],
                    fontSize: [513, 'font-size'],
                    color: [513],
                    align: [513],
                    weight: [520],
                    inline: [516],
                    underline: [516],
                    highlight: [513],
                    visible: [516],
                    href: [513],
                    target: [513],
                    rel: [513],
                    rolling: [516],
                    rollSpeed: [514, 'roll-speed'],
                    rollAxis: [513, 'roll-axis'],
                    rollClone: [514, 'roll-clone'],
                    rollGap: [513, 'roll-gap'],
                    rollPlay: [516, 'roll-play'],
                    rollStartOnViewport: [516, 'roll-start-on-viewport'],
                    pauseOnHover: [516, 'pause-on-hover'],
                    typingTexts: [513, 'typing-texts'],
                    typingDuration: [514, 'typing-duration'],
                    typingEraseDuration: [514, 'typing-erase-duration'],
                    typingLoop: [516, 'typing-loop'],
                    typingCursor: [516, 'typing-cursor'],
                    typingUnit: [513, 'typing-unit'],
                  },
                  null,
                  { fontSize: ['handleFontSizeChange'] },
                ],
                [
                  769,
                  'tinto-wrapper',
                  {
                    direction: [513],
                    wrap: [513],
                    justify: [513],
                    align: [513],
                    gap: [513],
                    directionDesktop: [513, 'direction-desktop'],
                    wrapDesktop: [513, 'wrap-desktop'],
                    justifyDesktop: [513, 'justify-desktop'],
                    alignDesktop: [513, 'align-desktop'],
                    gapDesktop: [513, 'gap-desktop'],
                    padding: [513],
                    margin: [513],
                    radius: [513],
                    shadow: [513],
                    border: [513],
                    color: [513],
                    background: [513],
                    src: [513],
                    bgSize: [513, 'bg-size'],
                    bgPosition: [513, 'bg-position'],
                    bgRepeat: [513, 'bg-repeat'],
                    bgAttachment: [513, 'bg-attachment'],
                    bgBlend: [513, 'bg-blend'],
                    overlay: [513],
                    overlayOpacity: [514, 'overlay-opacity'],
                    fill: [516],
                  },
                ],
              ],
            ],
            [
              'tinto-badge',
              [
                [
                  769,
                  'tinto-badge',
                  { variant: [513], size: [513], pill: [516], soft: [516], outline: [516] },
                ],
              ],
            ],
          ],
          t,
        )
      );
  };
(function () {
  if (typeof window < 'u' && window.Reflect !== void 0 && window.customElements !== void 0) {
    var e = HTMLElement;
    ((window.HTMLElement = function () {
      return Reflect.construct(e, [], this.constructor);
    }),
      (HTMLElement.prototype = e.prototype),
      (HTMLElement.prototype.constructor = HTMLElement),
      Object.setPrototypeOf(HTMLElement, e));
  }
})();
const d5 = '2025-11-26T03:11:42',
  p5 = { name: '@stencil/core', version: '4.38.3', typescriptVersion: '5.9.3' },
  f5 = JSON.parse(
    `[{"filePath":"src/components/badge/badge.tsx","encapsulation":"shadow","tag":"tinto-badge","docs":"","docsTags":[],"usage":{},"props":[{"name":"outline","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"outline","reflectToAttr":true,"docs":"  ( , border)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"pill","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"pill","reflectToAttr":true,"docs":"pill   (full radius)","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"size","type":"\\"md\\" | \\"sm\\"","complexType":{"original":"TintoBadgeSize","resolved":"\\"md\\" | \\"sm\\"","references":{"TintoBadgeSize":{"location":"local","path":"/Users/tintolab/Desktop/uxbit/src/components/badge/badge.tsx","id":"src/components/badge/badge.tsx::TintoBadgeSize"}}},"mutable":false,"attr":"size","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'md'"}],"default":"'md'","values":[{"value":"md","type":"string"},{"value":"sm","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"soft","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"soft","reflectToAttr":true,"docs":"  (  )","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"variant","type":"\\"danger\\" | \\"neutral\\" | \\"primary\\" | \\"success\\" | \\"warning\\"","complexType":{"original":"TintoBadgeVariant","resolved":"\\"danger\\" | \\"neutral\\" | \\"primary\\" | \\"success\\" | \\"warning\\"","references":{"TintoBadgeVariant":{"location":"local","path":"/Users/tintolab/Desktop/uxbit/src/components/badge/badge.tsx","id":"src/components/badge/badge.tsx::TintoBadgeVariant"}}},"mutable":false,"attr":"variant","reflectToAttr":true,"docs":"/ ","docsTags":[{"name":"default","text":"'neutral'"}],"default":"'neutral'","values":[{"value":"danger","type":"string"},{"value":"neutral","type":"string"},{"value":"primary","type":"string"},{"value":"success","type":"string"},{"value":"warning","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false}],"methods":[],"events":[],"listeners":[],"styles":[],"slots":[],"parts":[],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/button/button.tsx","encapsulation":"shadow","tag":"tinto-button","docs":"","docsTags":[],"usage":{},"props":[{"name":"block","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"block","reflectToAttr":true,"docs":"   ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"disabled","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"disabled","reflectToAttr":true,"docs":" ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"size","type":"\\"lg\\" | \\"md\\" | \\"sm\\"","complexType":{"original":"TintoButtonSize","resolved":"\\"lg\\" | \\"md\\" | \\"sm\\"","references":{"TintoButtonSize":{"location":"local","path":"/Users/tintolab/Desktop/uxbit/src/components/button/button.tsx","id":"src/components/button/button.tsx::TintoButtonSize"}}},"mutable":false,"attr":"size","reflectToAttr":true,"docs":" ","docsTags":[{"name":"default","text":"'md'"}],"default":"'md'","values":[{"value":"lg","type":"string"},{"value":"md","type":"string"},{"value":"sm","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"type","type":"\\"button\\" | \\"reset\\" | \\"submit\\"","complexType":{"original":"TintoButtonType","resolved":"\\"button\\" | \\"reset\\" | \\"submit\\"","references":{"TintoButtonType":{"location":"local","path":"/Users/tintolab/Desktop/uxbit/src/components/button/button.tsx","id":"src/components/button/button.tsx::TintoButtonType"}}},"mutable":false,"attr":"type","reflectToAttr":true,"docs":"HTML button type","docsTags":[{"name":"default","text":"'button'"}],"default":"'button'","values":[{"value":"button","type":"string"},{"value":"reset","type":"string"},{"value":"submit","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"variant","type":"\\"ghost\\" | \\"primary\\" | \\"secondary\\"","complexType":{"original":"TintoButtonVariant","resolved":"\\"ghost\\" | \\"primary\\" | \\"secondary\\"","references":{"TintoButtonVariant":{"location":"local","path":"/Users/tintolab/Desktop/uxbit/src/components/button/button.tsx","id":"src/components/button/button.tsx::TintoButtonVariant"}}},"mutable":false,"attr":"variant","reflectToAttr":true,"docs":" ( )","docsTags":[{"name":"default","text":"'primary'"}],"default":"'primary'","values":[{"value":"ghost","type":"string"},{"value":"primary","type":"string"},{"value":"secondary","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false}],"methods":[],"events":[{"event":"tintoClick","detail":"MouseEvent","bubbles":true,"complexType":{"original":"MouseEvent","resolved":"MouseEvent","references":{"MouseEvent":{"location":"global","id":"global::MouseEvent"}}},"cancelable":true,"composed":true,"docs":"  ( click  Stencil  )","docsTags":[]}],"listeners":[],"styles":[],"slots":[],"parts":[],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/image/image.tsx","encapsulation":"shadow","tag":"tinto-image","readme":"# tinto-image\\n","docs":"<tinto-image>\\n- Image/media props + simple animations (spin/float/wobble/pulse)\\n- If placeholder exists, main image loads eagerly by default (fast swap)\\n- rounded=\\"oval\\" => rounds TOP corners only (bottom corners are square)","docsTags":[],"usage":{},"props":[{"name":"alt","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"alt","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"animation","type":"\\"\\" | \\"float\\" | \\"pulse\\" | \\"spin\\" | \\"wobble\\"","complexType":{"original":"ImageAnimation","resolved":"\\"\\" | \\"float\\" | \\"pulse\\" | \\"spin\\" | \\"wobble\\"","references":{"ImageAnimation":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::ImageAnimation"}}},"mutable":false,"attr":"animation","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"''"}],"default":"''","values":[{"type":"\\"\\""},{"value":"float","type":"string"},{"value":"pulse","type":"string"},{"value":"spin","type":"string"},{"value":"wobble","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"as","type":"\\"button\\"","complexType":{"original":"AsKind","resolved":"\\"button\\"","references":{"AsKind":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::AsKind"}}},"mutable":false,"attr":"as","reflectToAttr":true,"docs":"as=\\"button\\" support","docsTags":[],"values":[{"value":"button","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"background","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"background","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"border","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"border","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"crossorigin","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"crossorigin","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"decoding","type":"\\"async\\" | \\"auto\\" | \\"sync\\"","complexType":{"original":"'async' | 'sync' | 'auto'","resolved":"\\"async\\" | \\"auto\\" | \\"sync\\"","references":{}},"mutable":false,"attr":"decoding","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'async'"}],"default":"'async'","values":[{"value":"async","type":"string"},{"value":"auto","type":"string"},{"value":"sync","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"disabled","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"disabled","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"download","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"download","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"duration","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"duration","reflectToAttr":true,"docs":"seconds (e.g., 20)","docsTags":[{"name":"default","text":"20"}],"default":"20","values":[{"type":"number"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"fit","type":"\\"contain\\" | \\"cover\\" | \\"fill\\" | \\"none\\" | \\"scale-down\\"","complexType":{"original":"ImageFit","resolved":"\\"contain\\" | \\"cover\\" | \\"fill\\" | \\"none\\" | \\"scale-down\\"","references":{"ImageFit":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::ImageFit"}}},"mutable":false,"attr":"fit","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'cover'"}],"default":"'cover'","values":[{"value":"contain","type":"string"},{"value":"cover","type":"string"},{"value":"fill","type":"string"},{"value":"none","type":"string"},{"value":"scale-down","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"height","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"height","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"href","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"href","reflectToAttr":true,"docs":"Wrap with anchor when href provided","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"loading","type":"\\"eager\\" | \\"lazy\\"","complexType":{"original":"'lazy' | 'eager'","resolved":"\\"eager\\" | \\"lazy\\"","references":{}},"mutable":false,"attr":"loading","reflectToAttr":true,"docs":"Loading policy","docsTags":[],"values":[{"value":"eager","type":"string"},{"value":"lazy","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"pauseOnHover","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"pause-on-hover","reflectToAttr":true,"docs":"pause on hover","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"placeholder","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"placeholder","reflectToAttr":true,"docs":"Blurred/low-res placeholder URL","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"play","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"play","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"position","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"position","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'50% 50%'"}],"default":"'50% 50%'","values":[{"type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"priority","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"priority","reflectToAttr":true,"docs":"Priority: eager + inject <link rel=\\"preload\\" as=\\"image\\">","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"radius","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"radius","reflectToAttr":true,"docs":"If radius exists, it overrides rounded preset","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"ratio","type":"\\"16:9\\" | \\"1:1\\" | \\"1:2\\" | \\"1:3\\" | \\"2:1\\" | \\"2:3\\" | \\"3:1\\" | \\"3:2\\" | \\"3:4\\" | \\"4:3\\" | \\"9:16\\"","complexType":{"original":"AspectRatio","resolved":"\\"16:9\\" | \\"1:1\\" | \\"1:2\\" | \\"1:3\\" | \\"2:1\\" | \\"2:3\\" | \\"3:1\\" | \\"3:2\\" | \\"3:4\\" | \\"4:3\\" | \\"9:16\\"","references":{"AspectRatio":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::AspectRatio"}}},"mutable":false,"attr":"ratio","reflectToAttr":true,"docs":"\\"w:h\\", e.g. \\"16:9\\", \\"1:1\\"","docsTags":[{"name":"default","text":"'16:9'"}],"default":"'16:9'","values":[{"value":"16:9","type":"string"},{"value":"1:1","type":"string"},{"value":"1:2","type":"string"},{"value":"1:3","type":"string"},{"value":"2:1","type":"string"},{"value":"2:3","type":"string"},{"value":"3:1","type":"string"},{"value":"3:2","type":"string"},{"value":"3:4","type":"string"},{"value":"4:3","type":"string"},{"value":"9:16","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"referrerpolicy","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"referrerpolicy","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"rel","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"rel","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"repeat","type":"number | string","complexType":{"original":"RepeatValue","resolved":"number | string","references":{"RepeatValue":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::RepeatValue"}}},"mutable":false,"attr":"repeat","reflectToAttr":true,"docs":"'infinite' or finite count (string/number)","docsTags":[{"name":"default","text":"'infinite'"}],"default":"'infinite'","values":[{"type":"number"},{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"rotate","type":"\\"left\\" | \\"right\\"","complexType":{"original":"AnimationRotate","resolved":"\\"left\\" | \\"right\\"","references":{"AnimationRotate":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::AnimationRotate"}}},"mutable":false,"attr":"rotate","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'right'"}],"default":"'right'","values":[{"value":"left","type":"string"},{"value":"right","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"rounded","type":"\\"base\\" | \\"circle\\" | \\"diagonal\\" | \\"full\\" | \\"lr\\" | \\"oval\\" | \\"soft\\" | \\"t\\" | \\"top\\"","complexType":{"original":"RoundedPreset","resolved":"\\"base\\" | \\"circle\\" | \\"diagonal\\" | \\"full\\" | \\"lr\\" | \\"oval\\" | \\"soft\\" | \\"t\\" | \\"top\\"","references":{"RoundedPreset":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::RoundedPreset"}}},"mutable":false,"attr":"rounded","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"value":"base","type":"string"},{"value":"circle","type":"string"},{"value":"diagonal","type":"string"},{"value":"full","type":"string"},{"value":"lr","type":"string"},{"value":"oval","type":"string"},{"value":"soft","type":"string"},{"value":"t","type":"string"},{"value":"top","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"shadow","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"shadow","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"sizes","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"sizes","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"src","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"src","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"srcset","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"srcset","reflectToAttr":true,"docs":"Responsive images","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"startOnViewport","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"start-on-viewport","reflectToAttr":true,"docs":"play/pause on viewport","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"target","type":"string","complexType":{"original":"LinkTarget","resolved":"string","references":{"LinkTarget":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::LinkTarget"}}},"mutable":false,"attr":"target","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"width","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"width","reflectToAttr":true,"docs":"Host box size (CSS inline/block size)","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false}],"methods":[],"events":[{"event":"tinto:error","detail":"TintoImageErrorDetail","bubbles":true,"complexType":{"original":"TintoImageErrorDetail","resolved":"TintoImageErrorDetail","references":{"TintoImageErrorDetail":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::TintoImageErrorDetail"}}},"cancelable":true,"composed":true,"docs":"","docsTags":[]},{"event":"tinto:loaded","detail":"TintoImageLoadedDetail","bubbles":true,"complexType":{"original":"TintoImageLoadedDetail","resolved":"TintoImageLoadedDetail","references":{"TintoImageLoadedDetail":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::TintoImageLoadedDetail"}}},"cancelable":true,"composed":true,"docs":"","docsTags":[]},{"event":"tinto:press","detail":"TintoImagePressDetail","bubbles":true,"complexType":{"original":"TintoImagePressDetail","resolved":"TintoImagePressDetail","references":{"TintoImagePressDetail":{"location":"import","path":"./image.types","id":"src/components/image/image.types.ts::TintoImagePressDetail"}}},"cancelable":true,"composed":true,"docs":"","docsTags":[]}],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"button","docs":""},{"name":"frame","docs":""},{"name":"img","docs":""},{"name":"layer","docs":""},{"name":"link","docs":""},{"name":"placeholder","docs":""},{"name":"plain","docs":""},{"name":"spacer","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/section/section.tsx","encapsulation":"shadow","tag":"tinto-section","readme":"# tinto-section\\n","docs":"","docsTags":[],"usage":{},"props":[{"name":"align","type":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","complexType":{"original":"AlignItems","resolved":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","references":{"AlignItems":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::AlignItems"}}},"mutable":false,"attr":"align","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'stretch'"}],"default":"'stretch'","values":[{"value":"baseline","type":"string"},{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"stretch","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"background","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"background","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"center","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"center","reflectToAttr":true,"docs":"  (maxWidth   margin-inline:auto)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"color","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"color","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"direction","type":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","complexType":{"original":"FlexDirection","resolved":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","references":{"FlexDirection":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::FlexDirection"}}},"mutable":false,"attr":"direction","reflectToAttr":true,"docs":"Flex  ( ,    )","docsTags":[{"name":"default","text":"'column'"}],"default":"'column'","values":[{"value":"column","type":"string"},{"value":"column-reverse","type":"string"},{"value":"row","type":"string"},{"value":"row-reverse","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"gap","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"gap","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"heightMode","type":"\\"auto\\" | \\"dvh\\" | \\"screen\\"","complexType":{"original":"HeightMode","resolved":"\\"auto\\" | \\"dvh\\" | \\"screen\\"","references":{"HeightMode":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::HeightMode"}}},"mutable":false,"attr":"height-mode","reflectToAttr":true,"docs":" \\n- auto:  ()\\n- dvh:    / \\n- screen:  100dvh","docsTags":[{"name":"default","text":"'auto'"}],"default":"'auto'","values":[{"value":"auto","type":"string"},{"value":"dvh","type":"string"},{"value":"screen","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"justify","type":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","complexType":{"original":"Justify","resolved":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","references":{"Justify":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::Justify"}}},"mutable":false,"attr":"justify","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'flex-start'"}],"default":"'flex-start'","values":[{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"space-around","type":"string"},{"value":"space-between","type":"string"},{"value":"space-evenly","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"margin","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"margin","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"maxWidth","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"max-width","reflectToAttr":true,"docs":"//  ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"padding","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"padding","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"radius","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"radius","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"scrollable","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"scrollable","reflectToAttr":true,"docs":"heightMode dvh/screen    ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"shadow","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"shadow","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"wrap","type":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","complexType":{"original":"FlexWrap","resolved":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","references":{"FlexWrap":{"location":"import","path":"./section.types","id":"src/components/section/section.types.ts::FlexWrap"}}},"mutable":false,"attr":"wrap","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'nowrap'"}],"default":"'nowrap'","values":[{"value":"nowrap","type":"string"},{"value":"wrap","type":"string"},{"value":"wrap-reverse","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false}],"methods":[],"events":[],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"root","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/typography/typography.tsx","encapsulation":"shadow","tag":"tinto-typography","readme":"# tinto-typography\\n","docs":"","docsTags":[],"usage":{},"props":[{"name":"align","type":"\\"center\\" | \\"justify\\" | \\"left\\" | \\"right\\"","complexType":{"original":"Align","resolved":"\\"center\\" | \\"justify\\" | \\"left\\" | \\"right\\"","references":{"Align":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::Align"}}},"mutable":false,"attr":"align","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'left'"}],"default":"'left'","values":[{"value":"center","type":"string"},{"value":"justify","type":"string"},{"value":"left","type":"string"},{"value":"right","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"as","type":"\\"h1\\" | \\"h2\\" | \\"h3\\" | \\"p\\" | \\"span\\"","complexType":{"original":"'h1' | 'h2' | 'h3' | 'p' | 'span'","resolved":"\\"h1\\" | \\"h2\\" | \\"h3\\" | \\"p\\" | \\"span\\"","references":{}},"mutable":false,"attr":"as","reflectToAttr":true,"docs":"   (: variant=\\"h1\\" + as=\\"h2\\")","docsTags":[],"values":[{"value":"h1","type":"string"},{"value":"h2","type":"string"},{"value":"h3","type":"string"},{"value":"p","type":"string"},{"value":"span","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"color","type":"string","complexType":{"original":"Color","resolved":"string","references":{"Color":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::Color"}}},"mutable":false,"attr":"color","reflectToAttr":true,"docs":"  ( )","docsTags":[{"name":"default","text":"'inherit'"}],"default":"'inherit'","values":[{"type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"font","type":"\\"clash-display\\" | \\"climate-crisis\\" | \\"paperlogy\\" | \\"pretendard\\" | \\"system\\"","complexType":{"original":"FontFamily","resolved":"\\"clash-display\\" | \\"climate-crisis\\" | \\"paperlogy\\" | \\"pretendard\\" | \\"system\\"","references":{"FontFamily":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::FontFamily"}}},"mutable":false,"attr":"font","reflectToAttr":true,"docs":"  preset","docsTags":[{"name":"default","text":"'system'"}],"default":"'system'","values":[{"value":"clash-display","type":"string"},{"value":"climate-crisis","type":"string"},{"value":"paperlogy","type":"string"},{"value":"pretendard","type":"string"},{"value":"system","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"fontSize","type":"string","complexType":{"original":"FontSize | string","resolved":"string","references":{"FontSize":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::FontSize"}}},"mutable":false,"attr":"font-size","reflectToAttr":true,"docs":"      (: \\"lg\\", \\"32px\\", \\"2.5rem\\")","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"highlight","type":"string","complexType":{"original":"HighlightColor","resolved":"string","references":{"HighlightColor":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::HighlightColor"}}},"mutable":false,"attr":"highlight","reflectToAttr":true,"docs":" ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"href","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"href","reflectToAttr":true,"docs":" URL (  <a> )","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"inline","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"inline","reflectToAttr":true,"docs":"  ( block)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"pauseOnHover","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"pause-on-hover","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rel","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"rel","reflectToAttr":true,"docs":" rel (target _blank    )","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"rollAxis","type":"\\"x\\" | \\"y\\"","complexType":{"original":"'x' | 'y'","resolved":"\\"x\\" | \\"y\\"","references":{}},"mutable":false,"attr":"roll-axis","reflectToAttr":true,"docs":" props     API  ","docsTags":[{"name":"default","text":"'x'"}],"default":"'x'","values":[{"value":"x","type":"string"},{"value":"y","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollClone","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"roll-clone","reflectToAttr":true,"docs":"   (    ,  3)","docsTags":[{"name":"default","text":"3"}],"default":"3","values":[{"type":"number"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollGap","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"roll-gap","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'2rem'"}],"default":"'2rem'","values":[{"type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollPlay","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"roll-play","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollSpeed","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"roll-speed","reflectToAttr":true,"docs":"()  duration  (1~10)   typingDuration  fallback","docsTags":[{"name":"default","text":"5"}],"default":"5","values":[{"type":"number"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rollStartOnViewport","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"roll-start-on-viewport","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"rolling","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"rolling","reflectToAttr":true,"docs":"rolling=true    ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"target","type":"\\"_blank\\" | \\"_parent\\" | \\"_self\\" | \\"_top\\"","complexType":{"original":"'_blank' | '_self' | '_parent' | '_top'","resolved":"\\"_blank\\" | \\"_parent\\" | \\"_self\\" | \\"_top\\"","references":{}},"mutable":false,"attr":"target","reflectToAttr":true,"docs":"  (_blank, _self, _parent, _top)","docsTags":[],"values":[{"value":"_blank","type":"string"},{"value":"_parent","type":"string"},{"value":"_self","type":"string"},{"value":"_top","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"typingCursor","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"typing-cursor","reflectToAttr":true,"docs":"( | )  ","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"typingDuration","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"typing-duration","reflectToAttr":true,"docs":"   duration  (1~10)","docsTags":[],"values":[{"type":"number"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"typingEraseDuration","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"typing-erase-duration","reflectToAttr":true,"docs":" duration  (1~10,  typingDuration )","docsTags":[],"values":[{"type":"number"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"typingLoop","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"typing-loop","reflectToAttr":true,"docs":"     ","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"typingTexts","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"typing-texts","reflectToAttr":true,"docs":"   .\\n-  JSON: '[\\"1\\",\\"2\\"]'\\n-   : '1|2|3'\\n   rollClone( 3)  .","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"typingUnit","type":"\\"char\\" | \\"word\\"","complexType":{"original":"TypingUnit","resolved":"\\"char\\" | \\"word\\"","references":{"TypingUnit":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::TypingUnit"}}},"mutable":false,"attr":"typing-unit","reflectToAttr":true,"docs":"  /  ","docsTags":[{"name":"default","text":"'char'"}],"default":"'char'","values":[{"value":"char","type":"string"},{"value":"word","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"underline","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"underline","reflectToAttr":true,"docs":" ","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"variant","type":"\\"h1\\" | \\"h2\\" | \\"h3\\" | \\"p\\" | \\"span\\"","complexType":{"original":"Variant","resolved":"\\"h1\\" | \\"h2\\" | \\"h3\\" | \\"p\\" | \\"span\\"","references":{"Variant":{"location":"import","path":"./typography.types","id":"src/components/typography/typography.types.ts::Variant"}}},"mutable":false,"attr":"variant","reflectToAttr":true,"docs":" HTML   ( as  )","docsTags":[{"name":"default","text":"'p'"}],"default":"'p'","values":[{"value":"h1","type":"string"},{"value":"h2","type":"string"},{"value":"h3","type":"string"},{"value":"p","type":"string"},{"value":"span","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"visible","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"visible","reflectToAttr":true,"docs":"  (false  hidden)","docsTags":[{"name":"default","text":"true"}],"default":"true","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"weight","type":"number | string","complexType":{"original":"number | string","resolved":"number | string","references":{}},"mutable":false,"attr":"weight","reflectToAttr":true,"docs":" (: 400, 500, 700, 'bold')","docsTags":[],"values":[{"type":"number"},{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false}],"methods":[],"events":[],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"link","docs":""},{"name":"root","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}},{"filePath":"src/components/wrapper/wrapper.tsx","encapsulation":"shadow","tag":"tinto-wrapper","readme":"# tinto-wrapper\\n","docs":"","docsTags":[],"usage":{},"props":[{"name":"align","type":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","complexType":{"original":"AlignItems","resolved":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","references":{"AlignItems":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::AlignItems"}}},"mutable":false,"attr":"align","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'stretch'"}],"default":"'stretch'","values":[{"value":"baseline","type":"string"},{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"stretch","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"alignDesktop","type":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","complexType":{"original":"AlignItems","resolved":"\\"baseline\\" | \\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"stretch\\"","references":{"AlignItems":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::AlignItems"}}},"mutable":false,"attr":"align-desktop","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"value":"baseline","type":"string"},{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"stretch","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"background","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"background","reflectToAttr":true,"docs":"(/) +  ","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgAttachment","type":"string","complexType":{"original":"BgAttachment","resolved":"string","references":{"BgAttachment":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::BgAttachment"}}},"mutable":false,"attr":"bg-attachment","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'scroll'"}],"default":"'scroll'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgBlend","type":"string","complexType":{"original":"BgBlend","resolved":"string","references":{"BgBlend":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::BgBlend"}}},"mutable":false,"attr":"bg-blend","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'normal'"}],"default":"'normal'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgPosition","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"bg-position","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'50% 50%'"}],"default":"'50% 50%'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgRepeat","type":"string","complexType":{"original":"BgRepeat","resolved":"string","references":{"BgRepeat":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::BgRepeat"}}},"mutable":false,"attr":"bg-repeat","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'no-repeat'"}],"default":"'no-repeat'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"bgSize","type":"string","complexType":{"original":"BgSize","resolved":"string","references":{"BgSize":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::BgSize"}}},"mutable":false,"attr":"bg-size","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'cover'"}],"default":"'cover'","values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"border","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"border","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"color","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"color","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"direction","type":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","complexType":{"original":"FlexDirection","resolved":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","references":{"FlexDirection":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::FlexDirection"}}},"mutable":false,"attr":"direction","reflectToAttr":true,"docs":"Flex ( )","docsTags":[{"name":"default","text":"'row'"}],"default":"'row'","values":[{"value":"column","type":"string"},{"value":"column-reverse","type":"string"},{"value":"row","type":"string"},{"value":"row-reverse","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"directionDesktop","type":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","complexType":{"original":"FlexDirection","resolved":"\\"column\\" | \\"column-reverse\\" | \\"row\\" | \\"row-reverse\\"","references":{"FlexDirection":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::FlexDirection"}}},"mutable":false,"attr":"direction-desktop","reflectToAttr":true,"docs":"Flex ( , >=1920px)","docsTags":[],"values":[{"value":"column","type":"string"},{"value":"column-reverse","type":"string"},{"value":"row","type":"string"},{"value":"row-reverse","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"fill","type":"boolean","complexType":{"original":"boolean","resolved":"boolean","references":{}},"mutable":false,"attr":"fill","reflectToAttr":true,"docs":"   (absolute; inset:0)","docsTags":[{"name":"default","text":"false"}],"default":"false","values":[{"type":"boolean"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"gap","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"gap","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"gapDesktop","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"gap-desktop","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"justify","type":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","complexType":{"original":"Justify","resolved":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","references":{"Justify":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::Justify"}}},"mutable":false,"attr":"justify","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'flex-start'"}],"default":"'flex-start'","values":[{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"space-around","type":"string"},{"value":"space-between","type":"string"},{"value":"space-evenly","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"justifyDesktop","type":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","complexType":{"original":"Justify","resolved":"\\"center\\" | \\"flex-end\\" | \\"flex-start\\" | \\"space-around\\" | \\"space-between\\" | \\"space-evenly\\"","references":{"Justify":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::Justify"}}},"mutable":false,"attr":"justify-desktop","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"value":"center","type":"string"},{"value":"flex-end","type":"string"},{"value":"flex-start","type":"string"},{"value":"space-around","type":"string"},{"value":"space-between","type":"string"},{"value":"space-evenly","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"margin","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"margin","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"overlay","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"overlay","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"overlayOpacity","type":"number","complexType":{"original":"number","resolved":"number","references":{}},"mutable":false,"attr":"overlay-opacity","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"number"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"padding","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"padding","reflectToAttr":true,"docs":"Box / Visual","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"radius","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"radius","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"shadow","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"shadow","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"src","type":"string","complexType":{"original":"string","resolved":"string","references":{}},"mutable":false,"attr":"src","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"type":"string"}],"optional":true,"required":false,"getter":false,"setter":false},{"name":"wrap","type":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","complexType":{"original":"FlexWrap","resolved":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","references":{"FlexWrap":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::FlexWrap"}}},"mutable":false,"attr":"wrap","reflectToAttr":true,"docs":"","docsTags":[{"name":"default","text":"'nowrap'"}],"default":"'nowrap'","values":[{"value":"nowrap","type":"string"},{"value":"wrap","type":"string"},{"value":"wrap-reverse","type":"string"}],"optional":false,"required":false,"getter":false,"setter":false},{"name":"wrapDesktop","type":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","complexType":{"original":"FlexWrap","resolved":"\\"nowrap\\" | \\"wrap\\" | \\"wrap-reverse\\"","references":{"FlexWrap":{"location":"import","path":"./wrapper.types","id":"src/components/wrapper/wrapper.types.ts::FlexWrap"}}},"mutable":false,"attr":"wrap-desktop","reflectToAttr":true,"docs":"","docsTags":[],"values":[{"value":"nowrap","type":"string"},{"value":"wrap","type":"string"},{"value":"wrap-reverse","type":"string"}],"optional":true,"required":false,"getter":false,"setter":false}],"methods":[],"events":[],"listeners":[],"styles":[],"slots":[],"parts":[{"name":"inner","docs":""},{"name":"root","docs":""}],"dependents":[],"dependencies":[],"dependencyGraph":{}}]`,
  ),
  m5 = {
    'src/components/badge/badge.tsx::TintoBadgeVariant': {
      declaration:
        "export type TintoBadgeVariant = 'neutral' | 'primary' | 'success' | 'warning' | 'danger';",
      docstring: '',
      path: 'src/components/badge/badge.tsx',
    },
    'src/components/badge/badge.tsx::TintoBadgeSize': {
      declaration: "export type TintoBadgeSize = 'sm' | 'md';",
      docstring: '',
      path: 'src/components/badge/badge.tsx',
    },
    'src/components/button/button.tsx::TintoButtonVariant': {
      declaration: "export type TintoButtonVariant = 'primary' | 'secondary' | 'ghost';",
      docstring: '',
      path: 'src/components/button/button.tsx',
    },
    'src/components/button/button.tsx::TintoButtonSize': {
      declaration: "export type TintoButtonSize = 'sm' | 'md' | 'lg';",
      docstring: '',
      path: 'src/components/button/button.tsx',
    },
    'src/components/button/button.tsx::TintoButtonType': {
      declaration: "export type TintoButtonType = 'button' | 'submit' | 'reset';",
      docstring: '',
      path: 'src/components/button/button.tsx',
    },
    'src/components/image/image.types.ts::AspectRatio': {
      declaration: `export type AspectRatio =
  | '1:1'
  | '2:1'
  | '3:2'
  | '4:3'
  | '16:9'
  | '3:1'
  | '1:2'
  | '2:3'
  | '3:4'
  | '9:16'
  | '1:3';`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::ImageFit': {
      declaration: "export type ImageFit = 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';",
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::RoundedPreset': {
      declaration: `export type RoundedPreset =
  | 'soft'
  | 'oval'
  | 'top'
  | 'diagonal'
  | 'circle'
  // alias ( )
  | 'base'
  | 'full'
  | 't'
  | 'lr';`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::LinkTarget': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::AsKind': {
      declaration: '"button"',
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::ImageAnimation': {
      declaration: "export type ImageAnimation = '' | 'spin' | 'float' | 'wobble' | 'pulse';",
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::AnimationRotate': {
      declaration: "export type AnimationRotate = 'left' | 'right';",
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::RepeatValue': {
      declaration: "export type RepeatValue = 'infinite' | number | string;",
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::TintoImageLoadedDetail': {
      declaration: `export interface TintoImageLoadedDetail {
  width: number;
  height: number;
  src?: string;
}`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::TintoImageErrorDetail': {
      declaration: `export interface TintoImageErrorDetail {
  src?: string;
}`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/image/image.types.ts::TintoImagePressDetail': {
      declaration: `export interface TintoImagePressDetail {
  kind: PressKind;
}`,
      docstring: '',
      path: 'src/components/image/image.types.ts',
    },
    'src/components/section/section.types.ts::FlexDirection': {
      declaration:
        "export type FlexDirection = 'row' | 'row-reverse' | 'column' | 'column-reverse';",
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/section/section.types.ts::FlexWrap': {
      declaration: "export type FlexWrap = 'nowrap' | 'wrap' | 'wrap-reverse';",
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/section/section.types.ts::Justify': {
      declaration: `export type Justify =
  | 'flex-start'
  | 'center'
  | 'flex-end'
  | 'space-between'
  | 'space-around'
  | 'space-evenly';`,
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/section/section.types.ts::AlignItems': {
      declaration:
        "export type AlignItems = 'stretch' | 'flex-start' | 'center' | 'flex-end' | 'baseline';",
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/section/section.types.ts::HeightMode': {
      declaration: "export type HeightMode = 'auto' | 'dvh' | 'screen';",
      docstring: '',
      path: 'src/components/section/section.types.ts',
    },
    'src/components/typography/typography.types.ts::Variant': {
      declaration: "export type Variant = 'h1' | 'h2' | 'h3' | 'p' | 'span';",
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::FontFamily': {
      declaration: '"system" | "pretendard" | "paperlogy" | "clash-display" | "climate-crisis"',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::FontSize': {
      declaration: '"sm" | "md" | "lg" | "xs" | "xl" | "xxl"',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::Color': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::Align': {
      declaration: "export type Align = 'left' | 'center' | 'right' | 'justify';",
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::HighlightColor': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/typography/typography.types.ts::TypingUnit': {
      declaration: '"char" | "word"',
      docstring: '',
      path: 'src/components/typography/typography.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::FlexDirection': {
      declaration:
        "export type FlexDirection = 'row' | 'row-reverse' | 'column' | 'column-reverse';",
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::FlexWrap': {
      declaration: "export type FlexWrap = 'nowrap' | 'wrap' | 'wrap-reverse';",
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::Justify': {
      declaration: `export type Justify =
  | 'flex-start'
  | 'center'
  | 'flex-end'
  | 'space-between'
  | 'space-around'
  | 'space-evenly';`,
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::AlignItems': {
      declaration:
        "export type AlignItems = 'stretch' | 'flex-start' | 'center' | 'flex-end' | 'baseline';",
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::BgSize': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::BgRepeat': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::BgAttachment': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
    'src/components/wrapper/wrapper.types.ts::BgBlend': {
      declaration: 'string',
      docstring: '',
      path: 'src/components/wrapper/wrapper.types.ts',
    },
  },
  y5 = { timestamp: d5, compiler: p5, components: f5, typeLibrary: m5 };
u5();
pW(y5);
const h5 = Object.freeze(
  Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: 'Module' }),
);
Zh();
const { composeConfigs: g5, PreviewWeb: b5 } = __STORYBOOK_MODULE_PREVIEW_API__,
  v5 = (e = []) => {
    const t = [e[0] ?? cW, e[1] ?? _W, e[2] ?? h5];
    return g5(t);
  };
window.__STORYBOOK_PREVIEW__ = window.__STORYBOOK_PREVIEW__ || new b5(sG, v5);
window.__STORYBOOK_STORY_STORE__ =
  window.__STORYBOOK_STORY_STORE__ || window.__STORYBOOK_PREVIEW__.storyStore;
export { BK as H, $G as a, JK as c, ml as h, UK as p };
