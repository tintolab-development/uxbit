var XN = Object.defineProperty;
var QN = (e, t, r) =>
  t in e ? XN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r);
var Le = (e, t, r) => QN(e, typeof t != 'symbol' ? t + '' : t, r);
import { h as dh, r as ZN } from './assets/vendor-stencil-dp4AnqGI.js';
class eI {
  constructor() {
    this.registry = new Map();
  }
  add(t) {
    if (!t) return;
    const r = t.url ?? t.id ?? Symbol();
    this.registry.set(r, t);
  }
  delete(t) {
    this.registry.delete(t);
  }
  clear() {
    this.registry.clear();
  }
  get(t) {
    return this.registry.get(t);
  }
  has(t) {
    return this.registry.has(t);
  }
}
class tI {
  constructor() {}
  queueMock() {}
  queueUnmock() {}
  importActual() {
    return Promise.resolve(void 0);
  }
  importMock() {
    return Promise.resolve({});
  }
}
function rI() {
  return {
    hoisted(e) {
      return typeof e == 'function' ? e() : e;
    },
    mock() {},
    unmock() {},
    doMock() {},
    doUnmock() {},
    importActual() {
      return Promise.resolve(void 0);
    },
    importMock() {
      return Promise.resolve({});
    },
  };
}
class nI {
  constructor() {
    Le(this, 'mocks', new eI());
  }
  async register(t) {
    this.mocks.add(t);
  }
  async delete(t) {
    this.mocks.delete(t);
  }
  async invalidate() {
    this.mocks.clear();
  }
}
const mc = (e) => {
  switch (e) {
    case 'resolveId':
      return Promise.resolve({ id: '', url: '', optimized: !1 });
    case 'resolveMock':
      return Promise.resolve({
        mockType: 'dummy',
        resolvedId: '',
        resolvedUrl: '',
        redirectUrl: '',
        needsInterop: !1,
      });
    case 'invalidate':
      return Promise.resolve();
  }
};
class oI extends tI {
  queueMock() {}
}
function iI(e) {
  const t = new oI(
    e('__vitest_mocker__'),
    {
      resolveId(r, n) {
        return mc('resolveId');
      },
      resolveMock(r, n, i) {
        return mc('resolveMock');
      },
      async invalidate(r) {
        return mc('invalidate');
      },
    },
    (...r) => globalThis.__STORYBOOK_MODULE_TEST__.spyOn(...r),
    { root: '' },
  );
  return ((globalThis.__vitest_mocker__ = t), rI());
}
globalThis.__STORYBOOK_MOCKER__ = iI(() => new nI());
var $c = {},
  sI = Object.create,
  Da = Object.defineProperty,
  aI = Object.getOwnPropertyDescriptor,
  ob = Object.getOwnPropertyNames,
  lI = Object.getPrototypeOf,
  cI = Object.prototype.hasOwnProperty,
  o = (e, t) => Da(e, 'name', { value: t, configurable: !0 }),
  vs = ((e) =>
    typeof require < 'u'
      ? require
      : typeof Proxy < 'u'
        ? new Proxy(e, { get: (t, r) => (typeof require < 'u' ? require : t)[r] })
        : e)(function (e) {
    if (typeof require < 'u') return require.apply(this, arguments);
    throw Error('Dynamic require of "' + e + '" is not supported');
  }),
  J = (e, t) =>
    function () {
      return (t || (0, e[ob(e)[0]])((t = { exports: {} }).exports, t), t.exports);
    },
  Et = (e, t) => {
    for (var r in t) Da(e, r, { get: t[r], enumerable: !0 });
  },
  uI = (e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let i of ob(t))
        !cI.call(e, i) &&
          i !== r &&
          Da(e, i, { get: () => t[i], enumerable: !(n = aI(t, i)) || n.enumerable });
    return e;
  },
  ze = (e, t, r) => (
    (r = e != null ? sI(lI(e)) : {}),
    uI(t || !e || !e.__esModule ? Da(r, 'default', { value: e, enumerable: !0 }) : r, e)
  ),
  dI = J({
    '../node_modules/@ngard/tiny-isequal/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.isEqual = (function () {
          var t = Object.prototype.toString,
            r = Object.getPrototypeOf,
            n = Object.getOwnPropertySymbols
              ? function (i) {
                  return Object.keys(i).concat(Object.getOwnPropertySymbols(i));
                }
              : Object.keys;
          return function (i, s) {
            return o(function a(c, d, u) {
              var p,
                f,
                y,
                h = t.call(c),
                g = t.call(d);
              if (c === d) return !0;
              if (c == null || d == null) return !1;
              if (u.indexOf(c) > -1 && u.indexOf(d) > -1) return !0;
              if (
                (u.push(c, d),
                h != g ||
                  ((p = n(c)),
                  (f = n(d)),
                  p.length != f.length ||
                    p.some(function (T) {
                      return !a(c[T], d[T], u);
                    })))
              )
                return !1;
              switch (h.slice(8, -1)) {
                case 'Symbol':
                  return c.valueOf() == d.valueOf();
                case 'Date':
                case 'Number':
                  return +c == +d || (+c != +c && +d != +d);
                case 'RegExp':
                case 'Function':
                case 'String':
                case 'Boolean':
                  return '' + c == '' + d;
                case 'Set':
                case 'Map':
                  ((p = c.entries()), (f = d.entries()));
                  do if (!a((y = p.next()).value, f.next().value, u)) return !1;
                  while (!y.done);
                  return !0;
                case 'ArrayBuffer':
                  ((c = new Uint8Array(c)), (d = new Uint8Array(d)));
                case 'DataView':
                  ((c = new Uint8Array(c.buffer)), (d = new Uint8Array(d.buffer)));
                case 'Float32Array':
                case 'Float64Array':
                case 'Int8Array':
                case 'Int16Array':
                case 'Int32Array':
                case 'Uint8Array':
                case 'Uint16Array':
                case 'Uint32Array':
                case 'Uint8ClampedArray':
                case 'Arguments':
                case 'Array':
                  if (c.length != d.length) return !1;
                  for (y = 0; y < c.length; y++)
                    if ((y in c || y in d) && (y in c != y in d || !a(c[y], d[y], u))) return !1;
                  return !0;
                case 'Object':
                  return a(r(c), r(d), u);
                default:
                  return !1;
              }
            }, 'n')(i, s, []);
          };
        })()));
    },
  }),
  pI = J({
    '../node_modules/min-indent/index.js'(e, t) {
      t.exports = (r) => {
        const n = r.match(/^[ \t]*(?=\S)/gm);
        return n ? n.reduce((i, s) => Math.min(i, s.length), 1 / 0) : 0;
      };
    },
  }),
  fI = J({
    '../node_modules/strip-indent/index.js'(e, t) {
      var r = pI();
      t.exports = (n) => {
        const i = r(n);
        if (i === 0) return n;
        const s = new RegExp(`^[ \\t]{${i}}`, 'gm');
        return n.replace(s, '');
      };
    },
  }),
  mI = J({
    '../node_modules/indent-string/index.js'(e, t) {
      t.exports = (r, n = 1, i) => {
        if (((i = { indent: ' ', includeEmptyLines: !1, ...i }), typeof r != 'string'))
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof r}\``);
        if (typeof n != 'number')
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof n}\``);
        if (typeof i.indent != 'string')
          throw new TypeError(
            `Expected \`options.indent\` to be a \`string\`, got \`${typeof i.indent}\``,
          );
        if (n === 0) return r;
        const s = i.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return r.replace(s, i.indent.repeat(n));
      };
    },
  }),
  ib = J({
    '../node_modules/redent/index.js'(e, t) {
      var r = fI(),
        n = mI();
      t.exports = (i, s = 0, a) => n(r(i), s, a);
    },
  }),
  yI = J({
    '../node_modules/aria-query/lib/util/iteratorProxy.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      function t() {
        var r = this,
          n = 0,
          i = {
            '@@iterator': o(function () {
              return i;
            }, 'iterator'),
            next: o(function () {
              if (n < r.length) {
                var a = r[n];
                return ((n = n + 1), { done: !1, value: a });
              } else return { done: !0 };
            }, 'next'),
          };
        return i;
      }
      (o(t, 'iteratorProxy'), (e.default = t));
    },
  }),
  Xi = J({
    '../node_modules/aria-query/lib/util/iterationDecorator.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = i));
      var t = r(yI());
      function r(s) {
        return s && s.__esModule ? s : { default: s };
      }
      o(r, '_interopRequireDefault');
      function n(s) {
        '@babel/helpers - typeof';
        return (
          (n =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (a) {
                  return typeof a;
                }
              : function (a) {
                  return a &&
                    typeof Symbol == 'function' &&
                    a.constructor === Symbol &&
                    a !== Symbol.prototype
                    ? 'symbol'
                    : typeof a;
                }),
          n(s)
        );
      }
      o(n, '_typeof');
      function i(s, a) {
        return (
          typeof Symbol == 'function' &&
            n(Symbol.iterator) === 'symbol' &&
            Object.defineProperty(s, Symbol.iterator, { value: t.default.bind(a) }),
          s
        );
      }
      o(i, 'iterationDecorator');
    },
  }),
  hI = J({
    '../node_modules/aria-query/lib/ariaPropsMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = r(Xi());
      function r(f) {
        return f && f.__esModule ? f : { default: f };
      }
      o(r, '_interopRequireDefault');
      function n(f, y) {
        return d(f) || c(f, y) || s(f, y) || i();
      }
      o(n, '_slicedToArray');
      function i() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      o(i, '_nonIterableRest');
      function s(f, y) {
        if (f) {
          if (typeof f == 'string') return a(f, y);
          var h = {}.toString.call(f).slice(8, -1);
          return (
            h === 'Object' && f.constructor && (h = f.constructor.name),
            h === 'Map' || h === 'Set'
              ? Array.from(f)
              : h === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)
                ? a(f, y)
                : void 0
          );
        }
      }
      o(s, '_unsupportedIterableToArray');
      function a(f, y) {
        (y == null || y > f.length) && (y = f.length);
        for (var h = 0, g = Array(y); h < y; h++) g[h] = f[h];
        return g;
      }
      o(a, '_arrayLikeToArray');
      function c(f, y) {
        var h = f == null ? null : (typeof Symbol < 'u' && f[Symbol.iterator]) || f['@@iterator'];
        if (h != null) {
          var g,
            T,
            E,
            v,
            S = [],
            A = !0,
            N = !1;
          try {
            if (((E = (h = h.call(f)).next), y === 0)) {
              if (Object(h) !== h) return;
              A = !1;
            } else for (; !(A = (g = E.call(h)).done) && (S.push(g.value), S.length !== y); A = !0);
          } catch (j) {
            ((N = !0), (T = j));
          } finally {
            try {
              if (!A && h.return != null && ((v = h.return()), Object(v) !== v)) return;
            } finally {
              if (N) throw T;
            }
          }
          return S;
        }
      }
      o(c, '_iterableToArrayLimit');
      function d(f) {
        if (Array.isArray(f)) return f;
      }
      o(d, '_arrayWithHoles');
      var u = [
          ['aria-activedescendant', { type: 'id' }],
          ['aria-atomic', { type: 'boolean' }],
          ['aria-autocomplete', { type: 'token', values: ['inline', 'list', 'both', 'none'] }],
          ['aria-braillelabel', { type: 'string' }],
          ['aria-brailleroledescription', { type: 'string' }],
          ['aria-busy', { type: 'boolean' }],
          ['aria-checked', { type: 'tristate' }],
          ['aria-colcount', { type: 'integer' }],
          ['aria-colindex', { type: 'integer' }],
          ['aria-colspan', { type: 'integer' }],
          ['aria-controls', { type: 'idlist' }],
          [
            'aria-current',
            { type: 'token', values: ['page', 'step', 'location', 'date', 'time', !0, !1] },
          ],
          ['aria-describedby', { type: 'idlist' }],
          ['aria-description', { type: 'string' }],
          ['aria-details', { type: 'id' }],
          ['aria-disabled', { type: 'boolean' }],
          [
            'aria-dropeffect',
            { type: 'tokenlist', values: ['copy', 'execute', 'link', 'move', 'none', 'popup'] },
          ],
          ['aria-errormessage', { type: 'id' }],
          ['aria-expanded', { type: 'boolean', allowundefined: !0 }],
          ['aria-flowto', { type: 'idlist' }],
          ['aria-grabbed', { type: 'boolean', allowundefined: !0 }],
          [
            'aria-haspopup',
            { type: 'token', values: [!1, !0, 'menu', 'listbox', 'tree', 'grid', 'dialog'] },
          ],
          ['aria-hidden', { type: 'boolean', allowundefined: !0 }],
          ['aria-invalid', { type: 'token', values: ['grammar', !1, 'spelling', !0] }],
          ['aria-keyshortcuts', { type: 'string' }],
          ['aria-label', { type: 'string' }],
          ['aria-labelledby', { type: 'idlist' }],
          ['aria-level', { type: 'integer' }],
          ['aria-live', { type: 'token', values: ['assertive', 'off', 'polite'] }],
          ['aria-modal', { type: 'boolean' }],
          ['aria-multiline', { type: 'boolean' }],
          ['aria-multiselectable', { type: 'boolean' }],
          ['aria-orientation', { type: 'token', values: ['vertical', 'undefined', 'horizontal'] }],
          ['aria-owns', { type: 'idlist' }],
          ['aria-placeholder', { type: 'string' }],
          ['aria-posinset', { type: 'integer' }],
          ['aria-pressed', { type: 'tristate' }],
          ['aria-readonly', { type: 'boolean' }],
          [
            'aria-relevant',
            { type: 'tokenlist', values: ['additions', 'all', 'removals', 'text'] },
          ],
          ['aria-required', { type: 'boolean' }],
          ['aria-roledescription', { type: 'string' }],
          ['aria-rowcount', { type: 'integer' }],
          ['aria-rowindex', { type: 'integer' }],
          ['aria-rowspan', { type: 'integer' }],
          ['aria-selected', { type: 'boolean', allowundefined: !0 }],
          ['aria-setsize', { type: 'integer' }],
          ['aria-sort', { type: 'token', values: ['ascending', 'descending', 'none', 'other'] }],
          ['aria-valuemax', { type: 'number' }],
          ['aria-valuemin', { type: 'number' }],
          ['aria-valuenow', { type: 'number' }],
          ['aria-valuetext', { type: 'string' }],
        ],
        p = {
          entries: o(function () {
            return u;
          }, 'entries'),
          forEach: o(function (y) {
            for (
              var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                g = 0,
                T = u;
              g < T.length;
              g++
            ) {
              var E = n(T[g], 2),
                v = E[0],
                S = E[1];
              y.call(h, S, v, u);
            }
          }, 'forEach'),
          get: o(function (y) {
            var h = u.filter(function (g) {
              return g[0] === y;
            })[0];
            return h && h[1];
          }, 'get'),
          has: o(function (y) {
            return !!p.get(y);
          }, 'has'),
          keys: o(function () {
            return u.map(function (y) {
              var h = n(y, 1),
                g = h[0];
              return g;
            });
          }, 'keys'),
          values: o(function () {
            return u.map(function (y) {
              var h = n(y, 2),
                g = h[1];
              return g;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(p, p.entries());
    },
  }),
  gI = J({
    '../node_modules/aria-query/lib/domMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = r(Xi());
      function r(f) {
        return f && f.__esModule ? f : { default: f };
      }
      o(r, '_interopRequireDefault');
      function n(f, y) {
        return d(f) || c(f, y) || s(f, y) || i();
      }
      o(n, '_slicedToArray');
      function i() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      o(i, '_nonIterableRest');
      function s(f, y) {
        if (f) {
          if (typeof f == 'string') return a(f, y);
          var h = {}.toString.call(f).slice(8, -1);
          return (
            h === 'Object' && f.constructor && (h = f.constructor.name),
            h === 'Map' || h === 'Set'
              ? Array.from(f)
              : h === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)
                ? a(f, y)
                : void 0
          );
        }
      }
      o(s, '_unsupportedIterableToArray');
      function a(f, y) {
        (y == null || y > f.length) && (y = f.length);
        for (var h = 0, g = Array(y); h < y; h++) g[h] = f[h];
        return g;
      }
      o(a, '_arrayLikeToArray');
      function c(f, y) {
        var h = f == null ? null : (typeof Symbol < 'u' && f[Symbol.iterator]) || f['@@iterator'];
        if (h != null) {
          var g,
            T,
            E,
            v,
            S = [],
            A = !0,
            N = !1;
          try {
            if (((E = (h = h.call(f)).next), y === 0)) {
              if (Object(h) !== h) return;
              A = !1;
            } else for (; !(A = (g = E.call(h)).done) && (S.push(g.value), S.length !== y); A = !0);
          } catch (j) {
            ((N = !0), (T = j));
          } finally {
            try {
              if (!A && h.return != null && ((v = h.return()), Object(v) !== v)) return;
            } finally {
              if (N) throw T;
            }
          }
          return S;
        }
      }
      o(c, '_iterableToArrayLimit');
      function d(f) {
        if (Array.isArray(f)) return f;
      }
      o(d, '_arrayWithHoles');
      var u = [
          ['a', { reserved: !1 }],
          ['abbr', { reserved: !1 }],
          ['acronym', { reserved: !1 }],
          ['address', { reserved: !1 }],
          ['applet', { reserved: !1 }],
          ['area', { reserved: !1 }],
          ['article', { reserved: !1 }],
          ['aside', { reserved: !1 }],
          ['audio', { reserved: !1 }],
          ['b', { reserved: !1 }],
          ['base', { reserved: !0 }],
          ['bdi', { reserved: !1 }],
          ['bdo', { reserved: !1 }],
          ['big', { reserved: !1 }],
          ['blink', { reserved: !1 }],
          ['blockquote', { reserved: !1 }],
          ['body', { reserved: !1 }],
          ['br', { reserved: !1 }],
          ['button', { reserved: !1 }],
          ['canvas', { reserved: !1 }],
          ['caption', { reserved: !1 }],
          ['center', { reserved: !1 }],
          ['cite', { reserved: !1 }],
          ['code', { reserved: !1 }],
          ['col', { reserved: !0 }],
          ['colgroup', { reserved: !0 }],
          ['content', { reserved: !1 }],
          ['data', { reserved: !1 }],
          ['datalist', { reserved: !1 }],
          ['dd', { reserved: !1 }],
          ['del', { reserved: !1 }],
          ['details', { reserved: !1 }],
          ['dfn', { reserved: !1 }],
          ['dialog', { reserved: !1 }],
          ['dir', { reserved: !1 }],
          ['div', { reserved: !1 }],
          ['dl', { reserved: !1 }],
          ['dt', { reserved: !1 }],
          ['em', { reserved: !1 }],
          ['embed', { reserved: !1 }],
          ['fieldset', { reserved: !1 }],
          ['figcaption', { reserved: !1 }],
          ['figure', { reserved: !1 }],
          ['font', { reserved: !1 }],
          ['footer', { reserved: !1 }],
          ['form', { reserved: !1 }],
          ['frame', { reserved: !1 }],
          ['frameset', { reserved: !1 }],
          ['h1', { reserved: !1 }],
          ['h2', { reserved: !1 }],
          ['h3', { reserved: !1 }],
          ['h4', { reserved: !1 }],
          ['h5', { reserved: !1 }],
          ['h6', { reserved: !1 }],
          ['head', { reserved: !0 }],
          ['header', { reserved: !1 }],
          ['hgroup', { reserved: !1 }],
          ['hr', { reserved: !1 }],
          ['html', { reserved: !0 }],
          ['i', { reserved: !1 }],
          ['iframe', { reserved: !1 }],
          ['img', { reserved: !1 }],
          ['input', { reserved: !1 }],
          ['ins', { reserved: !1 }],
          ['kbd', { reserved: !1 }],
          ['keygen', { reserved: !1 }],
          ['label', { reserved: !1 }],
          ['legend', { reserved: !1 }],
          ['li', { reserved: !1 }],
          ['link', { reserved: !0 }],
          ['main', { reserved: !1 }],
          ['map', { reserved: !1 }],
          ['mark', { reserved: !1 }],
          ['marquee', { reserved: !1 }],
          ['menu', { reserved: !1 }],
          ['menuitem', { reserved: !1 }],
          ['meta', { reserved: !0 }],
          ['meter', { reserved: !1 }],
          ['nav', { reserved: !1 }],
          ['noembed', { reserved: !0 }],
          ['noscript', { reserved: !0 }],
          ['object', { reserved: !1 }],
          ['ol', { reserved: !1 }],
          ['optgroup', { reserved: !1 }],
          ['option', { reserved: !1 }],
          ['output', { reserved: !1 }],
          ['p', { reserved: !1 }],
          ['param', { reserved: !0 }],
          ['picture', { reserved: !0 }],
          ['pre', { reserved: !1 }],
          ['progress', { reserved: !1 }],
          ['q', { reserved: !1 }],
          ['rp', { reserved: !1 }],
          ['rt', { reserved: !1 }],
          ['rtc', { reserved: !1 }],
          ['ruby', { reserved: !1 }],
          ['s', { reserved: !1 }],
          ['samp', { reserved: !1 }],
          ['script', { reserved: !0 }],
          ['section', { reserved: !1 }],
          ['select', { reserved: !1 }],
          ['small', { reserved: !1 }],
          ['source', { reserved: !0 }],
          ['spacer', { reserved: !1 }],
          ['span', { reserved: !1 }],
          ['strike', { reserved: !1 }],
          ['strong', { reserved: !1 }],
          ['style', { reserved: !0 }],
          ['sub', { reserved: !1 }],
          ['summary', { reserved: !1 }],
          ['sup', { reserved: !1 }],
          ['table', { reserved: !1 }],
          ['tbody', { reserved: !1 }],
          ['td', { reserved: !1 }],
          ['textarea', { reserved: !1 }],
          ['tfoot', { reserved: !1 }],
          ['th', { reserved: !1 }],
          ['thead', { reserved: !1 }],
          ['time', { reserved: !1 }],
          ['title', { reserved: !0 }],
          ['tr', { reserved: !1 }],
          ['track', { reserved: !0 }],
          ['tt', { reserved: !1 }],
          ['u', { reserved: !1 }],
          ['ul', { reserved: !1 }],
          ['var', { reserved: !1 }],
          ['video', { reserved: !1 }],
          ['wbr', { reserved: !1 }],
          ['xmp', { reserved: !1 }],
        ],
        p = {
          entries: o(function () {
            return u;
          }, 'entries'),
          forEach: o(function (y) {
            for (
              var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                g = 0,
                T = u;
              g < T.length;
              g++
            ) {
              var E = n(T[g], 2),
                v = E[0],
                S = E[1];
              y.call(h, S, v, u);
            }
          }, 'forEach'),
          get: o(function (y) {
            var h = u.filter(function (g) {
              return g[0] === y;
            })[0];
            return h && h[1];
          }, 'get'),
          has: o(function (y) {
            return !!p.get(y);
          }, 'has'),
          keys: o(function () {
            return u.map(function (y) {
              var h = n(y, 1),
                g = h[0];
              return g;
            });
          }, 'keys'),
          values: o(function () {
            return u.map(function (y) {
              var h = n(y, 2),
                g = h[1];
              return g;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(p, p.entries());
    },
  }),
  bI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  vI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-activedescendant': null, 'aria-disabled': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  EI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-disabled': null },
        relatedConcepts: [{ concept: { name: 'input' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget']],
      };
      e.default = t;
    },
  }),
  TI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  wI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuemax': null, 'aria-valuemin': null, 'aria-valuenow': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  SI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {
          'aria-atomic': null,
          'aria-busy': null,
          'aria-controls': null,
          'aria-current': null,
          'aria-describedby': null,
          'aria-details': null,
          'aria-dropeffect': null,
          'aria-flowto': null,
          'aria-grabbed': null,
          'aria-hidden': null,
          'aria-keyshortcuts': null,
          'aria-label': null,
          'aria-labelledby': null,
          'aria-live': null,
          'aria-owns': null,
          'aria-relevant': null,
          'aria-roledescription': null,
        },
        relatedConcepts: [
          { concept: { name: 'role' }, module: 'XHTML' },
          { concept: { name: 'type' }, module: 'Dublin Core' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [],
      };
      e.default = t;
    },
  }),
  _I = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'frontmatter' }, module: 'DTB' },
          { concept: { name: 'level' }, module: 'DTB' },
          { concept: { name: 'level' }, module: 'SMIL' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  RI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  PI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'structure', 'section', 'group'],
        ],
      };
      e.default = t;
    },
  }),
  AI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  OI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  CI = J({
    '../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !0,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-modal': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype']],
      };
      e.default = t;
    },
  }),
  xI = J({
    '../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = h(bI()),
        r = h(vI()),
        n = h(EI()),
        i = h(TI()),
        s = h(wI()),
        a = h(SI()),
        c = h(_I()),
        d = h(RI()),
        u = h(PI()),
        p = h(AI()),
        f = h(OI()),
        y = h(CI());
      function h(T) {
        return T && T.__esModule ? T : { default: T };
      }
      o(h, '_interopRequireDefault');
      var g = [
        ['command', t.default],
        ['composite', r.default],
        ['input', n.default],
        ['landmark', i.default],
        ['range', s.default],
        ['roletype', a.default],
        ['section', c.default],
        ['sectionhead', d.default],
        ['select', u.default],
        ['structure', p.default],
        ['widget', f.default],
        ['window', y.default],
      ];
      e.default = g;
    },
  }),
  NI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/alertRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-atomic': 'true', 'aria-live': 'assertive' },
        relatedConcepts: [{ concept: { name: 'alert' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  II = J({
    '../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'alert' }, module: 'XForms' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'alert'],
          ['roletype', 'window', 'dialog'],
        ],
      };
      e.default = t;
    },
  }),
  MI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'Device Independence Delivery Unit' } }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  qI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/articleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [{ concept: { name: 'article' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'document']],
      };
      e.default = t;
    },
  }),
  jI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { constraints: ['scoped to the body element'], name: 'header' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  kI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'blockquote' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  DI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-pressed': null,
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'button' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'image' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'reset' }], name: 'input' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'type', value: 'submit' }], name: 'input' },
            module: 'HTML',
          },
          { concept: { name: 'button' }, module: 'HTML' },
          { concept: { name: 'trigger' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  LI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/captionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'caption' }, module: 'HTML' }],
        requireContextRole: ['figure', 'grid', 'table'],
        requiredContextRole: ['figure', 'grid', 'table'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  FI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/cellRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-colindex': null,
          'aria-colspan': null,
          'aria-rowindex': null,
          'aria-rowspan': null,
        },
        relatedConcepts: [
          {
            concept: { constraints: ['ancestor table element has table role'], name: 'td' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  BI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'checkbox' }], name: 'input' },
            module: 'HTML',
          },
          { concept: { name: 'option' }, module: 'ARIA' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  JI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/codeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'code' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  $I = J({
    '../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-sort': null },
        relatedConcepts: [
          { concept: { name: 'th' }, module: 'HTML' },
          {
            concept: { attributes: [{ name: 'scope', value: 'col' }], name: 'th' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'scope', value: 'colgroup' }], name: 'th' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'structure', 'section', 'cell', 'gridcell'],
          ['roletype', 'widget', 'gridcell'],
          ['roletype', 'structure', 'sectionhead'],
        ],
      };
      e.default = t;
    },
  }),
  UI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-autocomplete': null,
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-expanded': 'false',
          'aria-haspopup': 'listbox',
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'email' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'search' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'tel' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'text' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['set'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'multiple' },
                { constraints: ['undefined'], name: 'size' },
              ],
              constraints: [
                'the multiple attribute is not set and the size attribute does not have a value greater than 1',
              ],
              name: 'select',
            },
            module: 'HTML',
          },
          { concept: { name: 'select' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-controls': null, 'aria-expanded': 'false' },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  VI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              constraints: ['scoped to the body element', 'scoped to the main element'],
              name: 'aside',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-label' }],
              constraints: [
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'aside',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              constraints: [
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'aside',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  HI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { constraints: ['scoped to the body element'], name: 'footer' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  GI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'dd' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  zI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'del' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  WI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'dialog' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'window']],
      };
      e.default = t;
    },
  }),
  KI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ module: 'DAISY Guide' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'list']],
      };
      e.default = t;
    },
  }),
  YI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/documentRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'Device Independence Delivery Unit' } },
          { concept: { name: 'html' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  XI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'em' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  QI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/feedRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['article']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'list']],
      };
      e.default = t;
    },
  }),
  ZI = J({
    '../node_modules/aria-query/lib/etc/roles/literal/figureRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'figure' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  eM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/formRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'aria-label' }], name: 'form' },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              name: 'form',
            },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['set'], name: 'name' }], name: 'form' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  tM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/genericRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [
          { concept: { name: 'a' }, module: 'HTML' },
          { concept: { name: 'area' }, module: 'HTML' },
          { concept: { name: 'aside' }, module: 'HTML' },
          { concept: { name: 'b' }, module: 'HTML' },
          { concept: { name: 'bdo' }, module: 'HTML' },
          { concept: { name: 'body' }, module: 'HTML' },
          { concept: { name: 'data' }, module: 'HTML' },
          { concept: { name: 'div' }, module: 'HTML' },
          {
            concept: {
              constraints: [
                'scoped to the main element',
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'footer',
            },
            module: 'HTML',
          },
          {
            concept: {
              constraints: [
                'scoped to the main element',
                'scoped to a sectioning content element',
                'scoped to a sectioning root element other than body',
              ],
              name: 'header',
            },
            module: 'HTML',
          },
          { concept: { name: 'hgroup' }, module: 'HTML' },
          { concept: { name: 'i' }, module: 'HTML' },
          { concept: { name: 'pre' }, module: 'HTML' },
          { concept: { name: 'q' }, module: 'HTML' },
          { concept: { name: 'samp' }, module: 'HTML' },
          { concept: { name: 'section' }, module: 'HTML' },
          { concept: { name: 'small' }, module: 'HTML' },
          { concept: { name: 'span' }, module: 'HTML' },
          { concept: { name: 'u' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  rM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/gridRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-multiselectable': null, 'aria-readonly': null },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'structure', 'section', 'table'],
        ],
      };
      e.default = t;
    },
  }),
  nM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-selected': null,
        },
        relatedConcepts: [
          {
            concept: {
              constraints: [
                'ancestor table element has grid role',
                'ancestor table element has treegrid role',
              ],
              name: 'td',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row'],
        requiredContextRole: ['row'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  oM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/groupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-activedescendant': null, 'aria-disabled': null },
        relatedConcepts: [
          { concept: { name: 'details' }, module: 'HTML' },
          { concept: { name: 'fieldset' }, module: 'HTML' },
          { concept: { name: 'optgroup' }, module: 'HTML' },
          { concept: { name: 'address' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  iM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/headingRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-level': '2' },
        relatedConcepts: [
          { concept: { name: 'h1' }, module: 'HTML' },
          { concept: { name: 'h2' }, module: 'HTML' },
          { concept: { name: 'h3' }, module: 'HTML' },
          { concept: { name: 'h4' }, module: 'HTML' },
          { concept: { name: 'h5' }, module: 'HTML' },
          { concept: { name: 'h6' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-level': '2' },
        superClass: [['roletype', 'structure', 'sectionhead']],
      };
      e.default = t;
    },
  }),
  sM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/imgRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'alt' }], name: 'img' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['undefined'], name: 'alt' }], name: 'img' },
            module: 'HTML',
          },
          { concept: { name: 'imggroup' }, module: 'DTB' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  aM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'ins' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  lM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/linkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-disabled': null, 'aria-expanded': null, 'aria-haspopup': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ constraints: ['set'], name: 'href' }], name: 'a' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ constraints: ['set'], name: 'href' }], name: 'area' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  cM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/listRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'menu' }, module: 'HTML' },
          { concept: { name: 'ol' }, module: 'HTML' },
          { concept: { name: 'ul' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['listitem']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  uM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-invalid': null,
          'aria-multiselectable': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-orientation': 'vertical',
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [{ constraints: ['>1'], name: 'size' }],
              constraints: ['the size attribute value is greater than 1'],
              name: 'select',
            },
            module: 'HTML',
          },
          { concept: { attributes: [{ name: 'multiple' }], name: 'select' }, module: 'HTML' },
          { concept: { name: 'datalist' }, module: 'HTML' },
          { concept: { name: 'list' }, module: 'ARIA' },
          { concept: { name: 'select' }, module: 'XForms' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['option', 'group'], ['option']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  dM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-level': null, 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [
          {
            concept: {
              constraints: [
                'direct descendant of ol',
                'direct descendant of ul',
                'direct descendant of menu',
              ],
              name: 'li',
            },
            module: 'HTML',
          },
          { concept: { name: 'item' }, module: 'XForms' },
        ],
        requireContextRole: ['directory', 'list'],
        requiredContextRole: ['directory', 'list'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  pM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/logRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-live': 'polite' },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  fM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/mainRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'main' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  mM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/markRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
        },
        relatedConcepts: [{ concept: { name: 'mark' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  yM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  hM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/mathRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'math' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  gM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/menuRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'vertical' },
        relatedConcepts: [
          { concept: { name: 'MENU' }, module: 'JAPI' },
          { concept: { name: 'list' }, module: 'ARIA' },
          { concept: { name: 'select' }, module: 'XForms' },
          { concept: { name: 'sidebar' }, module: 'DTB' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
          ['menuitem', 'group'],
          ['menuitemradio', 'group'],
          ['menuitemcheckbox', 'group'],
          ['menuitem'],
          ['menuitemcheckbox'],
          ['menuitemradio'],
        ],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  bM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'horizontal' },
        relatedConcepts: [{ concept: { name: 'toolbar' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
          ['menuitem', 'group'],
          ['menuitemradio', 'group'],
          ['menuitemcheckbox', 'group'],
          ['menuitem'],
          ['menuitemcheckbox'],
          ['menuitemradio'],
        ],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select', 'menu'],
          ['roletype', 'structure', 'section', 'group', 'select', 'menu'],
        ],
      };
      e.default = t;
    },
  }),
  vM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-posinset': null,
          'aria-setsize': null,
        },
        relatedConcepts: [
          { concept: { name: 'MENU_ITEM' }, module: 'JAPI' },
          { concept: { name: 'listitem' }, module: 'ARIA' },
          { concept: { name: 'option' }, module: 'ARIA' },
        ],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command']],
      };
      e.default = t;
    },
  }),
  EM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'menuitem' }, module: 'ARIA' }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [
          ['roletype', 'widget', 'input', 'checkbox'],
          ['roletype', 'widget', 'command', 'menuitem'],
        ],
      };
      e.default = t;
    },
  }),
  TM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'menuitem' }, module: 'ARIA' }],
        requireContextRole: ['group', 'menu', 'menubar'],
        requiredContextRole: ['group', 'menu', 'menubar'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [
          ['roletype', 'widget', 'input', 'checkbox', 'menuitemcheckbox'],
          ['roletype', 'widget', 'command', 'menuitem', 'menuitemcheckbox'],
          ['roletype', 'widget', 'input', 'radio'],
        ],
      };
      e.default = t;
    },
  }),
  wM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/meterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuetext': null, 'aria-valuemax': '100', 'aria-valuemin': '0' },
        relatedConcepts: [{ concept: { name: 'meter' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-valuenow': null },
        superClass: [['roletype', 'structure', 'range']],
      };
      e.default = t;
    },
  }),
  SM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'nav' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  _M = J({
    '../node_modules/aria-query/lib/etc/roles/literal/noneRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [],
      };
      e.default = t;
    },
  }),
  RM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/noteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  PM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/optionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-checked': null,
          'aria-posinset': null,
          'aria-setsize': null,
          'aria-selected': 'false',
        },
        relatedConcepts: [
          { concept: { name: 'item' }, module: 'XForms' },
          { concept: { name: 'listitem' }, module: 'ARIA' },
          { concept: { name: 'option' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-selected': 'false' },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  AM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'p' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  OM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [
          { concept: { attributes: [{ name: 'alt', value: '' }], name: 'img' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  CM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-valuetext': null },
        relatedConcepts: [
          { concept: { name: 'progress' }, module: 'HTML' },
          { concept: { name: 'status' }, module: 'ARIA' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'range'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  xM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/radioRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-checked': null, 'aria-posinset': null, 'aria-setsize': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'radio' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  NM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [{ concept: { name: 'list' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['radio']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  IM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/regionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-label' }],
              name: 'section',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
              name: 'section',
            },
            module: 'HTML',
          },
          { concept: { name: 'Device Independence Glossart perceivable unit' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  MM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/rowRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-colindex': null,
          'aria-expanded': null,
          'aria-level': null,
          'aria-posinset': null,
          'aria-rowindex': null,
          'aria-selected': null,
          'aria-setsize': null,
        },
        relatedConcepts: [{ concept: { name: 'tr' }, module: 'HTML' }],
        requireContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
        requiredContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
        requiredOwnedElements: [['cell'], ['columnheader'], ['gridcell'], ['rowheader']],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'group'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  qM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'tbody' }, module: 'HTML' },
          { concept: { name: 'tfoot' }, module: 'HTML' },
          { concept: { name: 'thead' }, module: 'HTML' },
        ],
        requireContextRole: ['grid', 'table', 'treegrid'],
        requiredContextRole: ['grid', 'table', 'treegrid'],
        requiredOwnedElements: [['row']],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  jM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-sort': null },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'scope', value: 'row' }], name: 'th' },
            module: 'HTML',
          },
          {
            concept: { attributes: [{ name: 'scope', value: 'rowgroup' }], name: 'th' },
            module: 'HTML',
          },
        ],
        requireContextRole: ['row', 'rowgroup'],
        requiredContextRole: ['row', 'rowgroup'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'section', 'cell'],
          ['roletype', 'structure', 'section', 'cell', 'gridcell'],
          ['roletype', 'widget', 'gridcell'],
          ['roletype', 'structure', 'sectionhead'],
        ],
      };
      e.default = t;
    },
  }),
  kM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-valuetext': null,
          'aria-orientation': 'vertical',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-controls': null, 'aria-valuenow': null },
        superClass: [
          ['roletype', 'structure', 'range'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  DM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/searchRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  LM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'search' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'input', 'textbox']],
      };
      e.default = t;
    },
  }),
  FM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-orientation': 'horizontal',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
          'aria-valuenow': null,
          'aria-valuetext': null,
        },
        relatedConcepts: [{ concept: { name: 'hr' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure']],
      };
      e.default = t;
    },
  }),
  BM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-valuetext': null,
          'aria-orientation': 'horizontal',
          'aria-valuemax': '100',
          'aria-valuemin': '0',
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'range' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-valuenow': null },
        superClass: [
          ['roletype', 'widget', 'input'],
          ['roletype', 'structure', 'range'],
        ],
      };
      e.default = t;
    },
  }),
  JM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-readonly': null,
          'aria-required': null,
          'aria-valuetext': null,
          'aria-valuenow': '0',
        },
        relatedConcepts: [
          {
            concept: { attributes: [{ name: 'type', value: 'number' }], name: 'input' },
            module: 'HTML',
          },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite'],
          ['roletype', 'widget', 'input'],
          ['roletype', 'structure', 'range'],
        ],
      };
      e.default = t;
    },
  }),
  $M = J({
    '../node_modules/aria-query/lib/etc/roles/literal/statusRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-atomic': 'true', 'aria-live': 'polite' },
        relatedConcepts: [{ concept: { name: 'output' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  UM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/strongRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'strong' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  VM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'sub' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  HM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: ['aria-label', 'aria-labelledby'],
        props: {},
        relatedConcepts: [{ concept: { name: 'sup' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  GM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/switchRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'button' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: { 'aria-checked': null },
        superClass: [['roletype', 'widget', 'input', 'checkbox']],
      };
      e.default = t;
    },
  }),
  zM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/tabRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-posinset': null,
          'aria-setsize': null,
          'aria-selected': 'false',
        },
        relatedConcepts: [],
        requireContextRole: ['tablist'],
        requiredContextRole: ['tablist'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
          ['roletype', 'structure', 'sectionhead'],
          ['roletype', 'widget'],
        ],
      };
      e.default = t;
    },
  }),
  WM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/tableRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-colcount': null, 'aria-rowcount': null },
        relatedConcepts: [{ concept: { name: 'table' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  KM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-level': null,
          'aria-multiselectable': null,
          'aria-orientation': 'horizontal',
        },
        relatedConcepts: [{ module: 'DAISY', concept: { name: 'guide' } }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['tab']],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'composite']],
      };
      e.default = t;
    },
  }),
  YM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  XM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/termRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
          { concept: { name: 'dfn' }, module: 'HTML' },
          { concept: { name: 'dt' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  QM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-activedescendant': null,
          'aria-autocomplete': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
          'aria-multiline': null,
          'aria-placeholder': null,
          'aria-readonly': null,
          'aria-required': null,
        },
        relatedConcepts: [
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'type' },
                { constraints: ['undefined'], name: 'list' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'email' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'tel' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'text' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          {
            concept: {
              attributes: [
                { constraints: ['undefined'], name: 'list' },
                { name: 'type', value: 'url' },
              ],
              constraints: ['the list attribute is not set'],
              name: 'input',
            },
            module: 'HTML',
          },
          { concept: { name: 'input' }, module: 'XForms' },
          { concept: { name: 'textarea' }, module: 'HTML' },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'input']],
      };
      e.default = t;
    },
  }),
  ZM = J({
    '../node_modules/aria-query/lib/etc/roles/literal/timeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'time' }, module: 'HTML' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  eq = J({
    '../node_modules/aria-query/lib/etc/roles/literal/timerRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'status']],
      };
      e.default = t;
    },
  }),
  tq = J({
    '../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: { 'aria-orientation': 'horizontal' },
        relatedConcepts: [{ concept: { name: 'menubar' }, module: 'ARIA' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group']],
      };
      e.default = t;
    },
  }),
  rq = J({
    '../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  nq = J({
    '../node_modules/aria-query/lib/etc/roles/literal/treeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-invalid': null,
          'aria-multiselectable': null,
          'aria-required': null,
          'aria-orientation': 'vertical',
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['treeitem', 'group'], ['treeitem']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'select'],
          ['roletype', 'structure', 'section', 'group', 'select'],
        ],
      };
      e.default = t;
    },
  }),
  oq = J({
    '../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['row'], ['row', 'rowgroup']],
        requiredProps: {},
        superClass: [
          ['roletype', 'widget', 'composite', 'grid'],
          ['roletype', 'structure', 'section', 'table', 'grid'],
          ['roletype', 'widget', 'composite', 'select', 'tree'],
          ['roletype', 'structure', 'section', 'group', 'select', 'tree'],
        ],
      };
      e.default = t;
    },
  }),
  iq = J({
    '../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-expanded': null, 'aria-haspopup': null },
        relatedConcepts: [],
        requireContextRole: ['group', 'tree'],
        requiredContextRole: ['group', 'tree'],
        requiredOwnedElements: [],
        requiredProps: { 'aria-selected': null },
        superClass: [
          ['roletype', 'structure', 'section', 'listitem'],
          ['roletype', 'widget', 'input', 'option'],
        ],
      };
      e.default = t;
    },
  }),
  sq = J({
    '../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = Y(NI()),
        r = Y(II()),
        n = Y(MI()),
        i = Y(qI()),
        s = Y(jI()),
        a = Y(kI()),
        c = Y(DI()),
        d = Y(LI()),
        u = Y(FI()),
        p = Y(BI()),
        f = Y(JI()),
        y = Y($I()),
        h = Y(UI()),
        g = Y(VI()),
        T = Y(HI()),
        E = Y(GI()),
        v = Y(zI()),
        S = Y(WI()),
        A = Y(KI()),
        N = Y(YI()),
        j = Y(XI()),
        C = Y(QI()),
        R = Y(ZI()),
        w = Y(eM()),
        _ = Y(tM()),
        k = Y(rM()),
        I = Y(nM()),
        V = Y(oM()),
        H = Y(iM()),
        P = Y(sM()),
        L = Y(aM()),
        B = Y(lM()),
        D = Y(cM()),
        K = Y(uM()),
        X = Y(dM()),
        ie = Y(pM()),
        se = Y(fM()),
        W = Y(mM()),
        ae = Y(yM()),
        be = Y(hM()),
        ue = Y(gM()),
        ee = Y(bM()),
        Ae = Y(vM()),
        Oe = Y(EM()),
        He = Y(TM()),
        Ke = Y(wM()),
        $ = Y(SM()),
        Q = Y(_M()),
        re = Y(RM()),
        oe = Y(PM()),
        ne = Y(AM()),
        de = Y(OM()),
        ye = Y(CM()),
        pe = Y(xM()),
        Je = Y(NM()),
        ot = Y(IM()),
        dt = Y(MM()),
        Tt = Y(qM()),
        it = Y(jM()),
        pt = Y(kM()),
        ft = Y(DM()),
        mt = Y(LM()),
        Qr = Y(FM()),
        Io = Y(BM()),
        Zr = Y(JM()),
        Mo = Y($M()),
        qo = Y(UM()),
        jo = Y(VM()),
        en = Y(HM()),
        ko = Y(GM()),
        Do = Y(zM()),
        Lo = Y(WM()),
        Fo = Y(KM()),
        Bo = Y(YM()),
        Jo = Y(XM()),
        $o = Y(QM()),
        Uo = Y(ZM()),
        Vo = Y(eq()),
        Ho = Y(tq()),
        Go = Y(rq()),
        zo = Y(nq()),
        lr = Y(oq()),
        tn = Y(iq());
      function Y(Nt) {
        return Nt && Nt.__esModule ? Nt : { default: Nt };
      }
      o(Y, '_interopRequireDefault');
      var le = [
        ['alert', t.default],
        ['alertdialog', r.default],
        ['application', n.default],
        ['article', i.default],
        ['banner', s.default],
        ['blockquote', a.default],
        ['button', c.default],
        ['caption', d.default],
        ['cell', u.default],
        ['checkbox', p.default],
        ['code', f.default],
        ['columnheader', y.default],
        ['combobox', h.default],
        ['complementary', g.default],
        ['contentinfo', T.default],
        ['definition', E.default],
        ['deletion', v.default],
        ['dialog', S.default],
        ['directory', A.default],
        ['document', N.default],
        ['emphasis', j.default],
        ['feed', C.default],
        ['figure', R.default],
        ['form', w.default],
        ['generic', _.default],
        ['grid', k.default],
        ['gridcell', I.default],
        ['group', V.default],
        ['heading', H.default],
        ['img', P.default],
        ['insertion', L.default],
        ['link', B.default],
        ['list', D.default],
        ['listbox', K.default],
        ['listitem', X.default],
        ['log', ie.default],
        ['main', se.default],
        ['mark', W.default],
        ['marquee', ae.default],
        ['math', be.default],
        ['menu', ue.default],
        ['menubar', ee.default],
        ['menuitem', Ae.default],
        ['menuitemcheckbox', Oe.default],
        ['menuitemradio', He.default],
        ['meter', Ke.default],
        ['navigation', $.default],
        ['none', Q.default],
        ['note', re.default],
        ['option', oe.default],
        ['paragraph', ne.default],
        ['presentation', de.default],
        ['progressbar', ye.default],
        ['radio', pe.default],
        ['radiogroup', Je.default],
        ['region', ot.default],
        ['row', dt.default],
        ['rowgroup', Tt.default],
        ['rowheader', it.default],
        ['scrollbar', pt.default],
        ['search', ft.default],
        ['searchbox', mt.default],
        ['separator', Qr.default],
        ['slider', Io.default],
        ['spinbutton', Zr.default],
        ['status', Mo.default],
        ['strong', qo.default],
        ['subscript', jo.default],
        ['superscript', en.default],
        ['switch', ko.default],
        ['tab', Do.default],
        ['table', Lo.default],
        ['tablist', Fo.default],
        ['tabpanel', Bo.default],
        ['term', Jo.default],
        ['textbox', $o.default],
        ['time', Uo.default],
        ['timer', Vo.default],
        ['toolbar', Ho.default],
        ['tooltip', Go.default],
        ['tree', zo.default],
        ['treegrid', lr.default],
        ['treeitem', tn.default],
      ];
      e.default = le;
    },
  }),
  aq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'abstract [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  lq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'acknowledgments [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  cq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'afterword [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  uq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'appendix [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  dq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'referrer [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  pq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'EPUB biblioentry [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: ['doc-bibliography'],
        requiredContextRole: ['doc-bibliography'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'listitem']],
      };
      e.default = t;
    },
  }),
  fq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'bibliography [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['doc-biblioentry']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  mq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'biblioref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  yq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'chapter [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  hq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'colophon [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  gq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'conclusion [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  bq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'cover [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'img']],
      };
      e.default = t;
    },
  }),
  vq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'credit [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Eq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'credits [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Tq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'dedication [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  wq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'rearnote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: ['doc-endnotes'],
        requiredContextRole: ['doc-endnotes'],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'listitem']],
      };
      e.default = t;
    },
  }),
  Sq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'rearnotes [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['doc-endnote']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  _q = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'epigraph [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Rq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'epilogue [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Pq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'errata [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Aq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Oq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'footnote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Cq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'foreword [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  xq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'glossary [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [['definition'], ['term']],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Nq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'glossref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  Iq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'index [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  Mq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'introduction [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  qq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: { 'aria-errormessage': null, 'aria-invalid': null },
        relatedConcepts: [{ concept: { name: 'noteref [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'widget', 'command', 'link']],
      };
      e.default = t;
    },
  }),
  jq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'notice [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'note']],
      };
      e.default = t;
    },
  }),
  kq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'pagebreak [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'separator']],
      };
      e.default = t;
    },
  }),
  Dq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Lq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['prohibited'],
        prohibitedProps: [],
        props: {
          'aria-braillelabel': null,
          'aria-brailleroledescription': null,
          'aria-description': null,
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Fq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'page-list [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  Bq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'part [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Jq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'preface [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  $q = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'prologue [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark']],
      };
      e.default = t;
    },
  }),
  Uq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{ concept: { name: 'pullquote [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['none']],
      };
      e.default = t;
    },
  }),
  Vq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'qna [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section']],
      };
      e.default = t;
    },
  }),
  Hq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'subtitle [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'sectionhead']],
      };
      e.default = t;
    },
  }),
  Gq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'help [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'note']],
      };
      e.default = t;
    },
  }),
  zq = J({
    '../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [{ concept: { name: 'toc [EPUB-SSV]' }, module: 'EPUB' }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']],
      };
      e.default = t;
    },
  }),
  Wq = J({
    '../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = ee(aq()),
        r = ee(lq()),
        n = ee(cq()),
        i = ee(uq()),
        s = ee(dq()),
        a = ee(pq()),
        c = ee(fq()),
        d = ee(mq()),
        u = ee(yq()),
        p = ee(hq()),
        f = ee(gq()),
        y = ee(bq()),
        h = ee(vq()),
        g = ee(Eq()),
        T = ee(Tq()),
        E = ee(wq()),
        v = ee(Sq()),
        S = ee(_q()),
        A = ee(Rq()),
        N = ee(Pq()),
        j = ee(Aq()),
        C = ee(Oq()),
        R = ee(Cq()),
        w = ee(xq()),
        _ = ee(Nq()),
        k = ee(Iq()),
        I = ee(Mq()),
        V = ee(qq()),
        H = ee(jq()),
        P = ee(kq()),
        L = ee(Dq()),
        B = ee(Lq()),
        D = ee(Fq()),
        K = ee(Bq()),
        X = ee(Jq()),
        ie = ee($q()),
        se = ee(Uq()),
        W = ee(Vq()),
        ae = ee(Hq()),
        be = ee(Gq()),
        ue = ee(zq());
      function ee(Oe) {
        return Oe && Oe.__esModule ? Oe : { default: Oe };
      }
      o(ee, '_interopRequireDefault');
      var Ae = [
        ['doc-abstract', t.default],
        ['doc-acknowledgments', r.default],
        ['doc-afterword', n.default],
        ['doc-appendix', i.default],
        ['doc-backlink', s.default],
        ['doc-biblioentry', a.default],
        ['doc-bibliography', c.default],
        ['doc-biblioref', d.default],
        ['doc-chapter', u.default],
        ['doc-colophon', p.default],
        ['doc-conclusion', f.default],
        ['doc-cover', y.default],
        ['doc-credit', h.default],
        ['doc-credits', g.default],
        ['doc-dedication', T.default],
        ['doc-endnote', E.default],
        ['doc-endnotes', v.default],
        ['doc-epigraph', S.default],
        ['doc-epilogue', A.default],
        ['doc-errata', N.default],
        ['doc-example', j.default],
        ['doc-footnote', C.default],
        ['doc-foreword', R.default],
        ['doc-glossary', w.default],
        ['doc-glossref', _.default],
        ['doc-index', k.default],
        ['doc-introduction', I.default],
        ['doc-noteref', V.default],
        ['doc-notice', H.default],
        ['doc-pagebreak', P.default],
        ['doc-pagefooter', L.default],
        ['doc-pageheader', B.default],
        ['doc-pagelist', D.default],
        ['doc-part', K.default],
        ['doc-preface', X.default],
        ['doc-prologue', ie.default],
        ['doc-pullquote', se.default],
        ['doc-qna', W.default],
        ['doc-subtitle', ae.default],
        ['doc-tip', be.default],
        ['doc-toc', ue.default],
      ];
      e.default = Ae;
    },
  }),
  Kq = J({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [
          { module: 'GRAPHICS', concept: { name: 'graphics-object' } },
          { module: 'ARIA', concept: { name: 'img' } },
          { module: 'ARIA', concept: { name: 'article' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'document']],
      };
      e.default = t;
    },
  }),
  Yq = J({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !1,
        baseConcepts: [],
        childrenPresentational: !1,
        nameFrom: ['author', 'contents'],
        prohibitedProps: [],
        props: {
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [
          { module: 'GRAPHICS', concept: { name: 'graphics-document' } },
          { module: 'ARIA', concept: { name: 'group' } },
          { module: 'ARIA', concept: { name: 'img' } },
          { module: 'GRAPHICS', concept: { name: 'graphics-symbol' } },
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'group']],
      };
      e.default = t;
    },
  }),
  Xq = J({
    '../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = {
        abstract: !1,
        accessibleNameRequired: !0,
        baseConcepts: [],
        childrenPresentational: !0,
        nameFrom: ['author'],
        prohibitedProps: [],
        props: {
          'aria-disabled': null,
          'aria-errormessage': null,
          'aria-expanded': null,
          'aria-haspopup': null,
          'aria-invalid': null,
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [['roletype', 'structure', 'section', 'img']],
      };
      e.default = t;
    },
  }),
  Qq = J({
    '../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = i(Kq()),
        r = i(Yq()),
        n = i(Xq());
      function i(a) {
        return a && a.__esModule ? a : { default: a };
      }
      o(i, '_interopRequireDefault');
      var s = [
        ['graphics-document', t.default],
        ['graphics-object', r.default],
        ['graphics-symbol', n.default],
      ];
      e.default = s;
    },
  }),
  Jd = J({
    '../node_modules/aria-query/lib/rolesMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = a(xI()),
        r = a(sq()),
        n = a(Wq()),
        i = a(Qq()),
        s = a(Xi());
      function a(E) {
        return E && E.__esModule ? E : { default: E };
      }
      o(a, '_interopRequireDefault');
      function c(E, v) {
        var S = (typeof Symbol < 'u' && E[Symbol.iterator]) || E['@@iterator'];
        if (!S) {
          if (Array.isArray(E) || (S = p(E)) || (v && E && typeof E.length == 'number')) {
            S && (E = S);
            var A = 0,
              N = o(function () {}, 'F');
            return {
              s: N,
              n: o(function () {
                return A >= E.length ? { done: !0 } : { done: !1, value: E[A++] };
              }, 'n'),
              e: o(function (_) {
                throw _;
              }, 'e'),
              f: N,
            };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var j,
          C = !0,
          R = !1;
        return {
          s: o(function () {
            S = S.call(E);
          }, 's'),
          n: o(function () {
            var _ = S.next();
            return ((C = _.done), _);
          }, 'n'),
          e: o(function (_) {
            ((R = !0), (j = _));
          }, 'e'),
          f: o(function () {
            try {
              C || S.return == null || S.return();
            } finally {
              if (R) throw j;
            }
          }, 'f'),
        };
      }
      o(c, '_createForOfIteratorHelper');
      function d(E, v) {
        return h(E) || y(E, v) || p(E, v) || u();
      }
      o(d, '_slicedToArray');
      function u() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      o(u, '_nonIterableRest');
      function p(E, v) {
        if (E) {
          if (typeof E == 'string') return f(E, v);
          var S = {}.toString.call(E).slice(8, -1);
          return (
            S === 'Object' && E.constructor && (S = E.constructor.name),
            S === 'Map' || S === 'Set'
              ? Array.from(E)
              : S === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(S)
                ? f(E, v)
                : void 0
          );
        }
      }
      o(p, '_unsupportedIterableToArray');
      function f(E, v) {
        (v == null || v > E.length) && (v = E.length);
        for (var S = 0, A = Array(v); S < v; S++) A[S] = E[S];
        return A;
      }
      o(f, '_arrayLikeToArray');
      function y(E, v) {
        var S = E == null ? null : (typeof Symbol < 'u' && E[Symbol.iterator]) || E['@@iterator'];
        if (S != null) {
          var A,
            N,
            j,
            C,
            R = [],
            w = !0,
            _ = !1;
          try {
            if (((j = (S = S.call(E)).next), v === 0)) {
              if (Object(S) !== S) return;
              w = !1;
            } else for (; !(w = (A = j.call(S)).done) && (R.push(A.value), R.length !== v); w = !0);
          } catch (k) {
            ((_ = !0), (N = k));
          } finally {
            try {
              if (!w && S.return != null && ((C = S.return()), Object(C) !== C)) return;
            } finally {
              if (_) throw N;
            }
          }
          return R;
        }
      }
      o(y, '_iterableToArrayLimit');
      function h(E) {
        if (Array.isArray(E)) return E;
      }
      o(h, '_arrayWithHoles');
      var g = [].concat(t.default, r.default, n.default, i.default);
      g.forEach(function (E) {
        var v = d(E, 2),
          S = v[1],
          A = c(S.superClass),
          N;
        try {
          for (A.s(); !(N = A.n()).done; ) {
            var j = N.value,
              C = c(j),
              R;
            try {
              var w = o(function () {
                var k = R.value,
                  I = g.filter(function (B) {
                    var D = d(B, 1),
                      K = D[0];
                    return K === k;
                  })[0];
                if (I)
                  for (var V = I[1], H = 0, P = Object.keys(V.props); H < P.length; H++) {
                    var L = P[H];
                    Object.prototype.hasOwnProperty.call(S.props, L) || (S.props[L] = V.props[L]);
                  }
              }, '_loop');
              for (C.s(); !(R = C.n()).done; ) w();
            } catch (_) {
              C.e(_);
            } finally {
              C.f();
            }
          }
        } catch (_) {
          A.e(_);
        } finally {
          A.f();
        }
      });
      var T = {
        entries: o(function () {
          return g;
        }, 'entries'),
        forEach: o(function (v) {
          var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
            A = c(g),
            N;
          try {
            for (A.s(); !(N = A.n()).done; ) {
              var j = d(N.value, 2),
                C = j[0],
                R = j[1];
              v.call(S, R, C, g);
            }
          } catch (w) {
            A.e(w);
          } finally {
            A.f();
          }
        }, 'forEach'),
        get: o(function (v) {
          var S = g.filter(function (A) {
            return A[0] === v;
          })[0];
          return S && S[1];
        }, 'get'),
        has: o(function (v) {
          return !!T.get(v);
        }, 'has'),
        keys: o(function () {
          return g.map(function (v) {
            var S = d(v, 1),
              A = S[0];
            return A;
          });
        }, 'keys'),
        values: o(function () {
          return g.map(function (v) {
            var S = d(v, 2),
              A = S[1];
            return A;
          });
        }, 'values'),
      };
      e.default = (0, s.default)(T, T.entries());
    },
  }),
  Zq = J({
    '../node_modules/aria-query/lib/elementRoleMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = n(Xi()),
        r = n(Jd());
      function n(C) {
        return C && C.__esModule ? C : { default: C };
      }
      o(n, '_interopRequireDefault');
      function i(C, R) {
        return u(C) || d(C, R) || a(C, R) || s();
      }
      o(i, '_slicedToArray');
      function s() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      o(s, '_nonIterableRest');
      function a(C, R) {
        if (C) {
          if (typeof C == 'string') return c(C, R);
          var w = {}.toString.call(C).slice(8, -1);
          return (
            w === 'Object' && C.constructor && (w = C.constructor.name),
            w === 'Map' || w === 'Set'
              ? Array.from(C)
              : w === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w)
                ? c(C, R)
                : void 0
          );
        }
      }
      o(a, '_unsupportedIterableToArray');
      function c(C, R) {
        (R == null || R > C.length) && (R = C.length);
        for (var w = 0, _ = Array(R); w < R; w++) _[w] = C[w];
        return _;
      }
      o(c, '_arrayLikeToArray');
      function d(C, R) {
        var w = C == null ? null : (typeof Symbol < 'u' && C[Symbol.iterator]) || C['@@iterator'];
        if (w != null) {
          var _,
            k,
            I,
            V,
            H = [],
            P = !0,
            L = !1;
          try {
            if (((I = (w = w.call(C)).next), R === 0)) {
              if (Object(w) !== w) return;
              P = !1;
            } else for (; !(P = (_ = I.call(w)).done) && (H.push(_.value), H.length !== R); P = !0);
          } catch (B) {
            ((L = !0), (k = B));
          } finally {
            try {
              if (!P && w.return != null && ((V = w.return()), Object(V) !== V)) return;
            } finally {
              if (L) throw k;
            }
          }
          return H;
        }
      }
      o(d, '_iterableToArrayLimit');
      function u(C) {
        if (Array.isArray(C)) return C;
      }
      o(u, '_arrayWithHoles');
      var p = [],
        f = r.default.keys();
      for (v = 0; v < f.length; v++)
        if (((y = f[v]), (h = r.default.get(y)), h))
          for (
            g = [].concat(h.baseConcepts, h.relatedConcepts),
              T = o(function () {
                var R = g[E];
                if (R.module === 'HTML') {
                  var w = R.concept;
                  if (w) {
                    var _ = p.filter(function (H) {
                        return A(H[0], w);
                      })[0],
                      k;
                    _ ? (k = _[1]) : (k = []);
                    for (var I = !0, V = 0; V < k.length; V++)
                      if (k[V] === y) {
                        I = !1;
                        break;
                      }
                    (I && k.push(y), _ || p.push([w, k]));
                  }
                }
              }, '_loop'),
              E = 0;
            E < g.length;
            E++
          )
            T();
      var y,
        h,
        g,
        T,
        E,
        v,
        S = {
          entries: o(function () {
            return p;
          }, 'entries'),
          forEach: o(function (R) {
            for (
              var w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                _ = 0,
                k = p;
              _ < k.length;
              _++
            ) {
              var I = i(k[_], 2),
                V = I[0],
                H = I[1];
              R.call(w, H, V, p);
            }
          }, 'forEach'),
          get: o(function (R) {
            var w = p.filter(function (_) {
              return R.name === _[0].name && j(R.attributes, _[0].attributes);
            })[0];
            return w && w[1];
          }, 'get'),
          has: o(function (R) {
            return !!S.get(R);
          }, 'has'),
          keys: o(function () {
            return p.map(function (R) {
              var w = i(R, 1),
                _ = w[0];
              return _;
            });
          }, 'keys'),
          values: o(function () {
            return p.map(function (R) {
              var w = i(R, 2),
                _ = w[1];
              return _;
            });
          }, 'values'),
        };
      function A(C, R) {
        return (
          C.name === R.name && N(C.constraints, R.constraints) && j(C.attributes, R.attributes)
        );
      }
      o(A, 'ariaRoleRelationConceptEquals');
      function N(C, R) {
        if ((C === void 0 && R !== void 0) || (C !== void 0 && R === void 0)) return !1;
        if (C !== void 0 && R !== void 0) {
          if (C.length !== R.length) return !1;
          for (var w = 0; w < C.length; w++) if (C[w] !== R[w]) return !1;
        }
        return !0;
      }
      o(N, 'ariaRoleRelationConstraintsEquals');
      function j(C, R) {
        if ((C === void 0 && R !== void 0) || (C !== void 0 && R === void 0)) return !1;
        if (C !== void 0 && R !== void 0) {
          if (C.length !== R.length) return !1;
          for (var w = 0; w < C.length; w++) {
            if (
              C[w].name !== R[w].name ||
              C[w].value !== R[w].value ||
              (C[w].constraints === void 0 && R[w].constraints !== void 0) ||
              (C[w].constraints !== void 0 && R[w].constraints === void 0)
            )
              return !1;
            if (C[w].constraints !== void 0 && R[w].constraints !== void 0) {
              if (C[w].constraints.length !== R[w].constraints.length) return !1;
              for (var _ = 0; _ < C[w].constraints.length; _++)
                if (C[w].constraints[_] !== R[w].constraints[_]) return !1;
            }
          }
        }
        return !0;
      }
      (o(j, 'ariaRoleRelationConceptAttributeEquals'),
        (e.default = (0, t.default)(S, S.entries())));
    },
  }),
  ej = J({
    '../node_modules/aria-query/lib/roleElementMap.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
      var t = n(Xi()),
        r = n(Jd());
      function n(j) {
        return j && j.__esModule ? j : { default: j };
      }
      o(n, '_interopRequireDefault');
      function i(j, C) {
        return u(j) || d(j, C) || a(j, C) || s();
      }
      o(i, '_slicedToArray');
      function s() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      o(s, '_nonIterableRest');
      function a(j, C) {
        if (j) {
          if (typeof j == 'string') return c(j, C);
          var R = {}.toString.call(j).slice(8, -1);
          return (
            R === 'Object' && j.constructor && (R = j.constructor.name),
            R === 'Map' || R === 'Set'
              ? Array.from(j)
              : R === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(R)
                ? c(j, C)
                : void 0
          );
        }
      }
      o(a, '_unsupportedIterableToArray');
      function c(j, C) {
        (C == null || C > j.length) && (C = j.length);
        for (var R = 0, w = Array(C); R < C; R++) w[R] = j[R];
        return w;
      }
      o(c, '_arrayLikeToArray');
      function d(j, C) {
        var R = j == null ? null : (typeof Symbol < 'u' && j[Symbol.iterator]) || j['@@iterator'];
        if (R != null) {
          var w,
            _,
            k,
            I,
            V = [],
            H = !0,
            P = !1;
          try {
            if (((k = (R = R.call(j)).next), C === 0)) {
              if (Object(R) !== R) return;
              H = !1;
            } else for (; !(H = (w = k.call(R)).done) && (V.push(w.value), V.length !== C); H = !0);
          } catch (L) {
            ((P = !0), (_ = L));
          } finally {
            try {
              if (!H && R.return != null && ((I = R.return()), Object(I) !== I)) return;
            } finally {
              if (P) throw _;
            }
          }
          return V;
        }
      }
      o(d, '_iterableToArrayLimit');
      function u(j) {
        if (Array.isArray(j)) return j;
      }
      o(u, '_arrayWithHoles');
      var p = [],
        f = r.default.keys();
      for (A = 0; A < f.length; A++)
        if (((y = f[A]), (h = r.default.get(y)), (g = []), h)) {
          for (T = [].concat(h.baseConcepts, h.relatedConcepts), S = 0; S < T.length; S++)
            ((E = T[S]), E.module === 'HTML' && ((v = E.concept), v != null && g.push(v)));
          g.length > 0 && p.push([y, g]);
        }
      var y,
        h,
        g,
        T,
        E,
        v,
        S,
        A,
        N = {
          entries: o(function () {
            return p;
          }, 'entries'),
          forEach: o(function (C) {
            for (
              var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                w = 0,
                _ = p;
              w < _.length;
              w++
            ) {
              var k = i(_[w], 2),
                I = k[0],
                V = k[1];
              C.call(R, V, I, p);
            }
          }, 'forEach'),
          get: o(function (C) {
            var R = p.filter(function (w) {
              return w[0] === C;
            })[0];
            return R && R[1];
          }, 'get'),
          has: o(function (C) {
            return !!N.get(C);
          }, 'has'),
          keys: o(function () {
            return p.map(function (C) {
              var R = i(C, 1),
                w = R[0];
              return w;
            });
          }, 'keys'),
          values: o(function () {
            return p.map(function (C) {
              var R = i(C, 2),
                w = R[1];
              return w;
            });
          }, 'values'),
        };
      e.default = (0, t.default)(N, N.entries());
    },
  }),
  $d = J({
    '../node_modules/aria-query/lib/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.roles = e.roleElements = e.elementRoles = e.dom = e.aria = void 0));
      var t = a(hI()),
        r = a(gI()),
        n = a(Jd()),
        i = a(Zq()),
        s = a(ej());
      function a(c) {
        return c && c.__esModule ? c : { default: c };
      }
      (o(a, '_interopRequireDefault'),
        (e.aria = t.default),
        (e.dom = r.default),
        (e.roles = n.default),
        (e.elementRoles = i.default),
        (e.roleElements = s.default));
    },
  }),
  sb = J({
    '../node_modules/picocolors/picocolors.browser.js'(e, t) {
      var r = String,
        n = o(function () {
          return {
            isColorSupported: !1,
            reset: r,
            bold: r,
            dim: r,
            italic: r,
            underline: r,
            inverse: r,
            hidden: r,
            strikethrough: r,
            black: r,
            red: r,
            green: r,
            yellow: r,
            blue: r,
            magenta: r,
            cyan: r,
            white: r,
            gray: r,
            bgBlack: r,
            bgRed: r,
            bgGreen: r,
            bgYellow: r,
            bgBlue: r,
            bgMagenta: r,
            bgCyan: r,
            bgWhite: r,
            blackBright: r,
            redBright: r,
            greenBright: r,
            yellowBright: r,
            blueBright: r,
            magentaBright: r,
            cyanBright: r,
            whiteBright: r,
            bgBlackBright: r,
            bgRedBright: r,
            bgGreenBright: r,
            bgYellowBright: r,
            bgBlueBright: r,
            bgMagentaBright: r,
            bgCyanBright: r,
            bgWhiteBright: r,
          };
        }, 'create');
      ((t.exports = n()), (t.exports.createColors = n));
    },
  }),
  ab = J({
    '../node_modules/css.escape/css.escape.js'(e, t) {
      (function (r, n) {
        typeof e == 'object'
          ? (t.exports = n(r))
          : typeof define == 'function' && define.amd
            ? define([], n.bind(r, r))
            : n(r);
      })(typeof global < 'u' ? global : e, function (r) {
        if (r.CSS && r.CSS.escape) return r.CSS.escape;
        var n = o(function (i) {
          if (arguments.length == 0) throw new TypeError('`CSS.escape` requires an argument.');
          for (var s = String(i), a = s.length, c = -1, d, u = '', p = s.charCodeAt(0); ++c < a; ) {
            if (((d = s.charCodeAt(c)), d == 0)) {
              u += '';
              continue;
            }
            if (
              (d >= 1 && d <= 31) ||
              d == 127 ||
              (c == 0 && d >= 48 && d <= 57) ||
              (c == 1 && d >= 48 && d <= 57 && p == 45)
            ) {
              u += '\\' + d.toString(16) + ' ';
              continue;
            }
            if (c == 0 && a == 1 && d == 45) {
              u += '\\' + s.charAt(c);
              continue;
            }
            if (
              d >= 128 ||
              d == 45 ||
              d == 95 ||
              (d >= 48 && d <= 57) ||
              (d >= 65 && d <= 90) ||
              (d >= 97 && d <= 122)
            ) {
              u += s.charAt(c);
              continue;
            }
            u += '\\' + s.charAt(c);
          }
          return u;
        }, 'cssEscape');
        return (r.CSS || (r.CSS = {}), (r.CSS.escape = n), n);
      });
    },
  }),
  lb = J({
    '../node_modules/pretty-format/node_modules/ansi-styles/index.js'(e, t) {
      var r = 10,
        n = o(
          (a = 0) =>
            (c) =>
              `\x1B[${38 + a};5;${c}m`,
          'wrapAnsi256',
        ),
        i = o(
          (a = 0) =>
            (c, d, u) =>
              `\x1B[${38 + a};2;${c};${d};${u}m`,
          'wrapAnsi16m',
        );
      function s() {
        const a = new Map(),
          c = {
            modifier: {
              reset: [0, 0],
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              overline: [53, 55],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29],
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              blackBright: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39],
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49],
            },
          };
        ((c.color.gray = c.color.blackBright),
          (c.bgColor.bgGray = c.bgColor.bgBlackBright),
          (c.color.grey = c.color.blackBright),
          (c.bgColor.bgGrey = c.bgColor.bgBlackBright));
        for (const [d, u] of Object.entries(c)) {
          for (const [p, f] of Object.entries(u))
            ((c[p] = { open: `\x1B[${f[0]}m`, close: `\x1B[${f[1]}m` }),
              (u[p] = c[p]),
              a.set(f[0], f[1]));
          Object.defineProperty(c, d, { value: u, enumerable: !1 });
        }
        return (
          Object.defineProperty(c, 'codes', { value: a, enumerable: !1 }),
          (c.color.close = '\x1B[39m'),
          (c.bgColor.close = '\x1B[49m'),
          (c.color.ansi256 = n()),
          (c.color.ansi16m = i()),
          (c.bgColor.ansi256 = n(r)),
          (c.bgColor.ansi16m = i(r)),
          Object.defineProperties(c, {
            rgbToAnsi256: {
              value: o(
                (d, u, p) =>
                  d === u && u === p
                    ? d < 8
                      ? 16
                      : d > 248
                        ? 231
                        : Math.round(((d - 8) / 247) * 24) + 232
                    : 16 +
                      36 * Math.round((d / 255) * 5) +
                      6 * Math.round((u / 255) * 5) +
                      Math.round((p / 255) * 5),
                'value',
              ),
              enumerable: !1,
            },
            hexToRgb: {
              value: o((d) => {
                const u = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(d.toString(16));
                if (!u) return [0, 0, 0];
                let { colorString: p } = u.groups;
                p.length === 3 &&
                  (p = p
                    .split('')
                    .map((y) => y + y)
                    .join(''));
                const f = Number.parseInt(p, 16);
                return [(f >> 16) & 255, (f >> 8) & 255, f & 255];
              }, 'value'),
              enumerable: !1,
            },
            hexToAnsi256: {
              value: o((d) => c.rgbToAnsi256(...c.hexToRgb(d)), 'value'),
              enumerable: !1,
            },
          }),
          c
        );
      }
      (o(s, 'assembleStyles'), Object.defineProperty(t, 'exports', { enumerable: !0, get: s }));
    },
  }),
  La = J({
    '../node_modules/pretty-format/build/collections.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.printIteratorEntries = r),
        (e.printIteratorValues = n),
        (e.printListItems = i),
        (e.printObjectProperties = s));
      var t = o((a, c) => {
        const d = Object.keys(a).sort(c);
        return (
          Object.getOwnPropertySymbols &&
            Object.getOwnPropertySymbols(a).forEach((u) => {
              Object.getOwnPropertyDescriptor(a, u).enumerable && d.push(u);
            }),
          d
        );
      }, 'getKeysOfEnumerableProperties');
      function r(a, c, d, u, p, f, y = ': ') {
        let h = '',
          g = a.next();
        if (!g.done) {
          h += c.spacingOuter;
          const T = d + c.indent;
          for (; !g.done; ) {
            const E = f(g.value[0], c, T, u, p),
              v = f(g.value[1], c, T, u, p);
            ((h += T + E + y + v),
              (g = a.next()),
              g.done ? c.min || (h += ',') : (h += ',' + c.spacingInner));
          }
          h += c.spacingOuter + d;
        }
        return h;
      }
      o(r, 'printIteratorEntries');
      function n(a, c, d, u, p, f) {
        let y = '',
          h = a.next();
        if (!h.done) {
          y += c.spacingOuter;
          const g = d + c.indent;
          for (; !h.done; )
            ((y += g + f(h.value, c, g, u, p)),
              (h = a.next()),
              h.done ? c.min || (y += ',') : (y += ',' + c.spacingInner));
          y += c.spacingOuter + d;
        }
        return y;
      }
      o(n, 'printIteratorValues');
      function i(a, c, d, u, p, f) {
        let y = '';
        if (a.length) {
          y += c.spacingOuter;
          const h = d + c.indent;
          for (let g = 0; g < a.length; g++)
            ((y += h),
              g in a && (y += f(a[g], c, h, u, p)),
              g < a.length - 1 ? (y += ',' + c.spacingInner) : c.min || (y += ','));
          y += c.spacingOuter + d;
        }
        return y;
      }
      o(i, 'printListItems');
      function s(a, c, d, u, p, f) {
        let y = '';
        const h = t(a, c.compareKeys);
        if (h.length) {
          y += c.spacingOuter;
          const g = d + c.indent;
          for (let T = 0; T < h.length; T++) {
            const E = h[T],
              v = f(E, c, g, u, p),
              S = f(a[E], c, g, u, p);
            ((y += g + v + ': ' + S),
              T < h.length - 1 ? (y += ',' + c.spacingInner) : c.min || (y += ','));
          }
          y += c.spacingOuter + d;
        }
        return y;
      }
      o(s, 'printObjectProperties');
    },
  }),
  tj = J({
    '../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = La(),
        r = (function () {
          return typeof globalThis < 'u'
            ? globalThis
            : typeof r < 'u'
              ? r
              : typeof self < 'u'
                ? self
                : typeof window < 'u'
                  ? window
                  : Function('return this')();
        })(),
        n = r['jest-symbol-do-not-touch'] || r.Symbol,
        i = typeof n == 'function' && n.for ? n.for('jest.asymmetricMatcher') : 1267621,
        s = ' ',
        a = o((p, f, y, h, g, T) => {
          const E = p.toString();
          return E === 'ArrayContaining' || E === 'ArrayNotContaining'
            ? ++h > f.maxDepth
              ? '[' + E + ']'
              : E + s + '[' + (0, t.printListItems)(p.sample, f, y, h, g, T) + ']'
            : E === 'ObjectContaining' || E === 'ObjectNotContaining'
              ? ++h > f.maxDepth
                ? '[' + E + ']'
                : E + s + '{' + (0, t.printObjectProperties)(p.sample, f, y, h, g, T) + '}'
              : E === 'StringMatching' ||
                  E === 'StringNotMatching' ||
                  E === 'StringContaining' ||
                  E === 'StringNotContaining'
                ? E + s + T(p.sample, f, y, h, g)
                : p.toAsymmetricMatcher();
        }, 'serialize');
      e.serialize = a;
      var c = o((p) => p && p.$$typeof === i, 'test');
      e.test = c;
      var d = { serialize: a, test: c },
        u = d;
      e.default = u;
    },
  }),
  rj = J({
    '../node_modules/pretty-format/node_modules/ansi-regex/index.js'(e, t) {
      t.exports = ({ onlyFirst: r = !1 } = {}) => {
        const n = [
          '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
          '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
        ].join('|');
        return new RegExp(n, r ? void 0 : 'g');
      };
    },
  }),
  nj = J({
    '../node_modules/pretty-format/build/plugins/ConvertAnsi.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = n(rj()),
        r = n(lb());
      function n(u) {
        return u && u.__esModule ? u : { default: u };
      }
      o(n, '_interopRequireDefault');
      var i = o(
          (u) =>
            u.replace((0, t.default)(), (p) => {
              switch (p) {
                case r.default.red.close:
                case r.default.green.close:
                case r.default.cyan.close:
                case r.default.gray.close:
                case r.default.white.close:
                case r.default.yellow.close:
                case r.default.bgRed.close:
                case r.default.bgGreen.close:
                case r.default.bgYellow.close:
                case r.default.inverse.close:
                case r.default.dim.close:
                case r.default.bold.close:
                case r.default.reset.open:
                case r.default.reset.close:
                  return '</>';
                case r.default.red.open:
                  return '<red>';
                case r.default.green.open:
                  return '<green>';
                case r.default.cyan.open:
                  return '<cyan>';
                case r.default.gray.open:
                  return '<gray>';
                case r.default.white.open:
                  return '<white>';
                case r.default.yellow.open:
                  return '<yellow>';
                case r.default.bgRed.open:
                  return '<bgRed>';
                case r.default.bgGreen.open:
                  return '<bgGreen>';
                case r.default.bgYellow.open:
                  return '<bgYellow>';
                case r.default.inverse.open:
                  return '<inverse>';
                case r.default.dim.open:
                  return '<dim>';
                case r.default.bold.open:
                  return '<bold>';
                default:
                  return '';
              }
            }),
          'toHumanReadableAnsi',
        ),
        s = o((u) => typeof u == 'string' && !!u.match((0, t.default)()), 'test');
      e.test = s;
      var a = o((u, p, f, y, h, g) => g(i(u), p, f, y, h), 'serialize');
      e.serialize = a;
      var c = { serialize: a, test: s },
        d = c;
      e.default = d;
    },
  }),
  oj = J({
    '../node_modules/pretty-format/build/plugins/DOMCollection.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = La(),
        r = ' ',
        n = ['DOMStringMap', 'NamedNodeMap'],
        i = /^(HTML\w*Collection|NodeList)$/,
        s = o((f) => n.indexOf(f) !== -1 || i.test(f), 'testName'),
        a = o((f) => f && f.constructor && !!f.constructor.name && s(f.constructor.name), 'test');
      e.test = a;
      var c = o((f) => f.constructor.name === 'NamedNodeMap', 'isNamedNodeMap'),
        d = o((f, y, h, g, T, E) => {
          const v = f.constructor.name;
          return ++g > y.maxDepth
            ? '[' + v + ']'
            : (y.min ? '' : v + r) +
                (n.indexOf(v) !== -1
                  ? '{' +
                    (0, t.printObjectProperties)(
                      c(f)
                        ? Array.from(f).reduce((S, A) => ((S[A.name] = A.value), S), {})
                        : { ...f },
                      y,
                      h,
                      g,
                      T,
                      E,
                    ) +
                    '}'
                  : '[' + (0, t.printListItems)(Array.from(f), y, h, g, T, E) + ']');
        }, 'serialize');
      e.serialize = d;
      var u = { serialize: d, test: a },
        p = u;
      e.default = p;
    },
  }),
  ij = J({
    '../node_modules/pretty-format/build/plugins/lib/escapeHTML.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = t));
      function t(r) {
        return r.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      o(t, 'escapeHTML');
    },
  }),
  Ud = J({
    '../node_modules/pretty-format/build/plugins/lib/markup.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.printText =
          e.printProps =
          e.printElementAsLeaf =
          e.printElement =
          e.printComment =
          e.printChildren =
            void 0));
      var t = r(ij());
      function r(u) {
        return u && u.__esModule ? u : { default: u };
      }
      o(r, '_interopRequireDefault');
      var n = o((u, p, f, y, h, g, T) => {
        const E = y + f.indent,
          v = f.colors;
        return u
          .map((S) => {
            const A = p[S];
            let N = T(A, f, E, h, g);
            return (
              typeof A != 'string' &&
                (N.indexOf(`
`) !== -1 && (N = f.spacingOuter + E + N + f.spacingOuter + y),
                (N = '{' + N + '}')),
              f.spacingInner +
                y +
                v.prop.open +
                S +
                v.prop.close +
                '=' +
                v.value.open +
                N +
                v.value.close
            );
          })
          .join('');
      }, 'printProps');
      e.printProps = n;
      var i = o(
        (u, p, f, y, h, g) =>
          u
            .map((T) => p.spacingOuter + f + (typeof T == 'string' ? s(T, p) : g(T, p, f, y, h)))
            .join(''),
        'printChildren',
      );
      e.printChildren = i;
      var s = o((u, p) => {
        const f = p.colors.content;
        return f.open + (0, t.default)(u) + f.close;
      }, 'printText');
      e.printText = s;
      var a = o((u, p) => {
        const f = p.colors.comment;
        return f.open + '<!--' + (0, t.default)(u) + '-->' + f.close;
      }, 'printComment');
      e.printComment = a;
      var c = o((u, p, f, y, h) => {
        const g = y.colors.tag;
        return (
          g.open +
          '<' +
          u +
          (p && g.close + p + y.spacingOuter + h + g.open) +
          (f
            ? '>' + g.close + f + y.spacingOuter + h + g.open + '</' + u
            : (p && !y.min ? '' : ' ') + '/') +
          '>' +
          g.close
        );
      }, 'printElement');
      e.printElement = c;
      var d = o((u, p) => {
        const f = p.colors.tag;
        return f.open + '<' + u + f.close + ' ' + f.open + ' />' + f.close;
      }, 'printElementAsLeaf');
      e.printElementAsLeaf = d;
    },
  }),
  sj = J({
    '../node_modules/pretty-format/build/plugins/DOMElement.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Ud(),
        r = 1,
        n = 3,
        i = 8,
        s = 11,
        a = /^((HTML|SVG)\w*)?Element$/,
        c = o((E) => {
          try {
            return typeof E.hasAttribute == 'function' && E.hasAttribute('is');
          } catch {
            return !1;
          }
        }, 'testHasAttribute'),
        d = o((E) => {
          const v = E.constructor.name,
            { nodeType: S, tagName: A } = E,
            N = (typeof A == 'string' && A.includes('-')) || c(E);
          return (
            (S === r && (a.test(v) || N)) ||
            (S === n && v === 'Text') ||
            (S === i && v === 'Comment') ||
            (S === s && v === 'DocumentFragment')
          );
        }, 'testNode'),
        u = o((E) => {
          var v;
          return (
            (E == null || (v = E.constructor) === null || v === void 0 ? void 0 : v.name) && d(E)
          );
        }, 'test');
      e.test = u;
      function p(E) {
        return E.nodeType === n;
      }
      o(p, 'nodeIsText');
      function f(E) {
        return E.nodeType === i;
      }
      o(f, 'nodeIsComment');
      function y(E) {
        return E.nodeType === s;
      }
      o(y, 'nodeIsFragment');
      var h = o((E, v, S, A, N, j) => {
        if (p(E)) return (0, t.printText)(E.data, v);
        if (f(E)) return (0, t.printComment)(E.data, v);
        const C = y(E) ? 'DocumentFragment' : E.tagName.toLowerCase();
        return ++A > v.maxDepth
          ? (0, t.printElementAsLeaf)(C, v)
          : (0, t.printElement)(
              C,
              (0, t.printProps)(
                y(E)
                  ? []
                  : Array.from(E.attributes)
                      .map((R) => R.name)
                      .sort(),
                y(E)
                  ? {}
                  : Array.from(E.attributes).reduce((R, w) => ((R[w.name] = w.value), R), {}),
                v,
                S + v.indent,
                A,
                N,
                j,
              ),
              (0, t.printChildren)(
                Array.prototype.slice.call(E.childNodes || E.children),
                v,
                S + v.indent,
                A,
                N,
                j,
              ),
              v,
              S,
            );
      }, 'serialize');
      e.serialize = h;
      var g = { serialize: h, test: u },
        T = g;
      e.default = T;
    },
  }),
  aj = J({
    '../node_modules/pretty-format/build/plugins/Immutable.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = La(),
        r = '@@__IMMUTABLE_ITERABLE__@@',
        n = '@@__IMMUTABLE_LIST__@@',
        i = '@@__IMMUTABLE_KEYED__@@',
        s = '@@__IMMUTABLE_MAP__@@',
        a = '@@__IMMUTABLE_ORDERED__@@',
        c = '@@__IMMUTABLE_RECORD__@@',
        d = '@@__IMMUTABLE_SEQ__@@',
        u = '@@__IMMUTABLE_SET__@@',
        p = '@@__IMMUTABLE_STACK__@@',
        f = o((w) => 'Immutable.' + w, 'getImmutableName'),
        y = o((w) => '[' + w + ']', 'printAsLeaf'),
        h = ' ',
        g = '',
        T = o(
          (w, _, k, I, V, H, P) =>
            ++I > _.maxDepth
              ? y(f(P))
              : f(P) + h + '{' + (0, t.printIteratorEntries)(w.entries(), _, k, I, V, H) + '}',
          'printImmutableEntries',
        );
      function E(w) {
        let _ = 0;
        return {
          next() {
            if (_ < w._keys.length) {
              const k = w._keys[_++];
              return { done: !1, value: [k, w.get(k)] };
            }
            return { done: !0, value: void 0 };
          },
        };
      }
      o(E, 'getRecordEntries');
      var v = o((w, _, k, I, V, H) => {
          const P = f(w._name || 'Record');
          return ++I > _.maxDepth
            ? y(P)
            : P + h + '{' + (0, t.printIteratorEntries)(E(w), _, k, I, V, H) + '}';
        }, 'printImmutableRecord'),
        S = o((w, _, k, I, V, H) => {
          const P = f('Seq');
          return ++I > _.maxDepth
            ? y(P)
            : w[i]
              ? P +
                h +
                '{' +
                (w._iter || w._object
                  ? (0, t.printIteratorEntries)(w.entries(), _, k, I, V, H)
                  : g) +
                '}'
              : P +
                h +
                '[' +
                (w._iter || w._array || w._collection || w._iterable
                  ? (0, t.printIteratorValues)(w.values(), _, k, I, V, H)
                  : g) +
                ']';
        }, 'printImmutableSeq'),
        A = o(
          (w, _, k, I, V, H, P) =>
            ++I > _.maxDepth
              ? y(f(P))
              : f(P) + h + '[' + (0, t.printIteratorValues)(w.values(), _, k, I, V, H) + ']',
          'printImmutableValues',
        ),
        N = o(
          (w, _, k, I, V, H) =>
            w[s]
              ? T(w, _, k, I, V, H, w[a] ? 'OrderedMap' : 'Map')
              : w[n]
                ? A(w, _, k, I, V, H, 'List')
                : w[u]
                  ? A(w, _, k, I, V, H, w[a] ? 'OrderedSet' : 'Set')
                  : w[p]
                    ? A(w, _, k, I, V, H, 'Stack')
                    : w[d]
                      ? S(w, _, k, I, V, H)
                      : v(w, _, k, I, V, H),
          'serialize',
        );
      e.serialize = N;
      var j = o((w) => w && (w[r] === !0 || w[c] === !0), 'test');
      e.test = j;
      var C = { serialize: N, test: j },
        R = C;
      e.default = R;
    },
  }),
  lj = J({
    '../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js'(e) {
      var t = 60103,
        r = 60106,
        n = 60107,
        i = 60108,
        s = 60114,
        a = 60109,
        c = 60110,
        d = 60112,
        u = 60113,
        p = 60120,
        f = 60115,
        y = 60116,
        h = 60121,
        g = 60122,
        T = 60117,
        E = 60129,
        v = 60131;
      typeof Symbol == 'function' &&
        Symbol.for &&
        ((S = Symbol.for),
        (t = S('react.element')),
        (r = S('react.portal')),
        (n = S('react.fragment')),
        (i = S('react.strict_mode')),
        (s = S('react.profiler')),
        (a = S('react.provider')),
        (c = S('react.context')),
        (d = S('react.forward_ref')),
        (u = S('react.suspense')),
        (p = S('react.suspense_list')),
        (f = S('react.memo')),
        (y = S('react.lazy')),
        (h = S('react.block')),
        (g = S('react.server.block')),
        (T = S('react.fundamental')),
        (E = S('react.debug_trace_mode')),
        (v = S('react.legacy_hidden')));
      var S;
      function A(P) {
        if (typeof P == 'object' && P !== null) {
          var L = P.$$typeof;
          switch (L) {
            case t:
              switch (((P = P.type), P)) {
                case n:
                case s:
                case i:
                case u:
                case p:
                  return P;
                default:
                  switch (((P = P && P.$$typeof), P)) {
                    case c:
                    case d:
                    case y:
                    case f:
                    case a:
                      return P;
                    default:
                      return L;
                  }
              }
            case r:
              return L;
          }
        }
      }
      o(A, 'y');
      var N = a,
        j = t,
        C = d,
        R = n,
        w = y,
        _ = f,
        k = r,
        I = s,
        V = i,
        H = u;
      ((e.ContextConsumer = c),
        (e.ContextProvider = N),
        (e.Element = j),
        (e.ForwardRef = C),
        (e.Fragment = R),
        (e.Lazy = w),
        (e.Memo = _),
        (e.Portal = k),
        (e.Profiler = I),
        (e.StrictMode = V),
        (e.Suspense = H),
        (e.isAsyncMode = function () {
          return !1;
        }),
        (e.isConcurrentMode = function () {
          return !1;
        }),
        (e.isContextConsumer = function (P) {
          return A(P) === c;
        }),
        (e.isContextProvider = function (P) {
          return A(P) === a;
        }),
        (e.isElement = function (P) {
          return typeof P == 'object' && P !== null && P.$$typeof === t;
        }),
        (e.isForwardRef = function (P) {
          return A(P) === d;
        }),
        (e.isFragment = function (P) {
          return A(P) === n;
        }),
        (e.isLazy = function (P) {
          return A(P) === y;
        }),
        (e.isMemo = function (P) {
          return A(P) === f;
        }),
        (e.isPortal = function (P) {
          return A(P) === r;
        }),
        (e.isProfiler = function (P) {
          return A(P) === s;
        }),
        (e.isStrictMode = function (P) {
          return A(P) === i;
        }),
        (e.isSuspense = function (P) {
          return A(P) === u;
        }),
        (e.isValidElementType = function (P) {
          return (
            typeof P == 'string' ||
            typeof P == 'function' ||
            P === n ||
            P === s ||
            P === E ||
            P === i ||
            P === u ||
            P === p ||
            P === v ||
            (typeof P == 'object' &&
              P !== null &&
              (P.$$typeof === y ||
                P.$$typeof === f ||
                P.$$typeof === a ||
                P.$$typeof === c ||
                P.$$typeof === d ||
                P.$$typeof === T ||
                P.$$typeof === h ||
                P[0] === g))
          );
        }),
        (e.typeOf = A));
    },
  }),
  cj = J({
    '../node_modules/pretty-format/node_modules/react-is/index.js'(e, t) {
      t.exports = lj();
    },
  }),
  uj = J({
    '../node_modules/pretty-format/build/plugins/ReactElement.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = i(cj()),
        r = Ud();
      function n(y) {
        if (typeof WeakMap != 'function') return null;
        var h = new WeakMap(),
          g = new WeakMap();
        return (n = o(function (T) {
          return T ? g : h;
        }, '_getRequireWildcardCache'))(y);
      }
      o(n, '_getRequireWildcardCache');
      function i(y, h) {
        if (!h && y && y.__esModule) return y;
        if (y === null || (typeof y != 'object' && typeof y != 'function')) return { default: y };
        var g = n(h);
        if (g && g.has(y)) return g.get(y);
        var T = {},
          E = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var v in y)
          if (v !== 'default' && Object.prototype.hasOwnProperty.call(y, v)) {
            var S = E ? Object.getOwnPropertyDescriptor(y, v) : null;
            S && (S.get || S.set) ? Object.defineProperty(T, v, S) : (T[v] = y[v]);
          }
        return ((T.default = y), g && g.set(y, T), T);
      }
      o(i, '_interopRequireWildcard');
      var s = o(
          (y, h = []) => (
            Array.isArray(y)
              ? y.forEach((g) => {
                  s(g, h);
                })
              : y != null && y !== !1 && h.push(y),
            h
          ),
          'getChildren',
        ),
        a = o((y) => {
          const h = y.type;
          if (typeof h == 'string') return h;
          if (typeof h == 'function') return h.displayName || h.name || 'Unknown';
          if (t.isFragment(y)) return 'React.Fragment';
          if (t.isSuspense(y)) return 'React.Suspense';
          if (typeof h == 'object' && h !== null) {
            if (t.isContextProvider(y)) return 'Context.Provider';
            if (t.isContextConsumer(y)) return 'Context.Consumer';
            if (t.isForwardRef(y)) {
              if (h.displayName) return h.displayName;
              const g = h.render.displayName || h.render.name || '';
              return g !== '' ? 'ForwardRef(' + g + ')' : 'ForwardRef';
            }
            if (t.isMemo(y)) {
              const g = h.displayName || h.type.displayName || h.type.name || '';
              return g !== '' ? 'Memo(' + g + ')' : 'Memo';
            }
          }
          return 'UNDEFINED';
        }, 'getType'),
        c = o((y) => {
          const { props: h } = y;
          return Object.keys(h)
            .filter((g) => g !== 'children' && h[g] !== void 0)
            .sort();
        }, 'getPropKeys'),
        d = o(
          (y, h, g, T, E, v) =>
            ++T > h.maxDepth
              ? (0, r.printElementAsLeaf)(a(y), h)
              : (0, r.printElement)(
                  a(y),
                  (0, r.printProps)(c(y), y.props, h, g + h.indent, T, E, v),
                  (0, r.printChildren)(s(y.props.children), h, g + h.indent, T, E, v),
                  h,
                  g,
                ),
          'serialize',
        );
      e.serialize = d;
      var u = o((y) => y != null && t.isElement(y), 'test');
      e.test = u;
      var p = { serialize: d, test: u },
        f = p;
      e.default = f;
    },
  }),
  dj = J({
    '../node_modules/pretty-format/build/plugins/ReactTestComponent.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.test = e.serialize = e.default = void 0));
      var t = Ud(),
        r = (function () {
          return typeof globalThis < 'u'
            ? globalThis
            : typeof r < 'u'
              ? r
              : typeof self < 'u'
                ? self
                : typeof window < 'u'
                  ? window
                  : Function('return this')();
        })(),
        n = r['jest-symbol-do-not-touch'] || r.Symbol,
        i = typeof n == 'function' && n.for ? n.for('react.test.json') : 245830487,
        s = o((p) => {
          const { props: f } = p;
          return f
            ? Object.keys(f)
                .filter((y) => f[y] !== void 0)
                .sort()
            : [];
        }, 'getPropKeys'),
        a = o(
          (p, f, y, h, g, T) =>
            ++h > f.maxDepth
              ? (0, t.printElementAsLeaf)(p.type, f)
              : (0, t.printElement)(
                  p.type,
                  p.props ? (0, t.printProps)(s(p), p.props, f, y + f.indent, h, g, T) : '',
                  p.children ? (0, t.printChildren)(p.children, f, y + f.indent, h, g, T) : '',
                  f,
                  y,
                ),
          'serialize',
        );
      e.serialize = a;
      var c = o((p) => p && p.$$typeof === i, 'test');
      e.test = c;
      var d = { serialize: a, test: c },
        u = d;
      e.default = u;
    },
  }),
  pj = J({
    '../node_modules/pretty-format/build/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = e.DEFAULT_OPTIONS = void 0),
        (e.format = Oe),
        (e.plugins = void 0));
      var t = p(lb()),
        r = La(),
        n = p(tj()),
        i = p(nj()),
        s = p(oj()),
        a = p(sj()),
        c = p(aj()),
        d = p(uj()),
        u = p(dj());
      function p($) {
        return $ && $.__esModule ? $ : { default: $ };
      }
      o(p, '_interopRequireDefault');
      var f = Object.prototype.toString,
        y = Date.prototype.toISOString,
        h = Error.prototype.toString,
        g = RegExp.prototype.toString,
        T = o(
          ($) => (typeof $.constructor == 'function' && $.constructor.name) || 'Object',
          'getConstructorName',
        ),
        E = o(($) => typeof window < 'u' && $ === window, 'isWindow'),
        v = /^Symbol\((.*)\)(.*)$/,
        S = /\n/gi,
        A = class extends Error {
          constructor(Q, re) {
            (super(Q), (this.stack = re), (this.name = this.constructor.name));
          }
        };
      o(A, 'PrettyFormatPluginError');
      var N = A;
      function j($) {
        return (
          $ === '[object Array]' ||
          $ === '[object ArrayBuffer]' ||
          $ === '[object DataView]' ||
          $ === '[object Float32Array]' ||
          $ === '[object Float64Array]' ||
          $ === '[object Int8Array]' ||
          $ === '[object Int16Array]' ||
          $ === '[object Int32Array]' ||
          $ === '[object Uint8Array]' ||
          $ === '[object Uint8ClampedArray]' ||
          $ === '[object Uint16Array]' ||
          $ === '[object Uint32Array]'
        );
      }
      o(j, 'isToStringedArrayType');
      function C($) {
        return Object.is($, -0) ? '-0' : String($);
      }
      o(C, 'printNumber');
      function R($) {
        return `${$}n`;
      }
      o(R, 'printBigInt');
      function w($, Q) {
        return Q ? '[Function ' + ($.name || 'anonymous') + ']' : '[Function]';
      }
      o(w, 'printFunction');
      function _($) {
        return String($).replace(v, 'Symbol($1)');
      }
      o(_, 'printSymbol');
      function k($) {
        return '[' + h.call($) + ']';
      }
      o(k, 'printError');
      function I($, Q, re, oe) {
        if ($ === !0 || $ === !1) return '' + $;
        if ($ === void 0) return 'undefined';
        if ($ === null) return 'null';
        const ne = typeof $;
        if (ne === 'number') return C($);
        if (ne === 'bigint') return R($);
        if (ne === 'string') return oe ? '"' + $.replace(/"|\\/g, '\\$&') + '"' : '"' + $ + '"';
        if (ne === 'function') return w($, Q);
        if (ne === 'symbol') return _($);
        const de = f.call($);
        return de === '[object WeakMap]'
          ? 'WeakMap {}'
          : de === '[object WeakSet]'
            ? 'WeakSet {}'
            : de === '[object Function]' || de === '[object GeneratorFunction]'
              ? w($, Q)
              : de === '[object Symbol]'
                ? _($)
                : de === '[object Date]'
                  ? isNaN(+$)
                    ? 'Date { NaN }'
                    : y.call($)
                  : de === '[object Error]'
                    ? k($)
                    : de === '[object RegExp]'
                      ? re
                        ? g.call($).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&')
                        : g.call($)
                      : $ instanceof Error
                        ? k($)
                        : null;
      }
      o(I, 'printBasicValue');
      function V($, Q, re, oe, ne, de) {
        if (ne.indexOf($) !== -1) return '[Circular]';
        ((ne = ne.slice()), ne.push($));
        const ye = ++oe > Q.maxDepth,
          pe = Q.min;
        if (Q.callToJSON && !ye && $.toJSON && typeof $.toJSON == 'function' && !de)
          return B($.toJSON(), Q, re, oe, ne, !0);
        const Je = f.call($);
        return Je === '[object Arguments]'
          ? ye
            ? '[Arguments]'
            : (pe ? '' : 'Arguments ') + '[' + (0, r.printListItems)($, Q, re, oe, ne, B) + ']'
          : j(Je)
            ? ye
              ? '[' + $.constructor.name + ']'
              : (pe || (!Q.printBasicPrototype && $.constructor.name === 'Array')
                  ? ''
                  : $.constructor.name + ' ') +
                '[' +
                (0, r.printListItems)($, Q, re, oe, ne, B) +
                ']'
            : Je === '[object Map]'
              ? ye
                ? '[Map]'
                : 'Map {' + (0, r.printIteratorEntries)($.entries(), Q, re, oe, ne, B, ' => ') + '}'
              : Je === '[object Set]'
                ? ye
                  ? '[Set]'
                  : 'Set {' + (0, r.printIteratorValues)($.values(), Q, re, oe, ne, B) + '}'
                : ye || E($)
                  ? '[' + T($) + ']'
                  : (pe || (!Q.printBasicPrototype && T($) === 'Object') ? '' : T($) + ' ') +
                    '{' +
                    (0, r.printObjectProperties)($, Q, re, oe, ne, B) +
                    '}';
      }
      o(V, 'printComplexValue');
      function H($) {
        return $.serialize != null;
      }
      o(H, 'isNewPlugin');
      function P($, Q, re, oe, ne, de) {
        let ye;
        try {
          ye = H($)
            ? $.serialize(Q, re, oe, ne, de, B)
            : $.print(
                Q,
                (pe) => B(pe, re, oe, ne, de),
                (pe) => {
                  const Je = oe + re.indent;
                  return (
                    Je +
                    pe.replace(
                      S,
                      `
` + Je,
                    )
                  );
                },
                { edgeSpacing: re.spacingOuter, min: re.min, spacing: re.spacingInner },
                re.colors,
              );
        } catch (pe) {
          throw new N(pe.message, pe.stack);
        }
        if (typeof ye != 'string')
          throw new Error(
            `pretty-format: Plugin must return type "string" but instead returned "${typeof ye}".`,
          );
        return ye;
      }
      o(P, 'printPlugin');
      function L($, Q) {
        for (let re = 0; re < $.length; re++)
          try {
            if ($[re].test(Q)) return $[re];
          } catch (oe) {
            throw new N(oe.message, oe.stack);
          }
        return null;
      }
      o(L, 'findPlugin');
      function B($, Q, re, oe, ne, de) {
        const ye = L(Q.plugins, $);
        if (ye !== null) return P(ye, $, Q, re, oe, ne);
        const pe = I($, Q.printFunctionName, Q.escapeRegex, Q.escapeString);
        return pe !== null ? pe : V($, Q, re, oe, ne, de);
      }
      o(B, 'printer');
      var D = { comment: 'gray', content: 'reset', prop: 'yellow', tag: 'cyan', value: 'green' },
        K = Object.keys(D),
        X = {
          callToJSON: !0,
          compareKeys: void 0,
          escapeRegex: !1,
          escapeString: !0,
          highlight: !1,
          indent: 2,
          maxDepth: 1 / 0,
          min: !1,
          plugins: [],
          printBasicPrototype: !0,
          printFunctionName: !0,
          theme: D,
        };
      e.DEFAULT_OPTIONS = X;
      function ie($) {
        if (
          (Object.keys($).forEach((Q) => {
            if (!X.hasOwnProperty(Q)) throw new Error(`pretty-format: Unknown option "${Q}".`);
          }),
          $.min && $.indent !== void 0 && $.indent !== 0)
        )
          throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
        if ($.theme !== void 0) {
          if ($.theme === null) throw new Error('pretty-format: Option "theme" must not be null.');
          if (typeof $.theme != 'object')
            throw new Error(
              `pretty-format: Option "theme" must be of type "object" but instead received "${typeof $.theme}".`,
            );
        }
      }
      o(ie, 'validateOptions');
      var se = o(
          ($) =>
            K.reduce((Q, re) => {
              const oe = $.theme && $.theme[re] !== void 0 ? $.theme[re] : D[re],
                ne = oe && t.default[oe];
              if (ne && typeof ne.close == 'string' && typeof ne.open == 'string') Q[re] = ne;
              else
                throw new Error(
                  `pretty-format: Option "theme" has a key "${re}" whose value "${oe}" is undefined in ansi-styles.`,
                );
              return Q;
            }, Object.create(null)),
          'getColorsHighlight',
        ),
        W = o(
          () => K.reduce(($, Q) => (($[Q] = { close: '', open: '' }), $), Object.create(null)),
          'getColorsEmpty',
        ),
        ae = o(
          ($) => ($ && $.printFunctionName !== void 0 ? $.printFunctionName : X.printFunctionName),
          'getPrintFunctionName',
        ),
        be = o(
          ($) => ($ && $.escapeRegex !== void 0 ? $.escapeRegex : X.escapeRegex),
          'getEscapeRegex',
        ),
        ue = o(
          ($) => ($ && $.escapeString !== void 0 ? $.escapeString : X.escapeString),
          'getEscapeString',
        ),
        ee = o(($) => {
          var Q;
          return {
            callToJSON: $ && $.callToJSON !== void 0 ? $.callToJSON : X.callToJSON,
            colors: $ && $.highlight ? se($) : W(),
            compareKeys: $ && typeof $.compareKeys == 'function' ? $.compareKeys : X.compareKeys,
            escapeRegex: be($),
            escapeString: ue($),
            indent: $ && $.min ? '' : Ae($ && $.indent !== void 0 ? $.indent : X.indent),
            maxDepth: $ && $.maxDepth !== void 0 ? $.maxDepth : X.maxDepth,
            min: $ && $.min !== void 0 ? $.min : X.min,
            plugins: $ && $.plugins !== void 0 ? $.plugins : X.plugins,
            printBasicPrototype: (Q = $?.printBasicPrototype) !== null && Q !== void 0 ? Q : !0,
            printFunctionName: ae($),
            spacingInner:
              $ && $.min
                ? ' '
                : `
`,
            spacingOuter:
              $ && $.min
                ? ''
                : `
`,
          };
        }, 'getConfig');
      function Ae($) {
        return new Array($ + 1).join(' ');
      }
      o(Ae, 'createIndent');
      function Oe($, Q) {
        if (Q && (ie(Q), Q.plugins)) {
          const oe = L(Q.plugins, $);
          if (oe !== null) return P(oe, $, ee(Q), '', 0, []);
        }
        const re = I($, ae(Q), be(Q), ue(Q));
        return re !== null ? re : V($, ee(Q), '', 0, []);
      }
      o(Oe, 'format');
      var He = {
        AsymmetricMatcher: n.default,
        ConvertAnsi: i.default,
        DOMCollection: s.default,
        DOMElement: a.default,
        Immutable: c.default,
        ReactElement: d.default,
        ReactTestComponent: u.default,
      };
      e.plugins = He;
      var Ke = Oe;
      e.default = Ke;
    },
  }),
  fj = J({
    '../node_modules/lz-string/libs/lz-string.js'(e, t) {
      var r = (function () {
        var n = String.fromCharCode,
          i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$',
          a = {};
        function c(u, p) {
          if (!a[u]) {
            a[u] = {};
            for (var f = 0; f < u.length; f++) a[u][u.charAt(f)] = f;
          }
          return a[u][p];
        }
        o(c, 'getBaseValue');
        var d = {
          compressToBase64: o(function (u) {
            if (u == null) return '';
            var p = d._compress(u, 6, function (f) {
              return i.charAt(f);
            });
            switch (p.length % 4) {
              default:
              case 0:
                return p;
              case 1:
                return p + '===';
              case 2:
                return p + '==';
              case 3:
                return p + '=';
            }
          }, 'compressToBase64'),
          decompressFromBase64: o(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 32, function (p) {
                    return c(i, u.charAt(p));
                  });
          }, 'decompressFromBase64'),
          compressToUTF16: o(function (u) {
            return u == null
              ? ''
              : d._compress(u, 15, function (p) {
                  return n(p + 32);
                }) + ' ';
          }, 'compressToUTF16'),
          decompressFromUTF16: o(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 16384, function (p) {
                    return u.charCodeAt(p) - 32;
                  });
          }, 'decompressFromUTF16'),
          compressToUint8Array: o(function (u) {
            for (
              var p = d.compress(u), f = new Uint8Array(p.length * 2), y = 0, h = p.length;
              y < h;
              y++
            ) {
              var g = p.charCodeAt(y);
              ((f[y * 2] = g >>> 8), (f[y * 2 + 1] = g % 256));
            }
            return f;
          }, 'compressToUint8Array'),
          decompressFromUint8Array: o(function (u) {
            if (u == null) return d.decompress(u);
            for (var p = new Array(u.length / 2), f = 0, y = p.length; f < y; f++)
              p[f] = u[f * 2] * 256 + u[f * 2 + 1];
            var h = [];
            return (
              p.forEach(function (g) {
                h.push(n(g));
              }),
              d.decompress(h.join(''))
            );
          }, 'decompressFromUint8Array'),
          compressToEncodedURIComponent: o(function (u) {
            return u == null
              ? ''
              : d._compress(u, 6, function (p) {
                  return s.charAt(p);
                });
          }, 'compressToEncodedURIComponent'),
          decompressFromEncodedURIComponent: o(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : ((u = u.replace(/ /g, '+')),
                  d._decompress(u.length, 32, function (p) {
                    return c(s, u.charAt(p));
                  }));
          }, 'decompressFromEncodedURIComponent'),
          compress: o(function (u) {
            return d._compress(u, 16, function (p) {
              return n(p);
            });
          }, 'compress'),
          _compress: o(function (u, p, f) {
            if (u == null) return '';
            var y,
              h,
              g = {},
              T = {},
              E = '',
              v = '',
              S = '',
              A = 2,
              N = 3,
              j = 2,
              C = [],
              R = 0,
              w = 0,
              _;
            for (_ = 0; _ < u.length; _ += 1)
              if (
                ((E = u.charAt(_)),
                Object.prototype.hasOwnProperty.call(g, E) || ((g[E] = N++), (T[E] = !0)),
                (v = S + E),
                Object.prototype.hasOwnProperty.call(g, v))
              )
                S = v;
              else {
                if (Object.prototype.hasOwnProperty.call(T, S)) {
                  if (S.charCodeAt(0) < 256) {
                    for (y = 0; y < j; y++)
                      ((R = R << 1), w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++);
                    for (h = S.charCodeAt(0), y = 0; y < 8; y++)
                      ((R = (R << 1) | (h & 1)),
                        w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                        (h = h >> 1));
                  } else {
                    for (h = 1, y = 0; y < j; y++)
                      ((R = (R << 1) | h),
                        w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                        (h = 0));
                    for (h = S.charCodeAt(0), y = 0; y < 16; y++)
                      ((R = (R << 1) | (h & 1)),
                        w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                        (h = h >> 1));
                  }
                  (A--, A == 0 && ((A = Math.pow(2, j)), j++), delete T[S]);
                } else
                  for (h = g[S], y = 0; y < j; y++)
                    ((R = (R << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                      (h = h >> 1));
                (A--, A == 0 && ((A = Math.pow(2, j)), j++), (g[v] = N++), (S = String(E)));
              }
            if (S !== '') {
              if (Object.prototype.hasOwnProperty.call(T, S)) {
                if (S.charCodeAt(0) < 256) {
                  for (y = 0; y < j; y++)
                    ((R = R << 1), w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++);
                  for (h = S.charCodeAt(0), y = 0; y < 8; y++)
                    ((R = (R << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                      (h = h >> 1));
                } else {
                  for (h = 1, y = 0; y < j; y++)
                    ((R = (R << 1) | h),
                      w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                      (h = 0));
                  for (h = S.charCodeAt(0), y = 0; y < 16; y++)
                    ((R = (R << 1) | (h & 1)),
                      w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                      (h = h >> 1));
                }
                (A--, A == 0 && ((A = Math.pow(2, j)), j++), delete T[S]);
              } else
                for (h = g[S], y = 0; y < j; y++)
                  ((R = (R << 1) | (h & 1)),
                    w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                    (h = h >> 1));
              (A--, A == 0 && ((A = Math.pow(2, j)), j++));
            }
            for (h = 2, y = 0; y < j; y++)
              ((R = (R << 1) | (h & 1)),
                w == p - 1 ? ((w = 0), C.push(f(R)), (R = 0)) : w++,
                (h = h >> 1));
            for (;;)
              if (((R = R << 1), w == p - 1)) {
                C.push(f(R));
                break;
              } else w++;
            return C.join('');
          }, '_compress'),
          decompress: o(function (u) {
            return u == null
              ? ''
              : u == ''
                ? null
                : d._decompress(u.length, 32768, function (p) {
                    return u.charCodeAt(p);
                  });
          }, 'decompress'),
          _decompress: o(function (u, p, f) {
            var y = [],
              h = 4,
              g = 4,
              T = 3,
              E = '',
              v = [],
              S,
              A,
              N,
              j,
              C,
              R,
              w,
              _ = { val: f(0), position: p, index: 1 };
            for (S = 0; S < 3; S += 1) y[S] = S;
            for (N = 0, C = Math.pow(2, 2), R = 1; R != C; )
              ((j = _.val & _.position),
                (_.position >>= 1),
                _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                (N |= (j > 0 ? 1 : 0) * R),
                (R <<= 1));
            switch (N) {
              case 0:
                for (N = 0, C = Math.pow(2, 8), R = 1; R != C; )
                  ((j = _.val & _.position),
                    (_.position >>= 1),
                    _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                    (N |= (j > 0 ? 1 : 0) * R),
                    (R <<= 1));
                w = n(N);
                break;
              case 1:
                for (N = 0, C = Math.pow(2, 16), R = 1; R != C; )
                  ((j = _.val & _.position),
                    (_.position >>= 1),
                    _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                    (N |= (j > 0 ? 1 : 0) * R),
                    (R <<= 1));
                w = n(N);
                break;
              case 2:
                return '';
            }
            for (y[3] = w, A = w, v.push(w); ; ) {
              if (_.index > u) return '';
              for (N = 0, C = Math.pow(2, T), R = 1; R != C; )
                ((j = _.val & _.position),
                  (_.position >>= 1),
                  _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                  (N |= (j > 0 ? 1 : 0) * R),
                  (R <<= 1));
              switch ((w = N)) {
                case 0:
                  for (N = 0, C = Math.pow(2, 8), R = 1; R != C; )
                    ((j = _.val & _.position),
                      (_.position >>= 1),
                      _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                      (N |= (j > 0 ? 1 : 0) * R),
                      (R <<= 1));
                  ((y[g++] = n(N)), (w = g - 1), h--);
                  break;
                case 1:
                  for (N = 0, C = Math.pow(2, 16), R = 1; R != C; )
                    ((j = _.val & _.position),
                      (_.position >>= 1),
                      _.position == 0 && ((_.position = p), (_.val = f(_.index++))),
                      (N |= (j > 0 ? 1 : 0) * R),
                      (R <<= 1));
                  ((y[g++] = n(N)), (w = g - 1), h--);
                  break;
                case 2:
                  return v.join('');
              }
              if ((h == 0 && ((h = Math.pow(2, T)), T++), y[w])) E = y[w];
              else if (w === g) E = A + A.charAt(0);
              else return null;
              (v.push(E),
                (y[g++] = A + E.charAt(0)),
                h--,
                (A = E),
                h == 0 && ((h = Math.pow(2, T)), T++));
            }
          }, '_decompress'),
        };
        return d;
      })();
      typeof define == 'function' && define.amd
        ? define(function () {
            return r;
          })
        : typeof t < 'u' && t != null
          ? (t.exports = r)
          : typeof angular < 'u' &&
            angular != null &&
            angular.module('LZString', []).factory('LZString', function () {
              return r;
            });
    },
  }),
  cb = J({
    '../node_modules/memoizerific/memoizerific.js'(e, t) {
      (function (r) {
        if (typeof e == 'object' && typeof t < 'u') t.exports = r();
        else if (typeof define == 'function' && define.amd) define([], r);
        else {
          var n;
          (typeof window < 'u'
            ? (n = window)
            : typeof global < 'u'
              ? (n = global)
              : typeof self < 'u'
                ? (n = self)
                : (n = this),
            (n.memoizerific = r()));
        }
      })(function () {
        return o(function r(n, i, s) {
          function a(u, p) {
            if (!i[u]) {
              if (!n[u]) {
                var f = typeof vs == 'function' && vs;
                if (!p && f) return f(u, !0);
                if (c) return c(u, !0);
                var y = new Error("Cannot find module '" + u + "'");
                throw ((y.code = 'MODULE_NOT_FOUND'), y);
              }
              var h = (i[u] = { exports: {} });
              n[u][0].call(
                h.exports,
                function (g) {
                  var T = n[u][1][g];
                  return a(T || g);
                },
                h,
                h.exports,
                r,
                n,
                i,
                s,
              );
            }
            return i[u].exports;
          }
          o(a, 's');
          for (var c = typeof vs == 'function' && vs, d = 0; d < s.length; d++) a(s[d]);
          return a;
        }, 'e')(
          {
            1: [
              function (r, n, i) {
                n.exports = function (s) {
                  if (typeof Map != 'function' || s) {
                    var a = r('./similar');
                    return new a();
                  } else return new Map();
                };
              },
              { './similar': 2 },
            ],
            2: [
              function (r, n, i) {
                function s() {
                  return ((this.list = []), (this.lastItem = void 0), (this.size = 0), this);
                }
                (o(s, 'Similar'),
                  (s.prototype.get = function (a) {
                    var c;
                    if (this.lastItem && this.isEqual(this.lastItem.key, a))
                      return this.lastItem.val;
                    if (((c = this.indexOf(a)), c >= 0))
                      return ((this.lastItem = this.list[c]), this.list[c].val);
                  }),
                  (s.prototype.set = function (a, c) {
                    var d;
                    return this.lastItem && this.isEqual(this.lastItem.key, a)
                      ? ((this.lastItem.val = c), this)
                      : ((d = this.indexOf(a)),
                        d >= 0
                          ? ((this.lastItem = this.list[d]), (this.list[d].val = c), this)
                          : ((this.lastItem = { key: a, val: c }),
                            this.list.push(this.lastItem),
                            this.size++,
                            this));
                  }),
                  (s.prototype.delete = function (a) {
                    var c;
                    if (
                      (this.lastItem &&
                        this.isEqual(this.lastItem.key, a) &&
                        (this.lastItem = void 0),
                      (c = this.indexOf(a)),
                      c >= 0)
                    )
                      return (this.size--, this.list.splice(c, 1)[0]);
                  }),
                  (s.prototype.has = function (a) {
                    var c;
                    return this.lastItem && this.isEqual(this.lastItem.key, a)
                      ? !0
                      : ((c = this.indexOf(a)), c >= 0 ? ((this.lastItem = this.list[c]), !0) : !1);
                  }),
                  (s.prototype.forEach = function (a, c) {
                    var d;
                    for (d = 0; d < this.size; d++)
                      a.call(c || this, this.list[d].val, this.list[d].key, this);
                  }),
                  (s.prototype.indexOf = function (a) {
                    var c;
                    for (c = 0; c < this.size; c++) if (this.isEqual(this.list[c].key, a)) return c;
                    return -1;
                  }),
                  (s.prototype.isEqual = function (a, c) {
                    return a === c || (a !== a && c !== c);
                  }),
                  (n.exports = s));
              },
              {},
            ],
            3: [
              function (r, n, i) {
                var s = r('map-or-similar');
                n.exports = function (u) {
                  var p = new s(!1),
                    f = [];
                  return function (y) {
                    var h = o(function () {
                      var g = p,
                        T,
                        E,
                        v = arguments.length - 1,
                        S = Array(v + 1),
                        A = !0,
                        N;
                      if ((h.numArgs || h.numArgs === 0) && h.numArgs !== v + 1)
                        throw new Error(
                          'Memoizerific functions should always be called with the same number of arguments',
                        );
                      for (N = 0; N < v; N++) {
                        if (((S[N] = { cacheItem: g, arg: arguments[N] }), g.has(arguments[N]))) {
                          g = g.get(arguments[N]);
                          continue;
                        }
                        ((A = !1), (T = new s(!1)), g.set(arguments[N], T), (g = T));
                      }
                      return (
                        A && (g.has(arguments[v]) ? (E = g.get(arguments[v])) : (A = !1)),
                        A || ((E = y.apply(null, arguments)), g.set(arguments[v], E)),
                        u > 0 &&
                          ((S[v] = { cacheItem: g, arg: arguments[v] }),
                          A ? a(f, S) : f.push(S),
                          f.length > u && c(f.shift())),
                        (h.wasMemoized = A),
                        (h.numArgs = v + 1),
                        E
                      );
                    }, 'memoizerific');
                    return ((h.limit = u), (h.wasMemoized = !1), (h.cache = p), (h.lru = f), h);
                  };
                };
                function a(u, p) {
                  var f = u.length,
                    y = p.length,
                    h,
                    g,
                    T;
                  for (g = 0; g < f; g++) {
                    for (h = !0, T = 0; T < y; T++)
                      if (!d(u[g][T].arg, p[T].arg)) {
                        h = !1;
                        break;
                      }
                    if (h) break;
                  }
                  u.push(u.splice(g, 1)[0]);
                }
                o(a, 'moveToMostRecentLru');
                function c(u) {
                  var p = u.length,
                    f = u[p - 1],
                    y,
                    h;
                  for (
                    f.cacheItem.delete(f.arg), h = p - 2;
                    h >= 0 && ((f = u[h]), (y = f.cacheItem.get(f.arg)), !y || !y.size);
                    h--
                  )
                    f.cacheItem.delete(f.arg);
                }
                o(c, 'removeCachedResult');
                function d(u, p) {
                  return u === p || (u !== u && p !== p);
                }
                o(d, 'isEqual');
              },
              { 'map-or-similar': 1 },
            ],
          },
          {},
          [3],
        )(3);
      });
    },
  }),
  ub = J({
    '../node_modules/picoquery/lib/string-util.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.encodeString = n));
      var t = Array.from(
          { length: 256 },
          (i, s) => '%' + ((s < 16 ? '0' : '') + s.toString(16)).toUpperCase(),
        ),
        r = new Int8Array([
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
          0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 0, 0, 0, 1, 0,
        ]);
      function n(i) {
        const s = i.length;
        if (s === 0) return '';
        let a = '',
          c = 0,
          d = 0;
        e: for (; d < s; d++) {
          let u = i.charCodeAt(d);
          for (; u < 128; ) {
            if (
              (r[u] !== 1 && (c < d && (a += i.slice(c, d)), (c = d + 1), (a += t[u])), ++d === s)
            )
              break e;
            u = i.charCodeAt(d);
          }
          if ((c < d && (a += i.slice(c, d)), u < 2048)) {
            ((c = d + 1), (a += t[192 | (u >> 6)] + t[128 | (u & 63)]));
            continue;
          }
          if (u < 55296 || u >= 57344) {
            ((c = d + 1), (a += t[224 | (u >> 12)] + t[128 | ((u >> 6) & 63)] + t[128 | (u & 63)]));
            continue;
          }
          if ((++d, d >= s)) throw new Error('URI malformed');
          const p = i.charCodeAt(d) & 1023;
          ((c = d + 1),
            (u = 65536 + (((u & 1023) << 10) | p)),
            (a +=
              t[240 | (u >> 18)] +
              t[128 | ((u >> 12) & 63)] +
              t[128 | ((u >> 6) & 63)] +
              t[128 | (u & 63)]));
        }
        return c === 0 ? i : c < s ? a + i.slice(c) : a;
      }
      o(n, 'encodeString');
    },
  }),
  Vd = J({
    '../node_modules/picoquery/lib/shared.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.defaultOptions = e.defaultShouldSerializeObject = e.defaultValueSerializer = void 0));
      var t = ub(),
        r = o((s) => {
          switch (typeof s) {
            case 'string':
              return (0, t.encodeString)(s);
            case 'bigint':
            case 'boolean':
              return '' + s;
            case 'number':
              if (Number.isFinite(s)) return s < 1e21 ? '' + s : (0, t.encodeString)('' + s);
              break;
          }
          return s instanceof Date ? (0, t.encodeString)(s.toISOString()) : '';
        }, 'defaultValueSerializer');
      e.defaultValueSerializer = r;
      var n = o((s) => s instanceof Date, 'defaultShouldSerializeObject');
      e.defaultShouldSerializeObject = n;
      var i = o((s) => s, 'identityFunc');
      e.defaultOptions = {
        nesting: !0,
        nestingSyntax: 'dot',
        arrayRepeat: !1,
        arrayRepeatSyntax: 'repeat',
        delimiter: 38,
        valueDeserializer: i,
        valueSerializer: e.defaultValueSerializer,
        keyDeserializer: i,
        shouldSerializeObject: e.defaultShouldSerializeObject,
      };
    },
  }),
  db = J({
    '../node_modules/picoquery/lib/object-util.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.getDeepObject = i),
        (e.stringifyObject = p));
      var t = Vd(),
        r = ub();
      function n(f) {
        return f === '__proto__' || f === 'constructor' || f === 'prototype';
      }
      o(n, 'isPrototypeKey');
      function i(f, y, h, g, T) {
        if (n(y)) return f;
        const E = f[y];
        return typeof E == 'object' && E !== null
          ? E
          : !g &&
              (T ||
                typeof h == 'number' ||
                (typeof h == 'string' && h * 0 === 0 && h.indexOf('.') === -1))
            ? (f[y] = [])
            : (f[y] = {});
      }
      o(i, 'getDeepObject');
      var s = 20,
        a = '[]',
        c = '[',
        d = ']',
        u = '.';
      function p(f, y, h = 0, g, T) {
        const {
            nestingSyntax: E = t.defaultOptions.nestingSyntax,
            arrayRepeat: v = t.defaultOptions.arrayRepeat,
            arrayRepeatSyntax: S = t.defaultOptions.arrayRepeatSyntax,
            nesting: A = t.defaultOptions.nesting,
            delimiter: N = t.defaultOptions.delimiter,
            valueSerializer: j = t.defaultOptions.valueSerializer,
            shouldSerializeObject: C = t.defaultOptions.shouldSerializeObject,
          } = y,
          R = typeof N == 'number' ? String.fromCharCode(N) : N,
          w = T === !0 && v,
          _ = E === 'dot' || (E === 'js' && !T);
        if (h > s) return '';
        let k = '',
          I = !0,
          V = !1;
        for (const H in f) {
          const P = f[H];
          if (P === void 0) continue;
          let L;
          (g
            ? ((L = g),
              w
                ? S === 'bracket' && (L += a)
                : _
                  ? ((L += u), (L += H))
                  : ((L += c), (L += H), (L += d)))
            : (L = H),
            I || (k += R),
            typeof P == 'object' && P !== null && !C(P)
              ? ((V = P.pop !== void 0), (A || (v && V)) && (k += p(P, y, h + 1, L, V)))
              : ((k += (0, r.encodeString)(L)), (k += '='), (k += j(P, H))),
            I && (I = !1));
        }
        return k;
      }
      o(p, 'stringifyObject');
    },
  }),
  mj = J({
    '../node_modules/picoquery/lib/decode-uri-component.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.decodeURIComponent = i));
      var t = 12,
        r = 0,
        n = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
          5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,
          10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,
          0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7,
        ];
      function i(c) {
        let d = c.indexOf('%');
        if (d === -1) return c;
        const u = c.length;
        let p = '',
          f = 0,
          y = 0,
          h = d,
          g = t;
        for (; d > -1 && d < u; ) {
          const T = a(c[d + 1], 4),
            E = a(c[d + 2], 0),
            v = T | E,
            S = n[v];
          if (((g = n[256 + g + S]), (y = (y << 6) | (v & n[364 + S])), g === t))
            ((p += c.slice(f, h)),
              (p +=
                y <= 65535
                  ? String.fromCharCode(y)
                  : String.fromCharCode(55232 + (y >> 10), 56320 + (y & 1023))),
              (y = 0),
              (f = d + 3),
              (d = h = c.indexOf('%', f)));
          else {
            if (g === r) return null;
            if (((d += 3), d < u && c.charCodeAt(d) === 37)) continue;
            return null;
          }
        }
        return p + c.slice(f);
      }
      o(i, 'decodeURIComponent');
      var s = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15,
      };
      function a(c, d) {
        const u = s[c];
        return u === void 0 ? 255 : u << d;
      }
      o(a, 'hexCodeToInt');
    },
  }),
  yj = J({
    '../node_modules/picoquery/lib/parse.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.numberValueDeserializer = e.numberKeyDeserializer = void 0),
        (e.parse = u));
      var t = db(),
        r = Vd(),
        n = mj(),
        i = o((p) => {
          const f = Number(p);
          return Number.isNaN(f) ? p : f;
        }, 'numberKeyDeserializer');
      e.numberKeyDeserializer = i;
      var s = o((p) => {
        const f = Number(p);
        return Number.isNaN(f) ? p : f;
      }, 'numberValueDeserializer');
      e.numberValueDeserializer = s;
      var a = /\+/g,
        c = o(function () {}, 'Empty');
      c.prototype = Object.create(null);
      function d(p, f, y, h, g) {
        let T = p.substring(f, y);
        return (h && (T = T.replace(a, ' ')), g && (T = (0, n.decodeURIComponent)(T) || T), T);
      }
      o(d, 'computeKeySlice');
      function u(p, f) {
        const {
            valueDeserializer: y = r.defaultOptions.valueDeserializer,
            keyDeserializer: h = r.defaultOptions.keyDeserializer,
            arrayRepeatSyntax: g = r.defaultOptions.arrayRepeatSyntax,
            nesting: T = r.defaultOptions.nesting,
            arrayRepeat: E = r.defaultOptions.arrayRepeat,
            nestingSyntax: v = r.defaultOptions.nestingSyntax,
            delimiter: S = r.defaultOptions.delimiter,
          } = f ?? {},
          A = typeof S == 'string' ? S.charCodeAt(0) : S,
          N = v === 'js',
          j = new c();
        if (typeof p != 'string') return j;
        const C = p.length;
        let R = '',
          w = -1,
          _ = -1,
          k = -1,
          I = j,
          V,
          H = '',
          P = '',
          L = !1,
          B = !1,
          D = !1,
          K = !1,
          X = !1,
          ie = !1,
          se = 0,
          W = -1,
          ae = -1,
          be = -1;
        for (let ue = 0; ue < C + 1; ue++) {
          if (((se = ue !== C ? p.charCodeAt(ue) : A), se === A)) {
            if (
              ((ie = _ > w),
              ie || (_ = ue),
              k !== _ - 1 &&
                ((P = d(p, k + 1, W > -1 ? W : _, D, L)),
                (H = h(P)),
                V !== void 0 && (I = (0, t.getDeepObject)(I, V, H, N && X, void 0))),
              ie || H !== '')
            ) {
              ie &&
                ((R = p.slice(_ + 1, ue)),
                K && (R = R.replace(a, ' ')),
                B && (R = (0, n.decodeURIComponent)(R) || R));
              const ee = y(R, H);
              if (E) {
                const Ae = I[H];
                Ae === void 0
                  ? W > -1
                    ? (I[H] = [ee])
                    : (I[H] = ee)
                  : Ae.pop
                    ? Ae.push(ee)
                    : (I[H] = [Ae, ee]);
              } else I[H] = ee;
            }
            ((R = ''),
              (w = ue),
              (_ = ue),
              (L = !1),
              (B = !1),
              (D = !1),
              (K = !1),
              (X = !1),
              (W = -1),
              (k = ue),
              (I = j),
              (V = void 0),
              (H = ''));
          } else
            se === 93
              ? (E && g === 'bracket' && be === 91 && (W = ae),
                T &&
                  (v === 'index' || N) &&
                  _ <= w &&
                  (k !== ae &&
                    ((P = d(p, k + 1, ue, D, L)),
                    (H = h(P)),
                    V !== void 0 && (I = (0, t.getDeepObject)(I, V, H, void 0, void 0)),
                    (V = H),
                    (D = !1),
                    (L = !1)),
                  (k = ue),
                  (X = !1)))
              : se === 46
                ? T &&
                  (v === 'dot' || N) &&
                  _ <= w &&
                  (k !== ae &&
                    ((P = d(p, k + 1, ue, D, L)),
                    (H = h(P)),
                    V !== void 0 && (I = (0, t.getDeepObject)(I, V, H, N)),
                    (V = H),
                    (D = !1),
                    (L = !1)),
                  (X = !0),
                  (k = ue))
                : se === 91
                  ? T &&
                    (v === 'index' || N) &&
                    _ <= w &&
                    (k !== ae &&
                      ((P = d(p, k + 1, ue, D, L)),
                      (H = h(P)),
                      N && V !== void 0 && (I = (0, t.getDeepObject)(I, V, H, N)),
                      (V = H),
                      (D = !1),
                      (L = !1),
                      (X = !1)),
                    (k = ue))
                  : se === 61
                    ? _ <= w
                      ? (_ = ue)
                      : (B = !0)
                    : se === 43
                      ? _ > w
                        ? (K = !0)
                        : (D = !0)
                      : se === 37 && (_ > w ? (B = !0) : (L = !0));
          ((ae = ue), (be = se));
        }
        return j;
      }
      o(u, 'parse');
    },
  }),
  hj = J({
    '../node_modules/picoquery/lib/stringify.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.stringify = r));
      var t = db();
      function r(n, i) {
        if (n === null || typeof n != 'object') return '';
        const s = i ?? {};
        return (0, t.stringifyObject)(n, s);
      }
      o(r, 'stringify');
    },
  }),
  Hd = J({
    '../node_modules/picoquery/lib/main.js'(e) {
      var t =
          (e && e.__createBinding) ||
          (Object.create
            ? function (s, a, c, d) {
                d === void 0 && (d = c);
                var u = Object.getOwnPropertyDescriptor(a, c);
                ((!u || ('get' in u ? !a.__esModule : u.writable || u.configurable)) &&
                  (u = {
                    enumerable: !0,
                    get: o(function () {
                      return a[c];
                    }, 'get'),
                  }),
                  Object.defineProperty(s, d, u));
              }
            : function (s, a, c, d) {
                (d === void 0 && (d = c), (s[d] = a[c]));
              }),
        r =
          (e && e.__exportStar) ||
          function (s, a) {
            for (var c in s)
              c !== 'default' && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
          };
      (Object.defineProperty(e, '__esModule', { value: !0 }), (e.stringify = e.parse = void 0));
      var n = yj();
      Object.defineProperty(e, 'parse', {
        enumerable: !0,
        get: o(function () {
          return n.parse;
        }, 'get'),
      });
      var i = hj();
      (Object.defineProperty(e, 'stringify', {
        enumerable: !0,
        get: o(function () {
          return i.stringify;
        }, 'get'),
      }),
        r(Vd(), e));
    },
  }),
  pb = J({
    '../node_modules/entities/lib/maps/entities.json'(e, t) {
      t.exports = {
        Aacute: '',
        aacute: '',
        Abreve: '',
        abreve: '',
        ac: '',
        acd: '',
        acE: '',
        Acirc: '',
        acirc: '',
        acute: '',
        Acy: '',
        acy: '',
        AElig: '',
        aelig: '',
        af: '',
        Afr: '',
        afr: '',
        Agrave: '',
        agrave: '',
        alefsym: '',
        aleph: '',
        Alpha: '',
        alpha: '',
        Amacr: '',
        amacr: '',
        amalg: '',
        amp: '&',
        AMP: '&',
        andand: '',
        And: '',
        and: '',
        andd: '',
        andslope: '',
        andv: '',
        ang: '',
        ange: '',
        angle: '',
        angmsdaa: '',
        angmsdab: '',
        angmsdac: '',
        angmsdad: '',
        angmsdae: '',
        angmsdaf: '',
        angmsdag: '',
        angmsdah: '',
        angmsd: '',
        angrt: '',
        angrtvb: '',
        angrtvbd: '',
        angsph: '',
        angst: '',
        angzarr: '',
        Aogon: '',
        aogon: '',
        Aopf: '',
        aopf: '',
        apacir: '',
        ap: '',
        apE: '',
        ape: '',
        apid: '',
        apos: "'",
        ApplyFunction: '',
        approx: '',
        approxeq: '',
        Aring: '',
        aring: '',
        Ascr: '',
        ascr: '',
        Assign: '',
        ast: '*',
        asymp: '',
        asympeq: '',
        Atilde: '',
        atilde: '',
        Auml: '',
        auml: '',
        awconint: '',
        awint: '',
        backcong: '',
        backepsilon: '',
        backprime: '',
        backsim: '',
        backsimeq: '',
        Backslash: '',
        Barv: '',
        barvee: '',
        barwed: '',
        Barwed: '',
        barwedge: '',
        bbrk: '',
        bbrktbrk: '',
        bcong: '',
        Bcy: '',
        bcy: '',
        bdquo: '',
        becaus: '',
        because: '',
        Because: '',
        bemptyv: '',
        bepsi: '',
        bernou: '',
        Bernoullis: '',
        Beta: '',
        beta: '',
        beth: '',
        between: '',
        Bfr: '',
        bfr: '',
        bigcap: '',
        bigcirc: '',
        bigcup: '',
        bigodot: '',
        bigoplus: '',
        bigotimes: '',
        bigsqcup: '',
        bigstar: '',
        bigtriangledown: '',
        bigtriangleup: '',
        biguplus: '',
        bigvee: '',
        bigwedge: '',
        bkarow: '',
        blacklozenge: '',
        blacksquare: '',
        blacktriangle: '',
        blacktriangledown: '',
        blacktriangleleft: '',
        blacktriangleright: '',
        blank: '',
        blk12: '',
        blk14: '',
        blk34: '',
        block: '',
        bne: '=',
        bnequiv: '',
        bNot: '',
        bnot: '',
        Bopf: '',
        bopf: '',
        bot: '',
        bottom: '',
        bowtie: '',
        boxbox: '',
        boxdl: '',
        boxdL: '',
        boxDl: '',
        boxDL: '',
        boxdr: '',
        boxdR: '',
        boxDr: '',
        boxDR: '',
        boxh: '',
        boxH: '',
        boxhd: '',
        boxHd: '',
        boxhD: '',
        boxHD: '',
        boxhu: '',
        boxHu: '',
        boxhU: '',
        boxHU: '',
        boxminus: '',
        boxplus: '',
        boxtimes: '',
        boxul: '',
        boxuL: '',
        boxUl: '',
        boxUL: '',
        boxur: '',
        boxuR: '',
        boxUr: '',
        boxUR: '',
        boxv: '',
        boxV: '',
        boxvh: '',
        boxvH: '',
        boxVh: '',
        boxVH: '',
        boxvl: '',
        boxvL: '',
        boxVl: '',
        boxVL: '',
        boxvr: '',
        boxvR: '',
        boxVr: '',
        boxVR: '',
        bprime: '',
        breve: '',
        Breve: '',
        brvbar: '',
        bscr: '',
        Bscr: '',
        bsemi: '',
        bsim: '',
        bsime: '',
        bsolb: '',
        bsol: '\\',
        bsolhsub: '',
        bull: '',
        bullet: '',
        bump: '',
        bumpE: '',
        bumpe: '',
        Bumpeq: '',
        bumpeq: '',
        Cacute: '',
        cacute: '',
        capand: '',
        capbrcup: '',
        capcap: '',
        cap: '',
        Cap: '',
        capcup: '',
        capdot: '',
        CapitalDifferentialD: '',
        caps: '',
        caret: '',
        caron: '',
        Cayleys: '',
        ccaps: '',
        Ccaron: '',
        ccaron: '',
        Ccedil: '',
        ccedil: '',
        Ccirc: '',
        ccirc: '',
        Cconint: '',
        ccups: '',
        ccupssm: '',
        Cdot: '',
        cdot: '',
        cedil: '',
        Cedilla: '',
        cemptyv: '',
        cent: '',
        centerdot: '',
        CenterDot: '',
        cfr: '',
        Cfr: '',
        CHcy: '',
        chcy: '',
        check: '',
        checkmark: '',
        Chi: '',
        chi: '',
        circ: '',
        circeq: '',
        circlearrowleft: '',
        circlearrowright: '',
        circledast: '',
        circledcirc: '',
        circleddash: '',
        CircleDot: '',
        circledR: '',
        circledS: '',
        CircleMinus: '',
        CirclePlus: '',
        CircleTimes: '',
        cir: '',
        cirE: '',
        cire: '',
        cirfnint: '',
        cirmid: '',
        cirscir: '',
        ClockwiseContourIntegral: '',
        CloseCurlyDoubleQuote: '',
        CloseCurlyQuote: '',
        clubs: '',
        clubsuit: '',
        colon: ':',
        Colon: '',
        Colone: '',
        colone: '',
        coloneq: '',
        comma: ',',
        commat: '@',
        comp: '',
        compfn: '',
        complement: '',
        complexes: '',
        cong: '',
        congdot: '',
        Congruent: '',
        conint: '',
        Conint: '',
        ContourIntegral: '',
        copf: '',
        Copf: '',
        coprod: '',
        Coproduct: '',
        copy: '',
        COPY: '',
        copysr: '',
        CounterClockwiseContourIntegral: '',
        crarr: '',
        cross: '',
        Cross: '',
        Cscr: '',
        cscr: '',
        csub: '',
        csube: '',
        csup: '',
        csupe: '',
        ctdot: '',
        cudarrl: '',
        cudarrr: '',
        cuepr: '',
        cuesc: '',
        cularr: '',
        cularrp: '',
        cupbrcap: '',
        cupcap: '',
        CupCap: '',
        cup: '',
        Cup: '',
        cupcup: '',
        cupdot: '',
        cupor: '',
        cups: '',
        curarr: '',
        curarrm: '',
        curlyeqprec: '',
        curlyeqsucc: '',
        curlyvee: '',
        curlywedge: '',
        curren: '',
        curvearrowleft: '',
        curvearrowright: '',
        cuvee: '',
        cuwed: '',
        cwconint: '',
        cwint: '',
        cylcty: '',
        dagger: '',
        Dagger: '',
        daleth: '',
        darr: '',
        Darr: '',
        dArr: '',
        dash: '',
        Dashv: '',
        dashv: '',
        dbkarow: '',
        dblac: '',
        Dcaron: '',
        dcaron: '',
        Dcy: '',
        dcy: '',
        ddagger: '',
        ddarr: '',
        DD: '',
        dd: '',
        DDotrahd: '',
        ddotseq: '',
        deg: '',
        Del: '',
        Delta: '',
        delta: '',
        demptyv: '',
        dfisht: '',
        Dfr: '',
        dfr: '',
        dHar: '',
        dharl: '',
        dharr: '',
        DiacriticalAcute: '',
        DiacriticalDot: '',
        DiacriticalDoubleAcute: '',
        DiacriticalGrave: '`',
        DiacriticalTilde: '',
        diam: '',
        diamond: '',
        Diamond: '',
        diamondsuit: '',
        diams: '',
        die: '',
        DifferentialD: '',
        digamma: '',
        disin: '',
        div: '',
        divide: '',
        divideontimes: '',
        divonx: '',
        DJcy: '',
        djcy: '',
        dlcorn: '',
        dlcrop: '',
        dollar: '$',
        Dopf: '',
        dopf: '',
        Dot: '',
        dot: '',
        DotDot: '',
        doteq: '',
        doteqdot: '',
        DotEqual: '',
        dotminus: '',
        dotplus: '',
        dotsquare: '',
        doublebarwedge: '',
        DoubleContourIntegral: '',
        DoubleDot: '',
        DoubleDownArrow: '',
        DoubleLeftArrow: '',
        DoubleLeftRightArrow: '',
        DoubleLeftTee: '',
        DoubleLongLeftArrow: '',
        DoubleLongLeftRightArrow: '',
        DoubleLongRightArrow: '',
        DoubleRightArrow: '',
        DoubleRightTee: '',
        DoubleUpArrow: '',
        DoubleUpDownArrow: '',
        DoubleVerticalBar: '',
        DownArrowBar: '',
        downarrow: '',
        DownArrow: '',
        Downarrow: '',
        DownArrowUpArrow: '',
        DownBreve: '',
        downdownarrows: '',
        downharpoonleft: '',
        downharpoonright: '',
        DownLeftRightVector: '',
        DownLeftTeeVector: '',
        DownLeftVectorBar: '',
        DownLeftVector: '',
        DownRightTeeVector: '',
        DownRightVectorBar: '',
        DownRightVector: '',
        DownTeeArrow: '',
        DownTee: '',
        drbkarow: '',
        drcorn: '',
        drcrop: '',
        Dscr: '',
        dscr: '',
        DScy: '',
        dscy: '',
        dsol: '',
        Dstrok: '',
        dstrok: '',
        dtdot: '',
        dtri: '',
        dtrif: '',
        duarr: '',
        duhar: '',
        dwangle: '',
        DZcy: '',
        dzcy: '',
        dzigrarr: '',
        Eacute: '',
        eacute: '',
        easter: '',
        Ecaron: '',
        ecaron: '',
        Ecirc: '',
        ecirc: '',
        ecir: '',
        ecolon: '',
        Ecy: '',
        ecy: '',
        eDDot: '',
        Edot: '',
        edot: '',
        eDot: '',
        ee: '',
        efDot: '',
        Efr: '',
        efr: '',
        eg: '',
        Egrave: '',
        egrave: '',
        egs: '',
        egsdot: '',
        el: '',
        Element: '',
        elinters: '',
        ell: '',
        els: '',
        elsdot: '',
        Emacr: '',
        emacr: '',
        empty: '',
        emptyset: '',
        EmptySmallSquare: '',
        emptyv: '',
        EmptyVerySmallSquare: '',
        emsp13: '',
        emsp14: '',
        emsp: '',
        ENG: '',
        eng: '',
        ensp: '',
        Eogon: '',
        eogon: '',
        Eopf: '',
        eopf: '',
        epar: '',
        eparsl: '',
        eplus: '',
        epsi: '',
        Epsilon: '',
        epsilon: '',
        epsiv: '',
        eqcirc: '',
        eqcolon: '',
        eqsim: '',
        eqslantgtr: '',
        eqslantless: '',
        Equal: '',
        equals: '=',
        EqualTilde: '',
        equest: '',
        Equilibrium: '',
        equiv: '',
        equivDD: '',
        eqvparsl: '',
        erarr: '',
        erDot: '',
        escr: '',
        Escr: '',
        esdot: '',
        Esim: '',
        esim: '',
        Eta: '',
        eta: '',
        ETH: '',
        eth: '',
        Euml: '',
        euml: '',
        euro: '',
        excl: '!',
        exist: '',
        Exists: '',
        expectation: '',
        exponentiale: '',
        ExponentialE: '',
        fallingdotseq: '',
        Fcy: '',
        fcy: '',
        female: '',
        ffilig: '',
        fflig: '',
        ffllig: '',
        Ffr: '',
        ffr: '',
        filig: '',
        FilledSmallSquare: '',
        FilledVerySmallSquare: '',
        fjlig: 'fj',
        flat: '',
        fllig: '',
        fltns: '',
        fnof: '',
        Fopf: '',
        fopf: '',
        forall: '',
        ForAll: '',
        fork: '',
        forkv: '',
        Fouriertrf: '',
        fpartint: '',
        frac12: '',
        frac13: '',
        frac14: '',
        frac15: '',
        frac16: '',
        frac18: '',
        frac23: '',
        frac25: '',
        frac34: '',
        frac35: '',
        frac38: '',
        frac45: '',
        frac56: '',
        frac58: '',
        frac78: '',
        frasl: '',
        frown: '',
        fscr: '',
        Fscr: '',
        gacute: '',
        Gamma: '',
        gamma: '',
        Gammad: '',
        gammad: '',
        gap: '',
        Gbreve: '',
        gbreve: '',
        Gcedil: '',
        Gcirc: '',
        gcirc: '',
        Gcy: '',
        gcy: '',
        Gdot: '',
        gdot: '',
        ge: '',
        gE: '',
        gEl: '',
        gel: '',
        geq: '',
        geqq: '',
        geqslant: '',
        gescc: '',
        ges: '',
        gesdot: '',
        gesdoto: '',
        gesdotol: '',
        gesl: '',
        gesles: '',
        Gfr: '',
        gfr: '',
        gg: '',
        Gg: '',
        ggg: '',
        gimel: '',
        GJcy: '',
        gjcy: '',
        gla: '',
        gl: '',
        glE: '',
        glj: '',
        gnap: '',
        gnapprox: '',
        gne: '',
        gnE: '',
        gneq: '',
        gneqq: '',
        gnsim: '',
        Gopf: '',
        gopf: '',
        grave: '`',
        GreaterEqual: '',
        GreaterEqualLess: '',
        GreaterFullEqual: '',
        GreaterGreater: '',
        GreaterLess: '',
        GreaterSlantEqual: '',
        GreaterTilde: '',
        Gscr: '',
        gscr: '',
        gsim: '',
        gsime: '',
        gsiml: '',
        gtcc: '',
        gtcir: '',
        gt: '>',
        GT: '>',
        Gt: '',
        gtdot: '',
        gtlPar: '',
        gtquest: '',
        gtrapprox: '',
        gtrarr: '',
        gtrdot: '',
        gtreqless: '',
        gtreqqless: '',
        gtrless: '',
        gtrsim: '',
        gvertneqq: '',
        gvnE: '',
        Hacek: '',
        hairsp: '',
        half: '',
        hamilt: '',
        HARDcy: '',
        hardcy: '',
        harrcir: '',
        harr: '',
        hArr: '',
        harrw: '',
        Hat: '^',
        hbar: '',
        Hcirc: '',
        hcirc: '',
        hearts: '',
        heartsuit: '',
        hellip: '',
        hercon: '',
        hfr: '',
        Hfr: '',
        HilbertSpace: '',
        hksearow: '',
        hkswarow: '',
        hoarr: '',
        homtht: '',
        hookleftarrow: '',
        hookrightarrow: '',
        hopf: '',
        Hopf: '',
        horbar: '',
        HorizontalLine: '',
        hscr: '',
        Hscr: '',
        hslash: '',
        Hstrok: '',
        hstrok: '',
        HumpDownHump: '',
        HumpEqual: '',
        hybull: '',
        hyphen: '',
        Iacute: '',
        iacute: '',
        ic: '',
        Icirc: '',
        icirc: '',
        Icy: '',
        icy: '',
        Idot: '',
        IEcy: '',
        iecy: '',
        iexcl: '',
        iff: '',
        ifr: '',
        Ifr: '',
        Igrave: '',
        igrave: '',
        ii: '',
        iiiint: '',
        iiint: '',
        iinfin: '',
        iiota: '',
        IJlig: '',
        ijlig: '',
        Imacr: '',
        imacr: '',
        image: '',
        ImaginaryI: '',
        imagline: '',
        imagpart: '',
        imath: '',
        Im: '',
        imof: '',
        imped: '',
        Implies: '',
        incare: '',
        in: '',
        infin: '',
        infintie: '',
        inodot: '',
        intcal: '',
        int: '',
        Int: '',
        integers: '',
        Integral: '',
        intercal: '',
        Intersection: '',
        intlarhk: '',
        intprod: '',
        InvisibleComma: '',
        InvisibleTimes: '',
        IOcy: '',
        iocy: '',
        Iogon: '',
        iogon: '',
        Iopf: '',
        iopf: '',
        Iota: '',
        iota: '',
        iprod: '',
        iquest: '',
        iscr: '',
        Iscr: '',
        isin: '',
        isindot: '',
        isinE: '',
        isins: '',
        isinsv: '',
        isinv: '',
        it: '',
        Itilde: '',
        itilde: '',
        Iukcy: '',
        iukcy: '',
        Iuml: '',
        iuml: '',
        Jcirc: '',
        jcirc: '',
        Jcy: '',
        jcy: '',
        Jfr: '',
        jfr: '',
        jmath: '',
        Jopf: '',
        jopf: '',
        Jscr: '',
        jscr: '',
        Jsercy: '',
        jsercy: '',
        Jukcy: '',
        jukcy: '',
        Kappa: '',
        kappa: '',
        kappav: '',
        Kcedil: '',
        kcedil: '',
        Kcy: '',
        kcy: '',
        Kfr: '',
        kfr: '',
        kgreen: '',
        KHcy: '',
        khcy: '',
        KJcy: '',
        kjcy: '',
        Kopf: '',
        kopf: '',
        Kscr: '',
        kscr: '',
        lAarr: '',
        Lacute: '',
        lacute: '',
        laemptyv: '',
        lagran: '',
        Lambda: '',
        lambda: '',
        lang: '',
        Lang: '',
        langd: '',
        langle: '',
        lap: '',
        Laplacetrf: '',
        laquo: '',
        larrb: '',
        larrbfs: '',
        larr: '',
        Larr: '',
        lArr: '',
        larrfs: '',
        larrhk: '',
        larrlp: '',
        larrpl: '',
        larrsim: '',
        larrtl: '',
        latail: '',
        lAtail: '',
        lat: '',
        late: '',
        lates: '',
        lbarr: '',
        lBarr: '',
        lbbrk: '',
        lbrace: '{',
        lbrack: '[',
        lbrke: '',
        lbrksld: '',
        lbrkslu: '',
        Lcaron: '',
        lcaron: '',
        Lcedil: '',
        lcedil: '',
        lceil: '',
        lcub: '{',
        Lcy: '',
        lcy: '',
        ldca: '',
        ldquo: '',
        ldquor: '',
        ldrdhar: '',
        ldrushar: '',
        ldsh: '',
        le: '',
        lE: '',
        LeftAngleBracket: '',
        LeftArrowBar: '',
        leftarrow: '',
        LeftArrow: '',
        Leftarrow: '',
        LeftArrowRightArrow: '',
        leftarrowtail: '',
        LeftCeiling: '',
        LeftDoubleBracket: '',
        LeftDownTeeVector: '',
        LeftDownVectorBar: '',
        LeftDownVector: '',
        LeftFloor: '',
        leftharpoondown: '',
        leftharpoonup: '',
        leftleftarrows: '',
        leftrightarrow: '',
        LeftRightArrow: '',
        Leftrightarrow: '',
        leftrightarrows: '',
        leftrightharpoons: '',
        leftrightsquigarrow: '',
        LeftRightVector: '',
        LeftTeeArrow: '',
        LeftTee: '',
        LeftTeeVector: '',
        leftthreetimes: '',
        LeftTriangleBar: '',
        LeftTriangle: '',
        LeftTriangleEqual: '',
        LeftUpDownVector: '',
        LeftUpTeeVector: '',
        LeftUpVectorBar: '',
        LeftUpVector: '',
        LeftVectorBar: '',
        LeftVector: '',
        lEg: '',
        leg: '',
        leq: '',
        leqq: '',
        leqslant: '',
        lescc: '',
        les: '',
        lesdot: '',
        lesdoto: '',
        lesdotor: '',
        lesg: '',
        lesges: '',
        lessapprox: '',
        lessdot: '',
        lesseqgtr: '',
        lesseqqgtr: '',
        LessEqualGreater: '',
        LessFullEqual: '',
        LessGreater: '',
        lessgtr: '',
        LessLess: '',
        lesssim: '',
        LessSlantEqual: '',
        LessTilde: '',
        lfisht: '',
        lfloor: '',
        Lfr: '',
        lfr: '',
        lg: '',
        lgE: '',
        lHar: '',
        lhard: '',
        lharu: '',
        lharul: '',
        lhblk: '',
        LJcy: '',
        ljcy: '',
        llarr: '',
        ll: '',
        Ll: '',
        llcorner: '',
        Lleftarrow: '',
        llhard: '',
        lltri: '',
        Lmidot: '',
        lmidot: '',
        lmoustache: '',
        lmoust: '',
        lnap: '',
        lnapprox: '',
        lne: '',
        lnE: '',
        lneq: '',
        lneqq: '',
        lnsim: '',
        loang: '',
        loarr: '',
        lobrk: '',
        longleftarrow: '',
        LongLeftArrow: '',
        Longleftarrow: '',
        longleftrightarrow: '',
        LongLeftRightArrow: '',
        Longleftrightarrow: '',
        longmapsto: '',
        longrightarrow: '',
        LongRightArrow: '',
        Longrightarrow: '',
        looparrowleft: '',
        looparrowright: '',
        lopar: '',
        Lopf: '',
        lopf: '',
        loplus: '',
        lotimes: '',
        lowast: '',
        lowbar: '_',
        LowerLeftArrow: '',
        LowerRightArrow: '',
        loz: '',
        lozenge: '',
        lozf: '',
        lpar: '(',
        lparlt: '',
        lrarr: '',
        lrcorner: '',
        lrhar: '',
        lrhard: '',
        lrm: '',
        lrtri: '',
        lsaquo: '',
        lscr: '',
        Lscr: '',
        lsh: '',
        Lsh: '',
        lsim: '',
        lsime: '',
        lsimg: '',
        lsqb: '[',
        lsquo: '',
        lsquor: '',
        Lstrok: '',
        lstrok: '',
        ltcc: '',
        ltcir: '',
        lt: '<',
        LT: '<',
        Lt: '',
        ltdot: '',
        lthree: '',
        ltimes: '',
        ltlarr: '',
        ltquest: '',
        ltri: '',
        ltrie: '',
        ltrif: '',
        ltrPar: '',
        lurdshar: '',
        luruhar: '',
        lvertneqq: '',
        lvnE: '',
        macr: '',
        male: '',
        malt: '',
        maltese: '',
        Map: '',
        map: '',
        mapsto: '',
        mapstodown: '',
        mapstoleft: '',
        mapstoup: '',
        marker: '',
        mcomma: '',
        Mcy: '',
        mcy: '',
        mdash: '',
        mDDot: '',
        measuredangle: '',
        MediumSpace: '',
        Mellintrf: '',
        Mfr: '',
        mfr: '',
        mho: '',
        micro: '',
        midast: '*',
        midcir: '',
        mid: '',
        middot: '',
        minusb: '',
        minus: '',
        minusd: '',
        minusdu: '',
        MinusPlus: '',
        mlcp: '',
        mldr: '',
        mnplus: '',
        models: '',
        Mopf: '',
        mopf: '',
        mp: '',
        mscr: '',
        Mscr: '',
        mstpos: '',
        Mu: '',
        mu: '',
        multimap: '',
        mumap: '',
        nabla: '',
        Nacute: '',
        nacute: '',
        nang: '',
        nap: '',
        napE: '',
        napid: '',
        napos: '',
        napprox: '',
        natural: '',
        naturals: '',
        natur: '',
        nbsp: '',
        nbump: '',
        nbumpe: '',
        ncap: '',
        Ncaron: '',
        ncaron: '',
        Ncedil: '',
        ncedil: '',
        ncong: '',
        ncongdot: '',
        ncup: '',
        Ncy: '',
        ncy: '',
        ndash: '',
        nearhk: '',
        nearr: '',
        neArr: '',
        nearrow: '',
        ne: '',
        nedot: '',
        NegativeMediumSpace: '',
        NegativeThickSpace: '',
        NegativeThinSpace: '',
        NegativeVeryThinSpace: '',
        nequiv: '',
        nesear: '',
        nesim: '',
        NestedGreaterGreater: '',
        NestedLessLess: '',
        NewLine: `
`,
        nexist: '',
        nexists: '',
        Nfr: '',
        nfr: '',
        ngE: '',
        nge: '',
        ngeq: '',
        ngeqq: '',
        ngeqslant: '',
        nges: '',
        nGg: '',
        ngsim: '',
        nGt: '',
        ngt: '',
        ngtr: '',
        nGtv: '',
        nharr: '',
        nhArr: '',
        nhpar: '',
        ni: '',
        nis: '',
        nisd: '',
        niv: '',
        NJcy: '',
        njcy: '',
        nlarr: '',
        nlArr: '',
        nldr: '',
        nlE: '',
        nle: '',
        nleftarrow: '',
        nLeftarrow: '',
        nleftrightarrow: '',
        nLeftrightarrow: '',
        nleq: '',
        nleqq: '',
        nleqslant: '',
        nles: '',
        nless: '',
        nLl: '',
        nlsim: '',
        nLt: '',
        nlt: '',
        nltri: '',
        nltrie: '',
        nLtv: '',
        nmid: '',
        NoBreak: '',
        NonBreakingSpace: '',
        nopf: '',
        Nopf: '',
        Not: '',
        not: '',
        NotCongruent: '',
        NotCupCap: '',
        NotDoubleVerticalBar: '',
        NotElement: '',
        NotEqual: '',
        NotEqualTilde: '',
        NotExists: '',
        NotGreater: '',
        NotGreaterEqual: '',
        NotGreaterFullEqual: '',
        NotGreaterGreater: '',
        NotGreaterLess: '',
        NotGreaterSlantEqual: '',
        NotGreaterTilde: '',
        NotHumpDownHump: '',
        NotHumpEqual: '',
        notin: '',
        notindot: '',
        notinE: '',
        notinva: '',
        notinvb: '',
        notinvc: '',
        NotLeftTriangleBar: '',
        NotLeftTriangle: '',
        NotLeftTriangleEqual: '',
        NotLess: '',
        NotLessEqual: '',
        NotLessGreater: '',
        NotLessLess: '',
        NotLessSlantEqual: '',
        NotLessTilde: '',
        NotNestedGreaterGreater: '',
        NotNestedLessLess: '',
        notni: '',
        notniva: '',
        notnivb: '',
        notnivc: '',
        NotPrecedes: '',
        NotPrecedesEqual: '',
        NotPrecedesSlantEqual: '',
        NotReverseElement: '',
        NotRightTriangleBar: '',
        NotRightTriangle: '',
        NotRightTriangleEqual: '',
        NotSquareSubset: '',
        NotSquareSubsetEqual: '',
        NotSquareSuperset: '',
        NotSquareSupersetEqual: '',
        NotSubset: '',
        NotSubsetEqual: '',
        NotSucceeds: '',
        NotSucceedsEqual: '',
        NotSucceedsSlantEqual: '',
        NotSucceedsTilde: '',
        NotSuperset: '',
        NotSupersetEqual: '',
        NotTilde: '',
        NotTildeEqual: '',
        NotTildeFullEqual: '',
        NotTildeTilde: '',
        NotVerticalBar: '',
        nparallel: '',
        npar: '',
        nparsl: '',
        npart: '',
        npolint: '',
        npr: '',
        nprcue: '',
        nprec: '',
        npreceq: '',
        npre: '',
        nrarrc: '',
        nrarr: '',
        nrArr: '',
        nrarrw: '',
        nrightarrow: '',
        nRightarrow: '',
        nrtri: '',
        nrtrie: '',
        nsc: '',
        nsccue: '',
        nsce: '',
        Nscr: '',
        nscr: '',
        nshortmid: '',
        nshortparallel: '',
        nsim: '',
        nsime: '',
        nsimeq: '',
        nsmid: '',
        nspar: '',
        nsqsube: '',
        nsqsupe: '',
        nsub: '',
        nsubE: '',
        nsube: '',
        nsubset: '',
        nsubseteq: '',
        nsubseteqq: '',
        nsucc: '',
        nsucceq: '',
        nsup: '',
        nsupE: '',
        nsupe: '',
        nsupset: '',
        nsupseteq: '',
        nsupseteqq: '',
        ntgl: '',
        Ntilde: '',
        ntilde: '',
        ntlg: '',
        ntriangleleft: '',
        ntrianglelefteq: '',
        ntriangleright: '',
        ntrianglerighteq: '',
        Nu: '',
        nu: '',
        num: '#',
        numero: '',
        numsp: '',
        nvap: '',
        nvdash: '',
        nvDash: '',
        nVdash: '',
        nVDash: '',
        nvge: '',
        nvgt: '>',
        nvHarr: '',
        nvinfin: '',
        nvlArr: '',
        nvle: '',
        nvlt: '<',
        nvltrie: '',
        nvrArr: '',
        nvrtrie: '',
        nvsim: '',
        nwarhk: '',
        nwarr: '',
        nwArr: '',
        nwarrow: '',
        nwnear: '',
        Oacute: '',
        oacute: '',
        oast: '',
        Ocirc: '',
        ocirc: '',
        ocir: '',
        Ocy: '',
        ocy: '',
        odash: '',
        Odblac: '',
        odblac: '',
        odiv: '',
        odot: '',
        odsold: '',
        OElig: '',
        oelig: '',
        ofcir: '',
        Ofr: '',
        ofr: '',
        ogon: '',
        Ograve: '',
        ograve: '',
        ogt: '',
        ohbar: '',
        ohm: '',
        oint: '',
        olarr: '',
        olcir: '',
        olcross: '',
        oline: '',
        olt: '',
        Omacr: '',
        omacr: '',
        Omega: '',
        omega: '',
        Omicron: '',
        omicron: '',
        omid: '',
        ominus: '',
        Oopf: '',
        oopf: '',
        opar: '',
        OpenCurlyDoubleQuote: '',
        OpenCurlyQuote: '',
        operp: '',
        oplus: '',
        orarr: '',
        Or: '',
        or: '',
        ord: '',
        order: '',
        orderof: '',
        ordf: '',
        ordm: '',
        origof: '',
        oror: '',
        orslope: '',
        orv: '',
        oS: '',
        Oscr: '',
        oscr: '',
        Oslash: '',
        oslash: '',
        osol: '',
        Otilde: '',
        otilde: '',
        otimesas: '',
        Otimes: '',
        otimes: '',
        Ouml: '',
        ouml: '',
        ovbar: '',
        OverBar: '',
        OverBrace: '',
        OverBracket: '',
        OverParenthesis: '',
        para: '',
        parallel: '',
        par: '',
        parsim: '',
        parsl: '',
        part: '',
        PartialD: '',
        Pcy: '',
        pcy: '',
        percnt: '%',
        period: '.',
        permil: '',
        perp: '',
        pertenk: '',
        Pfr: '',
        pfr: '',
        Phi: '',
        phi: '',
        phiv: '',
        phmmat: '',
        phone: '',
        Pi: '',
        pi: '',
        pitchfork: '',
        piv: '',
        planck: '',
        planckh: '',
        plankv: '',
        plusacir: '',
        plusb: '',
        pluscir: '',
        plus: '+',
        plusdo: '',
        plusdu: '',
        pluse: '',
        PlusMinus: '',
        plusmn: '',
        plussim: '',
        plustwo: '',
        pm: '',
        Poincareplane: '',
        pointint: '',
        popf: '',
        Popf: '',
        pound: '',
        prap: '',
        Pr: '',
        pr: '',
        prcue: '',
        precapprox: '',
        prec: '',
        preccurlyeq: '',
        Precedes: '',
        PrecedesEqual: '',
        PrecedesSlantEqual: '',
        PrecedesTilde: '',
        preceq: '',
        precnapprox: '',
        precneqq: '',
        precnsim: '',
        pre: '',
        prE: '',
        precsim: '',
        prime: '',
        Prime: '',
        primes: '',
        prnap: '',
        prnE: '',
        prnsim: '',
        prod: '',
        Product: '',
        profalar: '',
        profline: '',
        profsurf: '',
        prop: '',
        Proportional: '',
        Proportion: '',
        propto: '',
        prsim: '',
        prurel: '',
        Pscr: '',
        pscr: '',
        Psi: '',
        psi: '',
        puncsp: '',
        Qfr: '',
        qfr: '',
        qint: '',
        qopf: '',
        Qopf: '',
        qprime: '',
        Qscr: '',
        qscr: '',
        quaternions: '',
        quatint: '',
        quest: '?',
        questeq: '',
        quot: '"',
        QUOT: '"',
        rAarr: '',
        race: '',
        Racute: '',
        racute: '',
        radic: '',
        raemptyv: '',
        rang: '',
        Rang: '',
        rangd: '',
        range: '',
        rangle: '',
        raquo: '',
        rarrap: '',
        rarrb: '',
        rarrbfs: '',
        rarrc: '',
        rarr: '',
        Rarr: '',
        rArr: '',
        rarrfs: '',
        rarrhk: '',
        rarrlp: '',
        rarrpl: '',
        rarrsim: '',
        Rarrtl: '',
        rarrtl: '',
        rarrw: '',
        ratail: '',
        rAtail: '',
        ratio: '',
        rationals: '',
        rbarr: '',
        rBarr: '',
        RBarr: '',
        rbbrk: '',
        rbrace: '}',
        rbrack: ']',
        rbrke: '',
        rbrksld: '',
        rbrkslu: '',
        Rcaron: '',
        rcaron: '',
        Rcedil: '',
        rcedil: '',
        rceil: '',
        rcub: '}',
        Rcy: '',
        rcy: '',
        rdca: '',
        rdldhar: '',
        rdquo: '',
        rdquor: '',
        rdsh: '',
        real: '',
        realine: '',
        realpart: '',
        reals: '',
        Re: '',
        rect: '',
        reg: '',
        REG: '',
        ReverseElement: '',
        ReverseEquilibrium: '',
        ReverseUpEquilibrium: '',
        rfisht: '',
        rfloor: '',
        rfr: '',
        Rfr: '',
        rHar: '',
        rhard: '',
        rharu: '',
        rharul: '',
        Rho: '',
        rho: '',
        rhov: '',
        RightAngleBracket: '',
        RightArrowBar: '',
        rightarrow: '',
        RightArrow: '',
        Rightarrow: '',
        RightArrowLeftArrow: '',
        rightarrowtail: '',
        RightCeiling: '',
        RightDoubleBracket: '',
        RightDownTeeVector: '',
        RightDownVectorBar: '',
        RightDownVector: '',
        RightFloor: '',
        rightharpoondown: '',
        rightharpoonup: '',
        rightleftarrows: '',
        rightleftharpoons: '',
        rightrightarrows: '',
        rightsquigarrow: '',
        RightTeeArrow: '',
        RightTee: '',
        RightTeeVector: '',
        rightthreetimes: '',
        RightTriangleBar: '',
        RightTriangle: '',
        RightTriangleEqual: '',
        RightUpDownVector: '',
        RightUpTeeVector: '',
        RightUpVectorBar: '',
        RightUpVector: '',
        RightVectorBar: '',
        RightVector: '',
        ring: '',
        risingdotseq: '',
        rlarr: '',
        rlhar: '',
        rlm: '',
        rmoustache: '',
        rmoust: '',
        rnmid: '',
        roang: '',
        roarr: '',
        robrk: '',
        ropar: '',
        ropf: '',
        Ropf: '',
        roplus: '',
        rotimes: '',
        RoundImplies: '',
        rpar: ')',
        rpargt: '',
        rppolint: '',
        rrarr: '',
        Rrightarrow: '',
        rsaquo: '',
        rscr: '',
        Rscr: '',
        rsh: '',
        Rsh: '',
        rsqb: ']',
        rsquo: '',
        rsquor: '',
        rthree: '',
        rtimes: '',
        rtri: '',
        rtrie: '',
        rtrif: '',
        rtriltri: '',
        RuleDelayed: '',
        ruluhar: '',
        rx: '',
        Sacute: '',
        sacute: '',
        sbquo: '',
        scap: '',
        Scaron: '',
        scaron: '',
        Sc: '',
        sc: '',
        sccue: '',
        sce: '',
        scE: '',
        Scedil: '',
        scedil: '',
        Scirc: '',
        scirc: '',
        scnap: '',
        scnE: '',
        scnsim: '',
        scpolint: '',
        scsim: '',
        Scy: '',
        scy: '',
        sdotb: '',
        sdot: '',
        sdote: '',
        searhk: '',
        searr: '',
        seArr: '',
        searrow: '',
        sect: '',
        semi: ';',
        seswar: '',
        setminus: '',
        setmn: '',
        sext: '',
        Sfr: '',
        sfr: '',
        sfrown: '',
        sharp: '',
        SHCHcy: '',
        shchcy: '',
        SHcy: '',
        shcy: '',
        ShortDownArrow: '',
        ShortLeftArrow: '',
        shortmid: '',
        shortparallel: '',
        ShortRightArrow: '',
        ShortUpArrow: '',
        shy: '',
        Sigma: '',
        sigma: '',
        sigmaf: '',
        sigmav: '',
        sim: '',
        simdot: '',
        sime: '',
        simeq: '',
        simg: '',
        simgE: '',
        siml: '',
        simlE: '',
        simne: '',
        simplus: '',
        simrarr: '',
        slarr: '',
        SmallCircle: '',
        smallsetminus: '',
        smashp: '',
        smeparsl: '',
        smid: '',
        smile: '',
        smt: '',
        smte: '',
        smtes: '',
        SOFTcy: '',
        softcy: '',
        solbar: '',
        solb: '',
        sol: '/',
        Sopf: '',
        sopf: '',
        spades: '',
        spadesuit: '',
        spar: '',
        sqcap: '',
        sqcaps: '',
        sqcup: '',
        sqcups: '',
        Sqrt: '',
        sqsub: '',
        sqsube: '',
        sqsubset: '',
        sqsubseteq: '',
        sqsup: '',
        sqsupe: '',
        sqsupset: '',
        sqsupseteq: '',
        square: '',
        Square: '',
        SquareIntersection: '',
        SquareSubset: '',
        SquareSubsetEqual: '',
        SquareSuperset: '',
        SquareSupersetEqual: '',
        SquareUnion: '',
        squarf: '',
        squ: '',
        squf: '',
        srarr: '',
        Sscr: '',
        sscr: '',
        ssetmn: '',
        ssmile: '',
        sstarf: '',
        Star: '',
        star: '',
        starf: '',
        straightepsilon: '',
        straightphi: '',
        strns: '',
        sub: '',
        Sub: '',
        subdot: '',
        subE: '',
        sube: '',
        subedot: '',
        submult: '',
        subnE: '',
        subne: '',
        subplus: '',
        subrarr: '',
        subset: '',
        Subset: '',
        subseteq: '',
        subseteqq: '',
        SubsetEqual: '',
        subsetneq: '',
        subsetneqq: '',
        subsim: '',
        subsub: '',
        subsup: '',
        succapprox: '',
        succ: '',
        succcurlyeq: '',
        Succeeds: '',
        SucceedsEqual: '',
        SucceedsSlantEqual: '',
        SucceedsTilde: '',
        succeq: '',
        succnapprox: '',
        succneqq: '',
        succnsim: '',
        succsim: '',
        SuchThat: '',
        sum: '',
        Sum: '',
        sung: '',
        sup1: '',
        sup2: '',
        sup3: '',
        sup: '',
        Sup: '',
        supdot: '',
        supdsub: '',
        supE: '',
        supe: '',
        supedot: '',
        Superset: '',
        SupersetEqual: '',
        suphsol: '',
        suphsub: '',
        suplarr: '',
        supmult: '',
        supnE: '',
        supne: '',
        supplus: '',
        supset: '',
        Supset: '',
        supseteq: '',
        supseteqq: '',
        supsetneq: '',
        supsetneqq: '',
        supsim: '',
        supsub: '',
        supsup: '',
        swarhk: '',
        swarr: '',
        swArr: '',
        swarrow: '',
        swnwar: '',
        szlig: '',
        Tab: '	',
        target: '',
        Tau: '',
        tau: '',
        tbrk: '',
        Tcaron: '',
        tcaron: '',
        Tcedil: '',
        tcedil: '',
        Tcy: '',
        tcy: '',
        tdot: '',
        telrec: '',
        Tfr: '',
        tfr: '',
        there4: '',
        therefore: '',
        Therefore: '',
        Theta: '',
        theta: '',
        thetasym: '',
        thetav: '',
        thickapprox: '',
        thicksim: '',
        ThickSpace: '',
        ThinSpace: '',
        thinsp: '',
        thkap: '',
        thksim: '',
        THORN: '',
        thorn: '',
        tilde: '',
        Tilde: '',
        TildeEqual: '',
        TildeFullEqual: '',
        TildeTilde: '',
        timesbar: '',
        timesb: '',
        times: '',
        timesd: '',
        tint: '',
        toea: '',
        topbot: '',
        topcir: '',
        top: '',
        Topf: '',
        topf: '',
        topfork: '',
        tosa: '',
        tprime: '',
        trade: '',
        TRADE: '',
        triangle: '',
        triangledown: '',
        triangleleft: '',
        trianglelefteq: '',
        triangleq: '',
        triangleright: '',
        trianglerighteq: '',
        tridot: '',
        trie: '',
        triminus: '',
        TripleDot: '',
        triplus: '',
        trisb: '',
        tritime: '',
        trpezium: '',
        Tscr: '',
        tscr: '',
        TScy: '',
        tscy: '',
        TSHcy: '',
        tshcy: '',
        Tstrok: '',
        tstrok: '',
        twixt: '',
        twoheadleftarrow: '',
        twoheadrightarrow: '',
        Uacute: '',
        uacute: '',
        uarr: '',
        Uarr: '',
        uArr: '',
        Uarrocir: '',
        Ubrcy: '',
        ubrcy: '',
        Ubreve: '',
        ubreve: '',
        Ucirc: '',
        ucirc: '',
        Ucy: '',
        ucy: '',
        udarr: '',
        Udblac: '',
        udblac: '',
        udhar: '',
        ufisht: '',
        Ufr: '',
        ufr: '',
        Ugrave: '',
        ugrave: '',
        uHar: '',
        uharl: '',
        uharr: '',
        uhblk: '',
        ulcorn: '',
        ulcorner: '',
        ulcrop: '',
        ultri: '',
        Umacr: '',
        umacr: '',
        uml: '',
        UnderBar: '_',
        UnderBrace: '',
        UnderBracket: '',
        UnderParenthesis: '',
        Union: '',
        UnionPlus: '',
        Uogon: '',
        uogon: '',
        Uopf: '',
        uopf: '',
        UpArrowBar: '',
        uparrow: '',
        UpArrow: '',
        Uparrow: '',
        UpArrowDownArrow: '',
        updownarrow: '',
        UpDownArrow: '',
        Updownarrow: '',
        UpEquilibrium: '',
        upharpoonleft: '',
        upharpoonright: '',
        uplus: '',
        UpperLeftArrow: '',
        UpperRightArrow: '',
        upsi: '',
        Upsi: '',
        upsih: '',
        Upsilon: '',
        upsilon: '',
        UpTeeArrow: '',
        UpTee: '',
        upuparrows: '',
        urcorn: '',
        urcorner: '',
        urcrop: '',
        Uring: '',
        uring: '',
        urtri: '',
        Uscr: '',
        uscr: '',
        utdot: '',
        Utilde: '',
        utilde: '',
        utri: '',
        utrif: '',
        uuarr: '',
        Uuml: '',
        uuml: '',
        uwangle: '',
        vangrt: '',
        varepsilon: '',
        varkappa: '',
        varnothing: '',
        varphi: '',
        varpi: '',
        varpropto: '',
        varr: '',
        vArr: '',
        varrho: '',
        varsigma: '',
        varsubsetneq: '',
        varsubsetneqq: '',
        varsupsetneq: '',
        varsupsetneqq: '',
        vartheta: '',
        vartriangleleft: '',
        vartriangleright: '',
        vBar: '',
        Vbar: '',
        vBarv: '',
        Vcy: '',
        vcy: '',
        vdash: '',
        vDash: '',
        Vdash: '',
        VDash: '',
        Vdashl: '',
        veebar: '',
        vee: '',
        Vee: '',
        veeeq: '',
        vellip: '',
        verbar: '|',
        Verbar: '',
        vert: '|',
        Vert: '',
        VerticalBar: '',
        VerticalLine: '|',
        VerticalSeparator: '',
        VerticalTilde: '',
        VeryThinSpace: '',
        Vfr: '',
        vfr: '',
        vltri: '',
        vnsub: '',
        vnsup: '',
        Vopf: '',
        vopf: '',
        vprop: '',
        vrtri: '',
        Vscr: '',
        vscr: '',
        vsubnE: '',
        vsubne: '',
        vsupnE: '',
        vsupne: '',
        Vvdash: '',
        vzigzag: '',
        Wcirc: '',
        wcirc: '',
        wedbar: '',
        wedge: '',
        Wedge: '',
        wedgeq: '',
        weierp: '',
        Wfr: '',
        wfr: '',
        Wopf: '',
        wopf: '',
        wp: '',
        wr: '',
        wreath: '',
        Wscr: '',
        wscr: '',
        xcap: '',
        xcirc: '',
        xcup: '',
        xdtri: '',
        Xfr: '',
        xfr: '',
        xharr: '',
        xhArr: '',
        Xi: '',
        xi: '',
        xlarr: '',
        xlArr: '',
        xmap: '',
        xnis: '',
        xodot: '',
        Xopf: '',
        xopf: '',
        xoplus: '',
        xotime: '',
        xrarr: '',
        xrArr: '',
        Xscr: '',
        xscr: '',
        xsqcup: '',
        xuplus: '',
        xutri: '',
        xvee: '',
        xwedge: '',
        Yacute: '',
        yacute: '',
        YAcy: '',
        yacy: '',
        Ycirc: '',
        ycirc: '',
        Ycy: '',
        ycy: '',
        yen: '',
        Yfr: '',
        yfr: '',
        YIcy: '',
        yicy: '',
        Yopf: '',
        yopf: '',
        Yscr: '',
        yscr: '',
        YUcy: '',
        yucy: '',
        yuml: '',
        Yuml: '',
        Zacute: '',
        zacute: '',
        Zcaron: '',
        zcaron: '',
        Zcy: '',
        zcy: '',
        Zdot: '',
        zdot: '',
        zeetrf: '',
        ZeroWidthSpace: '',
        Zeta: '',
        zeta: '',
        zfr: '',
        Zfr: '',
        ZHcy: '',
        zhcy: '',
        zigrarr: '',
        zopf: '',
        Zopf: '',
        Zscr: '',
        zscr: '',
        zwj: '',
        zwnj: '',
      };
    },
  }),
  gj = J({
    '../node_modules/entities/lib/maps/legacy.json'(e, t) {
      t.exports = {
        Aacute: '',
        aacute: '',
        Acirc: '',
        acirc: '',
        acute: '',
        AElig: '',
        aelig: '',
        Agrave: '',
        agrave: '',
        amp: '&',
        AMP: '&',
        Aring: '',
        aring: '',
        Atilde: '',
        atilde: '',
        Auml: '',
        auml: '',
        brvbar: '',
        Ccedil: '',
        ccedil: '',
        cedil: '',
        cent: '',
        copy: '',
        COPY: '',
        curren: '',
        deg: '',
        divide: '',
        Eacute: '',
        eacute: '',
        Ecirc: '',
        ecirc: '',
        Egrave: '',
        egrave: '',
        ETH: '',
        eth: '',
        Euml: '',
        euml: '',
        frac12: '',
        frac14: '',
        frac34: '',
        gt: '>',
        GT: '>',
        Iacute: '',
        iacute: '',
        Icirc: '',
        icirc: '',
        iexcl: '',
        Igrave: '',
        igrave: '',
        iquest: '',
        Iuml: '',
        iuml: '',
        laquo: '',
        lt: '<',
        LT: '<',
        macr: '',
        micro: '',
        middot: '',
        nbsp: '',
        not: '',
        Ntilde: '',
        ntilde: '',
        Oacute: '',
        oacute: '',
        Ocirc: '',
        ocirc: '',
        Ograve: '',
        ograve: '',
        ordf: '',
        ordm: '',
        Oslash: '',
        oslash: '',
        Otilde: '',
        otilde: '',
        Ouml: '',
        ouml: '',
        para: '',
        plusmn: '',
        pound: '',
        quot: '"',
        QUOT: '"',
        raquo: '',
        reg: '',
        REG: '',
        sect: '',
        shy: '',
        sup1: '',
        sup2: '',
        sup3: '',
        szlig: '',
        THORN: '',
        thorn: '',
        times: '',
        Uacute: '',
        uacute: '',
        Ucirc: '',
        ucirc: '',
        Ugrave: '',
        ugrave: '',
        uml: '',
        Uuml: '',
        uuml: '',
        Yacute: '',
        yacute: '',
        yen: '',
        yuml: '',
      };
    },
  }),
  fb = J({
    '../node_modules/entities/lib/maps/xml.json'(e, t) {
      t.exports = { amp: '&', apos: "'", gt: '>', lt: '<', quot: '"' };
    },
  }),
  bj = J({
    '../node_modules/entities/lib/maps/decode.json'(e, t) {
      t.exports = {
        0: 65533,
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376,
      };
    },
  }),
  vj = J({
    '../node_modules/entities/lib/decode_codepoint.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (s) {
          return s && s.__esModule ? s : { default: s };
        };
      Object.defineProperty(e, '__esModule', { value: !0 });
      var r = t(bj()),
        n =
          String.fromCodePoint ||
          function (s) {
            var a = '';
            return (
              s > 65535 &&
                ((s -= 65536),
                (a += String.fromCharCode(((s >>> 10) & 1023) | 55296)),
                (s = 56320 | (s & 1023))),
              (a += String.fromCharCode(s)),
              a
            );
          };
      function i(s) {
        return (s >= 55296 && s <= 57343) || s > 1114111
          ? ''
          : (s in r.default && (s = r.default[s]), n(s));
      }
      (o(i, 'decodeCodePoint'), (e.default = i));
    },
  }),
  ph = J({
    '../node_modules/entities/lib/decode.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (p) {
          return p && p.__esModule ? p : { default: p };
        };
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0));
      var r = t(pb()),
        n = t(gj()),
        i = t(fb()),
        s = t(vj()),
        a = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
      ((e.decodeXML = c(i.default)), (e.decodeHTMLStrict = c(r.default)));
      function c(p) {
        var f = u(p);
        return function (y) {
          return String(y).replace(a, f);
        };
      }
      o(c, 'getStrictDecoder');
      var d = o(function (p, f) {
        return p < f ? 1 : -1;
      }, 'sorter');
      e.decodeHTML = (function () {
        for (
          var p = Object.keys(n.default).sort(d), f = Object.keys(r.default).sort(d), y = 0, h = 0;
          y < f.length;
          y++
        )
          p[h] === f[y] ? ((f[y] += ';?'), h++) : (f[y] += ';');
        var g = new RegExp('&(?:' + f.join('|') + '|#[xX][\\da-fA-F]+;?|#\\d+;?)', 'g'),
          T = u(r.default);
        function E(v) {
          return (v.substr(-1) !== ';' && (v += ';'), T(v));
        }
        return (
          o(E, 'replacer'),
          function (v) {
            return String(v).replace(g, E);
          }
        );
      })();
      function u(p) {
        return o(function (y) {
          if (y.charAt(1) === '#') {
            var h = y.charAt(2);
            return h === 'X' || h === 'x'
              ? s.default(parseInt(y.substr(3), 16))
              : s.default(parseInt(y.substr(2), 10));
          }
          return p[y.slice(1, -1)] || y;
        }, 'replace');
      }
      o(u, 'getReplacer');
    },
  }),
  fh = J({
    '../node_modules/entities/lib/encode.js'(e) {
      var t =
        (e && e.__importDefault) ||
        function (S) {
          return S && S.__esModule ? S : { default: S };
        };
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = void 0));
      var r = t(fb()),
        n = d(r.default),
        i = u(n);
      e.encodeXML = v(n);
      var s = t(pb()),
        a = d(s.default),
        c = u(a);
      ((e.encodeHTML = h(a, c)), (e.encodeNonAsciiHTML = v(a)));
      function d(S) {
        return Object.keys(S)
          .sort()
          .reduce(function (A, N) {
            return ((A[S[N]] = '&' + N + ';'), A);
          }, {});
      }
      o(d, 'getInverseObj');
      function u(S) {
        for (var A = [], N = [], j = 0, C = Object.keys(S); j < C.length; j++) {
          var R = C[j];
          R.length === 1 ? A.push('\\' + R) : N.push(R);
        }
        A.sort();
        for (var w = 0; w < A.length - 1; w++) {
          for (var _ = w; _ < A.length - 1 && A[_].charCodeAt(1) + 1 === A[_ + 1].charCodeAt(1); )
            _ += 1;
          var k = 1 + _ - w;
          k < 3 || A.splice(w, k, A[w] + '-' + A[_]);
        }
        return (N.unshift('[' + A.join('') + ']'), new RegExp(N.join('|'), 'g'));
      }
      o(u, 'getInverseReplacer');
      var p =
          /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
        f =
          String.prototype.codePointAt != null
            ? function (S) {
                return S.codePointAt(0);
              }
            : function (S) {
                return (S.charCodeAt(0) - 55296) * 1024 + S.charCodeAt(1) - 56320 + 65536;
              };
      function y(S) {
        return '&#x' + (S.length > 1 ? f(S) : S.charCodeAt(0)).toString(16).toUpperCase() + ';';
      }
      o(y, 'singleCharReplacer');
      function h(S, A) {
        return function (N) {
          return N.replace(A, function (j) {
            return S[j];
          }).replace(p, y);
        };
      }
      o(h, 'getInverse');
      var g = new RegExp(i.source + '|' + p.source, 'g');
      function T(S) {
        return S.replace(g, y);
      }
      (o(T, 'escape'), (e.escape = T));
      function E(S) {
        return S.replace(i, y);
      }
      (o(E, 'escapeUTF8'), (e.escapeUTF8 = E));
      function v(S) {
        return function (A) {
          return A.replace(g, function (N) {
            return S[N] || y(N);
          });
        };
      }
      o(v, 'getASCIIEncoder');
    },
  }),
  Ej = J({
    '../node_modules/entities/lib/index.js'(e) {
      (Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeXMLStrict =
          e.decodeHTML5Strict =
          e.decodeHTML4Strict =
          e.decodeHTML5 =
          e.decodeHTML4 =
          e.decodeHTMLStrict =
          e.decodeHTML =
          e.decodeXML =
          e.encodeHTML5 =
          e.encodeHTML4 =
          e.escapeUTF8 =
          e.escape =
          e.encodeNonAsciiHTML =
          e.encodeHTML =
          e.encodeXML =
          e.encode =
          e.decodeStrict =
          e.decode =
            void 0));
      var t = ph(),
        r = fh();
      function n(d, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTML)(d);
      }
      (o(n, 'decode'), (e.decode = n));
      function i(d, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTMLStrict)(d);
      }
      (o(i, 'decodeStrict'), (e.decodeStrict = i));
      function s(d, u) {
        return (!u || u <= 0 ? r.encodeXML : r.encodeHTML)(d);
      }
      (o(s, 'encode'), (e.encode = s));
      var a = fh();
      (Object.defineProperty(e, 'encodeXML', {
        enumerable: !0,
        get: o(function () {
          return a.encodeXML;
        }, 'get'),
      }),
        Object.defineProperty(e, 'encodeHTML', {
          enumerable: !0,
          get: o(function () {
            return a.encodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeNonAsciiHTML', {
          enumerable: !0,
          get: o(function () {
            return a.encodeNonAsciiHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'escape', {
          enumerable: !0,
          get: o(function () {
            return a.escape;
          }, 'get'),
        }),
        Object.defineProperty(e, 'escapeUTF8', {
          enumerable: !0,
          get: o(function () {
            return a.escapeUTF8;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML4', {
          enumerable: !0,
          get: o(function () {
            return a.encodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML5', {
          enumerable: !0,
          get: o(function () {
            return a.encodeHTML;
          }, 'get'),
        }));
      var c = ph();
      (Object.defineProperty(e, 'decodeXML', {
        enumerable: !0,
        get: o(function () {
          return c.decodeXML;
        }, 'get'),
      }),
        Object.defineProperty(e, 'decodeHTML', {
          enumerable: !0,
          get: o(function () {
            return c.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTMLStrict', {
          enumerable: !0,
          get: o(function () {
            return c.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4', {
          enumerable: !0,
          get: o(function () {
            return c.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5', {
          enumerable: !0,
          get: o(function () {
            return c.decodeHTML;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4Strict', {
          enumerable: !0,
          get: o(function () {
            return c.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5Strict', {
          enumerable: !0,
          get: o(function () {
            return c.decodeHTMLStrict;
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeXMLStrict', {
          enumerable: !0,
          get: o(function () {
            return c.decodeXML;
          }, 'get'),
        }));
    },
  }),
  Tj = J({
    '../node_modules/ansi-to-html/lib/ansi_to_html.js'(e, t) {
      function r(P, L) {
        if (!(P instanceof L)) throw new TypeError('Cannot call a class as a function');
      }
      o(r, '_classCallCheck');
      function n(P, L) {
        for (var B = 0; B < L.length; B++) {
          var D = L[B];
          ((D.enumerable = D.enumerable || !1),
            (D.configurable = !0),
            'value' in D && (D.writable = !0),
            Object.defineProperty(P, D.key, D));
        }
      }
      o(n, '_defineProperties');
      function i(P, L, B) {
        return (L && n(P.prototype, L), B && n(P, B), P);
      }
      o(i, '_createClass');
      function s(P, L) {
        var B = (typeof Symbol < 'u' && P[Symbol.iterator]) || P['@@iterator'];
        if (!B) {
          if (Array.isArray(P) || (B = a(P)) || (L && P && typeof P.length == 'number')) {
            B && (P = B);
            var D = 0,
              K = o(function () {}, 'F');
            return {
              s: K,
              n: o(function () {
                return D >= P.length ? { done: !0 } : { done: !1, value: P[D++] };
              }, 'n'),
              e: o(function (ae) {
                throw ae;
              }, 'e'),
              f: K,
            };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var X = !0,
          ie = !1,
          se;
        return {
          s: o(function () {
            B = B.call(P);
          }, 's'),
          n: o(function () {
            var ae = B.next();
            return ((X = ae.done), ae);
          }, 'n'),
          e: o(function (ae) {
            ((ie = !0), (se = ae));
          }, 'e'),
          f: o(function () {
            try {
              !X && B.return != null && B.return();
            } finally {
              if (ie) throw se;
            }
          }, 'f'),
        };
      }
      o(s, '_createForOfIteratorHelper');
      function a(P, L) {
        if (P) {
          if (typeof P == 'string') return c(P, L);
          var B = Object.prototype.toString.call(P).slice(8, -1);
          if (
            (B === 'Object' && P.constructor && (B = P.constructor.name),
            B === 'Map' || B === 'Set')
          )
            return Array.from(P);
          if (B === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(B))
            return c(P, L);
        }
      }
      o(a, '_unsupportedIterableToArray');
      function c(P, L) {
        (L == null || L > P.length) && (L = P.length);
        for (var B = 0, D = new Array(L); B < L; B++) D[B] = P[B];
        return D;
      }
      o(c, '_arrayLikeToArray');
      var d = Ej(),
        u = { fg: '#FFF', bg: '#000', newline: !1, escapeXML: !1, stream: !1, colors: p() };
      function p() {
        var P = {
          0: '#000',
          1: '#A00',
          2: '#0A0',
          3: '#A50',
          4: '#00A',
          5: '#A0A',
          6: '#0AA',
          7: '#AAA',
          8: '#555',
          9: '#F55',
          10: '#5F5',
          11: '#FF5',
          12: '#55F',
          13: '#F5F',
          14: '#5FF',
          15: '#FFF',
        };
        return (
          S(0, 5).forEach(function (L) {
            S(0, 5).forEach(function (B) {
              S(0, 5).forEach(function (D) {
                return f(L, B, D, P);
              });
            });
          }),
          S(0, 23).forEach(function (L) {
            var B = L + 232,
              D = y(L * 10 + 8);
            P[B] = '#' + D + D + D;
          }),
          P
        );
      }
      o(p, 'getDefaultColors');
      function f(P, L, B, D) {
        var K = 16 + P * 36 + L * 6 + B,
          X = P > 0 ? P * 40 + 55 : 0,
          ie = L > 0 ? L * 40 + 55 : 0,
          se = B > 0 ? B * 40 + 55 : 0;
        D[K] = h([X, ie, se]);
      }
      o(f, 'setStyleColor');
      function y(P) {
        for (var L = P.toString(16); L.length < 2; ) L = '0' + L;
        return L;
      }
      o(y, 'toHexString');
      function h(P) {
        var L = [],
          B = s(P),
          D;
        try {
          for (B.s(); !(D = B.n()).done; ) {
            var K = D.value;
            L.push(y(K));
          }
        } catch (X) {
          B.e(X);
        } finally {
          B.f();
        }
        return '#' + L.join('');
      }
      o(h, 'toColorHexString');
      function g(P, L, B, D) {
        var K;
        return (
          L === 'text'
            ? (K = j(B, D))
            : L === 'display'
              ? (K = E(P, B, D))
              : L === 'xterm256Foreground'
                ? (K = w(P, D.colors[B]))
                : L === 'xterm256Background'
                  ? (K = _(P, D.colors[B]))
                  : L === 'rgb' && (K = T(P, B)),
          K
        );
      }
      o(g, 'generateOutput');
      function T(P, L) {
        L = L.substring(2).slice(0, -1);
        var B = +L.substr(0, 2),
          D = L.substring(5).split(';'),
          K = D.map(function (X) {
            return ('0' + Number(X).toString(16)).substr(-2);
          }).join('');
        return R(P, (B === 38 ? 'color:#' : 'background-color:#') + K);
      }
      o(T, 'handleRgb');
      function E(P, L, B) {
        L = parseInt(L, 10);
        var D = {
            '-1': o(function () {
              return '<br/>';
            }, '_'),
            0: o(function () {
              return P.length && v(P);
            }, '_'),
            1: o(function () {
              return C(P, 'b');
            }, '_'),
            3: o(function () {
              return C(P, 'i');
            }, '_'),
            4: o(function () {
              return C(P, 'u');
            }, '_'),
            8: o(function () {
              return R(P, 'display:none');
            }, '_'),
            9: o(function () {
              return C(P, 'strike');
            }, '_'),
            22: o(function () {
              return R(P, 'font-weight:normal;text-decoration:none;font-style:normal');
            }, '_'),
            23: o(function () {
              return k(P, 'i');
            }, '_'),
            24: o(function () {
              return k(P, 'u');
            }, '_'),
            39: o(function () {
              return w(P, B.fg);
            }, '_'),
            49: o(function () {
              return _(P, B.bg);
            }, '_'),
            53: o(function () {
              return R(P, 'text-decoration:overline');
            }, '_'),
          },
          K;
        return (
          D[L]
            ? (K = D[L]())
            : 4 < L && L < 7
              ? (K = C(P, 'blink'))
              : 29 < L && L < 38
                ? (K = w(P, B.colors[L - 30]))
                : 39 < L && L < 48
                  ? (K = _(P, B.colors[L - 40]))
                  : 89 < L && L < 98
                    ? (K = w(P, B.colors[8 + (L - 90)]))
                    : 99 < L && L < 108 && (K = _(P, B.colors[8 + (L - 100)])),
          K
        );
      }
      o(E, 'handleDisplay');
      function v(P) {
        var L = P.slice(0);
        return (
          (P.length = 0),
          L.reverse()
            .map(function (B) {
              return '</' + B + '>';
            })
            .join('')
        );
      }
      o(v, 'resetStyles');
      function S(P, L) {
        for (var B = [], D = P; D <= L; D++) B.push(D);
        return B;
      }
      o(S, 'range');
      function A(P) {
        return function (L) {
          return (P === null || L.category !== P) && P !== 'all';
        };
      }
      o(A, 'notCategory');
      function N(P) {
        P = parseInt(P, 10);
        var L = null;
        return (
          P === 0
            ? (L = 'all')
            : P === 1
              ? (L = 'bold')
              : 2 < P && P < 5
                ? (L = 'underline')
                : 4 < P && P < 7
                  ? (L = 'blink')
                  : P === 8
                    ? (L = 'hide')
                    : P === 9
                      ? (L = 'strike')
                      : (29 < P && P < 38) || P === 39 || (89 < P && P < 98)
                        ? (L = 'foreground-color')
                        : ((39 < P && P < 48) || P === 49 || (99 < P && P < 108)) &&
                          (L = 'background-color'),
          L
        );
      }
      o(N, 'categoryForCode');
      function j(P, L) {
        return L.escapeXML ? d.encodeXML(P) : P;
      }
      o(j, 'pushText');
      function C(P, L, B) {
        return (
          B || (B = ''),
          P.push(L),
          '<'.concat(L).concat(B ? ' style="'.concat(B, '"') : '', '>')
        );
      }
      o(C, 'pushTag');
      function R(P, L) {
        return C(P, 'span', L);
      }
      o(R, 'pushStyle');
      function w(P, L) {
        return C(P, 'span', 'color:' + L);
      }
      o(w, 'pushForegroundColor');
      function _(P, L) {
        return C(P, 'span', 'background-color:' + L);
      }
      o(_, 'pushBackgroundColor');
      function k(P, L) {
        var B;
        if ((P.slice(-1)[0] === L && (B = P.pop()), B)) return '</' + L + '>';
      }
      o(k, 'closeTag');
      function I(P, L, B) {
        var D = !1,
          K = 3;
        function X() {
          return '';
        }
        o(X, 'remove');
        function ie(ne, de) {
          return (B('xterm256Foreground', de), '');
        }
        o(ie, 'removeXterm256Foreground');
        function se(ne, de) {
          return (B('xterm256Background', de), '');
        }
        o(se, 'removeXterm256Background');
        function W(ne) {
          return (L.newline ? B('display', -1) : B('text', ne), '');
        }
        o(W, 'newline');
        function ae(ne, de) {
          ((D = !0), de.trim().length === 0 && (de = '0'), (de = de.trimRight(';').split(';')));
          var ye = s(de),
            pe;
          try {
            for (ye.s(); !(pe = ye.n()).done; ) {
              var Je = pe.value;
              B('display', Je);
            }
          } catch (ot) {
            ye.e(ot);
          } finally {
            ye.f();
          }
          return '';
        }
        o(ae, 'ansiMess');
        function be(ne) {
          return (B('text', ne), '');
        }
        o(be, 'realText');
        function ue(ne) {
          return (B('rgb', ne), '');
        }
        o(ue, 'rgb');
        var ee = [
          { pattern: /^\x08+/, sub: X },
          { pattern: /^\x1b\[[012]?K/, sub: X },
          { pattern: /^\x1b\[\(B/, sub: X },
          { pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/, sub: ue },
          { pattern: /^\x1b\[38;5;(\d+)m/, sub: ie },
          { pattern: /^\x1b\[48;5;(\d+)m/, sub: se },
          { pattern: /^\n/, sub: W },
          { pattern: /^\r+\n/, sub: W },
          { pattern: /^\r/, sub: W },
          { pattern: /^\x1b\[((?:\d{1,3};?)+|)m/, sub: ae },
          { pattern: /^\x1b\[\d?J/, sub: X },
          { pattern: /^\x1b\[\d{0,3};\d{0,3}f/, sub: X },
          { pattern: /^\x1b\[?[\d;]{0,3}/, sub: X },
          { pattern: /^(([^\x1b\x08\r\n])+)/, sub: be },
        ];
        function Ae(ne, de) {
          (de > K && D) || ((D = !1), (P = P.replace(ne.pattern, ne.sub)));
        }
        o(Ae, 'process');
        var Oe = [],
          He = P,
          Ke = He.length;
        e: for (; Ke > 0; ) {
          for (var $ = 0, Q = 0, re = ee.length; Q < re; $ = ++Q) {
            var oe = ee[$];
            if ((Ae(oe, $), P.length !== Ke)) {
              Ke = P.length;
              continue e;
            }
          }
          if (P.length === Ke) break;
          (Oe.push(0), (Ke = P.length));
        }
        return Oe;
      }
      o(I, 'tokenize');
      function V(P, L, B) {
        return (
          L !== 'text' && ((P = P.filter(A(N(B)))), P.push({ token: L, data: B, category: N(B) })),
          P
        );
      }
      o(V, 'updateStickyStack');
      var H = (function () {
        function P(L) {
          (r(this, P),
            (L = L || {}),
            L.colors && (L.colors = Object.assign({}, u.colors, L.colors)),
            (this.options = Object.assign({}, u, L)),
            (this.stack = []),
            (this.stickyStack = []));
        }
        return (
          o(P, 'Filter'),
          i(P, [
            {
              key: 'toHtml',
              value: o(function (B) {
                var D = this;
                B = typeof B == 'string' ? [B] : B;
                var K = this.stack,
                  X = this.options,
                  ie = [];
                return (
                  this.stickyStack.forEach(function (se) {
                    var W = g(K, se.token, se.data, X);
                    W && ie.push(W);
                  }),
                  I(B.join(''), X, function (se, W) {
                    var ae = g(K, se, W, X);
                    (ae && ie.push(ae), X.stream && (D.stickyStack = V(D.stickyStack, se, W)));
                  }),
                  K.length && ie.push(v(K)),
                  ie.join('')
                );
              }, 'toHtml'),
            },
          ]),
          P
        );
      })();
      t.exports = H;
    },
  }),
  wj = J({
    '../node_modules/jsdoc-type-pratt-parser/dist/index.js'(e, t) {
      (function (r, n) {
        typeof e == 'object' && typeof t < 'u'
          ? n(e)
          : typeof define == 'function' && define.amd
            ? define(['exports'], n)
            : ((r = typeof globalThis < 'u' ? globalThis : r || self), n((r.jtpp = {})));
      })(e, function (r) {
        function n(l) {
          return l.text !== void 0 && l.text !== ''
            ? `'${l.type}' with value '${l.text}'`
            : `'${l.type}'`;
        }
        o(n, 'tokenToString');
        const i = class mb extends Error {
          constructor(m) {
            (super(`No parslet found for token: ${n(m)}`),
              (this.token = m),
              Object.setPrototypeOf(this, mb.prototype));
          }
          getToken() {
            return this.token;
          }
        };
        o(i, 'NoParsletFoundError');
        let s = i;
        const a = class yb extends Error {
          constructor(m) {
            (super(`The parsing ended early. The next token was: ${n(m)}`),
              (this.token = m),
              Object.setPrototypeOf(this, yb.prototype));
          }
          getToken() {
            return this.token;
          }
        };
        o(a, 'EarlyEndOfParseError');
        let c = a;
        const d = class hb extends Error {
          constructor(m, b) {
            let x = `Unexpected type: '${m.type}'.`;
            (b !== void 0 && (x += ` Message: ${b}`),
              super(x),
              Object.setPrototypeOf(this, hb.prototype));
          }
        };
        o(d, 'UnexpectedTypeError');
        let u = d;
        function p(l) {
          return (m) => (m.startsWith(l) ? { type: l, text: l } : null);
        }
        o(p, 'makePunctuationRule');
        function f(l) {
          let m = 0,
            b;
          const x = l[0];
          let F = !1;
          if (x !== "'" && x !== '"') return null;
          for (; m < l.length; ) {
            if ((m++, (b = l[m]), !F && b === x)) {
              m++;
              break;
            }
            F = !F && b === '\\';
          }
          if (b !== x) throw new Error('Unterminated String');
          return l.slice(0, m);
        }
        o(f, 'getQuoted');
        const y = new RegExp(
            '[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
            'u',
          ),
          h = new RegExp(
            '[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
            'u',
          );
        function g(l) {
          let m = l[0];
          if (!y.test(m)) return null;
          let b = 1;
          do {
            if (((m = l[b]), !h.test(m))) break;
            b++;
          } while (b < l.length);
          return l.slice(0, b);
        }
        o(g, 'getIdentifier');
        const T = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
        function E(l) {
          var m, b;
          return (b = (m = T.exec(l)) === null || m === void 0 ? void 0 : m[0]) !== null &&
            b !== void 0
            ? b
            : null;
        }
        o(E, 'getNumber');
        const v = o((l) => {
          const m = g(l);
          return m == null ? null : { type: 'Identifier', text: m };
        }, 'identifierRule');
        function S(l) {
          return (m) => {
            if (!m.startsWith(l)) return null;
            const b = m[l.length];
            return b !== void 0 && h.test(b) ? null : { type: l, text: l };
          };
        }
        o(S, 'makeKeyWordRule');
        const A = o((l) => {
            const m = f(l);
            return m == null ? null : { type: 'StringValue', text: m };
          }, 'stringValueRule'),
          N = o((l) => (l.length > 0 ? null : { type: 'EOF', text: '' }), 'eofRule'),
          j = o((l) => {
            const m = E(l);
            return m === null ? null : { type: 'Number', text: m };
          }, 'numberRule'),
          C = [
            N,
            p('=>'),
            p('('),
            p(')'),
            p('{'),
            p('}'),
            p('['),
            p(']'),
            p('|'),
            p('&'),
            p('<'),
            p('>'),
            p(','),
            p(';'),
            p('*'),
            p('?'),
            p('!'),
            p('='),
            p(':'),
            p('...'),
            p('.'),
            p('#'),
            p('~'),
            p('/'),
            p('@'),
            S('undefined'),
            S('null'),
            S('function'),
            S('this'),
            S('new'),
            S('module'),
            S('event'),
            S('extends'),
            S('external'),
            S('infer'),
            S('typeof'),
            S('keyof'),
            S('readonly'),
            S('import'),
            S('is'),
            S('in'),
            S('asserts'),
            j,
            v,
            A,
          ],
          R = /^\s*\n\s*/,
          w = class Ps {
            static create(m) {
              const b = this.read(m);
              m = b.text;
              const x = this.read(m);
              return ((m = x.text), new Ps(m, void 0, b.token, x.token));
            }
            constructor(m, b, x, F) {
              ((this.text = ''),
                (this.text = m),
                (this.previous = b),
                (this.current = x),
                (this.next = F));
            }
            static read(m, b = !1) {
              ((b = b || R.test(m)), (m = m.trim()));
              for (const x of C) {
                const F = x(m);
                if (F !== null) {
                  const z = Object.assign(Object.assign({}, F), { startOfLine: b });
                  return ((m = m.slice(z.text.length)), { text: m, token: z });
                }
              }
              throw new Error('Unexpected Token ' + m);
            }
            advance() {
              const m = Ps.read(this.text);
              return new Ps(m.text, this.current, this.next, m.token);
            }
          };
        o(w, 'Lexer');
        let _ = w;
        function k(l) {
          if (l === void 0) throw new Error('Unexpected undefined');
          if (
            l.type === 'JsdocTypeKeyValue' ||
            l.type === 'JsdocTypeParameterList' ||
            l.type === 'JsdocTypeProperty' ||
            l.type === 'JsdocTypeReadonlyProperty' ||
            l.type === 'JsdocTypeObjectField' ||
            l.type === 'JsdocTypeJsdocObjectField' ||
            l.type === 'JsdocTypeIndexSignature' ||
            l.type === 'JsdocTypeMappedType' ||
            l.type === 'JsdocTypeTypeParameter'
          )
            throw new u(l);
          return l;
        }
        o(k, 'assertRootResult');
        function I(l) {
          return l.type === 'JsdocTypeKeyValue' ? H(l) : k(l);
        }
        o(I, 'assertPlainKeyValueOrRootResult');
        function V(l) {
          return l.type === 'JsdocTypeName' ? l : H(l);
        }
        o(V, 'assertPlainKeyValueOrNameResult');
        function H(l) {
          if (l.type !== 'JsdocTypeKeyValue') throw new u(l);
          return l;
        }
        o(H, 'assertPlainKeyValueResult');
        function P(l) {
          var m;
          if (l.type === 'JsdocTypeVariadic') {
            if (((m = l.element) === null || m === void 0 ? void 0 : m.type) === 'JsdocTypeName')
              return l;
            throw new u(l);
          }
          if (l.type !== 'JsdocTypeNumber' && l.type !== 'JsdocTypeName') throw new u(l);
          return l;
        }
        o(P, 'assertNumberOrVariadicNameResult');
        function L(l) {
          if (
            l.type === 'JsdocTypeTuple' ||
            (l.type === 'JsdocTypeGeneric' && l.meta.brackets === 'square')
          )
            return l;
          throw new u(l);
        }
        o(L, 'assertArrayOrTupleResult');
        function B(l) {
          return l.type === 'JsdocTypeIndexSignature' || l.type === 'JsdocTypeMappedType';
        }
        o(B, 'isSquaredProperty');
        var D;
        (function (l) {
          ((l[(l.ALL = 0)] = 'ALL'),
            (l[(l.PARAMETER_LIST = 1)] = 'PARAMETER_LIST'),
            (l[(l.OBJECT = 2)] = 'OBJECT'),
            (l[(l.KEY_VALUE = 3)] = 'KEY_VALUE'),
            (l[(l.INDEX_BRACKETS = 4)] = 'INDEX_BRACKETS'),
            (l[(l.UNION = 5)] = 'UNION'),
            (l[(l.INTERSECTION = 6)] = 'INTERSECTION'),
            (l[(l.PREFIX = 7)] = 'PREFIX'),
            (l[(l.INFIX = 8)] = 'INFIX'),
            (l[(l.TUPLE = 9)] = 'TUPLE'),
            (l[(l.SYMBOL = 10)] = 'SYMBOL'),
            (l[(l.OPTIONAL = 11)] = 'OPTIONAL'),
            (l[(l.NULLABLE = 12)] = 'NULLABLE'),
            (l[(l.KEY_OF_TYPE_OF = 13)] = 'KEY_OF_TYPE_OF'),
            (l[(l.FUNCTION = 14)] = 'FUNCTION'),
            (l[(l.ARROW = 15)] = 'ARROW'),
            (l[(l.ARRAY_BRACKETS = 16)] = 'ARRAY_BRACKETS'),
            (l[(l.GENERIC = 17)] = 'GENERIC'),
            (l[(l.NAME_PATH = 18)] = 'NAME_PATH'),
            (l[(l.PARENTHESIS = 19)] = 'PARENTHESIS'),
            (l[(l.SPECIAL_TYPES = 20)] = 'SPECIAL_TYPES'));
        })(D || (D = {}));
        const K = class {
          constructor(m, b, x) {
            ((this.grammar = m),
              typeof b == 'string' ? (this._lexer = _.create(b)) : (this._lexer = b),
              (this.baseParser = x));
          }
          get lexer() {
            return this._lexer;
          }
          parse() {
            const m = this.parseType(D.ALL);
            if (this.lexer.current.type !== 'EOF') throw new c(this.lexer.current);
            return m;
          }
          parseType(m) {
            return k(this.parseIntermediateType(m));
          }
          parseIntermediateType(m) {
            const b = this.tryParslets(null, m);
            if (b === null) throw new s(this.lexer.current);
            return this.parseInfixIntermediateType(b, m);
          }
          parseInfixIntermediateType(m, b) {
            let x = this.tryParslets(m, b);
            for (; x !== null; ) ((m = x), (x = this.tryParslets(m, b)));
            return m;
          }
          tryParslets(m, b) {
            for (const x of this.grammar) {
              const F = x(this, b, m);
              if (F !== null) return F;
            }
            return null;
          }
          consume(m) {
            return (
              Array.isArray(m) || (m = [m]),
              m.includes(this.lexer.current.type) ? ((this._lexer = this.lexer.advance()), !0) : !1
            );
          }
          acceptLexerState(m) {
            this._lexer = m.lexer;
          }
        };
        o(K, 'Parser');
        let X = K;
        function ie(l) {
          return l === '}' || l === 'EOF' || l === '|' || l === ',' || l === ')' || l === '>';
        }
        o(ie, 'isQuestionMarkUnknownType');
        const se = o((l, m, b) => {
          const x = l.lexer.current.type,
            F = l.lexer.next.type;
          return (b == null && x === '?' && !ie(F)) || (b != null && x === '?')
            ? (l.consume('?'),
              b == null
                ? {
                    type: 'JsdocTypeNullable',
                    element: l.parseType(D.NULLABLE),
                    meta: { position: 'prefix' },
                  }
                : { type: 'JsdocTypeNullable', element: k(b), meta: { position: 'suffix' } })
            : null;
        }, 'nullableParslet');
        function W(l) {
          const m = o((b, x, F) => {
            const z = b.lexer.current.type,
              Z = b.lexer.next.type;
            if (F === null) {
              if ('parsePrefix' in l && l.accept(z, Z)) return l.parsePrefix(b);
            } else if ('parseInfix' in l && l.precedence > x && l.accept(z, Z))
              return l.parseInfix(b, F);
            return null;
          }, 'parslet');
          return (Object.defineProperty(m, 'name', { value: l.name }), m);
        }
        o(W, 'composeParslet');
        const ae = W({
            name: 'optionalParslet',
            accept: o((l) => l === '=', 'accept'),
            precedence: D.OPTIONAL,
            parsePrefix: o(
              (l) => (
                l.consume('='),
                {
                  type: 'JsdocTypeOptional',
                  element: l.parseType(D.OPTIONAL),
                  meta: { position: 'prefix' },
                }
              ),
              'parsePrefix',
            ),
            parseInfix: o(
              (l, m) => (
                l.consume('='),
                { type: 'JsdocTypeOptional', element: k(m), meta: { position: 'suffix' } }
              ),
              'parseInfix',
            ),
          }),
          be = W({
            name: 'numberParslet',
            accept: o((l) => l === 'Number', 'accept'),
            parsePrefix: o((l) => {
              const m = parseFloat(l.lexer.current.text);
              return (l.consume('Number'), { type: 'JsdocTypeNumber', value: m });
            }, 'parsePrefix'),
          }),
          ue = W({
            name: 'parenthesisParslet',
            accept: o((l) => l === '(', 'accept'),
            parsePrefix: o((l) => {
              if ((l.consume('('), l.consume(')')))
                return { type: 'JsdocTypeParameterList', elements: [] };
              const m = l.parseIntermediateType(D.ALL);
              if (!l.consume(')')) throw new Error('Unterminated parenthesis');
              return m.type === 'JsdocTypeParameterList'
                ? m
                : m.type === 'JsdocTypeKeyValue'
                  ? { type: 'JsdocTypeParameterList', elements: [m] }
                  : { type: 'JsdocTypeParenthesis', element: k(m) };
            }, 'parsePrefix'),
          }),
          ee = W({
            name: 'specialTypesParslet',
            accept: o(
              (l, m) => (l === '?' && ie(m)) || l === 'null' || l === 'undefined' || l === '*',
              'accept',
            ),
            parsePrefix: o((l) => {
              if (l.consume('null')) return { type: 'JsdocTypeNull' };
              if (l.consume('undefined')) return { type: 'JsdocTypeUndefined' };
              if (l.consume('*')) return { type: 'JsdocTypeAny' };
              if (l.consume('?')) return { type: 'JsdocTypeUnknown' };
              throw new Error('Unacceptable token: ' + l.lexer.current.text);
            }, 'parsePrefix'),
          }),
          Ae = W({
            name: 'notNullableParslet',
            accept: o((l) => l === '!', 'accept'),
            precedence: D.NULLABLE,
            parsePrefix: o(
              (l) => (
                l.consume('!'),
                {
                  type: 'JsdocTypeNotNullable',
                  element: l.parseType(D.NULLABLE),
                  meta: { position: 'prefix' },
                }
              ),
              'parsePrefix',
            ),
            parseInfix: o(
              (l, m) => (
                l.consume('!'),
                { type: 'JsdocTypeNotNullable', element: k(m), meta: { position: 'suffix' } }
              ),
              'parseInfix',
            ),
          });
        function Oe({ allowTrailingComma: l }) {
          return W({
            name: 'parameterListParslet',
            accept: o((m) => m === ',', 'accept'),
            precedence: D.PARAMETER_LIST,
            parseInfix: o((m, b) => {
              const x = [I(b)];
              m.consume(',');
              do
                try {
                  const F = m.parseIntermediateType(D.PARAMETER_LIST);
                  x.push(I(F));
                } catch (F) {
                  if (F instanceof s) break;
                  throw F;
                }
              while (m.consume(','));
              if (x.length > 0 && x.slice(0, -1).some((F) => F.type === 'JsdocTypeVariadic'))
                throw new Error('Only the last parameter may be a rest parameter');
              return { type: 'JsdocTypeParameterList', elements: x };
            }, 'parseInfix'),
          });
        }
        o(Oe, 'createParameterListParslet');
        const He = W({
            name: 'genericParslet',
            accept: o((l, m) => l === '<' || (l === '.' && m === '<'), 'accept'),
            precedence: D.GENERIC,
            parseInfix: o((l, m) => {
              const b = l.consume('.');
              l.consume('<');
              const x = [];
              let F = !1;
              if (l.consume('infer')) {
                F = !0;
                const z = l.parseIntermediateType(D.SYMBOL);
                if (z.type !== 'JsdocTypeName')
                  throw new u(
                    z,
                    'A typescript asserts always has to have a name on the left side.',
                  );
                x.push(z);
              } else
                do x.push(l.parseType(D.PARAMETER_LIST));
                while (l.consume(','));
              if (!l.consume('>')) throw new Error('Unterminated generic parameter list');
              return Object.assign(
                Object.assign(
                  { type: 'JsdocTypeGeneric', left: k(m), elements: x },
                  F ? { infer: !0 } : {},
                ),
                { meta: { brackets: 'angle', dot: b } },
              );
            }, 'parseInfix'),
          }),
          Ke = W({
            name: 'unionParslet',
            accept: o((l) => l === '|', 'accept'),
            precedence: D.UNION,
            parseInfix: o((l, m) => {
              l.consume('|');
              const b = [];
              do b.push(l.parseType(D.UNION));
              while (l.consume('|'));
              return { type: 'JsdocTypeUnion', elements: [k(m), ...b] };
            }, 'parseInfix'),
          }),
          $ = [se, ae, be, ue, ee, Ae, Oe({ allowTrailingComma: !0 }), He, Ke, ae];
        function Q({ allowSquareBracketsOnAnyType: l, allowJsdocNamePaths: m, pathGrammar: b }) {
          return o(function (F, z, Z) {
            if (Z == null || z >= D.NAME_PATH) return null;
            const ce = F.lexer.current.type,
              _e = F.lexer.next.type;
            if (
              !(
                (ce === '.' && _e !== '<') ||
                (ce === '[' && (l || Z.type === 'JsdocTypeName')) ||
                (m && (ce === '~' || ce === '#'))
              )
            )
              return null;
            let Me,
              dr = !1;
            F.consume('.')
              ? (Me = 'property')
              : F.consume('[')
                ? ((Me = 'property-brackets'), (dr = !0))
                : F.consume('~')
                  ? (Me = 'inner')
                  : (F.consume('#'), (Me = 'instance'));
            const ti = b !== null ? new X(b, F.lexer, F) : F,
              Qe = ti.parseIntermediateType(D.NAME_PATH);
            F.acceptLexerState(ti);
            let Jt;
            switch (Qe.type) {
              case 'JsdocTypeName':
                Jt = { type: 'JsdocTypeProperty', value: Qe.value, meta: { quote: void 0 } };
                break;
              case 'JsdocTypeNumber':
                Jt = {
                  type: 'JsdocTypeProperty',
                  value: Qe.value.toString(10),
                  meta: { quote: void 0 },
                };
                break;
              case 'JsdocTypeStringValue':
                Jt = { type: 'JsdocTypeProperty', value: Qe.value, meta: { quote: Qe.meta.quote } };
                break;
              case 'JsdocTypeSpecialNamePath':
                if (Qe.specialType === 'event') Jt = Qe;
                else
                  throw new u(
                    Qe,
                    "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'",
                  );
                break;
              default:
                throw new u(
                  Qe,
                  "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'",
                );
            }
            if (dr && !F.consume(']')) {
              const ri = F.lexer.current;
              throw new Error(
                `Unterminated square brackets. Next token is '${ri.type}' with text '${ri.text}'`,
              );
            }
            return { type: 'JsdocTypeNamePath', left: k(Z), right: Jt, pathType: Me };
          }, 'namePathParslet');
        }
        o(Q, 'createNamePathParslet');
        function re({ allowedAdditionalTokens: l }) {
          return W({
            name: 'nameParslet',
            accept: o(
              (m) => m === 'Identifier' || m === 'this' || m === 'new' || l.includes(m),
              'accept',
            ),
            parsePrefix: o((m) => {
              const { type: b, text: x } = m.lexer.current;
              return (m.consume(b), { type: 'JsdocTypeName', value: x });
            }, 'parsePrefix'),
          });
        }
        o(re, 'createNameParslet');
        const oe = W({
          name: 'stringValueParslet',
          accept: o((l) => l === 'StringValue', 'accept'),
          parsePrefix: o((l) => {
            const m = l.lexer.current.text;
            return (
              l.consume('StringValue'),
              {
                type: 'JsdocTypeStringValue',
                value: m.slice(1, -1),
                meta: { quote: m[0] === "'" ? 'single' : 'double' },
              }
            );
          }, 'parsePrefix'),
        });
        function ne({ pathGrammar: l, allowedTypes: m }) {
          return W({
            name: 'specialNamePathParslet',
            accept: o((b) => m.includes(b), 'accept'),
            parsePrefix: o((b) => {
              const x = b.lexer.current.type;
              if ((b.consume(x), !b.consume(':'))) return { type: 'JsdocTypeName', value: x };
              let F,
                z = b.lexer.current;
              if (b.consume('StringValue'))
                F = {
                  type: 'JsdocTypeSpecialNamePath',
                  value: z.text.slice(1, -1),
                  specialType: x,
                  meta: { quote: z.text[0] === "'" ? 'single' : 'double' },
                };
              else {
                let _e = '';
                const Ee = ['Identifier', '@', '/'];
                for (; Ee.some((Me) => b.consume(Me)); ) ((_e += z.text), (z = b.lexer.current));
                F = {
                  type: 'JsdocTypeSpecialNamePath',
                  value: _e,
                  specialType: x,
                  meta: { quote: void 0 },
                };
              }
              const Z = new X(l, b.lexer, b),
                ce = Z.parseInfixIntermediateType(F, D.ALL);
              return (b.acceptLexerState(Z), k(ce));
            }, 'parsePrefix'),
          });
        }
        o(ne, 'createSpecialNamePathParslet');
        const de = [
            re({ allowedAdditionalTokens: ['external', 'module'] }),
            oe,
            be,
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: null }),
          ],
          ye = [...de, ne({ allowedTypes: ['event'], pathGrammar: de })];
        function pe(l) {
          let m;
          if (l.type === 'JsdocTypeParameterList') m = l.elements;
          else if (l.type === 'JsdocTypeParenthesis') m = [l.element];
          else throw new u(l);
          return m.map((b) => I(b));
        }
        o(pe, 'getParameters');
        function Je(l) {
          const m = pe(l);
          if (m.some((b) => b.type === 'JsdocTypeKeyValue'))
            throw new Error('No parameter should be named');
          return m;
        }
        o(Je, 'getUnnamedParameters');
        function ot({
          allowNamedParameters: l,
          allowNoReturnType: m,
          allowWithoutParenthesis: b,
          allowNewAsFunctionKeyword: x,
        }) {
          return W({
            name: 'functionParslet',
            accept: o((F, z) => F === 'function' || (x && F === 'new' && z === '('), 'accept'),
            parsePrefix: o((F) => {
              const z = F.consume('new');
              F.consume('function');
              const Z = F.lexer.current.type === '(';
              if (!Z) {
                if (!b) throw new Error('function is missing parameter list');
                return { type: 'JsdocTypeName', value: 'function' };
              }
              let ce = {
                type: 'JsdocTypeFunction',
                parameters: [],
                arrow: !1,
                constructor: z,
                parenthesis: Z,
              };
              const _e = F.parseIntermediateType(D.FUNCTION);
              if (l === void 0) ce.parameters = Je(_e);
              else {
                if (z && _e.type === 'JsdocTypeFunction' && _e.arrow)
                  return ((ce = _e), (ce.constructor = !0), ce);
                ce.parameters = pe(_e);
                for (const Ee of ce.parameters)
                  if (Ee.type === 'JsdocTypeKeyValue' && !l.includes(Ee.key))
                    throw new Error(
                      `only allowed named parameters are ${l.join(', ')} but got ${Ee.type}`,
                    );
              }
              if (F.consume(':')) ce.returnType = F.parseType(D.PREFIX);
              else if (!m) throw new Error('function is missing return type');
              return ce;
            }, 'parsePrefix'),
          });
        }
        o(ot, 'createFunctionParslet');
        function dt({ allowPostfix: l, allowEnclosingBrackets: m }) {
          return W({
            name: 'variadicParslet',
            accept: o((b) => b === '...', 'accept'),
            precedence: D.PREFIX,
            parsePrefix: o((b) => {
              b.consume('...');
              const x = m && b.consume('[');
              try {
                const F = b.parseType(D.PREFIX);
                if (x && !b.consume(']'))
                  throw new Error("Unterminated variadic type. Missing ']'");
                return {
                  type: 'JsdocTypeVariadic',
                  element: k(F),
                  meta: { position: 'prefix', squareBrackets: x },
                };
              } catch (F) {
                if (F instanceof s) {
                  if (x) throw new Error('Empty square brackets for variadic are not allowed.');
                  return {
                    type: 'JsdocTypeVariadic',
                    meta: { position: void 0, squareBrackets: !1 },
                  };
                } else throw F;
              }
            }, 'parsePrefix'),
            parseInfix: l
              ? (b, x) => (
                  b.consume('...'),
                  {
                    type: 'JsdocTypeVariadic',
                    element: k(x),
                    meta: { position: 'suffix', squareBrackets: !1 },
                  }
                )
              : void 0,
          });
        }
        o(dt, 'createVariadicParslet');
        const Tt = W({
            name: 'symbolParslet',
            accept: o((l) => l === '(', 'accept'),
            precedence: D.SYMBOL,
            parseInfix: o((l, m) => {
              if (m.type !== 'JsdocTypeName')
                throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
              l.consume('(');
              const b = { type: 'JsdocTypeSymbol', value: m.value };
              if (!l.consume(')')) {
                const x = l.parseIntermediateType(D.SYMBOL);
                if (((b.element = P(x)), !l.consume(')')))
                  throw new Error('Symbol does not end after value');
              }
              return b;
            }, 'parseInfix'),
          }),
          it = W({
            name: 'arrayBracketsParslet',
            precedence: D.ARRAY_BRACKETS,
            accept: o((l, m) => l === '[' && m === ']', 'accept'),
            parseInfix: o(
              (l, m) => (
                l.consume('['),
                l.consume(']'),
                {
                  type: 'JsdocTypeGeneric',
                  left: { type: 'JsdocTypeName', value: 'Array' },
                  elements: [k(m)],
                  meta: { brackets: 'square', dot: !1 },
                }
              ),
              'parseInfix',
            ),
          });
        function pt({ objectFieldGrammar: l, allowKeyTypes: m }) {
          return W({
            name: 'objectParslet',
            accept: o((b) => b === '{', 'accept'),
            parsePrefix: o((b) => {
              b.consume('{');
              const x = { type: 'JsdocTypeObject', meta: { separator: 'comma' }, elements: [] };
              if (!b.consume('}')) {
                let F;
                const z = new X(l, b.lexer, b);
                for (;;) {
                  z.acceptLexerState(b);
                  let Z = z.parseIntermediateType(D.OBJECT);
                  (b.acceptLexerState(z),
                    Z === void 0 && m && (Z = b.parseIntermediateType(D.OBJECT)));
                  let ce = !1;
                  if (
                    (Z.type === 'JsdocTypeNullable' && ((ce = !0), (Z = Z.element)),
                    Z.type === 'JsdocTypeNumber' ||
                      Z.type === 'JsdocTypeName' ||
                      Z.type === 'JsdocTypeStringValue')
                  ) {
                    let Ee;
                    (Z.type === 'JsdocTypeStringValue' && (Ee = Z.meta.quote),
                      x.elements.push({
                        type: 'JsdocTypeObjectField',
                        key: Z.value.toString(),
                        right: void 0,
                        optional: ce,
                        readonly: !1,
                        meta: { quote: Ee },
                      }));
                  } else if (
                    Z.type === 'JsdocTypeObjectField' ||
                    Z.type === 'JsdocTypeJsdocObjectField'
                  )
                    x.elements.push(Z);
                  else throw new u(Z);
                  if (b.lexer.current.startOfLine)
                    ((F = 'linebreak'), b.consume(',') || b.consume(';'));
                  else if (b.consume(',')) F = 'comma';
                  else if (b.consume(';')) F = 'semicolon';
                  else break;
                  if (b.lexer.current.type === '}') break;
                }
                if (
                  ((x.meta.separator = F ?? 'comma'),
                  F === 'linebreak' && (x.meta.propertyIndent = '  '),
                  !b.consume('}'))
                )
                  throw new Error("Unterminated record type. Missing '}'");
              }
              return x;
            }, 'parsePrefix'),
          });
        }
        o(pt, 'createObjectParslet');
        function ft({
          allowSquaredProperties: l,
          allowKeyTypes: m,
          allowReadonly: b,
          allowOptional: x,
        }) {
          return W({
            name: 'objectFieldParslet',
            precedence: D.KEY_VALUE,
            accept: o((F) => F === ':', 'accept'),
            parseInfix: o((F, z) => {
              var Z;
              let ce = !1,
                _e = !1;
              (x && z.type === 'JsdocTypeNullable' && ((ce = !0), (z = z.element)),
                b && z.type === 'JsdocTypeReadonlyProperty' && ((_e = !0), (z = z.element)));
              const Ee = (Z = F.baseParser) !== null && Z !== void 0 ? Z : F;
              if (
                (Ee.acceptLexerState(F),
                z.type === 'JsdocTypeNumber' ||
                  z.type === 'JsdocTypeName' ||
                  z.type === 'JsdocTypeStringValue' ||
                  B(z))
              ) {
                if (B(z) && !l) throw new u(z);
                Ee.consume(':');
                let Me;
                z.type === 'JsdocTypeStringValue' && (Me = z.meta.quote);
                const dr = Ee.parseType(D.KEY_VALUE);
                return (
                  F.acceptLexerState(Ee),
                  {
                    type: 'JsdocTypeObjectField',
                    key: B(z) ? z : z.value.toString(),
                    right: dr,
                    optional: ce,
                    readonly: _e,
                    meta: { quote: Me },
                  }
                );
              } else {
                if (!m) throw new u(z);
                Ee.consume(':');
                const Me = Ee.parseType(D.KEY_VALUE);
                return (
                  F.acceptLexerState(Ee),
                  { type: 'JsdocTypeJsdocObjectField', left: k(z), right: Me }
                );
              }
            }, 'parseInfix'),
          });
        }
        o(ft, 'createObjectFieldParslet');
        function mt({ allowOptional: l, allowVariadic: m }) {
          return W({
            name: 'keyValueParslet',
            precedence: D.KEY_VALUE,
            accept: o((b) => b === ':', 'accept'),
            parseInfix: o((b, x) => {
              let F = !1,
                z = !1;
              if (
                (l && x.type === 'JsdocTypeNullable' && ((F = !0), (x = x.element)),
                m &&
                  x.type === 'JsdocTypeVariadic' &&
                  x.element !== void 0 &&
                  ((z = !0), (x = x.element)),
                x.type !== 'JsdocTypeName')
              )
                throw new u(x);
              b.consume(':');
              const Z = b.parseType(D.KEY_VALUE);
              return {
                type: 'JsdocTypeKeyValue',
                key: x.value,
                right: Z,
                optional: F,
                variadic: z,
              };
            }, 'parseInfix'),
          });
        }
        o(mt, 'createKeyValueParslet');
        const Qr = [
            ...$,
            ot({
              allowWithoutParenthesis: !0,
              allowNamedParameters: ['this', 'new'],
              allowNoReturnType: !0,
              allowNewAsFunctionKeyword: !1,
            }),
            oe,
            ne({ allowedTypes: ['module', 'external', 'event'], pathGrammar: ye }),
            dt({ allowEnclosingBrackets: !0, allowPostfix: !0 }),
            re({ allowedAdditionalTokens: ['keyof'] }),
            Tt,
            it,
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
          ],
          Io = [
            ...Qr,
            pt({
              objectFieldGrammar: [
                re({ allowedAdditionalTokens: ['typeof', 'module', 'in'] }),
                ft({
                  allowSquaredProperties: !1,
                  allowKeyTypes: !0,
                  allowOptional: !1,
                  allowReadonly: !1,
                }),
                ...Qr,
              ],
              allowKeyTypes: !0,
            }),
            mt({ allowOptional: !0, allowVariadic: !0 }),
          ],
          Zr = W({
            name: 'typeOfParslet',
            accept: o((l) => l === 'typeof', 'accept'),
            parsePrefix: o(
              (l) => (
                l.consume('typeof'),
                { type: 'JsdocTypeTypeof', element: l.parseType(D.KEY_OF_TYPE_OF) }
              ),
              'parsePrefix',
            ),
          }),
          Mo = [
            re({
              allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'],
            }),
            se,
            ae,
            oe,
            be,
            ft({
              allowSquaredProperties: !1,
              allowKeyTypes: !1,
              allowOptional: !1,
              allowReadonly: !1,
            }),
          ],
          qo = [
            ...$,
            pt({ allowKeyTypes: !1, objectFieldGrammar: Mo }),
            re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
            Zr,
            ot({
              allowWithoutParenthesis: !1,
              allowNamedParameters: ['this', 'new'],
              allowNoReturnType: !0,
              allowNewAsFunctionKeyword: !1,
            }),
            dt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
            re({ allowedAdditionalTokens: ['keyof'] }),
            ne({ allowedTypes: ['module'], pathGrammar: ye }),
            Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
            mt({ allowOptional: !1, allowVariadic: !1 }),
            Tt,
          ],
          jo = W({
            name: 'assertsParslet',
            accept: o((l) => l === 'asserts', 'accept'),
            parsePrefix: o((l) => {
              l.consume('asserts');
              const m = l.parseIntermediateType(D.SYMBOL);
              if (m.type !== 'JsdocTypeName')
                throw new u(m, 'A typescript asserts always has to have a name on the left side.');
              return l.consume('is')
                ? { type: 'JsdocTypeAsserts', left: m, right: k(l.parseIntermediateType(D.INFIX)) }
                : { type: 'JsdocTypeAssertsPlain', element: m };
            }, 'parsePrefix'),
          });
        function en({ allowQuestionMark: l }) {
          return W({
            name: 'tupleParslet',
            accept: o((m) => m === '[', 'accept'),
            parsePrefix: o((m) => {
              m.consume('[');
              const b = { type: 'JsdocTypeTuple', elements: [] };
              if (m.consume(']')) return b;
              const x = m.parseIntermediateType(D.ALL);
              if (
                (x.type === 'JsdocTypeParameterList'
                  ? x.elements[0].type === 'JsdocTypeKeyValue'
                    ? (b.elements = x.elements.map(H))
                    : (b.elements = x.elements.map(k))
                  : x.type === 'JsdocTypeKeyValue'
                    ? (b.elements = [H(x)])
                    : (b.elements = [k(x)]),
                !m.consume(']'))
              )
                throw new Error("Unterminated '['");
              if (b.elements.some((F) => F.type === 'JsdocTypeUnknown'))
                throw new Error('Question mark in tuple not allowed');
              return b;
            }, 'parsePrefix'),
          });
        }
        o(en, 'createTupleParslet');
        const ko = W({
            name: 'keyOfParslet',
            accept: o((l) => l === 'keyof', 'accept'),
            parsePrefix: o(
              (l) => (
                l.consume('keyof'),
                { type: 'JsdocTypeKeyof', element: k(l.parseType(D.KEY_OF_TYPE_OF)) }
              ),
              'parsePrefix',
            ),
          }),
          Do = W({
            name: 'importParslet',
            accept: o((l) => l === 'import', 'accept'),
            parsePrefix: o((l) => {
              if ((l.consume('import'), !l.consume('(')))
                throw new Error('Missing parenthesis after import keyword');
              const m = l.parseType(D.PREFIX);
              if (m.type !== 'JsdocTypeStringValue')
                throw new Error('Only string values are allowed as paths for imports');
              if (!l.consume(')'))
                throw new Error('Missing closing parenthesis after import keyword');
              return { type: 'JsdocTypeImport', element: m };
            }, 'parsePrefix'),
          }),
          Lo = W({
            name: 'readonlyPropertyParslet',
            accept: o((l) => l === 'readonly', 'accept'),
            parsePrefix: o(
              (l) => (
                l.consume('readonly'),
                { type: 'JsdocTypeReadonlyProperty', element: l.parseIntermediateType(D.KEY_VALUE) }
              ),
              'parsePrefix',
            ),
          }),
          Fo = W({
            name: 'arrowFunctionParslet',
            precedence: D.ARROW,
            accept: o((l) => l === '=>', 'accept'),
            parseInfix: o(
              (l, m) => (
                l.consume('=>'),
                {
                  type: 'JsdocTypeFunction',
                  parameters: pe(m).map(V),
                  arrow: !0,
                  constructor: !1,
                  parenthesis: !0,
                  returnType: l.parseType(D.OBJECT),
                }
              ),
              'parseInfix',
            ),
          }),
          Bo = W({
            name: 'genericArrowFunctionParslet',
            accept: o((l) => l === '<', 'accept'),
            parsePrefix: o((l) => {
              const m = [];
              l.consume('<');
              do {
                let x,
                  F = l.parseIntermediateType(D.SYMBOL);
                if (
                  (F.type === 'JsdocTypeOptional' && ((F = F.element), (x = l.parseType(D.SYMBOL))),
                  F.type !== 'JsdocTypeName')
                )
                  throw new u(F);
                let z;
                l.consume('extends') &&
                  ((z = l.parseType(D.SYMBOL)),
                  z.type === 'JsdocTypeOptional' && ((z = z.element), (x = l.parseType(D.SYMBOL))));
                const Z = { type: 'JsdocTypeTypeParameter', name: F };
                if (
                  (z !== void 0 && (Z.constraint = z),
                  x !== void 0 && (Z.defaultValue = x),
                  m.push(Z),
                  l.consume('>'))
                )
                  break;
              } while (l.consume(','));
              const b = l.parseIntermediateType(D.SYMBOL);
              return ((b.typeParameters = m), b);
            }, 'parsePrefix'),
          }),
          Jo = W({
            name: 'intersectionParslet',
            accept: o((l) => l === '&', 'accept'),
            precedence: D.INTERSECTION,
            parseInfix: o((l, m) => {
              l.consume('&');
              const b = [];
              do b.push(l.parseType(D.INTERSECTION));
              while (l.consume('&'));
              return { type: 'JsdocTypeIntersection', elements: [k(m), ...b] };
            }, 'parseInfix'),
          }),
          $o = W({
            name: 'predicateParslet',
            precedence: D.INFIX,
            accept: o((l) => l === 'is', 'accept'),
            parseInfix: o((l, m) => {
              if (m.type !== 'JsdocTypeName')
                throw new u(
                  m,
                  'A typescript predicate always has to have a name on the left side.',
                );
              return (
                l.consume('is'),
                { type: 'JsdocTypePredicate', left: m, right: k(l.parseIntermediateType(D.INFIX)) }
              );
            }, 'parseInfix'),
          }),
          Uo = W({
            name: 'objectSquareBracketPropertyParslet',
            accept: o((l) => l === '[', 'accept'),
            parsePrefix: o((l) => {
              if (l.baseParser === void 0) throw new Error('Only allowed inside object grammar');
              l.consume('[');
              const m = l.lexer.current.text;
              l.consume('Identifier');
              let b;
              if (l.consume(':')) {
                const x = l.baseParser;
                (x.acceptLexerState(l),
                  (b = {
                    type: 'JsdocTypeIndexSignature',
                    key: m,
                    right: x.parseType(D.INDEX_BRACKETS),
                  }),
                  l.acceptLexerState(x));
              } else if (l.consume('in')) {
                const x = l.baseParser;
                (x.acceptLexerState(l),
                  (b = {
                    type: 'JsdocTypeMappedType',
                    key: m,
                    right: x.parseType(D.ARRAY_BRACKETS),
                  }),
                  l.acceptLexerState(x));
              } else throw new Error("Missing ':' or 'in' inside square bracketed property.");
              if (!l.consume(']')) throw new Error('Unterminated square brackets');
              return b;
            }, 'parsePrefix'),
          }),
          Vo = W({
            name: 'readonlyArrayParslet',
            accept: o((l) => l === 'readonly', 'accept'),
            parsePrefix: o(
              (l) => (
                l.consume('readonly'),
                { type: 'JsdocTypeReadonlyArray', element: L(l.parseIntermediateType(D.ALL)) }
              ),
              'parsePrefix',
            ),
          }),
          Ho = W({
            name: 'conditionalParslet',
            precedence: D.INFIX,
            accept: o((l) => l === 'extends', 'accept'),
            parseInfix: o((l, m) => {
              l.consume('extends');
              const b = l.parseType(D.KEY_OF_TYPE_OF).element,
                x = l.parseType(D.INFIX);
              return (
                l.consume(':'),
                {
                  type: 'JsdocTypeConditional',
                  checksType: k(m),
                  extendsType: b,
                  trueType: x,
                  falseType: l.parseType(D.INFIX),
                }
              );
            }, 'parseInfix'),
          }),
          Go = [
            Lo,
            re({
              allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'],
            }),
            se,
            ae,
            oe,
            be,
            ft({
              allowSquaredProperties: !0,
              allowKeyTypes: !1,
              allowOptional: !0,
              allowReadonly: !0,
            }),
            Uo,
          ],
          zo = [
            ...$,
            pt({ allowKeyTypes: !1, objectFieldGrammar: Go }),
            Vo,
            Zr,
            ko,
            Do,
            oe,
            ot({
              allowWithoutParenthesis: !0,
              allowNoReturnType: !1,
              allowNamedParameters: ['this', 'new', 'args'],
              allowNewAsFunctionKeyword: !0,
            }),
            en({ allowQuestionMark: !1 }),
            dt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
            jo,
            Ho,
            re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
            ne({ allowedTypes: ['module'], pathGrammar: ye }),
            it,
            Fo,
            Bo,
            Q({ allowSquareBracketsOnAnyType: !0, allowJsdocNamePaths: !1, pathGrammar: ye }),
            Jo,
            $o,
            mt({ allowVariadic: !0, allowOptional: !0 }),
          ];
        function lr(l, m) {
          switch (m) {
            case 'closure':
              return new X(qo, l).parse();
            case 'jsdoc':
              return new X(Io, l).parse();
            case 'typescript':
              return new X(zo, l).parse();
          }
        }
        o(lr, 'parse');
        function tn(l, m = ['typescript', 'closure', 'jsdoc']) {
          let b;
          for (const x of m)
            try {
              return lr(l, x);
            } catch (F) {
              b = F;
            }
          throw b;
        }
        o(tn, 'tryParse');
        function Y(l, m) {
          const b = l[m.type];
          if (b === void 0)
            throw new Error(`In this set of transform rules exists no rule for type ${m.type}.`);
          return b(m, (x) => Y(l, x));
        }
        o(Y, 'transform');
        function le(l) {
          throw new Error(
            'This transform is not available. Are you trying the correct parsing mode?',
          );
        }
        o(le, 'notAvailableTransform');
        function Nt(l) {
          const m = { params: [] };
          for (const b of l.parameters)
            b.type === 'JsdocTypeKeyValue'
              ? b.key === 'this'
                ? (m.this = b.right)
                : b.key === 'new'
                  ? (m.new = b.right)
                  : m.params.push(b)
              : m.params.push(b);
          return m;
        }
        o(Nt, 'extractSpecialParams');
        function Bt(l, m, b) {
          return l === 'prefix' ? b + m : m + b;
        }
        o(Bt, 'applyPosition');
        function Ye(l, m) {
          switch (m) {
            case 'double':
              return `"${l}"`;
            case 'single':
              return `'${l}'`;
            case void 0:
              return l;
          }
        }
        o(Ye, 'quote');
        function rn() {
          return {
            JsdocTypeParenthesis: o(
              (l, m) => `(${l.element !== void 0 ? m(l.element) : ''})`,
              'JsdocTypeParenthesis',
            ),
            JsdocTypeKeyof: o((l, m) => `keyof ${m(l.element)}`, 'JsdocTypeKeyof'),
            JsdocTypeFunction: o((l, m) => {
              var b;
              if (l.arrow) {
                if (l.returnType === void 0) throw new Error('Arrow function needs a return type.');
                let x = `${l.typeParameters !== void 0 ? `<${(b = l.typeParameters.map(m).join(', ')) !== null && b !== void 0 ? b : ''}>` : ''}(${l.parameters.map(m).join(', ')}) => ${m(l.returnType)}`;
                return (l.constructor && (x = 'new ' + x), x);
              } else {
                let x = l.constructor ? 'new' : 'function';
                return (
                  l.parenthesis &&
                    ((x += `(${l.parameters.map(m).join(', ')})`),
                    l.returnType !== void 0 && (x += `: ${m(l.returnType)}`)),
                  x
                );
              }
            }, 'JsdocTypeFunction'),
            JsdocTypeName: o((l) => l.value, 'JsdocTypeName'),
            JsdocTypeTuple: o((l, m) => `[${l.elements.map(m).join(', ')}]`, 'JsdocTypeTuple'),
            JsdocTypeVariadic: o(
              (l, m) =>
                l.meta.position === void 0 ? '...' : Bt(l.meta.position, m(l.element), '...'),
              'JsdocTypeVariadic',
            ),
            JsdocTypeNamePath: o((l, m) => {
              const b = m(l.left),
                x = m(l.right);
              switch (l.pathType) {
                case 'inner':
                  return `${b}~${x}`;
                case 'instance':
                  return `${b}#${x}`;
                case 'property':
                  return `${b}.${x}`;
                case 'property-brackets':
                  return `${b}[${x}]`;
              }
            }, 'JsdocTypeNamePath'),
            JsdocTypeStringValue: o((l) => Ye(l.value, l.meta.quote), 'JsdocTypeStringValue'),
            JsdocTypeAny: o(() => '*', 'JsdocTypeAny'),
            JsdocTypeGeneric: o((l, m) => {
              if (l.meta.brackets === 'square') {
                const b = l.elements[0],
                  x = m(b);
                return b.type === 'JsdocTypeUnion' || b.type === 'JsdocTypeIntersection'
                  ? `(${x})[]`
                  : `${x}[]`;
              } else
                return `${m(l.left)}${l.meta.dot ? '.' : ''}<${l.infer === !0 ? 'infer ' : ''}${l.elements.map(m).join(', ')}>`;
            }, 'JsdocTypeGeneric'),
            JsdocTypeImport: o((l, m) => `import(${m(l.element)})`, 'JsdocTypeImport'),
            JsdocTypeObjectField: o((l, m) => {
              let b = '';
              return (
                l.readonly && (b += 'readonly '),
                typeof l.key == 'string' ? (b += Ye(l.key, l.meta.quote)) : (b += m(l.key)),
                l.optional && (b += '?'),
                l.right === void 0 ? b : b + `: ${m(l.right)}`
              );
            }, 'JsdocTypeObjectField'),
            JsdocTypeJsdocObjectField: o(
              (l, m) => `${m(l.left)}: ${m(l.right)}`,
              'JsdocTypeJsdocObjectField',
            ),
            JsdocTypeKeyValue: o((l, m) => {
              let b = l.key;
              return (
                l.optional && (b += '?'),
                l.variadic && (b = '...' + b),
                l.right === void 0 ? b : b + `: ${m(l.right)}`
              );
            }, 'JsdocTypeKeyValue'),
            JsdocTypeSpecialNamePath: o(
              (l) => `${l.specialType}:${Ye(l.value, l.meta.quote)}`,
              'JsdocTypeSpecialNamePath',
            ),
            JsdocTypeNotNullable: o(
              (l, m) => Bt(l.meta.position, m(l.element), '!'),
              'JsdocTypeNotNullable',
            ),
            JsdocTypeNull: o(() => 'null', 'JsdocTypeNull'),
            JsdocTypeNullable: o(
              (l, m) => Bt(l.meta.position, m(l.element), '?'),
              'JsdocTypeNullable',
            ),
            JsdocTypeNumber: o((l) => l.value.toString(), 'JsdocTypeNumber'),
            JsdocTypeObject: o((l, m) => {
              var b, x;
              return `{${
                (l.meta.separator === 'linebreak' && l.elements.length > 1
                  ? `
` + ((b = l.meta.propertyIndent) !== null && b !== void 0 ? b : '')
                  : '') +
                l.elements.map(m).join(
                  l.meta.separator === 'comma'
                    ? ', '
                    : l.meta.separator === 'linebreak'
                      ? `
` + ((x = l.meta.propertyIndent) !== null && x !== void 0 ? x : '')
                      : '; ',
                ) +
                (l.meta.separator === 'linebreak' && l.elements.length > 1
                  ? `
`
                  : '')
              }}`;
            }, 'JsdocTypeObject'),
            JsdocTypeOptional: o(
              (l, m) => Bt(l.meta.position, m(l.element), '='),
              'JsdocTypeOptional',
            ),
            JsdocTypeSymbol: o(
              (l, m) => `${l.value}(${l.element !== void 0 ? m(l.element) : ''})`,
              'JsdocTypeSymbol',
            ),
            JsdocTypeTypeof: o((l, m) => `typeof ${m(l.element)}`, 'JsdocTypeTypeof'),
            JsdocTypeUndefined: o(() => 'undefined', 'JsdocTypeUndefined'),
            JsdocTypeUnion: o((l, m) => l.elements.map(m).join(' | '), 'JsdocTypeUnion'),
            JsdocTypeUnknown: o(() => '?', 'JsdocTypeUnknown'),
            JsdocTypeIntersection: o(
              (l, m) => l.elements.map(m).join(' & '),
              'JsdocTypeIntersection',
            ),
            JsdocTypeProperty: o((l) => Ye(l.value, l.meta.quote), 'JsdocTypeProperty'),
            JsdocTypePredicate: o((l, m) => `${m(l.left)} is ${m(l.right)}`, 'JsdocTypePredicate'),
            JsdocTypeIndexSignature: o(
              (l, m) => `[${l.key}: ${m(l.right)}]`,
              'JsdocTypeIndexSignature',
            ),
            JsdocTypeMappedType: o((l, m) => `[${l.key} in ${m(l.right)}]`, 'JsdocTypeMappedType'),
            JsdocTypeAsserts: o(
              (l, m) => `asserts ${m(l.left)} is ${m(l.right)}`,
              'JsdocTypeAsserts',
            ),
            JsdocTypeReadonlyArray: o(
              (l, m) => `readonly ${m(l.element)}`,
              'JsdocTypeReadonlyArray',
            ),
            JsdocTypeAssertsPlain: o((l, m) => `asserts ${m(l.element)}`, 'JsdocTypeAssertsPlain'),
            JsdocTypeConditional: o(
              (l, m) =>
                `${m(l.checksType)} extends ${m(l.extendsType)} ? ${m(l.trueType)} : ${m(l.falseType)}`,
              'JsdocTypeConditional',
            ),
            JsdocTypeTypeParameter: o(
              (l, m) =>
                `${m(l.name)}${l.constraint !== void 0 ? ` extends ${m(l.constraint)}` : ''}${l.defaultValue !== void 0 ? ` = ${m(l.defaultValue)}` : ''}`,
              'JsdocTypeTypeParameter',
            ),
          };
        }
        o(rn, 'stringifyRules');
        const uc = rn();
        function Wo(l) {
          return Y(uc, l);
        }
        o(Wo, 'stringify');
        const dc = [
          'null',
          'true',
          'false',
          'break',
          'case',
          'catch',
          'class',
          'const',
          'continue',
          'debugger',
          'default',
          'delete',
          'do',
          'else',
          'export',
          'extends',
          'finally',
          'for',
          'function',
          'if',
          'import',
          'in',
          'instanceof',
          'new',
          'return',
          'super',
          'switch',
          'this',
          'throw',
          'try',
          'typeof',
          'var',
          'void',
          'while',
          'with',
          'yield',
        ];
        function Xe(l) {
          const m = { type: 'NameExpression', name: l };
          return (dc.includes(l) && (m.reservedWord = !0), m);
        }
        o(Xe, 'makeName');
        const pc = {
          JsdocTypeOptional: o((l, m) => {
            const b = m(l.element);
            return ((b.optional = !0), b);
          }, 'JsdocTypeOptional'),
          JsdocTypeNullable: o((l, m) => {
            const b = m(l.element);
            return ((b.nullable = !0), b);
          }, 'JsdocTypeNullable'),
          JsdocTypeNotNullable: o((l, m) => {
            const b = m(l.element);
            return ((b.nullable = !1), b);
          }, 'JsdocTypeNotNullable'),
          JsdocTypeVariadic: o((l, m) => {
            if (l.element === void 0)
              throw new Error('dots without value are not allowed in catharsis mode');
            const b = m(l.element);
            return ((b.repeatable = !0), b);
          }, 'JsdocTypeVariadic'),
          JsdocTypeAny: o(() => ({ type: 'AllLiteral' }), 'JsdocTypeAny'),
          JsdocTypeNull: o(() => ({ type: 'NullLiteral' }), 'JsdocTypeNull'),
          JsdocTypeStringValue: o((l) => Xe(Ye(l.value, l.meta.quote)), 'JsdocTypeStringValue'),
          JsdocTypeUndefined: o(() => ({ type: 'UndefinedLiteral' }), 'JsdocTypeUndefined'),
          JsdocTypeUnknown: o(() => ({ type: 'UnknownLiteral' }), 'JsdocTypeUnknown'),
          JsdocTypeFunction: o((l, m) => {
            const b = Nt(l),
              x = { type: 'FunctionType', params: b.params.map(m) };
            return (
              b.this !== void 0 && (x.this = m(b.this)),
              b.new !== void 0 && (x.new = m(b.new)),
              l.returnType !== void 0 && (x.result = m(l.returnType)),
              x
            );
          }, 'JsdocTypeFunction'),
          JsdocTypeGeneric: o(
            (l, m) => ({
              type: 'TypeApplication',
              applications: l.elements.map((b) => m(b)),
              expression: m(l.left),
            }),
            'JsdocTypeGeneric',
          ),
          JsdocTypeSpecialNamePath: o(
            (l) => Xe(l.specialType + ':' + Ye(l.value, l.meta.quote)),
            'JsdocTypeSpecialNamePath',
          ),
          JsdocTypeName: o(
            (l) => (l.value !== 'function' ? Xe(l.value) : { type: 'FunctionType', params: [] }),
            'JsdocTypeName',
          ),
          JsdocTypeNumber: o((l) => Xe(l.value.toString()), 'JsdocTypeNumber'),
          JsdocTypeObject: o((l, m) => {
            const b = { type: 'RecordType', fields: [] };
            for (const x of l.elements)
              x.type !== 'JsdocTypeObjectField' && x.type !== 'JsdocTypeJsdocObjectField'
                ? b.fields.push({ type: 'FieldType', key: m(x), value: void 0 })
                : b.fields.push(m(x));
            return b;
          }, 'JsdocTypeObject'),
          JsdocTypeObjectField: o((l, m) => {
            if (typeof l.key != 'string')
              throw new Error('Index signatures and mapped types are not supported');
            return {
              type: 'FieldType',
              key: Xe(Ye(l.key, l.meta.quote)),
              value: l.right === void 0 ? void 0 : m(l.right),
            };
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: o(
            (l, m) => ({ type: 'FieldType', key: m(l.left), value: m(l.right) }),
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeUnion: o(
            (l, m) => ({ type: 'TypeUnion', elements: l.elements.map((b) => m(b)) }),
            'JsdocTypeUnion',
          ),
          JsdocTypeKeyValue: o(
            (l, m) => ({
              type: 'FieldType',
              key: Xe(l.key),
              value: l.right === void 0 ? void 0 : m(l.right),
            }),
            'JsdocTypeKeyValue',
          ),
          JsdocTypeNamePath: o((l, m) => {
            const b = m(l.left);
            let x;
            l.right.type === 'JsdocTypeSpecialNamePath'
              ? (x = m(l.right).name)
              : (x = Ye(l.right.value, l.right.meta.quote));
            const F = l.pathType === 'inner' ? '~' : l.pathType === 'instance' ? '#' : '.';
            return Xe(`${b.name}${F}${x}`);
          }, 'JsdocTypeNamePath'),
          JsdocTypeSymbol: o((l) => {
            let m = '',
              b = l.element,
              x = !1;
            return (
              b?.type === 'JsdocTypeVariadic' &&
                (b.meta.position === 'prefix' ? (m = '...') : (x = !0), (b = b.element)),
              b?.type === 'JsdocTypeName'
                ? (m += b.value)
                : b?.type === 'JsdocTypeNumber' && (m += b.value.toString()),
              x && (m += '...'),
              Xe(`${l.value}(${m})`)
            );
          }, 'JsdocTypeSymbol'),
          JsdocTypeParenthesis: o((l, m) => m(k(l.element)), 'JsdocTypeParenthesis'),
          JsdocTypeMappedType: le,
          JsdocTypeIndexSignature: le,
          JsdocTypeImport: le,
          JsdocTypeKeyof: le,
          JsdocTypeTuple: le,
          JsdocTypeTypeof: le,
          JsdocTypeIntersection: le,
          JsdocTypeProperty: le,
          JsdocTypePredicate: le,
          JsdocTypeAsserts: le,
          JsdocTypeReadonlyArray: le,
          JsdocTypeAssertsPlain: le,
          JsdocTypeConditional: le,
          JsdocTypeTypeParameter: le,
        };
        function Ko(l) {
          return Y(pc, l);
        }
        o(Ko, 'catharsisTransform');
        function st(l) {
          switch (l) {
            case void 0:
              return 'none';
            case 'single':
              return 'single';
            case 'double':
              return 'double';
          }
        }
        o(st, 'getQuoteStyle');
        function Yo(l) {
          switch (l) {
            case 'inner':
              return 'INNER_MEMBER';
            case 'instance':
              return 'INSTANCE_MEMBER';
            case 'property':
              return 'MEMBER';
            case 'property-brackets':
              return 'MEMBER';
          }
        }
        o(Yo, 'getMemberType');
        function cr(l, m) {
          return m.length === 2
            ? { type: l, left: m[0], right: m[1] }
            : { type: l, left: m[0], right: cr(l, m.slice(1)) };
        }
        o(cr, 'nestResults');
        const fc = {
          JsdocTypeOptional: o(
            (l, m) => ({
              type: 'OPTIONAL',
              value: m(l.element),
              meta: {
                syntax: l.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN',
              },
            }),
            'JsdocTypeOptional',
          ),
          JsdocTypeNullable: o(
            (l, m) => ({
              type: 'NULLABLE',
              value: m(l.element),
              meta: {
                syntax:
                  l.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK',
              },
            }),
            'JsdocTypeNullable',
          ),
          JsdocTypeNotNullable: o(
            (l, m) => ({
              type: 'NOT_NULLABLE',
              value: m(l.element),
              meta: { syntax: l.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG' },
            }),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeVariadic: o((l, m) => {
            const b = {
              type: 'VARIADIC',
              meta: {
                syntax:
                  l.meta.position === 'prefix'
                    ? 'PREFIX_DOTS'
                    : l.meta.position === 'suffix'
                      ? 'SUFFIX_DOTS'
                      : 'ONLY_DOTS',
              },
            };
            return (l.element !== void 0 && (b.value = m(l.element)), b);
          }, 'JsdocTypeVariadic'),
          JsdocTypeName: o((l) => ({ type: 'NAME', name: l.value }), 'JsdocTypeName'),
          JsdocTypeTypeof: o(
            (l, m) => ({ type: 'TYPE_QUERY', name: m(l.element) }),
            'JsdocTypeTypeof',
          ),
          JsdocTypeTuple: o(
            (l, m) => ({ type: 'TUPLE', entries: l.elements.map(m) }),
            'JsdocTypeTuple',
          ),
          JsdocTypeKeyof: o(
            (l, m) => ({ type: 'KEY_QUERY', value: m(l.element) }),
            'JsdocTypeKeyof',
          ),
          JsdocTypeImport: o(
            (l) => ({
              type: 'IMPORT',
              path: {
                type: 'STRING_VALUE',
                quoteStyle: st(l.element.meta.quote),
                string: l.element.value,
              },
            }),
            'JsdocTypeImport',
          ),
          JsdocTypeUndefined: o(() => ({ type: 'NAME', name: 'undefined' }), 'JsdocTypeUndefined'),
          JsdocTypeAny: o(() => ({ type: 'ANY' }), 'JsdocTypeAny'),
          JsdocTypeFunction: o((l, m) => {
            const b = Nt(l),
              x = {
                type: l.arrow ? 'ARROW' : 'FUNCTION',
                params: b.params.map((F) => {
                  if (F.type === 'JsdocTypeKeyValue') {
                    if (F.right === void 0)
                      throw new Error(
                        "Function parameter without ':' is not expected to be 'KEY_VALUE'",
                      );
                    return { type: 'NAMED_PARAMETER', name: F.key, typeName: m(F.right) };
                  } else return m(F);
                }),
                new: null,
                returns: null,
              };
            return (
              b.this !== void 0 ? (x.this = m(b.this)) : l.arrow || (x.this = null),
              b.new !== void 0 && (x.new = m(b.new)),
              l.returnType !== void 0 && (x.returns = m(l.returnType)),
              x
            );
          }, 'JsdocTypeFunction'),
          JsdocTypeGeneric: o((l, m) => {
            const b = {
              type: 'GENERIC',
              subject: m(l.left),
              objects: l.elements.map(m),
              meta: {
                syntax:
                  l.meta.brackets === 'square'
                    ? 'SQUARE_BRACKET'
                    : l.meta.dot
                      ? 'ANGLE_BRACKET_WITH_DOT'
                      : 'ANGLE_BRACKET',
              },
            };
            return (
              l.meta.brackets === 'square' &&
                l.elements[0].type === 'JsdocTypeFunction' &&
                !l.elements[0].parenthesis &&
                (b.objects[0] = { type: 'NAME', name: 'function' }),
              b
            );
          }, 'JsdocTypeGeneric'),
          JsdocTypeObjectField: o((l, m) => {
            if (typeof l.key != 'string')
              throw new Error('Index signatures and mapped types are not supported');
            if (l.right === void 0)
              return {
                type: 'RECORD_ENTRY',
                key: l.key,
                quoteStyle: st(l.meta.quote),
                value: null,
                readonly: !1,
              };
            let b = m(l.right);
            return (
              l.optional &&
                (b = { type: 'OPTIONAL', value: b, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
              {
                type: 'RECORD_ENTRY',
                key: l.key.toString(),
                quoteStyle: st(l.meta.quote),
                value: b,
                readonly: !1,
              }
            );
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: o(() => {
            throw new Error('Keys may not be typed in jsdoctypeparser.');
          }, 'JsdocTypeJsdocObjectField'),
          JsdocTypeKeyValue: o((l, m) => {
            if (l.right === void 0)
              return {
                type: 'RECORD_ENTRY',
                key: l.key,
                quoteStyle: 'none',
                value: null,
                readonly: !1,
              };
            let b = m(l.right);
            return (
              l.optional &&
                (b = { type: 'OPTIONAL', value: b, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
              { type: 'RECORD_ENTRY', key: l.key, quoteStyle: 'none', value: b, readonly: !1 }
            );
          }, 'JsdocTypeKeyValue'),
          JsdocTypeObject: o((l, m) => {
            const b = [];
            for (const x of l.elements)
              (x.type === 'JsdocTypeObjectField' || x.type === 'JsdocTypeJsdocObjectField') &&
                b.push(m(x));
            return { type: 'RECORD', entries: b };
          }, 'JsdocTypeObject'),
          JsdocTypeSpecialNamePath: o((l) => {
            if (l.specialType !== 'module')
              throw new Error(
                `jsdoctypeparser does not support type ${l.specialType} at this point.`,
              );
            return {
              type: 'MODULE',
              value: { type: 'FILE_PATH', quoteStyle: st(l.meta.quote), path: l.value },
            };
          }, 'JsdocTypeSpecialNamePath'),
          JsdocTypeNamePath: o((l, m) => {
            let b = !1,
              x,
              F;
            l.right.type === 'JsdocTypeSpecialNamePath' && l.right.specialType === 'event'
              ? ((b = !0), (x = l.right.value), (F = st(l.right.meta.quote)))
              : ((x = l.right.value), (F = st(l.right.meta.quote)));
            const z = {
              type: Yo(l.pathType),
              owner: m(l.left),
              name: x,
              quoteStyle: F,
              hasEventPrefix: b,
            };
            if (z.owner.type === 'MODULE') {
              const Z = z.owner;
              return ((z.owner = z.owner.value), (Z.value = z), Z);
            } else return z;
          }, 'JsdocTypeNamePath'),
          JsdocTypeUnion: o((l, m) => cr('UNION', l.elements.map(m)), 'JsdocTypeUnion'),
          JsdocTypeParenthesis: o(
            (l, m) => ({ type: 'PARENTHESIS', value: m(k(l.element)) }),
            'JsdocTypeParenthesis',
          ),
          JsdocTypeNull: o(() => ({ type: 'NAME', name: 'null' }), 'JsdocTypeNull'),
          JsdocTypeUnknown: o(() => ({ type: 'UNKNOWN' }), 'JsdocTypeUnknown'),
          JsdocTypeStringValue: o(
            (l) => ({ type: 'STRING_VALUE', quoteStyle: st(l.meta.quote), string: l.value }),
            'JsdocTypeStringValue',
          ),
          JsdocTypeIntersection: o(
            (l, m) => cr('INTERSECTION', l.elements.map(m)),
            'JsdocTypeIntersection',
          ),
          JsdocTypeNumber: o(
            (l) => ({ type: 'NUMBER_VALUE', number: l.value.toString() }),
            'JsdocTypeNumber',
          ),
          JsdocTypeSymbol: le,
          JsdocTypeProperty: le,
          JsdocTypePredicate: le,
          JsdocTypeMappedType: le,
          JsdocTypeIndexSignature: le,
          JsdocTypeAsserts: le,
          JsdocTypeReadonlyArray: le,
          JsdocTypeAssertsPlain: le,
          JsdocTypeConditional: le,
          JsdocTypeTypeParameter: le,
        };
        function Xo(l) {
          return Y(fc, l);
        }
        o(Xo, 'jtpTransform');
        function Qo() {
          return {
            JsdocTypeIntersection: o(
              (l, m) => ({ type: 'JsdocTypeIntersection', elements: l.elements.map(m) }),
              'JsdocTypeIntersection',
            ),
            JsdocTypeGeneric: o(
              (l, m) => ({
                type: 'JsdocTypeGeneric',
                left: m(l.left),
                elements: l.elements.map(m),
                meta: { dot: l.meta.dot, brackets: l.meta.brackets },
              }),
              'JsdocTypeGeneric',
            ),
            JsdocTypeNullable: o((l) => l, 'JsdocTypeNullable'),
            JsdocTypeUnion: o(
              (l, m) => ({ type: 'JsdocTypeUnion', elements: l.elements.map(m) }),
              'JsdocTypeUnion',
            ),
            JsdocTypeUnknown: o((l) => l, 'JsdocTypeUnknown'),
            JsdocTypeUndefined: o((l) => l, 'JsdocTypeUndefined'),
            JsdocTypeTypeof: o(
              (l, m) => ({ type: 'JsdocTypeTypeof', element: m(l.element) }),
              'JsdocTypeTypeof',
            ),
            JsdocTypeSymbol: o((l, m) => {
              const b = { type: 'JsdocTypeSymbol', value: l.value };
              return (l.element !== void 0 && (b.element = m(l.element)), b);
            }, 'JsdocTypeSymbol'),
            JsdocTypeOptional: o(
              (l, m) => ({
                type: 'JsdocTypeOptional',
                element: m(l.element),
                meta: { position: l.meta.position },
              }),
              'JsdocTypeOptional',
            ),
            JsdocTypeObject: o(
              (l, m) => ({
                type: 'JsdocTypeObject',
                meta: { separator: 'comma' },
                elements: l.elements.map(m),
              }),
              'JsdocTypeObject',
            ),
            JsdocTypeNumber: o((l) => l, 'JsdocTypeNumber'),
            JsdocTypeNull: o((l) => l, 'JsdocTypeNull'),
            JsdocTypeNotNullable: o(
              (l, m) => ({
                type: 'JsdocTypeNotNullable',
                element: m(l.element),
                meta: { position: l.meta.position },
              }),
              'JsdocTypeNotNullable',
            ),
            JsdocTypeSpecialNamePath: o((l) => l, 'JsdocTypeSpecialNamePath'),
            JsdocTypeObjectField: o(
              (l, m) => ({
                type: 'JsdocTypeObjectField',
                key: l.key,
                right: l.right === void 0 ? void 0 : m(l.right),
                optional: l.optional,
                readonly: l.readonly,
                meta: l.meta,
              }),
              'JsdocTypeObjectField',
            ),
            JsdocTypeJsdocObjectField: o(
              (l, m) => ({ type: 'JsdocTypeJsdocObjectField', left: m(l.left), right: m(l.right) }),
              'JsdocTypeJsdocObjectField',
            ),
            JsdocTypeKeyValue: o(
              (l, m) => ({
                type: 'JsdocTypeKeyValue',
                key: l.key,
                right: l.right === void 0 ? void 0 : m(l.right),
                optional: l.optional,
                variadic: l.variadic,
              }),
              'JsdocTypeKeyValue',
            ),
            JsdocTypeImport: o(
              (l, m) => ({ type: 'JsdocTypeImport', element: m(l.element) }),
              'JsdocTypeImport',
            ),
            JsdocTypeAny: o((l) => l, 'JsdocTypeAny'),
            JsdocTypeStringValue: o((l) => l, 'JsdocTypeStringValue'),
            JsdocTypeNamePath: o((l) => l, 'JsdocTypeNamePath'),
            JsdocTypeVariadic: o((l, m) => {
              const b = {
                type: 'JsdocTypeVariadic',
                meta: { position: l.meta.position, squareBrackets: l.meta.squareBrackets },
              };
              return (l.element !== void 0 && (b.element = m(l.element)), b);
            }, 'JsdocTypeVariadic'),
            JsdocTypeTuple: o(
              (l, m) => ({ type: 'JsdocTypeTuple', elements: l.elements.map(m) }),
              'JsdocTypeTuple',
            ),
            JsdocTypeName: o((l) => l, 'JsdocTypeName'),
            JsdocTypeFunction: o((l, m) => {
              const b = {
                type: 'JsdocTypeFunction',
                arrow: l.arrow,
                parameters: l.parameters.map(m),
                constructor: l.constructor,
                parenthesis: l.parenthesis,
              };
              return (l.returnType !== void 0 && (b.returnType = m(l.returnType)), b);
            }, 'JsdocTypeFunction'),
            JsdocTypeKeyof: o(
              (l, m) => ({ type: 'JsdocTypeKeyof', element: m(l.element) }),
              'JsdocTypeKeyof',
            ),
            JsdocTypeParenthesis: o(
              (l, m) => ({ type: 'JsdocTypeParenthesis', element: m(l.element) }),
              'JsdocTypeParenthesis',
            ),
            JsdocTypeProperty: o((l) => l, 'JsdocTypeProperty'),
            JsdocTypePredicate: o(
              (l, m) => ({ type: 'JsdocTypePredicate', left: m(l.left), right: m(l.right) }),
              'JsdocTypePredicate',
            ),
            JsdocTypeIndexSignature: o(
              (l, m) => ({ type: 'JsdocTypeIndexSignature', key: l.key, right: m(l.right) }),
              'JsdocTypeIndexSignature',
            ),
            JsdocTypeMappedType: o(
              (l, m) => ({ type: 'JsdocTypeMappedType', key: l.key, right: m(l.right) }),
              'JsdocTypeMappedType',
            ),
            JsdocTypeAsserts: o(
              (l, m) => ({ type: 'JsdocTypeAsserts', left: m(l.left), right: m(l.right) }),
              'JsdocTypeAsserts',
            ),
            JsdocTypeReadonlyArray: o(
              (l, m) => ({ type: 'JsdocTypeReadonlyArray', element: m(l.element) }),
              'JsdocTypeReadonlyArray',
            ),
            JsdocTypeAssertsPlain: o(
              (l, m) => ({ type: 'JsdocTypeAssertsPlain', element: m(l.element) }),
              'JsdocTypeAssertsPlain',
            ),
            JsdocTypeConditional: o(
              (l, m) => ({
                type: 'JsdocTypeConditional',
                checksType: m(l.checksType),
                extendsType: m(l.extendsType),
                trueType: m(l.trueType),
                falseType: m(l.falseType),
              }),
              'JsdocTypeConditional',
            ),
            JsdocTypeTypeParameter: o(
              (l, m) => ({
                type: 'JsdocTypeTypeParameter',
                name: m(l.name),
                constraint: l.constraint !== void 0 ? m(l.constraint) : void 0,
                defaultValue: l.defaultValue !== void 0 ? m(l.defaultValue) : void 0,
              }),
              'JsdocTypeTypeParameter',
            ),
          };
        }
        o(Qo, 'identityTransformRules');
        const Zo = {
          JsdocTypeAny: [],
          JsdocTypeFunction: ['parameters', 'returnType'],
          JsdocTypeGeneric: ['left', 'elements'],
          JsdocTypeImport: [],
          JsdocTypeIndexSignature: ['right'],
          JsdocTypeIntersection: ['elements'],
          JsdocTypeKeyof: ['element'],
          JsdocTypeKeyValue: ['right'],
          JsdocTypeMappedType: ['right'],
          JsdocTypeName: [],
          JsdocTypeNamePath: ['left', 'right'],
          JsdocTypeNotNullable: ['element'],
          JsdocTypeNull: [],
          JsdocTypeNullable: ['element'],
          JsdocTypeNumber: [],
          JsdocTypeObject: ['elements'],
          JsdocTypeObjectField: ['right'],
          JsdocTypeJsdocObjectField: ['left', 'right'],
          JsdocTypeOptional: ['element'],
          JsdocTypeParenthesis: ['element'],
          JsdocTypeSpecialNamePath: [],
          JsdocTypeStringValue: [],
          JsdocTypeSymbol: ['element'],
          JsdocTypeTuple: ['elements'],
          JsdocTypeTypeof: ['element'],
          JsdocTypeUndefined: [],
          JsdocTypeUnion: ['elements'],
          JsdocTypeUnknown: [],
          JsdocTypeVariadic: ['element'],
          JsdocTypeProperty: [],
          JsdocTypePredicate: ['left', 'right'],
          JsdocTypeAsserts: ['left', 'right'],
          JsdocTypeReadonlyArray: ['element'],
          JsdocTypeAssertsPlain: ['element'],
          JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],
          JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue'],
        };
        function ur(l, m, b, x, F) {
          x?.(l, m, b);
          const z = Zo[l.type];
          for (const Z of z) {
            const ce = l[Z];
            if (ce !== void 0)
              if (Array.isArray(ce)) for (const _e of ce) ur(_e, l, Z, x, F);
              else ur(ce, l, Z, x, F);
          }
          F?.(l, m, b);
        }
        o(ur, '_traverse');
        function ei(l, m, b) {
          ur(l, void 0, void 0, m, b);
        }
        (o(ei, 'traverse'),
          (r.catharsisTransform = Ko),
          (r.identityTransformRules = Qo),
          (r.jtpTransform = Xo),
          (r.parse = lr),
          (r.stringify = Wo),
          (r.stringifyRules = rn),
          (r.transform = Y),
          (r.traverse = ei),
          (r.tryParse = tn),
          (r.visitorKeys = Zo));
      });
    },
  }),
  Sj = J({
    '../node_modules/browser-dtector/browser-dtector.umd.min.js'(e, t) {
      (function (r, n) {
        typeof e == 'object' && typeof t < 'u'
          ? (t.exports = n())
          : typeof define == 'function' && define.amd
            ? define(n)
            : ((r = typeof globalThis < 'u' ? globalThis : r || self).BrowserDetector = n());
      })(e, function () {
        function r(d, u) {
          for (var p = 0; p < u.length; p++) {
            var f = u[p];
            ((f.enumerable = f.enumerable || !1),
              (f.configurable = !0),
              'value' in f && (f.writable = !0),
              Object.defineProperty(
                d,
                ((y = f.key),
                (h = void 0),
                typeof (h = (function (g, T) {
                  if (typeof g != 'object' || g === null) return g;
                  var E = g[Symbol.toPrimitive];
                  if (E !== void 0) {
                    var v = E.call(g, T);
                    if (typeof v != 'object') return v;
                    throw new TypeError('@@toPrimitive must return a primitive value.');
                  }
                  return (T === 'string' ? String : Number)(g);
                })(y, 'string')) == 'symbol'
                  ? h
                  : String(h)),
                f,
              ));
          }
          var y, h;
        }
        o(r, 'e');
        var n = {
            chrome: 'Google Chrome',
            brave: 'Brave',
            crios: 'Google Chrome',
            edge: 'Microsoft Edge',
            edg: 'Microsoft Edge',
            edgios: 'Microsoft Edge',
            fennec: 'Mozilla Firefox',
            jsdom: 'JsDOM',
            mozilla: 'Mozilla Firefox',
            fxios: 'Mozilla Firefox',
            msie: 'Microsoft Internet Explorer',
            opera: 'Opera',
            opios: 'Opera',
            opr: 'Opera',
            opt: 'Opera',
            rv: 'Microsoft Internet Explorer',
            safari: 'Safari',
            samsungbrowser: 'Samsung Browser',
            electron: 'Electron',
          },
          i = {
            android: 'Android',
            androidTablet: 'Android Tablet',
            cros: 'Chrome OS',
            fennec: 'Android Tablet',
            ipad: 'IPad',
            iphone: 'IPhone',
            jsdom: 'JsDOM',
            linux: 'Linux',
            mac: 'Macintosh',
            tablet: 'Android Tablet',
            win: 'Windows',
            'windows phone': 'Windows Phone',
            xbox: 'Microsoft Xbox',
          },
          s = o(function (d) {
            var u = new RegExp(
                '^-?\\d+(?:.\\d{0,'.concat(
                  arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1,
                  '})?',
                ),
              ),
              p = Number(d).toString().match(u);
            return p ? p[0] : null;
          }, 'n'),
          a = o(function () {
            return typeof window < 'u' ? window.navigator : null;
          }, 'i'),
          c = (function () {
            function d(y) {
              var h;
              ((function (g, T) {
                if (!(g instanceof T)) throw new TypeError('Cannot call a class as a function');
              })(this, d),
                (this.userAgent =
                  y || ((h = a()) === null || h === void 0 ? void 0 : h.userAgent) || null));
            }
            o(d, 't');
            var u, p, f;
            return (
              (u = d),
              (p = [
                {
                  key: 'parseUserAgent',
                  value: o(function (y) {
                    var h,
                      g,
                      T,
                      E = {},
                      v = y || this.userAgent || '',
                      S = v.toLowerCase().replace(/\s\s+/g, ' '),
                      A =
                        /(edge)\/([\w.]+)/.exec(S) ||
                        /(edg)[/]([\w.]+)/.exec(S) ||
                        /(opr)[/]([\w.]+)/.exec(S) ||
                        /(opt)[/]([\w.]+)/.exec(S) ||
                        /(fxios)[/]([\w.]+)/.exec(S) ||
                        /(edgios)[/]([\w.]+)/.exec(S) ||
                        /(jsdom)[/]([\w.]+)/.exec(S) ||
                        /(samsungbrowser)[/]([\w.]+)/.exec(S) ||
                        /(electron)[/]([\w.]+)/.exec(S) ||
                        /(chrome)[/]([\w.]+)/.exec(S) ||
                        /(crios)[/]([\w.]+)/.exec(S) ||
                        /(opios)[/]([\w.]+)/.exec(S) ||
                        /(version)(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(webkit)[/]([\w.]+).*(version)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(S) ||
                        /(webkit)[/]([\w.]+)/.exec(S) ||
                        /(opera)(?:.*version|)[/]([\w.]+)/.exec(S) ||
                        /(msie) ([\w.]+)/.exec(S) ||
                        /(fennec)[/]([\w.]+)/.exec(S) ||
                        (S.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(S)) ||
                        (S.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(S)) ||
                        [],
                      N =
                        /(ipad)/.exec(S) ||
                        /(ipod)/.exec(S) ||
                        /(iphone)/.exec(S) ||
                        /(jsdom)/.exec(S) ||
                        /(windows phone)/.exec(S) ||
                        /(xbox)/.exec(S) ||
                        /(win)/.exec(S) ||
                        /(tablet)/.exec(S) ||
                        (/(android)/.test(S) && /(mobile)/.test(S) === !1 && ['androidTablet']) ||
                        /(android)/.exec(S) ||
                        /(mac)/.exec(S) ||
                        /(linux)/.exec(S) ||
                        /(cros)/.exec(S) ||
                        [],
                      j = A[5] || A[3] || A[1] || null,
                      C = N[0] || null,
                      R = A[4] || A[2] || null,
                      w = a();
                    (j === 'chrome' &&
                      typeof (w == null || (h = w.brave) === null || h === void 0
                        ? void 0
                        : h.isBrave) == 'function' &&
                      (j = 'brave'),
                      j && (E[j] = !0),
                      C && (E[C] = !0));
                    var _ = !!(E.tablet || E.android || E.androidTablet),
                      k = !!(E.ipad || E.tablet || E.androidTablet),
                      I = !!(
                        E.android ||
                        E.androidTablet ||
                        E.tablet ||
                        E.ipad ||
                        E.ipod ||
                        E.iphone ||
                        E['windows phone']
                      ),
                      V = !!(E.cros || E.mac || E.linux || E.win),
                      H = !!(
                        E.brave ||
                        E.chrome ||
                        E.crios ||
                        E.opr ||
                        E.safari ||
                        E.edg ||
                        E.electron
                      ),
                      P = !!(E.msie || E.rv);
                    return {
                      name: (g = n[j]) !== null && g !== void 0 ? g : null,
                      platform: (T = i[C]) !== null && T !== void 0 ? T : null,
                      userAgent: v,
                      version: R,
                      shortVersion: R ? s(parseFloat(R), 2) : null,
                      isAndroid: _,
                      isTablet: k,
                      isMobile: I,
                      isDesktop: V,
                      isWebkit: H,
                      isIE: P,
                    };
                  }, 'value'),
                },
                {
                  key: 'getBrowserInfo',
                  value: o(function () {
                    var y = this.parseUserAgent();
                    return {
                      name: y.name,
                      platform: y.platform,
                      userAgent: y.userAgent,
                      version: y.version,
                      shortVersion: y.shortVersion,
                    };
                  }, 'value'),
                },
              ]),
              (f = [
                {
                  key: 'VERSION',
                  get: o(function () {
                    return '3.4.0';
                  }, 'get'),
                },
              ]),
              p && r(u.prototype, p),
              f && r(u, f),
              Object.defineProperty(u, 'prototype', { writable: !1 }),
              d
            );
          })();
        return c;
      });
    },
  }),
  Gd = {};
Et(Gd, {
  ARGTYPES_INFO_REQUEST: () => Db,
  ARGTYPES_INFO_RESPONSE: () => Gc,
  CHANNEL_CREATED: () => Rj,
  CHANNEL_WS_DISCONNECT: () => gb,
  CONFIG_ERROR: () => bb,
  CREATE_NEW_STORYFILE_REQUEST: () => Pj,
  CREATE_NEW_STORYFILE_RESPONSE: () => Aj,
  CURRENT_STORY_WAS_SET: () => Uc,
  DOCS_PREPARED: () => vb,
  DOCS_RENDERED: () => Wd,
  FILE_COMPONENT_SEARCH_REQUEST: () => Oj,
  FILE_COMPONENT_SEARCH_RESPONSE: () => Cj,
  FORCE_REMOUNT: () => Us,
  FORCE_RE_RENDER: () => Kd,
  GLOBALS_UPDATED: () => Ci,
  NAVIGATE_URL: () => xj,
  OPEN_IN_EDITOR_REQUEST: () => Wj,
  OPEN_IN_EDITOR_RESPONSE: () => Kj,
  PLAY_FUNCTION_THREW_EXCEPTION: () => Eb,
  PRELOAD_ENTRIES: () => wb,
  PREVIEW_BUILDER_PROGRESS: () => Nj,
  PREVIEW_INITIALIZED: () => Sb,
  PREVIEW_KEYDOWN: () => _b,
  REGISTER_SUBSCRIPTION: () => Ij,
  REQUEST_WHATS_NEW_DATA: () => $j,
  RESET_STORY_ARGS: () => Yd,
  RESULT_WHATS_NEW_DATA: () => Uj,
  SAVE_STORY_REQUEST: () => Gj,
  SAVE_STORY_RESPONSE: () => zj,
  SELECT_STORY: () => Mj,
  SET_CONFIG: () => qj,
  SET_CURRENT_STORY: () => Xd,
  SET_FILTER: () => jj,
  SET_GLOBALS: () => Rb,
  SET_INDEX: () => kj,
  SET_STORIES: () => Dj,
  SET_WHATS_NEW_CACHE: () => Vj,
  SHARED_STATE_CHANGED: () => Lj,
  SHARED_STATE_SET: () => Fj,
  STORIES_COLLAPSE_ALL: () => Bj,
  STORIES_EXPAND_ALL: () => Jj,
  STORY_ARGS_UPDATED: () => Pb,
  STORY_CHANGED: () => Ab,
  STORY_ERRORED: () => Ob,
  STORY_FINISHED: () => Hc,
  STORY_HOT_UPDATED: () => qb,
  STORY_INDEX_INVALIDATED: () => Cb,
  STORY_MISSING: () => Vc,
  STORY_PREPARED: () => xb,
  STORY_RENDERED: () => Vs,
  STORY_RENDER_PHASE_CHANGED: () => gn,
  STORY_SPECIFIED: () => Nb,
  STORY_THREW_EXCEPTION: () => Ib,
  STORY_UNCHANGED: () => Mb,
  TELEMETRY_ERROR: () => kb,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => Hj,
  UNHANDLED_ERRORS_WHILE_PLAYING: () => Tb,
  UPDATE_GLOBALS: () => Qd,
  UPDATE_QUERY_PARAMS: () => jb,
  UPDATE_STORY_ARGS: () => Zd,
  default: () => _j,
});
var zd = ((e) => (
    (e.CHANNEL_WS_DISCONNECT = 'channelWSDisconnect'),
    (e.CHANNEL_CREATED = 'channelCreated'),
    (e.CONFIG_ERROR = 'configError'),
    (e.STORY_INDEX_INVALIDATED = 'storyIndexInvalidated'),
    (e.STORY_SPECIFIED = 'storySpecified'),
    (e.SET_CONFIG = 'setConfig'),
    (e.SET_STORIES = 'setStories'),
    (e.SET_INDEX = 'setIndex'),
    (e.SET_CURRENT_STORY = 'setCurrentStory'),
    (e.CURRENT_STORY_WAS_SET = 'currentStoryWasSet'),
    (e.FORCE_RE_RENDER = 'forceReRender'),
    (e.FORCE_REMOUNT = 'forceRemount'),
    (e.PRELOAD_ENTRIES = 'preloadStories'),
    (e.STORY_PREPARED = 'storyPrepared'),
    (e.DOCS_PREPARED = 'docsPrepared'),
    (e.STORY_CHANGED = 'storyChanged'),
    (e.STORY_UNCHANGED = 'storyUnchanged'),
    (e.STORY_RENDERED = 'storyRendered'),
    (e.STORY_FINISHED = 'storyFinished'),
    (e.STORY_MISSING = 'storyMissing'),
    (e.STORY_ERRORED = 'storyErrored'),
    (e.STORY_THREW_EXCEPTION = 'storyThrewException'),
    (e.STORY_RENDER_PHASE_CHANGED = 'storyRenderPhaseChanged'),
    (e.STORY_HOT_UPDATED = 'storyHotUpdated'),
    (e.PLAY_FUNCTION_THREW_EXCEPTION = 'playFunctionThrewException'),
    (e.UNHANDLED_ERRORS_WHILE_PLAYING = 'unhandledErrorsWhilePlaying'),
    (e.UPDATE_STORY_ARGS = 'updateStoryArgs'),
    (e.STORY_ARGS_UPDATED = 'storyArgsUpdated'),
    (e.RESET_STORY_ARGS = 'resetStoryArgs'),
    (e.SET_FILTER = 'setFilter'),
    (e.SET_GLOBALS = 'setGlobals'),
    (e.UPDATE_GLOBALS = 'updateGlobals'),
    (e.GLOBALS_UPDATED = 'globalsUpdated'),
    (e.REGISTER_SUBSCRIPTION = 'registerSubscription'),
    (e.PREVIEW_INITIALIZED = 'previewInitialized'),
    (e.PREVIEW_KEYDOWN = 'previewKeydown'),
    (e.PREVIEW_BUILDER_PROGRESS = 'preview_builder_progress'),
    (e.SELECT_STORY = 'selectStory'),
    (e.STORIES_COLLAPSE_ALL = 'storiesCollapseAll'),
    (e.STORIES_EXPAND_ALL = 'storiesExpandAll'),
    (e.DOCS_RENDERED = 'docsRendered'),
    (e.SHARED_STATE_CHANGED = 'sharedStateChanged'),
    (e.SHARED_STATE_SET = 'sharedStateSet'),
    (e.NAVIGATE_URL = 'navigateUrl'),
    (e.UPDATE_QUERY_PARAMS = 'updateQueryParams'),
    (e.REQUEST_WHATS_NEW_DATA = 'requestWhatsNewData'),
    (e.RESULT_WHATS_NEW_DATA = 'resultWhatsNewData'),
    (e.SET_WHATS_NEW_CACHE = 'setWhatsNewCache'),
    (e.TOGGLE_WHATS_NEW_NOTIFICATIONS = 'toggleWhatsNewNotifications'),
    (e.TELEMETRY_ERROR = 'telemetryError'),
    (e.FILE_COMPONENT_SEARCH_REQUEST = 'fileComponentSearchRequest'),
    (e.FILE_COMPONENT_SEARCH_RESPONSE = 'fileComponentSearchResponse'),
    (e.SAVE_STORY_REQUEST = 'saveStoryRequest'),
    (e.SAVE_STORY_RESPONSE = 'saveStoryResponse'),
    (e.ARGTYPES_INFO_REQUEST = 'argtypesInfoRequest'),
    (e.ARGTYPES_INFO_RESPONSE = 'argtypesInfoResponse'),
    (e.CREATE_NEW_STORYFILE_REQUEST = 'createNewStoryfileRequest'),
    (e.CREATE_NEW_STORYFILE_RESPONSE = 'createNewStoryfileResponse'),
    (e.OPEN_IN_EDITOR_REQUEST = 'openInEditorRequest'),
    (e.OPEN_IN_EDITOR_RESPONSE = 'openInEditorResponse'),
    e
  ))(zd || {}),
  _j = zd,
  {
    CHANNEL_WS_DISCONNECT: gb,
    CHANNEL_CREATED: Rj,
    CONFIG_ERROR: bb,
    CREATE_NEW_STORYFILE_REQUEST: Pj,
    CREATE_NEW_STORYFILE_RESPONSE: Aj,
    CURRENT_STORY_WAS_SET: Uc,
    DOCS_PREPARED: vb,
    DOCS_RENDERED: Wd,
    FILE_COMPONENT_SEARCH_REQUEST: Oj,
    FILE_COMPONENT_SEARCH_RESPONSE: Cj,
    FORCE_RE_RENDER: Kd,
    FORCE_REMOUNT: Us,
    GLOBALS_UPDATED: Ci,
    NAVIGATE_URL: xj,
    PLAY_FUNCTION_THREW_EXCEPTION: Eb,
    UNHANDLED_ERRORS_WHILE_PLAYING: Tb,
    PRELOAD_ENTRIES: wb,
    PREVIEW_INITIALIZED: Sb,
    PREVIEW_BUILDER_PROGRESS: Nj,
    PREVIEW_KEYDOWN: _b,
    REGISTER_SUBSCRIPTION: Ij,
    RESET_STORY_ARGS: Yd,
    SELECT_STORY: Mj,
    SET_CONFIG: qj,
    SET_CURRENT_STORY: Xd,
    SET_FILTER: jj,
    SET_GLOBALS: Rb,
    SET_INDEX: kj,
    SET_STORIES: Dj,
    SHARED_STATE_CHANGED: Lj,
    SHARED_STATE_SET: Fj,
    STORIES_COLLAPSE_ALL: Bj,
    STORIES_EXPAND_ALL: Jj,
    STORY_ARGS_UPDATED: Pb,
    STORY_CHANGED: Ab,
    STORY_ERRORED: Ob,
    STORY_INDEX_INVALIDATED: Cb,
    STORY_MISSING: Vc,
    STORY_PREPARED: xb,
    STORY_RENDER_PHASE_CHANGED: gn,
    STORY_RENDERED: Vs,
    STORY_FINISHED: Hc,
    STORY_SPECIFIED: Nb,
    STORY_THREW_EXCEPTION: Ib,
    STORY_UNCHANGED: Mb,
    STORY_HOT_UPDATED: qb,
    UPDATE_GLOBALS: Qd,
    UPDATE_QUERY_PARAMS: jb,
    UPDATE_STORY_ARGS: Zd,
    REQUEST_WHATS_NEW_DATA: $j,
    RESULT_WHATS_NEW_DATA: Uj,
    SET_WHATS_NEW_CACHE: Vj,
    TOGGLE_WHATS_NEW_NOTIFICATIONS: Hj,
    TELEMETRY_ERROR: kb,
    SAVE_STORY_REQUEST: Gj,
    SAVE_STORY_RESPONSE: zj,
    ARGTYPES_INFO_REQUEST: Db,
    ARGTYPES_INFO_RESPONSE: Gc,
    OPEN_IN_EDITOR_REQUEST: Wj,
    OPEN_IN_EDITOR_RESPONSE: Kj,
  } = zd,
  Lb = {};
Et(Lb, { global: () => te });
var te = (() => {
    let e;
    return (
      typeof window < 'u'
        ? (e = window)
        : typeof globalThis < 'u'
          ? (e = globalThis)
          : typeof global < 'u'
            ? (e = global)
            : typeof self < 'u'
              ? (e = self)
              : (e = {}),
      e
    );
  })(),
  Fb = {
    '@storybook/global': '__STORYBOOK_MODULE_GLOBAL__',
    'storybook/test': '__STORYBOOK_MODULE_TEST__',
    'storybook/actions': '__STORYBOOK_MODULE_ACTIONS__',
    'storybook/preview-api': '__STORYBOOK_MODULE_PREVIEW_API__',
    'storybook/internal/channels': '__STORYBOOK_MODULE_CHANNELS__',
    'storybook/internal/client-logger': '__STORYBOOK_MODULE_CLIENT_LOGGER__',
    'storybook/internal/core-events': '__STORYBOOK_MODULE_CORE_EVENTS__',
    'storybook/internal/preview-errors': '__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__',
    'storybook/internal/types': '__STORYBOOK_MODULE_TYPES__',
    'storybook/internal/preview-api': '__STORYBOOK_MODULE_PREVIEW_API__',
  },
  Yj = Object.keys(Fb),
  Bb = {};
Et(Bb, {
  Channel: () => Fa,
  HEARTBEAT_INTERVAL: () => Xv,
  HEARTBEAT_MAX_LATENCY: () => Qv,
  PostMessageTransport: () => Yv,
  WebsocketTransport: () => eE,
  createBrowserChannel: () => tE,
  default: () => TL,
});
function ve(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = Array.from(typeof e == 'string' ? [e] : e);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '');
  var i = n.reduce(function (c, d) {
    var u = d.match(/\n([\t ]+|(?!\s).)/g);
    return u
      ? c.concat(
          u.map(function (p) {
            var f, y;
            return (y = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !==
              null && y !== void 0
              ? y
              : 0;
          }),
        )
      : c;
  }, []);
  if (i.length) {
    var s = new RegExp(
      `
[	 ]{` +
        Math.min.apply(Math, i) +
        '}',
      'g',
    );
    n = n.map(function (c) {
      return c.replace(
        s,
        `
`,
      );
    });
  }
  n[0] = n[0].replace(/^\r?\n/, '');
  var a = n[0];
  return (
    t.forEach(function (c, d) {
      var u = a.match(/(?:^|\n)( *)$/),
        p = u ? u[1] : '',
        f = c;
      (typeof c == 'string' &&
        c.includes(`
`) &&
        (f = String(c)
          .split(
            `
`,
          )
          .map(function (y, h) {
            return h === 0 ? y : '' + p + y;
          }).join(`
`)),
        (a += f + n[d + 1]));
    }),
    a
  );
}
o(ve, 'dedent');
var mh = new Map(),
  Xj = 'UNIVERSAL_STORE:',
  It = { PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED' },
  zr = class fe {
    constructor(t, r) {
      if (
        ((this.debugging = !1),
        (this.listeners = new Map([['*', new Set()]])),
        (this.getState = o(
          () => (this.debug('getState', { state: this.state }), this.state),
          'getState',
        )),
        (this.subscribe = o((n, i) => {
          const s = typeof n == 'function',
            a = s ? '*' : n,
            c = s ? n : i;
          if ((this.debug('subscribe', { eventType: a, listener: c }), !c))
            throw new TypeError(
              `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`,
            );
          return (
            this.listeners.has(a) || this.listeners.set(a, new Set()),
            this.listeners.get(a).add(c),
            () => {
              (this.debug('unsubscribe', { eventType: a, listener: c }),
                this.listeners.has(a) &&
                  (this.listeners.get(a).delete(c),
                  this.listeners.get(a)?.size === 0 && this.listeners.delete(a)));
            }
          );
        }, 'subscribe')),
        (this.send = o((n) => {
          if ((this.debug('send', { event: n }), this.status !== fe.Status.READY))
            throw new TypeError(ve`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify({ event: n, id: this.id, actor: this.actor, environment: this.environment }, null, 2)}`);
          (this.emitToListeners(n, { actor: this.actor }),
            this.emitToChannel(n, { actor: this.actor }));
        }, 'send')),
        (this.debugging = t.debug ?? !1),
        !fe.isInternalConstructing)
      )
        throw new TypeError(
          'UniversalStore is not constructable - use UniversalStore.create() instead',
        );
      if (
        ((fe.isInternalConstructing = !1),
        (this.id = t.id),
        (this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2)),
        (this.actorType = t.leader ? fe.ActorType.LEADER : fe.ActorType.FOLLOWER),
        (this.state = t.initialState),
        (this.channelEventName = `${Xj}${this.id}`),
        this.debug('constructor', {
          options: t,
          environmentOverrides: r,
          channelEventName: this.channelEventName,
        }),
        this.actor.type === fe.ActorType.LEADER)
      )
        this.syncing = { state: It.RESOLVED, promise: Promise.resolve() };
      else {
        let n, i;
        const s = new Promise((a, c) => {
          ((n = o(() => {
            this.syncing.state === It.PENDING && ((this.syncing.state = It.RESOLVED), a());
          }, 'syncingResolve')),
            (i = o((d) => {
              this.syncing.state === It.PENDING && ((this.syncing.state = It.REJECTED), c(d));
            }, 'syncingReject')));
        });
        this.syncing = { state: It.PENDING, promise: s, resolve: n, reject: i };
      }
      ((this.getState = this.getState.bind(this)),
        (this.setState = this.setState.bind(this)),
        (this.subscribe = this.subscribe.bind(this)),
        (this.onStateChange = this.onStateChange.bind(this)),
        (this.send = this.send.bind(this)),
        (this.emitToChannel = this.emitToChannel.bind(this)),
        (this.prepareThis = this.prepareThis.bind(this)),
        (this.emitToListeners = this.emitToListeners.bind(this)),
        (this.handleChannelEvents = this.handleChannelEvents.bind(this)),
        (this.debug = this.debug.bind(this)),
        (this.channel = r?.channel ?? fe.preparation.channel),
        (this.environment = r?.environment ?? fe.preparation.environment),
        this.channel && this.environment
          ? (fe.preparation.resolve({ channel: this.channel, environment: this.environment }),
            this.prepareThis({ channel: this.channel, environment: this.environment }))
          : fe.preparation.promise.then(this.prepareThis));
    }
    static setupPreparationPromise() {
      let t, r;
      const n = new Promise((i, s) => {
        ((t = o((a) => {
          i(a);
        }, 'resolveRef')),
          (r = o((...a) => {
            s(a);
          }, 'rejectRef')));
      });
      fe.preparation = { resolve: t, reject: r, promise: n };
    }
    get actor() {
      return Object.freeze({
        id: this.actorId,
        type: this.actorType,
        environment: this.environment ?? fe.Environment.UNKNOWN,
      });
    }
    get status() {
      if (!this.channel || !this.environment) return fe.Status.UNPREPARED;
      switch (this.syncing?.state) {
        case It.PENDING:
        case void 0:
          return fe.Status.SYNCING;
        case It.REJECTED:
          return fe.Status.ERROR;
        case It.RESOLVED:
        default:
          return fe.Status.READY;
      }
    }
    untilReady() {
      return Promise.all([fe.preparation.promise, this.syncing?.promise]);
    }
    static create(t) {
      if (!t || typeof t?.id != 'string')
        throw new TypeError('id is required and must be a string, when creating a UniversalStore');
      t.debug &&
        console.debug(
          ve`[UniversalStore]
        create`,
          { options: t },
        );
      const r = mh.get(t.id);
      if (r)
        return (
          console.warn(ve`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`),
          r
        );
      fe.isInternalConstructing = !0;
      const n = new fe(t);
      return (mh.set(t.id, n), n);
    }
    static __prepare(t, r) {
      ((fe.preparation.channel = t),
        (fe.preparation.environment = r),
        fe.preparation.resolve({ channel: t, environment: r }));
    }
    setState(t) {
      const r = this.state,
        n = typeof t == 'function' ? t(r) : t;
      if (
        (this.debug('setState', { newState: n, previousState: r, updater: t }),
        this.status !== fe.Status.READY)
      )
        throw new TypeError(ve`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify({ newState: n, id: this.id, actor: this.actor, environment: this.environment }, null, 2)}`);
      this.state = n;
      const i = { type: fe.InternalEventType.SET_STATE, payload: { state: n, previousState: r } };
      (this.emitToChannel(i, { actor: this.actor }),
        this.emitToListeners(i, { actor: this.actor }));
    }
    onStateChange(t) {
      return (
        this.debug('onStateChange', { listener: t }),
        this.subscribe(fe.InternalEventType.SET_STATE, ({ payload: r }, n) => {
          t(r.state, r.previousState, n);
        })
      );
    }
    emitToChannel(t, r) {
      (this.debug('emitToChannel', { event: t, eventInfo: r, channel: !!this.channel }),
        this.channel?.emit(this.channelEventName, { event: t, eventInfo: r }));
    }
    prepareThis({ channel: t, environment: r }) {
      ((this.channel = t),
        (this.environment = r),
        this.debug('prepared', { channel: !!t, environment: r }),
        this.channel.on(this.channelEventName, this.handleChannelEvents),
        this.actor.type === fe.ActorType.LEADER
          ? this.emitToChannel({ type: fe.InternalEventType.LEADER_CREATED }, { actor: this.actor })
          : (this.emitToChannel(
              { type: fe.InternalEventType.FOLLOWER_CREATED },
              { actor: this.actor },
            ),
            this.emitToChannel(
              { type: fe.InternalEventType.EXISTING_STATE_REQUEST },
              { actor: this.actor },
            ),
            setTimeout(() => {
              this.syncing.reject(
                new TypeError(
                  `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`,
                ),
              );
            }, 1e3)));
    }
    emitToListeners(t, r) {
      const n = this.listeners.get(t.type),
        i = this.listeners.get('*');
      (this.debug('emitToListeners', {
        event: t,
        eventInfo: r,
        eventTypeListeners: n,
        everythingListeners: i,
      }),
        [...(n ?? []), ...(i ?? [])].forEach((s) => s(t, r)));
    }
    handleChannelEvents(t) {
      const { event: r, eventInfo: n } = t;
      if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
        this.debug('handleChannelEvents: Ignoring event from self', { channelEvent: t });
        return;
      } else if (
        this.syncing?.state === It.PENDING &&
        r.type !== fe.InternalEventType.EXISTING_STATE_RESPONSE
      ) {
        this.debug('handleChannelEvents: Ignoring event while syncing', { channelEvent: t });
        return;
      }
      if (
        (this.debug('handleChannelEvents', { channelEvent: t }),
        this.actor.type === fe.ActorType.LEADER)
      ) {
        let i = !0;
        switch (r.type) {
          case fe.InternalEventType.EXISTING_STATE_REQUEST:
            i = !1;
            const s = { type: fe.InternalEventType.EXISTING_STATE_RESPONSE, payload: this.state };
            (this.debug('handleChannelEvents: responding to existing state request', {
              responseEvent: s,
            }),
              this.emitToChannel(s, { actor: this.actor }),
              this.emitToListeners(s, { actor: this.actor }));
            break;
          case fe.InternalEventType.LEADER_CREATED:
            ((i = !1),
              (this.syncing.state = It.REJECTED),
              this.debug('handleChannelEvents: erroring due to second leader being created', {
                event: r,
              }),
              console.error(ve`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`));
            break;
        }
        i &&
          (this.debug('handleChannelEvents: forwarding event', { channelEvent: t }),
          this.emitToChannel(r, { actor: n.actor, forwardingActor: this.actor }));
      }
      if (this.actor.type === fe.ActorType.FOLLOWER)
        switch (r.type) {
          case fe.InternalEventType.EXISTING_STATE_RESPONSE:
            if (
              (this.debug(
                "handleChannelEvents: Setting state from leader's existing state response",
                { event: r },
              ),
              this.syncing?.state !== It.PENDING)
            )
              break;
            this.syncing.resolve?.();
            const i = {
              type: fe.InternalEventType.SET_STATE,
              payload: { state: r.payload, previousState: this.state },
            };
            ((this.state = r.payload), this.emitToListeners(i, n));
            break;
        }
      switch (r.type) {
        case fe.InternalEventType.SET_STATE:
          (this.debug('handleChannelEvents: Setting state', { event: r }),
            (this.state = r.payload.state));
          break;
      }
      this.emitToListeners(r, { actor: n.actor });
    }
    debug(t, r) {
      this.debugging &&
        console.debug(
          ve`[UniversalStore::${this.id}::${this.environment ?? fe.Environment.UNKNOWN}]
        ${t}`,
          JSON.stringify(
            { data: r, actor: this.actor, state: this.state, status: this.status },
            null,
            2,
          ),
        );
    }
    static __reset() {
      (fe.preparation.reject(new Error('reset')),
        fe.setupPreparationPromise(),
        (fe.isInternalConstructing = !1));
    }
  };
o(zr, 'UniversalStore');
zr.ActorType = { LEADER: 'LEADER', FOLLOWER: 'FOLLOWER' };
zr.Environment = {
  SERVER: 'SERVER',
  MANAGER: 'MANAGER',
  PREVIEW: 'PREVIEW',
  UNKNOWN: 'UNKNOWN',
  MOCK: 'MOCK',
};
zr.InternalEventType = {
  EXISTING_STATE_REQUEST: '__EXISTING_STATE_REQUEST',
  EXISTING_STATE_RESPONSE: '__EXISTING_STATE_RESPONSE',
  SET_STATE: '__SET_STATE',
  LEADER_CREATED: '__LEADER_CREATED',
  FOLLOWER_CREATED: '__FOLLOWER_CREATED',
};
zr.Status = { UNPREPARED: 'UNPREPARED', SYNCING: 'SYNCING', READY: 'READY', ERROR: 'ERROR' };
zr.isInternalConstructing = !1;
zr.setupPreparationPromise();
var yc = zr,
  Qj = o((e) => e.transports !== void 0, 'isMulti'),
  Zj = o(() => Math.random().toString(16).slice(2), 'generateRandomId'),
  Jb = class {
    constructor(t = {}) {
      ((this.sender = Zj()),
        (this.events = {}),
        (this.data = {}),
        (this.transports = []),
        (this.isAsync = t.async || !1),
        Qj(t)
          ? ((this.transports = t.transports || []),
            this.transports.forEach((r) => {
              r.setHandler((n) => this.handleEvent(n));
            }))
          : (this.transports = t.transport ? [t.transport] : []),
        this.transports.forEach((r) => {
          r.setHandler((n) => this.handleEvent(n));
        }));
    }
    get hasTransport() {
      return this.transports.length > 0;
    }
    addListener(t, r) {
      ((this.events[t] = this.events[t] || []), this.events[t].push(r));
    }
    emit(t, ...r) {
      const n = { type: t, args: r, from: this.sender };
      let i = {};
      r.length >= 1 && r[0] && r[0].options && (i = r[0].options);
      const s = o(() => {
        (this.transports.forEach((a) => {
          a.send(n, i);
        }),
          this.handleEvent(n));
      }, 'handler');
      this.isAsync ? setImmediate(s) : s();
    }
    last(t) {
      return this.data[t];
    }
    eventNames() {
      return Object.keys(this.events);
    }
    listenerCount(t) {
      const r = this.listeners(t);
      return r ? r.length : 0;
    }
    listeners(t) {
      return this.events[t] || void 0;
    }
    once(t, r) {
      const n = this.onceListener(t, r);
      this.addListener(t, n);
    }
    removeAllListeners(t) {
      t ? this.events[t] && delete this.events[t] : (this.events = {});
    }
    removeListener(t, r) {
      const n = this.listeners(t);
      n && (this.events[t] = n.filter((i) => i !== r));
    }
    on(t, r) {
      this.addListener(t, r);
    }
    off(t, r) {
      this.removeListener(t, r);
    }
    handleEvent(t) {
      const r = this.listeners(t.type);
      (r &&
        r.length &&
        r.forEach((n) => {
          n.apply(t, t.args);
        }),
        (this.data[t.type] = t.args));
    }
    onceListener(t, r) {
      const n = o((...i) => (this.removeListener(t, n), r(...i)), 'onceListener');
      return n;
    }
  };
o(Jb, 'Channel');
var Fa = Jb,
  $b = {};
Et($b, { deprecate: () => ep, logger: () => De, once: () => Ve, pretty: () => Ot });
var { LOGLEVEL: ek } = te,
  Ir = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 },
  tk = ek,
  kn = Ir[tk] || Ir.info,
  De = {
    trace: o((e, ...t) => {
      kn <= Ir.trace && console.trace(e, ...t);
    }, 'trace'),
    debug: o((e, ...t) => {
      kn <= Ir.debug && console.debug(e, ...t);
    }, 'debug'),
    info: o((e, ...t) => {
      kn <= Ir.info && console.info(e, ...t);
    }, 'info'),
    warn: o((e, ...t) => {
      kn <= Ir.warn && console.warn(e, ...t);
    }, 'warn'),
    error: o((e, ...t) => {
      kn <= Ir.error && console.error(e, ...t);
    }, 'error'),
    log: o((e, ...t) => {
      kn < Ir.silent && console.log(e, ...t);
    }, 'log'),
  },
  zc = new Set(),
  Ve = o(
    (e) =>
      (t, ...r) => {
        if (!zc.has(t)) return (zc.add(t), De[e](t, ...r));
      },
    'once',
  );
Ve.clear = () => zc.clear();
Ve.trace = Ve('trace');
Ve.debug = Ve('debug');
Ve.info = Ve('info');
Ve.warn = Ve('warn');
Ve.error = Ve('error');
Ve.log = Ve('log');
var ep = Ve('warn'),
  Ot = o(
    (e) =>
      (...t) => {
        const r = [];
        if (t.length) {
          const n = /<span\s+style=(['"])([^'"]*)\1\s*>/gi,
            i = /<\/span>/gi;
          let s;
          for (r.push(t[0].replace(n, '%c').replace(i, '%c')); (s = n.exec(t[0])); )
            (r.push(s[2]), r.push(''));
          for (let a = 1; a < t.length; a++) r.push(t[a]);
        }
        De[e].apply(De, r);
      },
    'pretty',
  );
Ot.trace = Ot('trace');
Ot.debug = Ot('debug');
Ot.info = Ot('info');
Ot.warn = Ot('warn');
Ot.error = Ot('error');
var rk = Object.create,
  Ub = Object.defineProperty,
  nk = Object.getOwnPropertyDescriptor,
  Vb = Object.getOwnPropertyNames,
  ok = Object.getPrototypeOf,
  ik = Object.prototype.hasOwnProperty,
  ge = o(
    (e, t) =>
      o(function () {
        return (t || (0, e[Vb(e)[0]])((t = { exports: {} }).exports, t), t.exports);
      }, '__require'),
    '__commonJS',
  ),
  sk = o((e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let i of Vb(t))
        !ik.call(e, i) &&
          i !== r &&
          Ub(e, i, { get: o(() => t[i], 'get'), enumerable: !(n = nk(t, i)) || n.enumerable });
    return e;
  }, '__copyProps'),
  tp = o(
    (e, t, r) => (
      (r = e != null ? rk(ok(e)) : {}),
      sk(t || !e || !e.__esModule ? Ub(r, 'default', { value: e, enumerable: !0 }) : r, e)
    ),
    '__toESM',
  ),
  ak = [
    'bubbles',
    'cancelBubble',
    'cancelable',
    'composed',
    'currentTarget',
    'defaultPrevented',
    'eventPhase',
    'isTrusted',
    'returnValue',
    'srcElement',
    'target',
    'timeStamp',
    'type',
  ],
  lk = ['detail'];
function Hb(e) {
  const t = ak.filter((r) => e[r] !== void 0).reduce((r, n) => ((r[n] = e[n]), r), {});
  if (e instanceof CustomEvent) for (const r of lk.filter((n) => e[n] !== void 0)) t[r] = e[r];
  return t;
}
o(Hb, 'extractEventHiddenProperties');
var Gb = ge({
    'node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js'(e, t) {
      t.exports = Object;
    },
  }),
  ck = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js'(e, t) {
      t.exports = Error;
    },
  }),
  uk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js'(e, t) {
      t.exports = EvalError;
    },
  }),
  dk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js'(e, t) {
      t.exports = RangeError;
    },
  }),
  pk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js'(e, t) {
      t.exports = ReferenceError;
    },
  }),
  fk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js'(e, t) {
      t.exports = SyntaxError;
    },
  }),
  rp = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js'(e, t) {
      t.exports = TypeError;
    },
  }),
  mk = ge({
    'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js'(e, t) {
      t.exports = URIError;
    },
  }),
  yk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js'(e, t) {
      t.exports = Math.abs;
    },
  }),
  hk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js'(e, t) {
      t.exports = Math.floor;
    },
  }),
  gk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js'(e, t) {
      t.exports = Math.max;
    },
  }),
  bk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js'(e, t) {
      t.exports = Math.min;
    },
  }),
  vk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js'(e, t) {
      t.exports = Math.pow;
    },
  }),
  Ek = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js'(e, t) {
      t.exports = Math.round;
    },
  }),
  Tk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js'(e, t) {
      t.exports =
        Number.isNaN ||
        o(function (n) {
          return n !== n;
        }, 'isNaN2');
    },
  }),
  wk = ge({
    'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js'(e, t) {
      var r = Tk();
      t.exports = o(function (i) {
        return r(i) || i === 0 ? i : i < 0 ? -1 : 1;
      }, 'sign');
    },
  }),
  Sk = ge({
    'node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js'(e, t) {
      t.exports = Object.getOwnPropertyDescriptor;
    },
  }),
  np = ge({
    'node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js'(e, t) {
      var r = Sk();
      if (r)
        try {
          r([], 'length');
        } catch {
          r = null;
        }
      t.exports = r;
    },
  }),
  _k = ge({
    'node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js'(e, t) {
      var r = Object.defineProperty || !1;
      if (r)
        try {
          r({}, 'a', { value: 1 });
        } catch {
          r = !1;
        }
      t.exports = r;
    },
  }),
  zb = ge({
    'node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js'(e, t) {
      t.exports = o(function () {
        if (typeof Symbol != 'function' || typeof Object.getOwnPropertySymbols != 'function')
          return !1;
        if (typeof Symbol.iterator == 'symbol') return !0;
        var n = {},
          i = Symbol('test'),
          s = Object(i);
        if (
          typeof i == 'string' ||
          Object.prototype.toString.call(i) !== '[object Symbol]' ||
          Object.prototype.toString.call(s) !== '[object Symbol]'
        )
          return !1;
        var a = 42;
        n[i] = a;
        for (var c in n) return !1;
        if (
          (typeof Object.keys == 'function' && Object.keys(n).length !== 0) ||
          (typeof Object.getOwnPropertyNames == 'function' &&
            Object.getOwnPropertyNames(n).length !== 0)
        )
          return !1;
        var d = Object.getOwnPropertySymbols(n);
        if (d.length !== 1 || d[0] !== i || !Object.prototype.propertyIsEnumerable.call(n, i))
          return !1;
        if (typeof Object.getOwnPropertyDescriptor == 'function') {
          var u = Object.getOwnPropertyDescriptor(n, i);
          if (u.value !== a || u.enumerable !== !0) return !1;
        }
        return !0;
      }, 'hasSymbols');
    },
  }),
  Wb = ge({
    'node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js'(e, t) {
      var r = typeof Symbol < 'u' && Symbol,
        n = zb();
      t.exports = o(function () {
        return typeof r != 'function' ||
          typeof Symbol != 'function' ||
          typeof r('foo') != 'symbol' ||
          typeof Symbol('bar') != 'symbol'
          ? !1
          : n();
      }, 'hasNativeSymbols');
    },
  }),
  Kb = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js'(e, t) {
      t.exports = (typeof Reflect < 'u' && Reflect.getPrototypeOf) || null;
    },
  }),
  Yb = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js'(e, t) {
      var r = Gb();
      t.exports = r.getPrototypeOf || null;
    },
  }),
  Rk = ge({
    'node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js'(e, t) {
      var r = 'Function.prototype.bind called on incompatible ',
        n = Object.prototype.toString,
        i = Math.max,
        s = '[object Function]',
        a = o(function (p, f) {
          for (var y = [], h = 0; h < p.length; h += 1) y[h] = p[h];
          for (var g = 0; g < f.length; g += 1) y[g + p.length] = f[g];
          return y;
        }, 'concatty2'),
        c = o(function (p, f) {
          for (var y = [], h = f || 0, g = 0; h < p.length; h += 1, g += 1) y[g] = p[h];
          return y;
        }, 'slicy2'),
        d = o(function (u, p) {
          for (var f = '', y = 0; y < u.length; y += 1) ((f += u[y]), y + 1 < u.length && (f += p));
          return f;
        }, 'joiny');
      t.exports = o(function (p) {
        var f = this;
        if (typeof f != 'function' || n.apply(f) !== s) throw new TypeError(r + f);
        for (
          var y = c(arguments, 1),
            h,
            g = o(function () {
              if (this instanceof h) {
                var A = f.apply(this, a(y, arguments));
                return Object(A) === A ? A : this;
              }
              return f.apply(p, a(y, arguments));
            }, 'binder'),
            T = i(0, f.length - y.length),
            E = [],
            v = 0;
          v < T;
          v++
        )
          E[v] = '$' + v;
        if (
          ((h = Function(
            'binder',
            'return function (' + d(E, ',') + '){ return binder.apply(this,arguments); }',
          )(g)),
          f.prototype)
        ) {
          var S = o(function () {}, 'Empty2');
          ((S.prototype = f.prototype), (h.prototype = new S()), (S.prototype = null));
        }
        return h;
      }, 'bind');
    },
  }),
  Ba = ge({
    'node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js'(e, t) {
      var r = Rk();
      t.exports = Function.prototype.bind || r;
    },
  }),
  op = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js'(
      e,
      t,
    ) {
      t.exports = Function.prototype.call;
    },
  }),
  Xb = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js'(
      e,
      t,
    ) {
      t.exports = Function.prototype.apply;
    },
  }),
  Pk = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js'(
      e,
      t,
    ) {
      t.exports = typeof Reflect < 'u' && Reflect && Reflect.apply;
    },
  }),
  Ak = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js'(
      e,
      t,
    ) {
      var r = Ba(),
        n = Xb(),
        i = op(),
        s = Pk();
      t.exports = s || r.call(i, n);
    },
  }),
  Qb = ge({
    'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js'(
      e,
      t,
    ) {
      var r = Ba(),
        n = rp(),
        i = op(),
        s = Ak();
      t.exports = o(function (c) {
        if (c.length < 1 || typeof c[0] != 'function') throw new n('a function is required');
        return s(r, i, c);
      }, 'callBindBasic');
    },
  }),
  Ok = ge({
    'node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js'(e, t) {
      var r = Qb(),
        n = np(),
        i;
      try {
        i = [].__proto__ === Array.prototype;
      } catch (d) {
        if (!d || typeof d != 'object' || !('code' in d) || d.code !== 'ERR_PROTO_ACCESS') throw d;
      }
      var s = !!i && n && n(Object.prototype, '__proto__'),
        a = Object,
        c = a.getPrototypeOf;
      t.exports =
        s && typeof s.get == 'function'
          ? r([s.get])
          : typeof c == 'function'
            ? o(function (u) {
                return c(u == null ? u : a(u));
              }, 'getDunder')
            : !1;
    },
  }),
  Ck = ge({
    'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js'(e, t) {
      var r = Kb(),
        n = Yb(),
        i = Ok();
      t.exports = r
        ? o(function (a) {
            return r(a);
          }, 'getProto')
        : n
          ? o(function (a) {
              if (!a || (typeof a != 'object' && typeof a != 'function'))
                throw new TypeError('getProto: not an object');
              return n(a);
            }, 'getProto')
          : i
            ? o(function (a) {
                return i(a);
              }, 'getProto')
            : null;
    },
  }),
  Zb = ge({
    'node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js'(e, t) {
      var r = Function.prototype.call,
        n = Object.prototype.hasOwnProperty,
        i = Ba();
      t.exports = i.call(r, n);
    },
  }),
  xk = ge({
    'node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js'(e, t) {
      var r,
        n = Gb(),
        i = ck(),
        s = uk(),
        a = dk(),
        c = pk(),
        d = fk(),
        u = rp(),
        p = mk(),
        f = yk(),
        y = hk(),
        h = gk(),
        g = bk(),
        T = vk(),
        E = Ek(),
        v = wk(),
        S = Function,
        A = o(function ($) {
          try {
            return S('"use strict"; return (' + $ + ').constructor;')();
          } catch {}
        }, 'getEvalledConstructor'),
        N = np(),
        j = _k(),
        C = o(function () {
          throw new u();
        }, 'throwTypeError'),
        R = N
          ? (function () {
              try {
                return (arguments.callee, C);
              } catch {
                try {
                  return N(arguments, 'callee').get;
                } catch {
                  return C;
                }
              }
            })()
          : C,
        w = Wb()(),
        _ = Ck(),
        k = Yb(),
        I = Kb(),
        V = Xb(),
        H = op(),
        P = {},
        L = typeof Uint8Array > 'u' || !_ ? r : _(Uint8Array),
        B = {
          __proto__: null,
          '%AggregateError%': typeof AggregateError > 'u' ? r : AggregateError,
          '%Array%': Array,
          '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? r : ArrayBuffer,
          '%ArrayIteratorPrototype%': w && _ ? _([][Symbol.iterator]()) : r,
          '%AsyncFromSyncIteratorPrototype%': r,
          '%AsyncFunction%': P,
          '%AsyncGenerator%': P,
          '%AsyncGeneratorFunction%': P,
          '%AsyncIteratorPrototype%': P,
          '%Atomics%': typeof Atomics > 'u' ? r : Atomics,
          '%BigInt%': typeof BigInt > 'u' ? r : BigInt,
          '%BigInt64Array%': typeof BigInt64Array > 'u' ? r : BigInt64Array,
          '%BigUint64Array%': typeof BigUint64Array > 'u' ? r : BigUint64Array,
          '%Boolean%': Boolean,
          '%DataView%': typeof DataView > 'u' ? r : DataView,
          '%Date%': Date,
          '%decodeURI%': decodeURI,
          '%decodeURIComponent%': decodeURIComponent,
          '%encodeURI%': encodeURI,
          '%encodeURIComponent%': encodeURIComponent,
          '%Error%': i,
          '%eval%': eval,
          '%EvalError%': s,
          '%Float16Array%': typeof Float16Array > 'u' ? r : Float16Array,
          '%Float32Array%': typeof Float32Array > 'u' ? r : Float32Array,
          '%Float64Array%': typeof Float64Array > 'u' ? r : Float64Array,
          '%FinalizationRegistry%': typeof FinalizationRegistry > 'u' ? r : FinalizationRegistry,
          '%Function%': S,
          '%GeneratorFunction%': P,
          '%Int8Array%': typeof Int8Array > 'u' ? r : Int8Array,
          '%Int16Array%': typeof Int16Array > 'u' ? r : Int16Array,
          '%Int32Array%': typeof Int32Array > 'u' ? r : Int32Array,
          '%isFinite%': isFinite,
          '%isNaN%': isNaN,
          '%IteratorPrototype%': w && _ ? _(_([][Symbol.iterator]())) : r,
          '%JSON%': typeof JSON == 'object' ? JSON : r,
          '%Map%': typeof Map > 'u' ? r : Map,
          '%MapIteratorPrototype%':
            typeof Map > 'u' || !w || !_ ? r : _(new Map()[Symbol.iterator]()),
          '%Math%': Math,
          '%Number%': Number,
          '%Object%': n,
          '%Object.getOwnPropertyDescriptor%': N,
          '%parseFloat%': parseFloat,
          '%parseInt%': parseInt,
          '%Promise%': typeof Promise > 'u' ? r : Promise,
          '%Proxy%': typeof Proxy > 'u' ? r : Proxy,
          '%RangeError%': a,
          '%ReferenceError%': c,
          '%Reflect%': typeof Reflect > 'u' ? r : Reflect,
          '%RegExp%': RegExp,
          '%Set%': typeof Set > 'u' ? r : Set,
          '%SetIteratorPrototype%':
            typeof Set > 'u' || !w || !_ ? r : _(new Set()[Symbol.iterator]()),
          '%SharedArrayBuffer%': typeof SharedArrayBuffer > 'u' ? r : SharedArrayBuffer,
          '%String%': String,
          '%StringIteratorPrototype%': w && _ ? _(''[Symbol.iterator]()) : r,
          '%Symbol%': w ? Symbol : r,
          '%SyntaxError%': d,
          '%ThrowTypeError%': R,
          '%TypedArray%': L,
          '%TypeError%': u,
          '%Uint8Array%': typeof Uint8Array > 'u' ? r : Uint8Array,
          '%Uint8ClampedArray%': typeof Uint8ClampedArray > 'u' ? r : Uint8ClampedArray,
          '%Uint16Array%': typeof Uint16Array > 'u' ? r : Uint16Array,
          '%Uint32Array%': typeof Uint32Array > 'u' ? r : Uint32Array,
          '%URIError%': p,
          '%WeakMap%': typeof WeakMap > 'u' ? r : WeakMap,
          '%WeakRef%': typeof WeakRef > 'u' ? r : WeakRef,
          '%WeakSet%': typeof WeakSet > 'u' ? r : WeakSet,
          '%Function.prototype.call%': H,
          '%Function.prototype.apply%': V,
          '%Object.defineProperty%': j,
          '%Object.getPrototypeOf%': k,
          '%Math.abs%': f,
          '%Math.floor%': y,
          '%Math.max%': h,
          '%Math.min%': g,
          '%Math.pow%': T,
          '%Math.round%': E,
          '%Math.sign%': v,
          '%Reflect.getPrototypeOf%': I,
        };
      if (_)
        try {
          null.error;
        } catch ($) {
          ((D = _(_($))), (B['%Error.prototype%'] = D));
        }
      var D,
        K = o(function $(Q) {
          var re;
          if (Q === '%AsyncFunction%') re = A('async function () {}');
          else if (Q === '%GeneratorFunction%') re = A('function* () {}');
          else if (Q === '%AsyncGeneratorFunction%') re = A('async function* () {}');
          else if (Q === '%AsyncGenerator%') {
            var oe = $('%AsyncGeneratorFunction%');
            oe && (re = oe.prototype);
          } else if (Q === '%AsyncIteratorPrototype%') {
            var ne = $('%AsyncGenerator%');
            ne && _ && (re = _(ne.prototype));
          }
          return ((B[Q] = re), re);
        }, 'doEval2'),
        X = {
          __proto__: null,
          '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
          '%ArrayPrototype%': ['Array', 'prototype'],
          '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
          '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
          '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
          '%ArrayProto_values%': ['Array', 'prototype', 'values'],
          '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
          '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
          '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
          '%BooleanPrototype%': ['Boolean', 'prototype'],
          '%DataViewPrototype%': ['DataView', 'prototype'],
          '%DatePrototype%': ['Date', 'prototype'],
          '%ErrorPrototype%': ['Error', 'prototype'],
          '%EvalErrorPrototype%': ['EvalError', 'prototype'],
          '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
          '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
          '%FunctionPrototype%': ['Function', 'prototype'],
          '%Generator%': ['GeneratorFunction', 'prototype'],
          '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
          '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
          '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
          '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
          '%JSONParse%': ['JSON', 'parse'],
          '%JSONStringify%': ['JSON', 'stringify'],
          '%MapPrototype%': ['Map', 'prototype'],
          '%NumberPrototype%': ['Number', 'prototype'],
          '%ObjectPrototype%': ['Object', 'prototype'],
          '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
          '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
          '%PromisePrototype%': ['Promise', 'prototype'],
          '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
          '%Promise_all%': ['Promise', 'all'],
          '%Promise_reject%': ['Promise', 'reject'],
          '%Promise_resolve%': ['Promise', 'resolve'],
          '%RangeErrorPrototype%': ['RangeError', 'prototype'],
          '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
          '%RegExpPrototype%': ['RegExp', 'prototype'],
          '%SetPrototype%': ['Set', 'prototype'],
          '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
          '%StringPrototype%': ['String', 'prototype'],
          '%SymbolPrototype%': ['Symbol', 'prototype'],
          '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
          '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
          '%TypeErrorPrototype%': ['TypeError', 'prototype'],
          '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
          '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
          '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
          '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
          '%URIErrorPrototype%': ['URIError', 'prototype'],
          '%WeakMapPrototype%': ['WeakMap', 'prototype'],
          '%WeakSetPrototype%': ['WeakSet', 'prototype'],
        },
        ie = Ba(),
        se = Zb(),
        W = ie.call(H, Array.prototype.concat),
        ae = ie.call(V, Array.prototype.splice),
        be = ie.call(H, String.prototype.replace),
        ue = ie.call(H, String.prototype.slice),
        ee = ie.call(H, RegExp.prototype.exec),
        Ae =
          /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        Oe = /\\(\\)?/g,
        He = o(function (Q) {
          var re = ue(Q, 0, 1),
            oe = ue(Q, -1);
          if (re === '%' && oe !== '%')
            throw new d('invalid intrinsic syntax, expected closing `%`');
          if (oe === '%' && re !== '%')
            throw new d('invalid intrinsic syntax, expected opening `%`');
          var ne = [];
          return (
            be(Q, Ae, function (de, ye, pe, Je) {
              ne[ne.length] = pe ? be(Je, Oe, '$1') : ye || de;
            }),
            ne
          );
        }, 'stringToPath3'),
        Ke = o(function (Q, re) {
          var oe = Q,
            ne;
          if ((se(X, oe) && ((ne = X[oe]), (oe = '%' + ne[0] + '%')), se(B, oe))) {
            var de = B[oe];
            if ((de === P && (de = K(oe)), typeof de > 'u' && !re))
              throw new u(
                'intrinsic ' + Q + ' exists, but is not available. Please file an issue!',
              );
            return { alias: ne, name: oe, value: de };
          }
          throw new d('intrinsic ' + Q + ' does not exist!');
        }, 'getBaseIntrinsic2');
      t.exports = o(function (Q, re) {
        if (typeof Q != 'string' || Q.length === 0)
          throw new u('intrinsic name must be a non-empty string');
        if (arguments.length > 1 && typeof re != 'boolean')
          throw new u('"allowMissing" argument must be a boolean');
        if (ee(/^%?[^%]*%?$/, Q) === null)
          throw new d(
            '`%` may not be present anywhere but at the beginning and end of the intrinsic name',
          );
        var oe = He(Q),
          ne = oe.length > 0 ? oe[0] : '',
          de = Ke('%' + ne + '%', re),
          ye = de.name,
          pe = de.value,
          Je = !1,
          ot = de.alias;
        ot && ((ne = ot[0]), ae(oe, W([0, 1], ot)));
        for (var dt = 1, Tt = !0; dt < oe.length; dt += 1) {
          var it = oe[dt],
            pt = ue(it, 0, 1),
            ft = ue(it, -1);
          if (
            (pt === '"' || pt === "'" || pt === '`' || ft === '"' || ft === "'" || ft === '`') &&
            pt !== ft
          )
            throw new d('property names with quotes must have matching quotes');
          if (
            ((it === 'constructor' || !Tt) && (Je = !0),
            (ne += '.' + it),
            (ye = '%' + ne + '%'),
            se(B, ye))
          )
            pe = B[ye];
          else if (pe != null) {
            if (!(it in pe)) {
              if (!re)
                throw new u(
                  'base intrinsic for ' + Q + ' exists, but the property is not available.',
                );
              return;
            }
            if (N && dt + 1 >= oe.length) {
              var mt = N(pe, it);
              ((Tt = !!mt),
                Tt && 'get' in mt && !('originalValue' in mt.get) ? (pe = mt.get) : (pe = pe[it]));
            } else ((Tt = se(pe, it)), (pe = pe[it]));
            Tt && !Je && (B[ye] = pe);
          }
        }
        return pe;
      }, 'GetIntrinsic');
    },
  }),
  ip = ge({
    'node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js'(e, t) {
      var r = xk(),
        n = Qb(),
        i = n([r('%String.prototype.indexOf%')]);
      t.exports = o(function (a, c) {
        var d = r(a, !!c);
        return typeof d == 'function' && i(a, '.prototype.') > -1 ? n([d]) : d;
      }, 'callBoundIntrinsic');
    },
  }),
  Nk = ge({
    'node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js'(e, t) {
      var r = zb();
      t.exports = o(function () {
        return r() && !!Symbol.toStringTag;
      }, 'hasToStringTagShams');
    },
  }),
  ev = ge({
    'node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js'(e, t) {
      var r = ip(),
        n = Nk()(),
        i = Zb(),
        s = np(),
        a;
      n
        ? ((c = r('RegExp.prototype.exec')),
          (d = {}),
          (u = o(function () {
            throw d;
          }, 'throwRegexMarker')),
          (p = { toString: u, valueOf: u }),
          typeof Symbol.toPrimitive == 'symbol' && (p[Symbol.toPrimitive] = u),
          (a = o(function (g) {
            if (!g || typeof g != 'object') return !1;
            var T = s(g, 'lastIndex'),
              E = T && i(T, 'value');
            if (!E) return !1;
            try {
              c(g, p);
            } catch (v) {
              return v === d;
            }
          }, 'isRegex')))
        : ((f = r('Object.prototype.toString')),
          (y = '[object RegExp]'),
          (a = o(function (g) {
            return !g || (typeof g != 'object' && typeof g != 'function') ? !1 : f(g) === y;
          }, 'isRegex')));
      var c, d, u, p, f, y;
      t.exports = a;
    },
  }),
  Ik = ge({
    'node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js'(e, t) {
      t.exports = n;
      var r = Object.prototype.toString;
      function n(i) {
        if (!i) return !1;
        var s = r.call(i);
        return (
          s === '[object Function]' ||
          (typeof i == 'function' && s !== '[object RegExp]') ||
          (typeof window < 'u' &&
            (i === window.setTimeout ||
              i === window.alert ||
              i === window.confirm ||
              i === window.prompt))
        );
      }
      o(n, 'isFunction3');
    },
  }),
  Mk = ge({
    'node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js'(e, t) {
      var r = ip(),
        n = ev(),
        i = r('RegExp.prototype.exec'),
        s = rp();
      t.exports = o(function (c) {
        if (!n(c)) throw new s('`regex` must be a RegExp');
        return o(function (u) {
          return i(c, u) !== null;
        }, 'test');
      }, 'regexTester');
    },
  }),
  qk = ge({
    'node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js'(e, t) {
      var r = ip(),
        n = r('Object.prototype.toString'),
        i = Wb()(),
        s = Mk();
      i
        ? ((a = r('Symbol.prototype.toString')),
          (c = s(/^Symbol\(.*\)$/)),
          (d = o(function (p) {
            return typeof p.valueOf() != 'symbol' ? !1 : c(a(p));
          }, 'isRealSymbolObject')),
          (t.exports = o(function (p) {
            if (typeof p == 'symbol') return !0;
            if (!p || typeof p != 'object' || n(p) !== '[object Symbol]') return !1;
            try {
              return d(p);
            } catch {
              return !1;
            }
          }, 'isSymbol3')))
        : (t.exports = o(function (p) {
            return !1;
          }, 'isSymbol3'));
      var a, c, d;
    },
  }),
  jk = tp(ev()),
  kk = tp(Ik()),
  Dk = tp(qk());
function tv(e) {
  return e != null && typeof e == 'object' && Array.isArray(e) === !1;
}
o(tv, 'isObject');
var Lk = typeof global == 'object' && global && global.Object === Object && global,
  Fk = Lk,
  Bk = typeof self == 'object' && self && self.Object === Object && self,
  Jk = Fk || Bk || Function('return this')(),
  sp = Jk,
  $k = sp.Symbol,
  eo = $k,
  rv = Object.prototype,
  Uk = rv.hasOwnProperty,
  Vk = rv.toString,
  ni = eo ? eo.toStringTag : void 0;
function nv(e) {
  var t = Uk.call(e, ni),
    r = e[ni];
  try {
    e[ni] = void 0;
    var n = !0;
  } catch {}
  var i = Vk.call(e);
  return (n && (t ? (e[ni] = r) : delete e[ni]), i);
}
o(nv, 'getRawTag');
var Hk = nv,
  Gk = Object.prototype,
  zk = Gk.toString;
function ov(e) {
  return zk.call(e);
}
o(ov, 'objectToString');
var Wk = ov,
  Kk = '[object Null]',
  Yk = '[object Undefined]',
  yh = eo ? eo.toStringTag : void 0;
function iv(e) {
  return e == null ? (e === void 0 ? Yk : Kk) : yh && yh in Object(e) ? Hk(e) : Wk(e);
}
o(iv, 'baseGetTag');
var sv = iv;
function av(e) {
  return e != null && typeof e == 'object';
}
o(av, 'isObjectLike');
var Xk = av,
  Qk = '[object Symbol]';
function lv(e) {
  return typeof e == 'symbol' || (Xk(e) && sv(e) == Qk);
}
o(lv, 'isSymbol');
var ap = lv;
function cv(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; ) i[r] = t(e[r], r, e);
  return i;
}
o(cv, 'arrayMap');
var Zk = cv,
  eD = Array.isArray,
  lp = eD,
  hh = eo ? eo.prototype : void 0,
  gh = hh ? hh.toString : void 0;
function cp(e) {
  if (typeof e == 'string') return e;
  if (lp(e)) return Zk(e, cp) + '';
  if (ap(e)) return gh ? gh.call(e) : '';
  var t = e + '';
  return t == '0' && 1 / e == -1 / 0 ? '-0' : t;
}
o(cp, 'baseToString');
var tD = cp;
function uv(e) {
  var t = typeof e;
  return e != null && (t == 'object' || t == 'function');
}
o(uv, 'isObject2');
var dv = uv,
  rD = '[object AsyncFunction]',
  nD = '[object Function]',
  oD = '[object GeneratorFunction]',
  iD = '[object Proxy]';
function pv(e) {
  if (!dv(e)) return !1;
  var t = sv(e);
  return t == nD || t == oD || t == rD || t == iD;
}
o(pv, 'isFunction');
var sD = pv,
  aD = sp['__core-js_shared__'],
  hc = aD,
  bh = (function () {
    var e = /[^.]+$/.exec((hc && hc.keys && hc.keys.IE_PROTO) || '');
    return e ? 'Symbol(src)_1.' + e : '';
  })();
function fv(e) {
  return !!bh && bh in e;
}
o(fv, 'isMasked');
var lD = fv,
  cD = Function.prototype,
  uD = cD.toString;
function mv(e) {
  if (e != null) {
    try {
      return uD.call(e);
    } catch {}
    try {
      return e + '';
    } catch {}
  }
  return '';
}
o(mv, 'toSource');
var dD = mv,
  pD = /[\\^$.*+?()[\]{}|]/g,
  fD = /^\[object .+?Constructor\]$/,
  mD = Function.prototype,
  yD = Object.prototype,
  hD = mD.toString,
  gD = yD.hasOwnProperty,
  bD = RegExp(
    '^' +
      hD
        .call(gD)
        .replace(pD, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
      '$',
  );
function yv(e) {
  if (!dv(e) || lD(e)) return !1;
  var t = sD(e) ? bD : fD;
  return t.test(dD(e));
}
o(yv, 'baseIsNative');
var vD = yv;
function hv(e, t) {
  return e?.[t];
}
o(hv, 'getValue');
var ED = hv;
function gv(e, t) {
  var r = ED(e, t);
  return vD(r) ? r : void 0;
}
o(gv, 'getNative');
var bv = gv;
function vv(e, t) {
  return e === t || (e !== e && t !== t);
}
o(vv, 'eq');
var TD = vv,
  wD = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  SD = /^\w*$/;
function Ev(e, t) {
  if (lp(e)) return !1;
  var r = typeof e;
  return r == 'number' || r == 'symbol' || r == 'boolean' || e == null || ap(e)
    ? !0
    : SD.test(e) || !wD.test(e) || (t != null && e in Object(t));
}
o(Ev, 'isKey');
var _D = Ev,
  RD = bv(Object, 'create'),
  xi = RD;
function Tv() {
  ((this.__data__ = xi ? xi(null) : {}), (this.size = 0));
}
o(Tv, 'hashClear');
var PD = Tv;
function wv(e) {
  var t = this.has(e) && delete this.__data__[e];
  return ((this.size -= t ? 1 : 0), t);
}
o(wv, 'hashDelete');
var AD = wv,
  OD = '__lodash_hash_undefined__',
  CD = Object.prototype,
  xD = CD.hasOwnProperty;
function Sv(e) {
  var t = this.__data__;
  if (xi) {
    var r = t[e];
    return r === OD ? void 0 : r;
  }
  return xD.call(t, e) ? t[e] : void 0;
}
o(Sv, 'hashGet');
var ND = Sv,
  ID = Object.prototype,
  MD = ID.hasOwnProperty;
function _v(e) {
  var t = this.__data__;
  return xi ? t[e] !== void 0 : MD.call(t, e);
}
o(_v, 'hashHas');
var qD = _v,
  jD = '__lodash_hash_undefined__';
function Rv(e, t) {
  var r = this.__data__;
  return ((this.size += this.has(e) ? 0 : 1), (r[e] = xi && t === void 0 ? jD : t), this);
}
o(Rv, 'hashSet');
var kD = Rv;
function On(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(On, 'Hash');
On.prototype.clear = PD;
On.prototype.delete = AD;
On.prototype.get = ND;
On.prototype.has = qD;
On.prototype.set = kD;
var vh = On;
function Pv() {
  ((this.__data__ = []), (this.size = 0));
}
o(Pv, 'listCacheClear');
var DD = Pv;
function Av(e, t) {
  for (var r = e.length; r--; ) if (TD(e[r][0], t)) return r;
  return -1;
}
o(Av, 'assocIndexOf');
var Ja = Av,
  LD = Array.prototype,
  FD = LD.splice;
function Ov(e) {
  var t = this.__data__,
    r = Ja(t, e);
  if (r < 0) return !1;
  var n = t.length - 1;
  return (r == n ? t.pop() : FD.call(t, r, 1), --this.size, !0);
}
o(Ov, 'listCacheDelete');
var BD = Ov;
function Cv(e) {
  var t = this.__data__,
    r = Ja(t, e);
  return r < 0 ? void 0 : t[r][1];
}
o(Cv, 'listCacheGet');
var JD = Cv;
function xv(e) {
  return Ja(this.__data__, e) > -1;
}
o(xv, 'listCacheHas');
var $D = xv;
function Nv(e, t) {
  var r = this.__data__,
    n = Ja(r, e);
  return (n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this);
}
o(Nv, 'listCacheSet');
var UD = Nv;
function Cn(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(Cn, 'ListCache');
Cn.prototype.clear = DD;
Cn.prototype.delete = BD;
Cn.prototype.get = JD;
Cn.prototype.has = $D;
Cn.prototype.set = UD;
var VD = Cn,
  HD = bv(sp, 'Map'),
  GD = HD;
function Iv() {
  ((this.size = 0), (this.__data__ = { hash: new vh(), map: new (GD || VD)(), string: new vh() }));
}
o(Iv, 'mapCacheClear');
var zD = Iv;
function Mv(e) {
  var t = typeof e;
  return t == 'string' || t == 'number' || t == 'symbol' || t == 'boolean'
    ? e !== '__proto__'
    : e === null;
}
o(Mv, 'isKeyable');
var WD = Mv;
function qv(e, t) {
  var r = e.__data__;
  return WD(t) ? r[typeof t == 'string' ? 'string' : 'hash'] : r.map;
}
o(qv, 'getMapData');
var $a = qv;
function jv(e) {
  var t = $a(this, e).delete(e);
  return ((this.size -= t ? 1 : 0), t);
}
o(jv, 'mapCacheDelete');
var KD = jv;
function kv(e) {
  return $a(this, e).get(e);
}
o(kv, 'mapCacheGet');
var YD = kv;
function Dv(e) {
  return $a(this, e).has(e);
}
o(Dv, 'mapCacheHas');
var XD = Dv;
function Lv(e, t) {
  var r = $a(this, e),
    n = r.size;
  return (r.set(e, t), (this.size += r.size == n ? 0 : 1), this);
}
o(Lv, 'mapCacheSet');
var QD = Lv;
function xn(e) {
  var t = -1,
    r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(xn, 'MapCache');
xn.prototype.clear = zD;
xn.prototype.delete = KD;
xn.prototype.get = YD;
xn.prototype.has = XD;
xn.prototype.set = QD;
var Fv = xn,
  ZD = 'Expected a function';
function Ua(e, t) {
  if (typeof e != 'function' || (t != null && typeof t != 'function')) throw new TypeError(ZD);
  var r = o(function () {
    var n = arguments,
      i = t ? t.apply(this, n) : n[0],
      s = r.cache;
    if (s.has(i)) return s.get(i);
    var a = e.apply(this, n);
    return ((r.cache = s.set(i, a) || s), a);
  }, 'memoized');
  return ((r.cache = new (Ua.Cache || Fv)()), r);
}
o(Ua, 'memoize');
Ua.Cache = Fv;
var eL = Ua,
  tL = 500;
function Bv(e) {
  var t = eL(e, function (n) {
      return (r.size === tL && r.clear(), n);
    }),
    r = t.cache;
  return t;
}
o(Bv, 'memoizeCapped');
var rL = Bv,
  nL =
    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
  oL = /\\(\\)?/g,
  iL = rL(function (e) {
    var t = [];
    return (
      e.charCodeAt(0) === 46 && t.push(''),
      e.replace(nL, function (r, n, i, s) {
        t.push(i ? s.replace(oL, '$1') : n || r);
      }),
      t
    );
  }),
  sL = iL;
function Jv(e) {
  return e == null ? '' : tD(e);
}
o(Jv, 'toString');
var aL = Jv;
function $v(e, t) {
  return lp(e) ? e : _D(e, t) ? [e] : sL(aL(e));
}
o($v, 'castPath');
var lL = $v;
function Uv(e) {
  if (typeof e == 'string' || ap(e)) return e;
  var t = e + '';
  return t == '0' && 1 / e == -1 / 0 ? '-0' : t;
}
o(Uv, 'toKey');
var cL = Uv;
function Vv(e, t) {
  t = lL(t, e);
  for (var r = 0, n = t.length; e != null && r < n; ) e = e[cL(t[r++])];
  return r && r == n ? e : void 0;
}
o(Vv, 'baseGet');
var uL = Vv;
function Hv(e, t, r) {
  var n = e == null ? void 0 : uL(e, t);
  return n === void 0 ? r : n;
}
o(Hv, 'get');
var dL = Hv,
  up = tv,
  pL = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/,
  dp = o((e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/), 'isJSON');
function pp(e) {
  if (!up(e)) return e;
  let t = e,
    r = !1;
  return (
    typeof Event < 'u' && e instanceof Event && ((t = Hb(t)), (r = !0)),
    (t = Object.keys(t).reduce((n, i) => {
      try {
        (t[i] && t[i].toJSON, (n[i] = t[i]));
      } catch {
        r = !0;
      }
      return n;
    }, {})),
    r ? t : e
  );
}
o(pp, 'convertUnconventionalData');
var fL = o(function (t) {
    let r, n, i, s;
    return o(function (c, d) {
      try {
        if (c === '') return ((s = []), (r = new Map([[d, '[]']])), (n = new Map()), (i = []), d);
        const u = n.get(this) || this;
        for (; i.length && u !== i[0]; ) (i.shift(), s.pop());
        if (typeof d == 'boolean') return d;
        if (d === void 0) return t.allowUndefined ? '_undefined_' : void 0;
        if (d === null) return null;
        if (typeof d == 'number')
          return d === Number.NEGATIVE_INFINITY
            ? '_-Infinity_'
            : d === Number.POSITIVE_INFINITY
              ? '_Infinity_'
              : Number.isNaN(d)
                ? '_NaN_'
                : d;
        if (typeof d == 'bigint') return `_bigint_${d.toString()}`;
        if (typeof d == 'string') return pL.test(d) ? (t.allowDate ? `_date_${d}` : void 0) : d;
        if ((0, jk.default)(d)) return t.allowRegExp ? `_regexp_${d.flags}|${d.source}` : void 0;
        if ((0, kk.default)(d)) return;
        if ((0, Dk.default)(d)) {
          if (!t.allowSymbol) return;
          const f = Symbol.keyFor(d);
          return f !== void 0 ? `_gsymbol_${f}` : `_symbol_${d.toString().slice(7, -1)}`;
        }
        if (i.length >= t.maxDepth) return Array.isArray(d) ? `[Array(${d.length})]` : '[Object]';
        if (d === this) return `_duplicate_${JSON.stringify(s)}`;
        if (d instanceof Error && t.allowError)
          return {
            __isConvertedError__: !0,
            errorProperties: {
              ...(d.cause ? { cause: d.cause } : {}),
              ...d,
              name: d.name,
              message: d.message,
              stack: d.stack,
              '_constructor-name_': d.constructor.name,
            },
          };
        if (d?.constructor?.name && d.constructor.name !== 'Object' && !Array.isArray(d)) {
          const f = r.get(d);
          if (!f) {
            const y = {
              __isClassInstance__: !0,
              __className__: d.constructor.name,
              ...Object.getOwnPropertyNames(d).reduce((h, g) => {
                try {
                  h[g] = d[g];
                } catch {}
                return h;
              }, {}),
            };
            return (
              s.push(c),
              i.unshift(y),
              r.set(d, JSON.stringify(s)),
              d !== y && n.set(d, y),
              y
            );
          }
          return `_duplicate_${f}`;
        }
        const p = r.get(d);
        if (!p) {
          const f = Array.isArray(d) ? d : pp(d);
          return (s.push(c), i.unshift(f), r.set(d, JSON.stringify(s)), d !== f && n.set(d, f), f);
        }
        return `_duplicate_${p}`;
      } catch {
        return;
      }
    }, 'replace');
  }, 'replacer2'),
  mL = o(function (t) {
    const r = [];
    let n;
    return o(function (s, a) {
      if (
        (s === '' &&
          ((n = a),
          r.forEach(({ target: c, container: d, replacement: u }) => {
            const p = dp(u) ? JSON.parse(u) : u.split('.');
            p.length === 0 ? (d[c] = n) : (d[c] = dL(n, p));
          })),
        s === '_constructor-name_')
      )
        return a;
      if (up(a) && a.__isConvertedError__) {
        const { message: c, ...d } = a.errorProperties,
          u = new Error(c);
        return (Object.assign(u, d), u);
      }
      if (typeof a == 'string' && a.startsWith('_regexp_') && t.allowRegExp) {
        const [, c, d] = a.match(/_regexp_([^|]*)\|(.*)/) || [];
        return new RegExp(d, c);
      }
      return typeof a == 'string' && a.startsWith('_date_') && t.allowDate
        ? new Date(a.replace('_date_', ''))
        : typeof a == 'string' && a.startsWith('_duplicate_')
          ? (r.push({ target: s, container: this, replacement: a.replace(/^_duplicate_/, '') }),
            null)
          : typeof a == 'string' && a.startsWith('_symbol_') && t.allowSymbol
            ? Symbol(a.replace('_symbol_', ''))
            : typeof a == 'string' && a.startsWith('_gsymbol_') && t.allowSymbol
              ? Symbol.for(a.replace('_gsymbol_', ''))
              : typeof a == 'string' && a === '_-Infinity_'
                ? Number.NEGATIVE_INFINITY
                : typeof a == 'string' && a === '_Infinity_'
                  ? Number.POSITIVE_INFINITY
                  : typeof a == 'string' && a === '_NaN_'
                    ? Number.NaN
                    : typeof a == 'string' &&
                        a.startsWith('_bigint_') &&
                        typeof BigInt == 'function'
                      ? BigInt(a.replace('_bigint_', ''))
                      : a;
    }, 'revive');
  }, 'reviver2'),
  Gv = {
    maxDepth: 10,
    space: void 0,
    allowRegExp: !0,
    allowDate: !0,
    allowError: !0,
    allowUndefined: !0,
    allowSymbol: !0,
  },
  zv = o((e, t = {}) => {
    const r = { ...Gv, ...t };
    return JSON.stringify(pp(e), fL(r), t.space);
  }, 'stringify'),
  yL = o(() => {
    const e = new Map();
    return o(function t(r) {
      (up(r) &&
        Object.entries(r).forEach(([n, i]) => {
          i === '_undefined_' ? (r[n] = void 0) : e.get(i) || (e.set(i, !0), t(i));
        }),
        Array.isArray(r) &&
          r.forEach((n, i) => {
            n === '_undefined_'
              ? (e.set(n, !0), (r[i] = void 0))
              : e.get(n) || (e.set(n, !0), t(n));
          }));
    }, 'mutateUndefined');
  }, 'mutator'),
  Wv = o((e, t = {}) => {
    const r = { ...Gv, ...t },
      n = JSON.parse(e, mL(r));
    return (yL()(n), n);
  }, 'parse'),
  hL = 'Invariant failed';
function rr(e, t) {
  if (!e) throw new Error(hL);
}
o(rr, 'invariant');
var gL = o((e) => {
    const t = Array.from(document.querySelectorAll('iframe[data-is-storybook]')),
      [r, ...n] = t.filter((s) => {
        try {
          return (
            s.contentWindow?.location.origin === e.source.location.origin &&
            s.contentWindow?.location.pathname === e.source.location.pathname
          );
        } catch {}
        try {
          return s.contentWindow === e.source;
        } catch {}
        const a = s.getAttribute('src');
        let c;
        try {
          if (!a) return !1;
          ({ origin: c } = new URL(a, document.location.toString()));
        } catch {
          return !1;
        }
        return c === e.origin;
      }),
      i = r?.getAttribute('src');
    if (i && n.length === 0) {
      const { protocol: s, host: a, pathname: c } = new URL(i, document.location.toString());
      return `${s}//${a}${c}`;
    }
    return (n.length > 0 && De.error('found multiple candidates for event source'), null);
  }, 'getEventSourceUrl'),
  { document: gc, location: bc } = te,
  Eh = 'storybook-channel',
  bL = { maxDepth: 25 },
  Kv = class {
    constructor(t) {
      if (
        ((this.config = t),
        (this.connected = !1),
        (this.buffer = []),
        typeof te?.addEventListener == 'function' &&
          te.addEventListener('message', this.handleEvent.bind(this), !1),
        t.page !== 'manager' && t.page !== 'preview')
      )
        throw new Error(`postmsg-channel: "config.page" cannot be "${t.page}"`);
    }
    setHandler(t) {
      this.handler = (...r) => {
        (t.apply(this, r),
          !this.connected && this.getLocalFrame().length && (this.flush(), (this.connected = !0)));
      };
    }
    send(t, r) {
      const {
          target: n,
          allowRegExp: i,
          allowSymbol: s,
          allowDate: a,
          allowError: c,
          allowUndefined: d,
          maxDepth: u,
          space: p,
        } = r || {},
        f = Object.fromEntries(
          Object.entries({
            allowRegExp: i,
            allowSymbol: s,
            allowDate: a,
            allowError: c,
            allowUndefined: d,
            maxDepth: u,
            space: p,
          }).filter(([E, v]) => typeof v < 'u'),
        ),
        y = { ...bL, ...(te.CHANNEL_OPTIONS || {}), ...f },
        h = this.getFrames(n),
        g = new URLSearchParams(bc?.search || ''),
        T = zv({ key: Eh, event: t, refId: g.get('refId') }, y);
      return h.length
        ? (this.buffer.length && this.flush(),
          h.forEach((E) => {
            try {
              E.postMessage(T, '*');
            } catch {
              De.error('sending over postmessage fail');
            }
          }),
          Promise.resolve(null))
        : new Promise((E, v) => {
            this.buffer.push({ event: t, resolve: E, reject: v });
          });
    }
    flush() {
      const { buffer: t } = this;
      ((this.buffer = []),
        t.forEach((r) => {
          this.send(r.event).then(r.resolve).catch(r.reject);
        }));
    }
    getFrames(t) {
      if (this.config.page === 'manager') {
        const n = Array.from(
          gc.querySelectorAll('iframe[data-is-storybook][data-is-loaded]'),
        ).flatMap((i) => {
          try {
            return i.contentWindow && i.dataset.isStorybook !== void 0 && i.id === t
              ? [i.contentWindow]
              : [];
          } catch {
            return [];
          }
        });
        return n?.length ? n : this.getCurrentFrames();
      }
      return te && te.parent && te.parent !== te.self ? [te.parent] : [];
    }
    getCurrentFrames() {
      return this.config.page === 'manager'
        ? Array.from(gc.querySelectorAll('[data-is-storybook="true"]')).flatMap((r) =>
            r.contentWindow ? [r.contentWindow] : [],
          )
        : te && te.parent
          ? [te.parent]
          : [];
    }
    getLocalFrame() {
      return this.config.page === 'manager'
        ? Array.from(gc.querySelectorAll('#storybook-preview-iframe')).flatMap((r) =>
            r.contentWindow ? [r.contentWindow] : [],
          )
        : te && te.parent
          ? [te.parent]
          : [];
    }
    handleEvent(t) {
      try {
        const { data: r } = t,
          {
            key: n,
            event: i,
            refId: s,
          } = typeof r == 'string' && dp(r) ? Wv(r, te.CHANNEL_OPTIONS || {}) : r;
        if (n === Eh) {
          const a =
              this.config.page === 'manager'
                ? '<span style="color: #37D5D3; background: black"> manager </span>'
                : '<span style="color: #1EA7FD; background: black"> preview </span>',
            c = Object.values(Gd).includes(i.type)
              ? `<span style="color: #FF4785">${i.type}</span>`
              : `<span style="color: #FFAE00">${i.type}</span>`;
          if (
            (s && (i.refId = s),
            (i.source = this.config.page === 'preview' ? t.origin : gL(t)),
            !i.source)
          ) {
            Ot.error(`${a} received ${c} but was unable to determine the source of the event`);
            return;
          }
          const d = `${a} received ${c} (${r.length})`;
          (Ot.debug(
            bc.origin !== i.source
              ? d
              : `${d} <span style="color: gray">(on ${bc.origin} from ${i.source})</span>`,
            ...i.args,
          ),
            rr(this.handler, 'ChannelHandler should be set'),
            this.handler(i));
        }
      } catch (r) {
        De.error(r);
      }
    }
  };
o(Kv, 'PostMessageTransport');
var Yv = Kv,
  { WebSocket: vL } = te,
  Xv = 15e3,
  Qv = 5e3,
  Zv = class {
    constructor({ url: t, onError: r, page: n }) {
      ((this.buffer = []),
        (this.isReady = !1),
        (this.isClosed = !1),
        (this.pingTimeout = 0),
        (this.socket = new vL(t)),
        (this.socket.onopen = () => {
          ((this.isReady = !0), this.heartbeat(), this.flush());
        }),
        (this.socket.onmessage = ({ data: i }) => {
          const s = typeof i == 'string' && dp(i) ? Wv(i) : i;
          (rr(this.handler),
            this.handler(s),
            s.type === 'ping' && (this.heartbeat(), this.send({ type: 'pong' })));
        }),
        (this.socket.onerror = (i) => {
          r && r(i);
        }),
        (this.socket.onclose = (i) => {
          (rr(this.handler),
            this.handler({
              type: gb,
              args: [{ reason: i.reason, code: i.code }],
              from: n || 'preview',
            }),
            (this.isClosed = !0),
            clearTimeout(this.pingTimeout));
        }));
    }
    heartbeat() {
      (clearTimeout(this.pingTimeout),
        (this.pingTimeout = setTimeout(() => {
          this.socket.close(3008, 'timeout');
        }, Xv + Qv)));
    }
    setHandler(t) {
      this.handler = t;
    }
    send(t) {
      this.isClosed || (this.isReady ? this.sendNow(t) : this.sendLater(t));
    }
    sendLater(t) {
      this.buffer.push(t);
    }
    sendNow(t) {
      const r = zv(t, { maxDepth: 15, ...te.CHANNEL_OPTIONS });
      this.socket.send(r);
    }
    flush() {
      const { buffer: t } = this;
      ((this.buffer = []), t.forEach((r) => this.send(r)));
    }
  };
o(Zv, 'WebsocketTransport');
var eE = Zv,
  { CONFIG_TYPE: EL } = te,
  TL = Fa;
function tE({ page: e, extraTransports: t = [] }) {
  const r = [new Yv({ page: e }), ...t];
  if (EL === 'DEVELOPMENT') {
    const i = window.location.protocol === 'http:' ? 'ws' : 'wss',
      { hostname: s, port: a } = window.location,
      c = `${i}://${s}:${a}/storybook-server-channel`;
    r.push(new eE({ url: c, onError: o(() => {}, 'onError'), page: e }));
  }
  const n = new Fa({ transports: r });
  return (yc.__prepare(n, e === 'manager' ? yc.Environment.MANAGER : yc.Environment.PREVIEW), n);
}
o(tE, 'createBrowserChannel');
var rE = {};
Et(rE, {
  CalledExtractOnStoreError: () => dE,
  CalledPreviewMethodBeforeInitializationError: () => Rt,
  Category: () => iE,
  ElementA11yParameterError: () => AL,
  EmptyIndexError: () => EE,
  ImplicitActionsDuringRendering: () => cE,
  MdxFileWithNoCsfReferencesError: () => bE,
  MissingRenderToCanvasError: () => fE,
  MissingStoryAfterHmrError: () => aE,
  MissingStoryFromCsfFileError: () => _E,
  MountMustBeDestructuredError: () => fp,
  NextJsSharpError: () => SL,
  NextjsRouterMocksNotAvailable: () => _L,
  NoRenderFunctionError: () => CE,
  NoStoryMatchError: () => wE,
  NoStoryMountedError: () => NE,
  StatusTypeIdMismatchError: () => wL,
  StoryIndexFetchError: () => hE,
  StoryStoreAccessedBeforeInitializationError: () => PE,
  UnknownArgTypesError: () => RL,
  UnsupportedViewportDimensionError: () => PL,
});
function Wc({ code: e, category: t }) {
  const r = String(e).padStart(4, '0');
  return `SB_${t}_${r}`;
}
o(Wc, 'parseErrorCode');
function Kc(e) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e)) return e;
  try {
    const t = new URL(e);
    return (t.searchParams.set('ref', 'error'), t.toString());
  } catch {
    return e;
  }
}
o(Kc, 'appendErrorRef');
var nE = class oE extends Error {
  constructor(t) {
    (super(oE.getFullMessage(t)),
      (this.data = {}),
      (this.fromStorybook = !0),
      (this.category = t.category),
      (this.documentation = t.documentation ?? !1),
      (this.code = t.code));
  }
  get fullErrorCode() {
    return Wc({ code: this.code, category: this.category });
  }
  get name() {
    const t = this.constructor.name;
    return `${this.fullErrorCode} (${t})`;
  }
  static getFullMessage({ documentation: t, code: r, category: n, message: i }) {
    let s;
    return (
      t === !0
        ? (s = `https://storybook.js.org/error/${Wc({ code: r, category: n })}?ref=error`)
        : typeof t == 'string'
          ? (s = Kc(t))
          : Array.isArray(t) &&
            (s = `
${t.map((a) => `	- ${Kc(a)}`).join(`
`)}`),
      `${i}${
        s != null
          ? `

More info: ${s}
`
          : ''
      }`
    );
  }
};
o(nE, 'StorybookError');
var We = nE,
  iE = ((e) => (
    (e.BLOCKS = 'BLOCKS'),
    (e.DOCS_TOOLS = 'DOCS-TOOLS'),
    (e.PREVIEW_CLIENT_LOGGER = 'PREVIEW_CLIENT-LOGGER'),
    (e.PREVIEW_CHANNELS = 'PREVIEW_CHANNELS'),
    (e.PREVIEW_CORE_EVENTS = 'PREVIEW_CORE-EVENTS'),
    (e.PREVIEW_INSTRUMENTER = 'PREVIEW_INSTRUMENTER'),
    (e.PREVIEW_API = 'PREVIEW_API'),
    (e.PREVIEW_REACT_DOM_SHIM = 'PREVIEW_REACT-DOM-SHIM'),
    (e.PREVIEW_ROUTER = 'PREVIEW_ROUTER'),
    (e.PREVIEW_THEMING = 'PREVIEW_THEMING'),
    (e.RENDERER_HTML = 'RENDERER_HTML'),
    (e.RENDERER_PREACT = 'RENDERER_PREACT'),
    (e.RENDERER_REACT = 'RENDERER_REACT'),
    (e.RENDERER_SERVER = 'RENDERER_SERVER'),
    (e.RENDERER_SVELTE = 'RENDERER_SVELTE'),
    (e.RENDERER_VUE = 'RENDERER_VUE'),
    (e.RENDERER_VUE3 = 'RENDERER_VUE3'),
    (e.RENDERER_WEB_COMPONENTS = 'RENDERER_WEB-COMPONENTS'),
    (e.FRAMEWORK_NEXTJS = 'FRAMEWORK_NEXTJS'),
    (e.ADDON_VITEST = 'ADDON_VITEST'),
    (e.ADDON_A11Y = 'ADDON_A11Y'),
    e
  ))(iE || {}),
  sE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 1,
        message: ve`
        Couldn't find story matching id '${t.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${t.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`,
      }),
        (this.data = t));
    }
  };
o(sE, 'MissingStoryAfterHmrError');
var aE = sE,
  lE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 2,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function',
        message: ve`
        We detected that you use an implicit action arg while ${t.phase} of your story.  
        ${
          t.deprecated
            ? `
This is deprecated and won't work in Storybook 8 anymore.
`
            : ''
        }
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${t.name}: fn()
          }`,
      }),
        (this.data = t));
    }
  };
o(lE, 'ImplicitActionsDuringRendering');
var cE = lE,
  uE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 3,
        message: ve`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`,
      });
    }
  };
o(uE, 'CalledExtractOnStoreError');
var dE = uE,
  pE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 4,
        message: ve`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field',
      });
    }
  };
o(pE, 'MissingRenderToCanvasError');
var fE = pE,
  mE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 5,
        message: ve`
        Called \`Preview.${t.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${t.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`,
      }),
        (this.data = t));
    }
  };
o(mE, 'CalledPreviewMethodBeforeInitializationError');
var Rt = mE,
  yE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 6,
        message: ve`
        Error fetching \`/index.json\`:
        
        ${t.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`,
      }),
        (this.data = t));
    }
  };
o(yE, 'StoryIndexFetchError');
var hE = yE,
  gE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 7,
        message: ve`
        Tried to render docs entry ${t.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`,
      }),
        (this.data = t));
    }
  };
o(gE, 'MdxFileWithNoCsfReferencesError');
var bE = gE,
  vE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 8,
        message: ve`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`,
      });
    }
  };
o(vE, 'EmptyIndexError');
var EE = vE,
  TE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 9,
        message: ve`
        Couldn't find story matching '${t.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`,
      }),
        (this.data = t));
    }
  };
o(TE, 'NoStoryMatchError');
var wE = TE,
  SE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 10,
        message: ve`
        Couldn't find story matching id '${t.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`,
      }),
        (this.data = t));
    }
  };
o(SE, 'MissingStoryFromCsfFileError');
var _E = SE,
  RE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 11,
        message: ve`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`,
      });
    }
  };
o(RE, 'StoryStoreAccessedBeforeInitializationError');
var PE = RE,
  AE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 12,
        message: ve`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${t.playFunction}`,
      }),
        (this.data = t));
    }
  };
o(AE, 'MountMustBeDestructuredError');
var fp = AE,
  OE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 14,
        message: ve`
        No render function available for storyId '${t.id}'
      `,
      }),
        (this.data = t));
    }
  };
o(OE, 'NoRenderFunctionError');
var CE = OE,
  xE = class extends We {
    constructor() {
      super({
        category: 'PREVIEW_API',
        code: 15,
        message: ve`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `,
      });
    }
  };
o(xE, 'NoStoryMountedError');
var NE = xE,
  IE = class extends We {
    constructor(t) {
      (super({
        category: 'PREVIEW_API',
        code: 16,
        message: `Status has typeId "${t.status.typeId}" but was added to store with typeId "${t.typeId}". Full status: ${JSON.stringify(t.status, null, 2)}`,
      }),
        (this.data = t));
    }
  };
o(IE, 'StatusTypeIdMismatchError');
var wL = IE,
  ME = class extends We {
    constructor() {
      super({
        category: 'FRAMEWORK_NEXTJS',
        code: 1,
        documentation: 'https://storybook.js.org/docs/get-started/nextjs#faq',
        message: ve`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `,
      });
    }
  };
o(ME, 'NextJsSharpError');
var SL = ME,
  qE = class extends We {
    constructor(t) {
      (super({
        category: 'FRAMEWORK_NEXTJS',
        code: 2,
        message: ve`
        Tried to access router mocks from "${t.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `,
      }),
        (this.data = t));
    }
  };
o(qE, 'NextjsRouterMocksNotAvailable');
var _L = qE,
  jE = class extends We {
    constructor(t) {
      (super({
        category: 'DOCS-TOOLS',
        code: 1,
        documentation: 'https://github.com/storybookjs/storybook/issues/26606',
        message: ve`
        There was a failure when generating detailed ArgTypes in ${t.language} for:
        ${JSON.stringify(t.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `,
      }),
        (this.data = t));
    }
  };
o(jE, 'UnknownArgTypesError');
var RL = jE,
  kE = class extends We {
    constructor(t) {
      (super({
        category: 'ADDON_VITEST',
        code: 1,
        message: ve`
        Encountered an unsupported value "${t.value}" when setting the viewport ${t.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `,
      }),
        (this.data = t));
    }
  };
o(kE, 'UnsupportedViewportDimensionError');
var PL = kE,
  DE = class extends We {
    constructor() {
      super({
        category: 'ADDON_A11Y',
        code: 1,
        documentation:
          'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter',
        message:
          'The "element" parameter in parameters.a11y has been removed. Use "context" instead.',
      });
    }
  };
o(DE, 'ElementA11yParameterError');
var AL = DE,
  LE = {};
Et(LE, { Addon_TypesEnum: () => FE });
var FE = ((e) => (
    (e.TAB = 'tab'),
    (e.PANEL = 'panel'),
    (e.TOOL = 'tool'),
    (e.TOOLEXTRA = 'toolextra'),
    (e.PREVIEW = 'preview'),
    (e.experimental_PAGE = 'page'),
    (e.experimental_TEST_PROVIDER = 'test-provider'),
    e
  ))(FE || {}),
  BE = {};
Et(BE, {
  ADDON_ID: () => Va,
  CLEAR_ID: () => xL,
  CYCLIC_KEY: () => NL,
  EVENT_ID: () => JE,
  PANEL_ID: () => CL,
  PARAM_KEY: () => OL,
  action: () => No,
  actions: () => uH,
  config: () => Yi,
  configureActions: () => aH,
});
var OL = 'actions',
  Va = 'storybook/actions',
  CL = `${Va}/panel`,
  JE = `${Va}/action-event`,
  xL = `${Va}/action-clear`,
  NL = '$___storybook.isCyclic',
  Yc = {};
Et(Yc, {
  DocsContext: () => Zy,
  HooksContext: () => yp,
  Preview: () => wx,
  PreviewWeb: () => ZV,
  PreviewWithSelection: () => Ix,
  ReporterAPI: () => Yy,
  StoryStore: () => gx,
  UrlStore: () => Fx,
  WebView: () => $x,
  addons: () => Dt,
  applyHooks: () => HE,
  combineArgs: () => Ia,
  combineParameters: () => Pn,
  composeConfigs: () => An,
  composeStepRunners: () => zy,
  composeStories: () => fx,
  composeStory: () => Qy,
  createPlaywrightTest: () => mx,
  decorateStory: () => By,
  defaultDecorateStory: () => $y,
  emitTransformCode: () => zx,
  filterArgTypes: () => ax,
  getCsfFactoryAnnotations: () => Xy,
  inferControls: () => Gy,
  makeDecorator: () => jL,
  mockChannel: () => mp,
  normalizeArrays: () => Ie,
  normalizeProjectAnnotations: () => Ki,
  normalizeStory: () => Zn,
  pauseAnimations: () => ic,
  prepareMeta: () => Uy,
  prepareStory: () => oc,
  sanitizeStoryContextUpdate: () => Jy,
  setDefaultProjectAnnotations: () => ux,
  setProjectAnnotations: () => px,
  simulateDOMContentLoaded: () => ka,
  simulatePageLoad: () => Hx,
  sortStoriesV7: () => BV,
  useArgs: () => ZE,
  useCallback: () => to,
  useChannel: () => XE,
  useEffect: () => $r,
  useGlobals: () => eT,
  useMemo: () => bp,
  useParameter: () => QE,
  useReducer: () => YE,
  useRef: () => zE,
  useState: () => KE,
  useStoryContext: () => Zi,
  userOrAutoTitle: () => DV,
  userOrAutoTitleFromSpecifier: () => vx,
  waitForAnimations: () => sc,
});
function mp() {
  const e = { setHandler: o(() => {}, 'setHandler'), send: o(() => {}, 'send') };
  return new Fa({ transport: e });
}
o(mp, 'mockChannel');
var $E = class {
  constructor() {
    ((this.getChannel = o(() => {
      if (!this.channel) {
        const t = mp();
        return (this.setChannel(t), t);
      }
      return this.channel;
    }, 'getChannel')),
      (this.ready = o(() => this.promise, 'ready')),
      (this.hasChannel = o(() => !!this.channel, 'hasChannel')),
      (this.setChannel = o((t) => {
        ((this.channel = t), this.resolve());
      }, 'setChannel')),
      (this.promise = new Promise((t) => {
        this.resolve = () => t(this.getChannel());
      })));
  }
};
o($E, 'AddonStore');
var IL = $E,
  vc = '__STORYBOOK_ADDONS_PREVIEW';
function UE() {
  return (te[vc] || (te[vc] = new IL()), te[vc]);
}
o(UE, 'getAddonsStore');
var Dt = UE(),
  VE = class {
    constructor() {
      ((this.hookListsMap = void 0),
        (this.mountedDecorators = void 0),
        (this.prevMountedDecorators = void 0),
        (this.currentHooks = void 0),
        (this.nextHookIndex = void 0),
        (this.currentPhase = void 0),
        (this.currentEffects = void 0),
        (this.prevEffects = void 0),
        (this.currentDecoratorName = void 0),
        (this.hasUpdates = void 0),
        (this.currentContext = void 0),
        (this.renderListener = o((t) => {
          t === this.currentContext?.id &&
            (this.triggerEffects(), (this.currentContext = null), this.removeRenderListeners());
        }, 'renderListener')),
        this.init());
    }
    init() {
      ((this.hookListsMap = new WeakMap()),
        (this.mountedDecorators = new Set()),
        (this.prevMountedDecorators = new Set()),
        (this.currentHooks = []),
        (this.nextHookIndex = 0),
        (this.currentPhase = 'NONE'),
        (this.currentEffects = []),
        (this.prevEffects = []),
        (this.currentDecoratorName = null),
        (this.hasUpdates = !1),
        (this.currentContext = null));
    }
    clean() {
      (this.prevEffects.forEach((t) => {
        t.destroy && t.destroy();
      }),
        this.init(),
        this.removeRenderListeners());
    }
    getNextHook() {
      const t = this.currentHooks[this.nextHookIndex];
      return ((this.nextHookIndex += 1), t);
    }
    triggerEffects() {
      (this.prevEffects.forEach((t) => {
        !this.currentEffects.includes(t) && t.destroy && t.destroy();
      }),
        this.currentEffects.forEach((t) => {
          this.prevEffects.includes(t) || (t.destroy = t.create());
        }),
        (this.prevEffects = this.currentEffects),
        (this.currentEffects = []));
    }
    addRenderListeners() {
      (this.removeRenderListeners(), Dt.getChannel().on(Vs, this.renderListener));
    }
    removeRenderListeners() {
      Dt.getChannel().removeListener(Vs, this.renderListener);
    }
  };
o(VE, 'HooksContext');
var yp = VE;
function Xc(e) {
  const t = o((...r) => {
    const { hooks: n } = typeof r[0] == 'function' ? r[1] : r[0],
      i = n.currentPhase,
      s = n.currentHooks,
      a = n.nextHookIndex,
      c = n.currentDecoratorName;
    ((n.currentDecoratorName = e.name),
      n.prevMountedDecorators.has(e)
        ? ((n.currentPhase = 'UPDATE'), (n.currentHooks = n.hookListsMap.get(e) || []))
        : ((n.currentPhase = 'MOUNT'),
          (n.currentHooks = []),
          n.hookListsMap.set(e, n.currentHooks),
          n.prevMountedDecorators.add(e)),
      (n.nextHookIndex = 0));
    const d = te.STORYBOOK_HOOKS_CONTEXT;
    te.STORYBOOK_HOOKS_CONTEXT = n;
    const u = e(...r);
    if (((te.STORYBOOK_HOOKS_CONTEXT = d), n.currentPhase === 'UPDATE' && n.getNextHook() != null))
      throw new Error(
        'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.',
      );
    return (
      (n.currentPhase = i),
      (n.currentHooks = s),
      (n.nextHookIndex = a),
      (n.currentDecoratorName = c),
      u
    );
  }, 'hookified');
  return ((t.originalFn = e), t);
}
o(Xc, 'hookify');
var Ec = 0,
  ML = 25,
  HE = o(
    (e) => (t, r) => {
      const n = e(
        Xc(t),
        r.map((i) => Xc(i)),
      );
      return (i) => {
        const { hooks: s } = i;
        (s.prevMountedDecorators ?? (s.prevMountedDecorators = new Set()),
          (s.mountedDecorators = new Set([t, ...r])),
          (s.currentContext = i),
          (s.hasUpdates = !1));
        let a = n(i);
        for (Ec = 1; s.hasUpdates; )
          if (((s.hasUpdates = !1), (s.currentEffects = []), (a = n(i)), (Ec += 1), Ec > ML))
            throw new Error(
              'Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.',
            );
        return (s.addRenderListeners(), a);
      };
    },
    'applyHooks',
  ),
  qL = o((e, t) => e.length === t.length && e.every((r, n) => r === t[n]), 'areDepsEqual'),
  hp = o(
    () =>
      new Error(
        'Storybook preview hooks can only be called inside decorators and story functions.',
      ),
    'invalidHooksError',
  );
function gp() {
  return te.STORYBOOK_HOOKS_CONTEXT || null;
}
o(gp, 'getHooksContextOrNull');
function Ha() {
  const e = gp();
  if (e == null) throw hp();
  return e;
}
o(Ha, 'getHooksContextOrThrow');
function GE(e, t, r) {
  const n = Ha();
  if (n.currentPhase === 'MOUNT') {
    r != null &&
      !Array.isArray(r) &&
      De.warn(
        `${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`,
      );
    const i = { name: e, deps: r };
    return (n.currentHooks.push(i), t(i), i);
  }
  if (n.currentPhase === 'UPDATE') {
    const i = n.getNextHook();
    if (i == null) throw new Error('Rendered more hooks than during the previous render.');
    return (
      i.name !== e &&
        De.warn(
          `Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ''}. This will lead to bugs and errors if not fixed.`,
        ),
      r != null &&
        i.deps == null &&
        De.warn(
          `${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`,
        ),
      r != null &&
        i.deps != null &&
        r.length !== i.deps.length &&
        De.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${i.deps}
Incoming: ${r}`),
      (r == null || i.deps == null || !qL(r, i.deps)) && (t(i), (i.deps = r)),
      i
    );
  }
  throw hp();
}
o(GE, 'useHook');
function Qi(e, t, r) {
  const { memoizedState: n } = GE(
    e,
    (i) => {
      i.memoizedState = t();
    },
    r,
  );
  return n;
}
o(Qi, 'useMemoLike');
function bp(e, t) {
  return Qi('useMemo', e, t);
}
o(bp, 'useMemo');
function to(e, t) {
  return Qi('useCallback', () => e, t);
}
o(to, 'useCallback');
function vp(e, t) {
  return Qi(e, () => ({ current: t }), []);
}
o(vp, 'useRefLike');
function zE(e) {
  return vp('useRef', e);
}
o(zE, 'useRef');
function WE() {
  const e = gp();
  if (e != null && e.currentPhase !== 'NONE') e.hasUpdates = !0;
  else
    try {
      Dt.getChannel().emit(Kd);
    } catch {
      De.warn('State updates of Storybook preview hooks work only in browser');
    }
}
o(WE, 'triggerUpdate');
function Ep(e, t) {
  const r = vp(e, typeof t == 'function' ? t() : t),
    n = o((i) => {
      ((r.current = typeof i == 'function' ? i(r.current) : i), WE());
    }, 'setState');
  return [r.current, n];
}
o(Ep, 'useStateLike');
function KE(e) {
  return Ep('useState', e);
}
o(KE, 'useState');
function YE(e, t, r) {
  const n = r != null ? () => r(t) : t,
    [i, s] = Ep('useReducer', n);
  return [i, o((c) => s((d) => e(d, c)), 'dispatch')];
}
o(YE, 'useReducer');
function $r(e, t) {
  const r = Ha(),
    n = Qi('useEffect', () => ({ create: e }), t);
  r.currentEffects.includes(n) || r.currentEffects.push(n);
}
o($r, 'useEffect');
function XE(e, t = []) {
  const r = Dt.getChannel();
  return (
    $r(
      () => (
        Object.entries(e).forEach(([n, i]) => r.on(n, i)),
        () => {
          Object.entries(e).forEach(([n, i]) => r.removeListener(n, i));
        }
      ),
      [...Object.keys(e), ...t],
    ),
    to(r.emit.bind(r), [r])
  );
}
o(XE, 'useChannel');
function Zi() {
  const { currentContext: e } = Ha();
  if (e == null) throw hp();
  return e;
}
o(Zi, 'useStoryContext');
function QE(e, t) {
  const { parameters: r } = Zi();
  if (e) return r[e] ?? t;
}
o(QE, 'useParameter');
function ZE() {
  const e = Dt.getChannel(),
    { id: t, args: r } = Zi(),
    n = to((s) => e.emit(Zd, { storyId: t, updatedArgs: s }), [e, t]),
    i = to((s) => e.emit(Yd, { storyId: t, argNames: s }), [e, t]);
  return [r, n, i];
}
o(ZE, 'useArgs');
function eT() {
  const e = Dt.getChannel(),
    { globals: t } = Zi(),
    r = to((n) => e.emit(Qd, { globals: n }), [e]);
  return [t, r];
}
o(eT, 'useGlobals');
var jL = o(({ name: e, parameterName: t, wrapper: r, skipIfNoParametersOrOptions: n = !1 }) => {
  const i = o(
    (s) => (a, c) => {
      const d = c.parameters && c.parameters[t];
      return (d && d.disable) || (n && !s && !d) ? a(c) : r(a, c, { options: s, parameters: d });
    },
    'decorator',
  );
  return (...s) =>
    typeof s[0] == 'function'
      ? i()(...s)
      : (...a) => {
          if (a.length > 1) return s.length > 1 ? i(s)(...a) : i(...s)(...a);
          throw new Error(`Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`);
        };
}, 'makeDecorator');
function tT(e) {
  return e
    .replace(/_/g, ' ')
    .replace(/-/g, ' ')
    .replace(/\./g, ' ')
    .replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, i) => `${r} ${n}${i}`)
    .replace(/([a-z])([A-Z])/g, (t, r, n) => `${r} ${n}`)
    .replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`)
    .replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`)
    .replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`)
    .replace(/ +/g, ' ')
    .trim();
}
o(tT, 'toStartCaseStr');
var Th = ze(dI(), 1),
  rT = o((e) => e.map((t) => typeof t < 'u').filter(Boolean).length, 'count'),
  kL = o((e, t) => {
    const { exists: r, eq: n, neq: i, truthy: s } = e;
    if (rT([r, n, i, s]) > 1)
      throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: i })}`);
    if (typeof n < 'u') return (0, Th.isEqual)(t, n);
    if (typeof i < 'u') return !(0, Th.isEqual)(t, i);
    if (typeof r < 'u') {
      const c = typeof t < 'u';
      return r ? c : !c;
    }
    return (typeof s > 'u' ? !0 : s) ? !!t : !t;
  }, 'testValue'),
  DL = o((e, t, r) => {
    if (!e.if) return !0;
    const { arg: n, global: i } = e.if;
    if (rT([n, i]) !== 1)
      throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n, global: i })}`);
    const s = n ? t[n] : r[i];
    return kL(e.if, s);
  }, 'includeConditionalArg');
function nT(e) {
  return e != null && oT(e).includes('mount');
}
o(nT, 'mountDestructured');
function oT(e) {
  const t = e.toString().match(/[^(]*\(([^)]*)/);
  if (!t) return [];
  const r = Qc(t[1]);
  if (!r.length) return [];
  const n = r[0];
  return n.startsWith('{') && n.endsWith('}')
    ? Qc(n.slice(1, -1).replace(/\s/g, '')).map((s) => s.replace(/:.*|=.*/g, ''))
    : [];
}
o(oT, 'getUsedProps');
function Qc(e) {
  const t = [],
    r = [];
  let n = 0;
  for (let s = 0; s < e.length; s++)
    if (e[s] === '{' || e[s] === '[') r.push(e[s] === '{' ? '}' : ']');
    else if (e[s] === r[r.length - 1]) r.pop();
    else if (!r.length && e[s] === ',') {
      const a = e.substring(n, s).trim();
      (a && t.push(a), (n = s + 1));
    }
  const i = e.substring(n).trim();
  return (i && t.push(i), t);
}
o(Qc, 'splitByComma');
var iT = {};
Et(iT, { argsEnhancers: () => BL });
var sT = o((e, t) => typeof t[e] > 'u' && !(e in t), 'isInInitialArgs'),
  LL = o((e) => {
    const {
      initialArgs: t,
      argTypes: r,
      id: n,
      parameters: { actions: i },
    } = e;
    if (!i || i.disable || !i.argTypesRegex || !r) return {};
    const s = new RegExp(i.argTypesRegex);
    return Object.entries(r)
      .filter(([c]) => !!s.test(c))
      .reduce((c, [d, u]) => (sT(d, t) && (c[d] = No(d, { implicit: !0, id: n })), c), {});
  }, 'inferActionsFromArgTypesRegex'),
  FL = o((e) => {
    const {
      initialArgs: t,
      argTypes: r,
      parameters: { actions: n },
    } = e;
    return n?.disable || !r
      ? {}
      : Object.entries(r)
          .filter(([s, a]) => !!a.action)
          .reduce(
            (s, [a, c]) => (sT(a, t) && (s[a] = No(typeof c.action == 'string' ? c.action : a)), s),
            {},
          );
  }, 'addActionsFromArgTypes'),
  BL = [FL, LL],
  aT = {};
Et(aT, { loaders: () => eU });
var lT = {};
Et(lT, {
  buildQueries: () => MJ,
  clearAllMocks: () => qm,
  configure: () => qJ,
  createEvent: () => jJ,
  expect: () => X$,
  findAllByAltText: () => DJ,
  findAllByDisplayValue: () => LJ,
  findAllByLabelText: () => FJ,
  findAllByPlaceholderText: () => BJ,
  findAllByRole: () => JJ,
  findAllByTestId: () => $J,
  findAllByText: () => UJ,
  findAllByTitle: () => VJ,
  findByAltText: () => HJ,
  findByDisplayValue: () => GJ,
  findByLabelText: () => zJ,
  findByPlaceholderText: () => WJ,
  findByRole: () => KJ,
  findByTestId: () => YJ,
  findByText: () => XJ,
  findByTitle: () => QJ,
  fireEvent: () => kJ,
  fn: () => Im,
  getAllByAltText: () => ZJ,
  getAllByDisplayValue: () => e$,
  getAllByLabelText: () => t$,
  getAllByPlaceholderText: () => r$,
  getAllByRole: () => n$,
  getAllByTestId: () => o$,
  getAllByText: () => i$,
  getAllByTitle: () => s$,
  getByAltText: () => a$,
  getByDisplayValue: () => l$,
  getByLabelText: () => c$,
  getByPlaceholderText: () => u$,
  getByRole: () => d$,
  getByTestId: () => p$,
  getByText: () => f$,
  getByTitle: () => m$,
  getConfig: () => y$,
  getDefaultNormalizer: () => h$,
  getElementError: () => g$,
  getNodeText: () => b$,
  getQueriesForElement: () => v$,
  getRoles: () => E$,
  getSuggestedQuery: () => T$,
  isInaccessible: () => w$,
  isMockFunction: () => fn,
  logDOM: () => S$,
  logRoles: () => _$,
  mocked: () => O0,
  mocks: () => ms,
  onMockCall: () => Nm,
  prettyDOM: () => R$,
  prettyFormat: () => K$,
  queries: () => P$,
  queryAllByAltText: () => A$,
  queryAllByAttribute: () => O$,
  queryAllByDisplayValue: () => C$,
  queryAllByLabelText: () => x$,
  queryAllByPlaceholderText: () => N$,
  queryAllByRole: () => I$,
  queryAllByTestId: () => M$,
  queryAllByText: () => q$,
  queryAllByTitle: () => j$,
  queryByAltText: () => k$,
  queryByAttribute: () => D$,
  queryByDisplayValue: () => L$,
  queryByLabelText: () => F$,
  queryByPlaceholderText: () => B$,
  queryByRole: () => J$,
  queryByTestId: () => $$,
  queryByText: () => U$,
  queryByTitle: () => V$,
  queryHelpers: () => H$,
  resetAllMocks: () => jm,
  restoreAllMocks: () => km,
  sb: () => Q$,
  screen: () => G$,
  spyOn: () => PB,
  uninstrumentedUserEvent: () => EC,
  userEvent: () => Y$,
  waitFor: () => z$,
  waitForElementToBeRemoved: () => W$,
  within: () => vC,
});
var JL = {
    reset: [0, 0],
    bold: [1, 22, '\x1B[22m\x1B[1m'],
    dim: [2, 22, '\x1B[22m\x1B[2m'],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBright: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
    bgBlackBright: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49],
  },
  cT = Object.entries(JL);
function es(e) {
  return String(e);
}
o(es, 'a');
es.open = '';
es.close = '';
cT.reduce((e, [t]) => ((e[t] = es), e), { isColorSupported: !1 });
function uT(e = !1) {
  let t = typeof process < 'u' ? process : void 0,
    r = t?.env || {},
    n = t?.argv || [];
  return (
    (!('NO_COLOR' in r || n.includes('--no-color')) &&
      ('FORCE_COLOR' in r ||
        n.includes('--color') ||
        t?.platform === 'win32' ||
        (e && r.TERM !== 'dumb') ||
        'CI' in r)) ||
    (typeof window < 'u' && !!window.chrome)
  );
}
o(uT, 'C');
function dT(e = !1) {
  let t = uT(e),
    r = o((a, c, d, u) => {
      let p = '',
        f = 0;
      do ((p += a.substring(f, u) + d), (f = u + c.length), (u = a.indexOf(c, f)));
      while (~u);
      return p + a.substring(f);
    }, 'i'),
    n = o((a, c, d = a) => {
      let u = o((p) => {
        let f = String(p),
          y = f.indexOf(c, a.length);
        return ~y ? a + r(f, c, d, y) + c : a + f + c;
      }, 'o');
      return ((u.open = a), (u.close = c), u);
    }, 'g'),
    i = { isColorSupported: t },
    s = o((a) => `\x1B[${a}m`, 'd');
  for (let [a, c] of cT) i[a] = t ? n(s(c[0]), s(c[1]), c[2]) : es;
  return i;
}
o(dT, 'p');
var Ue = dT();
function Tp(e, t) {
  return (
    t.forEach(function (r) {
      r &&
        typeof r != 'string' &&
        !Array.isArray(r) &&
        Object.keys(r).forEach(function (n) {
          if (n !== 'default' && !(n in e)) {
            var i = Object.getOwnPropertyDescriptor(r, n);
            Object.defineProperty(
              e,
              n,
              i.get
                ? i
                : {
                    enumerable: !0,
                    get: o(function () {
                      return r[n];
                    }, 'get'),
                  },
            );
          }
        });
    }),
    Object.freeze(e)
  );
}
o(Tp, '_mergeNamespaces');
function pT(e, t) {
  const r = Object.keys(e),
    n = t === null ? r : r.sort(t);
  if (Object.getOwnPropertySymbols)
    for (const i of Object.getOwnPropertySymbols(e))
      Object.getOwnPropertyDescriptor(e, i).enumerable && n.push(i);
  return n;
}
o(pT, 'getKeysOfEnumerableProperties');
function Eo(e, t, r, n, i, s, a = ': ') {
  let c = '',
    d = 0,
    u = e.next();
  if (!u.done) {
    c += t.spacingOuter;
    const p = r + t.indent;
    for (; !u.done; ) {
      if (((c += p), d++ === t.maxWidth)) {
        c += '';
        break;
      }
      const f = s(u.value[0], t, p, n, i),
        y = s(u.value[1], t, p, n, i);
      ((c += f + a + y),
        (u = e.next()),
        u.done ? t.min || (c += ',') : (c += `,${t.spacingInner}`));
    }
    c += t.spacingOuter + r;
  }
  return c;
}
o(Eo, 'printIteratorEntries');
function Ga(e, t, r, n, i, s) {
  let a = '',
    c = 0,
    d = e.next();
  if (!d.done) {
    a += t.spacingOuter;
    const u = r + t.indent;
    for (; !d.done; ) {
      if (((a += u), c++ === t.maxWidth)) {
        a += '';
        break;
      }
      ((a += s(d.value, t, u, n, i)),
        (d = e.next()),
        d.done ? t.min || (a += ',') : (a += `,${t.spacingInner}`));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
o(Ga, 'printIteratorValues');
function Ni(e, t, r, n, i, s) {
  let a = '';
  e = e instanceof ArrayBuffer ? new DataView(e) : e;
  const c = o((u) => u instanceof DataView, 'isDataView'),
    d = c(e) ? e.byteLength : e.length;
  if (d > 0) {
    a += t.spacingOuter;
    const u = r + t.indent;
    for (let p = 0; p < d; p++) {
      if (((a += u), p === t.maxWidth)) {
        a += '';
        break;
      }
      ((c(e) || p in e) && (a += s(c(e) ? e.getInt8(p) : e[p], t, u, n, i)),
        p < d - 1 ? (a += `,${t.spacingInner}`) : t.min || (a += ','));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
o(Ni, 'printListItems');
function za(e, t, r, n, i, s) {
  let a = '';
  const c = pT(e, t.compareKeys);
  if (c.length > 0) {
    a += t.spacingOuter;
    const d = r + t.indent;
    for (let u = 0; u < c.length; u++) {
      const p = c[u],
        f = s(p, t, d, n, i),
        y = s(e[p], t, d, n, i);
      ((a += `${d + f}: ${y}`),
        u < c.length - 1 ? (a += `,${t.spacingInner}`) : t.min || (a += ','));
    }
    a += t.spacingOuter + r;
  }
  return a;
}
o(za, 'printObjectProperties');
var $L = typeof Symbol == 'function' && Symbol.for ? Symbol.for('jest.asymmetricMatcher') : 1267621,
  Es = ' ',
  UL = o((e, t, r, n, i, s) => {
    const a = e.toString();
    if (a === 'ArrayContaining' || a === 'ArrayNotContaining')
      return ++n > t.maxDepth ? `[${a}]` : `${a + Es}[${Ni(e.sample, t, r, n, i, s)}]`;
    if (a === 'ObjectContaining' || a === 'ObjectNotContaining')
      return ++n > t.maxDepth ? `[${a}]` : `${a + Es}{${za(e.sample, t, r, n, i, s)}}`;
    if (
      a === 'StringMatching' ||
      a === 'StringNotMatching' ||
      a === 'StringContaining' ||
      a === 'StringNotContaining'
    )
      return a + Es + s(e.sample, t, r, n, i);
    if (typeof e.toAsymmetricMatcher != 'function')
      throw new TypeError(
        `Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`,
      );
    return e.toAsymmetricMatcher();
  }, 'serialize$5'),
  VL = o((e) => e && e.$$typeof === $L, 'test$5'),
  HL = { serialize: UL, test: VL },
  GL = ' ',
  fT = new Set(['DOMStringMap', 'NamedNodeMap']),
  zL = /^(?:HTML\w*Collection|NodeList)$/;
function mT(e) {
  return fT.has(e) || zL.test(e);
}
o(mT, 'testName');
var WL = o((e) => e && e.constructor && !!e.constructor.name && mT(e.constructor.name), 'test$4');
function yT(e) {
  return e.constructor.name === 'NamedNodeMap';
}
o(yT, 'isNamedNodeMap');
var KL = o((e, t, r, n, i, s) => {
    const a = e.constructor.name;
    return ++n > t.maxDepth
      ? `[${a}]`
      : (t.min ? '' : a + GL) +
          (fT.has(a)
            ? `{${za(yT(e) ? [...e].reduce((c, d) => ((c[d.name] = d.value), c), {}) : { ...e }, t, r, n, i, s)}}`
            : `[${Ni([...e], t, r, n, i, s)}]`);
  }, 'serialize$4'),
  YL = { serialize: KL, test: WL };
function wp(e) {
  return e.replaceAll('<', '&lt;').replaceAll('>', '&gt;');
}
o(wp, 'escapeHTML');
function Wa(e, t, r, n, i, s, a) {
  const c = n + r.indent,
    d = r.colors;
  return e
    .map((u) => {
      const p = t[u];
      let f = a(p, r, c, i, s);
      return (
        typeof p != 'string' &&
          (f.includes(`
`) && (f = r.spacingOuter + c + f + r.spacingOuter + n),
          (f = `{${f}}`)),
        `${r.spacingInner + n + d.prop.open + u + d.prop.close}=${d.value.open}${f}${d.value.close}`
      );
    })
    .join('');
}
o(Wa, 'printProps');
function Ka(e, t, r, n, i, s) {
  return e
    .map((a) => t.spacingOuter + r + (typeof a == 'string' ? Sp(a, t) : s(a, t, r, n, i)))
    .join('');
}
o(Ka, 'printChildren');
function Sp(e, t) {
  const r = t.colors.content;
  return r.open + wp(e) + r.close;
}
o(Sp, 'printText');
function hT(e, t) {
  const r = t.colors.comment;
  return `${r.open}<!--${wp(e)}-->${r.close}`;
}
o(hT, 'printComment');
function Ya(e, t, r, n, i) {
  const s = n.colors.tag;
  return `${s.open}<${e}${t && s.close + t + n.spacingOuter + i + s.open}${r ? `>${s.close}${r}${n.spacingOuter}${i}${s.open}</${e}` : `${t && !n.min ? '' : ' '}/`}>${s.close}`;
}
o(Ya, 'printElement');
function Xa(e, t) {
  const r = t.colors.tag;
  return `${r.open}<${e}${r.close} ${r.open} />${r.close}`;
}
o(Xa, 'printElementAsLeaf');
var XL = 1,
  gT = 3,
  bT = 8,
  vT = 11,
  QL = /^(?:(?:HTML|SVG)\w*)?Element$/;
function ET(e) {
  try {
    return typeof e.hasAttribute == 'function' && e.hasAttribute('is');
  } catch {
    return !1;
  }
}
o(ET, 'testHasAttribute');
function TT(e) {
  const t = e.constructor.name,
    { nodeType: r, tagName: n } = e,
    i = (typeof n == 'string' && n.includes('-')) || ET(e);
  return (
    (r === XL && (QL.test(t) || i)) ||
    (r === gT && t === 'Text') ||
    (r === bT && t === 'Comment') ||
    (r === vT && t === 'DocumentFragment')
  );
}
o(TT, 'testNode');
var ZL = o((e) => {
  var t;
  return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && TT(e);
}, 'test$3');
function wT(e) {
  return e.nodeType === gT;
}
o(wT, 'nodeIsText');
function ST(e) {
  return e.nodeType === bT;
}
o(ST, 'nodeIsComment');
function As(e) {
  return e.nodeType === vT;
}
o(As, 'nodeIsFragment');
var e1 = o((e, t, r, n, i, s) => {
    if (wT(e)) return Sp(e.data, t);
    if (ST(e)) return hT(e.data, t);
    const a = As(e) ? 'DocumentFragment' : e.tagName.toLowerCase();
    return ++n > t.maxDepth
      ? Xa(a, t)
      : Ya(
          a,
          Wa(
            As(e) ? [] : Array.from(e.attributes, (c) => c.name).sort(),
            As(e) ? {} : [...e.attributes].reduce((c, d) => ((c[d.name] = d.value), c), {}),
            t,
            r + t.indent,
            n,
            i,
            s,
          ),
          Ka(Array.prototype.slice.call(e.childNodes || e.children), t, r + t.indent, n, i, s),
          t,
          r,
        );
  }, 'serialize$3'),
  t1 = { serialize: e1, test: ZL },
  r1 = '@@__IMMUTABLE_ITERABLE__@@',
  n1 = '@@__IMMUTABLE_LIST__@@',
  o1 = '@@__IMMUTABLE_KEYED__@@',
  i1 = '@@__IMMUTABLE_MAP__@@',
  wh = '@@__IMMUTABLE_ORDERED__@@',
  s1 = '@@__IMMUTABLE_RECORD__@@',
  a1 = '@@__IMMUTABLE_SEQ__@@',
  l1 = '@@__IMMUTABLE_SET__@@',
  c1 = '@@__IMMUTABLE_STACK__@@',
  ro = o((e) => `Immutable.${e}`, 'getImmutableName'),
  Qa = o((e) => `[${e}]`, 'printAsLeaf'),
  Ii = ' ',
  Sh = '';
function _T(e, t, r, n, i, s, a) {
  return ++n > t.maxDepth ? Qa(ro(a)) : `${ro(a) + Ii}{${Eo(e.entries(), t, r, n, i, s)}}`;
}
o(_T, 'printImmutableEntries');
function RT(e) {
  let t = 0;
  return {
    next() {
      if (t < e._keys.length) {
        const r = e._keys[t++];
        return { done: !1, value: [r, e.get(r)] };
      }
      return { done: !0, value: void 0 };
    },
  };
}
o(RT, 'getRecordEntries');
function PT(e, t, r, n, i, s) {
  const a = ro(e._name || 'Record');
  return ++n > t.maxDepth ? Qa(a) : `${a + Ii}{${Eo(RT(e), t, r, n, i, s)}}`;
}
o(PT, 'printImmutableRecord');
function AT(e, t, r, n, i, s) {
  const a = ro('Seq');
  return ++n > t.maxDepth
    ? Qa(a)
    : e[o1]
      ? `${a + Ii}{${e._iter || e._object ? Eo(e.entries(), t, r, n, i, s) : Sh}}`
      : `${a + Ii}[${e._iter || e._array || e._collection || e._iterable ? Ga(e.values(), t, r, n, i, s) : Sh}]`;
}
o(AT, 'printImmutableSeq');
function Os(e, t, r, n, i, s, a) {
  return ++n > t.maxDepth ? Qa(ro(a)) : `${ro(a) + Ii}[${Ga(e.values(), t, r, n, i, s)}]`;
}
o(Os, 'printImmutableValues');
var u1 = o(
    (e, t, r, n, i, s) =>
      e[i1]
        ? _T(e, t, r, n, i, s, e[wh] ? 'OrderedMap' : 'Map')
        : e[n1]
          ? Os(e, t, r, n, i, s, 'List')
          : e[l1]
            ? Os(e, t, r, n, i, s, e[wh] ? 'OrderedSet' : 'Set')
            : e[c1]
              ? Os(e, t, r, n, i, s, 'Stack')
              : e[a1]
                ? AT(e, t, r, n, i, s)
                : PT(e, t, r, n, i, s),
    'serialize$2',
  ),
  d1 = o((e) => e && (e[r1] === !0 || e[s1] === !0), 'test$2'),
  p1 = { serialize: u1, test: d1 };
function _p(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
o(_p, 'getDefaultExportFromCjs');
var Tc = { exports: {} },
  Ne = {},
  _h;
function OT() {
  if (_h) return Ne;
  _h = 1;
  var e = Symbol.for('react.transitional.element'),
    t = Symbol.for('react.portal'),
    r = Symbol.for('react.fragment'),
    n = Symbol.for('react.strict_mode'),
    i = Symbol.for('react.profiler'),
    s = Symbol.for('react.consumer'),
    a = Symbol.for('react.context'),
    c = Symbol.for('react.forward_ref'),
    d = Symbol.for('react.suspense'),
    u = Symbol.for('react.suspense_list'),
    p = Symbol.for('react.memo'),
    f = Symbol.for('react.lazy'),
    y = Symbol.for('react.view_transition'),
    h = Symbol.for('react.client.reference');
  function g(T) {
    if (typeof T == 'object' && T !== null) {
      var E = T.$$typeof;
      switch (E) {
        case e:
          switch (((T = T.type), T)) {
            case r:
            case i:
            case n:
            case d:
            case u:
            case y:
              return T;
            default:
              switch (((T = T && T.$$typeof), T)) {
                case a:
                case c:
                case f:
                case p:
                  return T;
                case s:
                  return T;
                default:
                  return E;
              }
          }
        case t:
          return E;
      }
    }
  }
  return (
    o(g, 'typeOf'),
    (Ne.ContextConsumer = s),
    (Ne.ContextProvider = a),
    (Ne.Element = e),
    (Ne.ForwardRef = c),
    (Ne.Fragment = r),
    (Ne.Lazy = f),
    (Ne.Memo = p),
    (Ne.Portal = t),
    (Ne.Profiler = i),
    (Ne.StrictMode = n),
    (Ne.Suspense = d),
    (Ne.SuspenseList = u),
    (Ne.isContextConsumer = function (T) {
      return g(T) === s;
    }),
    (Ne.isContextProvider = function (T) {
      return g(T) === a;
    }),
    (Ne.isElement = function (T) {
      return typeof T == 'object' && T !== null && T.$$typeof === e;
    }),
    (Ne.isForwardRef = function (T) {
      return g(T) === c;
    }),
    (Ne.isFragment = function (T) {
      return g(T) === r;
    }),
    (Ne.isLazy = function (T) {
      return g(T) === f;
    }),
    (Ne.isMemo = function (T) {
      return g(T) === p;
    }),
    (Ne.isPortal = function (T) {
      return g(T) === t;
    }),
    (Ne.isProfiler = function (T) {
      return g(T) === i;
    }),
    (Ne.isStrictMode = function (T) {
      return g(T) === n;
    }),
    (Ne.isSuspense = function (T) {
      return g(T) === d;
    }),
    (Ne.isSuspenseList = function (T) {
      return g(T) === u;
    }),
    (Ne.isValidElementType = function (T) {
      return (
        typeof T == 'string' ||
        typeof T == 'function' ||
        T === r ||
        T === i ||
        T === n ||
        T === d ||
        T === u ||
        (typeof T == 'object' &&
          T !== null &&
          (T.$$typeof === f ||
            T.$$typeof === p ||
            T.$$typeof === a ||
            T.$$typeof === s ||
            T.$$typeof === c ||
            T.$$typeof === h ||
            T.getModuleId !== void 0))
      );
    }),
    (Ne.typeOf = g),
    Ne
  );
}
o(OT, 'requireReactIs_production');
var Rh;
function CT() {
  return (Rh || ((Rh = 1), (Tc.exports = OT())), Tc.exports);
}
o(CT, 'requireReactIs$1');
var xT = CT(),
  f1 = _p(xT),
  m1 = Tp({ __proto__: null, default: f1 }, [xT]),
  wc = { exports: {} },
  Ce = {},
  Ph;
function NT() {
  if (Ph) return Ce;
  Ph = 1;
  var e = Symbol.for('react.element'),
    t = Symbol.for('react.portal'),
    r = Symbol.for('react.fragment'),
    n = Symbol.for('react.strict_mode'),
    i = Symbol.for('react.profiler'),
    s = Symbol.for('react.provider'),
    a = Symbol.for('react.context'),
    c = Symbol.for('react.server_context'),
    d = Symbol.for('react.forward_ref'),
    u = Symbol.for('react.suspense'),
    p = Symbol.for('react.suspense_list'),
    f = Symbol.for('react.memo'),
    y = Symbol.for('react.lazy'),
    h = Symbol.for('react.offscreen'),
    g;
  g = Symbol.for('react.module.reference');
  function T(E) {
    if (typeof E == 'object' && E !== null) {
      var v = E.$$typeof;
      switch (v) {
        case e:
          switch (((E = E.type), E)) {
            case r:
            case i:
            case n:
            case u:
            case p:
              return E;
            default:
              switch (((E = E && E.$$typeof), E)) {
                case c:
                case a:
                case d:
                case y:
                case f:
                case s:
                  return E;
                default:
                  return v;
              }
          }
        case t:
          return v;
      }
    }
  }
  return (
    o(T, 'v'),
    (Ce.ContextConsumer = a),
    (Ce.ContextProvider = s),
    (Ce.Element = e),
    (Ce.ForwardRef = d),
    (Ce.Fragment = r),
    (Ce.Lazy = y),
    (Ce.Memo = f),
    (Ce.Portal = t),
    (Ce.Profiler = i),
    (Ce.StrictMode = n),
    (Ce.Suspense = u),
    (Ce.SuspenseList = p),
    (Ce.isAsyncMode = function () {
      return !1;
    }),
    (Ce.isConcurrentMode = function () {
      return !1;
    }),
    (Ce.isContextConsumer = function (E) {
      return T(E) === a;
    }),
    (Ce.isContextProvider = function (E) {
      return T(E) === s;
    }),
    (Ce.isElement = function (E) {
      return typeof E == 'object' && E !== null && E.$$typeof === e;
    }),
    (Ce.isForwardRef = function (E) {
      return T(E) === d;
    }),
    (Ce.isFragment = function (E) {
      return T(E) === r;
    }),
    (Ce.isLazy = function (E) {
      return T(E) === y;
    }),
    (Ce.isMemo = function (E) {
      return T(E) === f;
    }),
    (Ce.isPortal = function (E) {
      return T(E) === t;
    }),
    (Ce.isProfiler = function (E) {
      return T(E) === i;
    }),
    (Ce.isStrictMode = function (E) {
      return T(E) === n;
    }),
    (Ce.isSuspense = function (E) {
      return T(E) === u;
    }),
    (Ce.isSuspenseList = function (E) {
      return T(E) === p;
    }),
    (Ce.isValidElementType = function (E) {
      return (
        typeof E == 'string' ||
        typeof E == 'function' ||
        E === r ||
        E === i ||
        E === n ||
        E === u ||
        E === p ||
        E === h ||
        (typeof E == 'object' &&
          E !== null &&
          (E.$$typeof === y ||
            E.$$typeof === f ||
            E.$$typeof === s ||
            E.$$typeof === a ||
            E.$$typeof === d ||
            E.$$typeof === g ||
            E.getModuleId !== void 0))
      );
    }),
    (Ce.typeOf = T),
    Ce
  );
}
o(NT, 'requireReactIs_production_min');
var Ah;
function IT() {
  return (Ah || ((Ah = 1), (wc.exports = NT())), wc.exports);
}
o(IT, 'requireReactIs');
var MT = IT(),
  y1 = _p(MT),
  h1 = Tp({ __proto__: null, default: y1 }, [MT]),
  g1 = [
    'isAsyncMode',
    'isConcurrentMode',
    'isContextConsumer',
    'isContextProvider',
    'isElement',
    'isForwardRef',
    'isFragment',
    'isLazy',
    'isMemo',
    'isPortal',
    'isProfiler',
    'isStrictMode',
    'isSuspense',
    'isSuspenseList',
    'isValidElementType',
  ],
  on = Object.fromEntries(g1.map((e) => [e, (t) => h1[e](t) || m1[e](t)]));
function Rp(e, t = []) {
  if (Array.isArray(e)) for (const r of e) Rp(r, t);
  else e != null && e !== !1 && e !== '' && t.push(e);
  return t;
}
o(Rp, 'getChildren');
function Zc(e) {
  const t = e.type;
  if (typeof t == 'string') return t;
  if (typeof t == 'function') return t.displayName || t.name || 'Unknown';
  if (on.isFragment(e)) return 'React.Fragment';
  if (on.isSuspense(e)) return 'React.Suspense';
  if (typeof t == 'object' && t !== null) {
    if (on.isContextProvider(e)) return 'Context.Provider';
    if (on.isContextConsumer(e)) return 'Context.Consumer';
    if (on.isForwardRef(e)) {
      if (t.displayName) return t.displayName;
      const r = t.render.displayName || t.render.name || '';
      return r === '' ? 'ForwardRef' : `ForwardRef(${r})`;
    }
    if (on.isMemo(e)) {
      const r = t.displayName || t.type.displayName || t.type.name || '';
      return r === '' ? 'Memo' : `Memo(${r})`;
    }
  }
  return 'UNDEFINED';
}
o(Zc, 'getType');
function qT(e) {
  const { props: t } = e;
  return Object.keys(t)
    .filter((r) => r !== 'children' && t[r] !== void 0)
    .sort();
}
o(qT, 'getPropKeys$1');
var b1 = o(
    (e, t, r, n, i, s) =>
      ++n > t.maxDepth
        ? Xa(Zc(e), t)
        : Ya(
            Zc(e),
            Wa(qT(e), e.props, t, r + t.indent, n, i, s),
            Ka(Rp(e.props.children), t, r + t.indent, n, i, s),
            t,
            r,
          ),
    'serialize$1',
  ),
  v1 = o((e) => e != null && on.isElement(e), 'test$1'),
  E1 = { serialize: b1, test: v1 },
  T1 = typeof Symbol == 'function' && Symbol.for ? Symbol.for('react.test.json') : 245830487;
function jT(e) {
  const { props: t } = e;
  return t
    ? Object.keys(t)
        .filter((r) => t[r] !== void 0)
        .sort()
    : [];
}
o(jT, 'getPropKeys');
var w1 = o(
    (e, t, r, n, i, s) =>
      ++n > t.maxDepth
        ? Xa(e.type, t)
        : Ya(
            e.type,
            e.props ? Wa(jT(e), e.props, t, r + t.indent, n, i, s) : '',
            e.children ? Ka(e.children, t, r + t.indent, n, i, s) : '',
            t,
            r,
          ),
    'serialize',
  ),
  S1 = o((e) => e && e.$$typeof === T1, 'test'),
  _1 = { serialize: w1, test: S1 },
  kT = Object.prototype.toString,
  R1 = Date.prototype.toISOString,
  P1 = Error.prototype.toString,
  Oh = RegExp.prototype.toString;
function gi(e) {
  return (typeof e.constructor == 'function' && e.constructor.name) || 'Object';
}
o(gi, 'getConstructorName');
function DT(e) {
  return typeof window < 'u' && e === window;
}
o(DT, 'isWindow');
var A1 = /^Symbol\((.*)\)(.*)$/,
  O1 = /\n/g,
  LT = class extends Error {
    constructor(t, r) {
      (super(t), (this.stack = r), (this.name = this.constructor.name));
    }
  };
o(LT, 'PrettyFormatPluginError');
var FT = LT;
function BT(e) {
  return (
    e === '[object Array]' ||
    e === '[object ArrayBuffer]' ||
    e === '[object DataView]' ||
    e === '[object Float32Array]' ||
    e === '[object Float64Array]' ||
    e === '[object Int8Array]' ||
    e === '[object Int16Array]' ||
    e === '[object Int32Array]' ||
    e === '[object Uint8Array]' ||
    e === '[object Uint8ClampedArray]' ||
    e === '[object Uint16Array]' ||
    e === '[object Uint32Array]'
  );
}
o(BT, 'isToStringedArrayType');
function JT(e) {
  return Object.is(e, -0) ? '-0' : String(e);
}
o(JT, 'printNumber');
function $T(e) {
  return `${e}n`;
}
o($T, 'printBigInt');
function eu(e, t) {
  return t ? `[Function ${e.name || 'anonymous'}]` : '[Function]';
}
o(eu, 'printFunction');
function tu(e) {
  return String(e).replace(A1, 'Symbol($1)');
}
o(tu, 'printSymbol');
function ru(e) {
  return `[${P1.call(e)}]`;
}
o(ru, 'printError');
function Pp(e, t, r, n) {
  if (e === !0 || e === !1) return `${e}`;
  if (e === void 0) return 'undefined';
  if (e === null) return 'null';
  const i = typeof e;
  if (i === 'number') return JT(e);
  if (i === 'bigint') return $T(e);
  if (i === 'string') return n ? `"${e.replaceAll(/"|\\/g, '\\$&')}"` : `"${e}"`;
  if (i === 'function') return eu(e, t);
  if (i === 'symbol') return tu(e);
  const s = kT.call(e);
  return s === '[object WeakMap]'
    ? 'WeakMap {}'
    : s === '[object WeakSet]'
      ? 'WeakSet {}'
      : s === '[object Function]' || s === '[object GeneratorFunction]'
        ? eu(e, t)
        : s === '[object Symbol]'
          ? tu(e)
          : s === '[object Date]'
            ? Number.isNaN(+e)
              ? 'Date { NaN }'
              : R1.call(e)
            : s === '[object Error]'
              ? ru(e)
              : s === '[object RegExp]'
                ? r
                  ? Oh.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, '\\$&')
                  : Oh.call(e)
                : e instanceof Error
                  ? ru(e)
                  : null;
}
o(Pp, 'printBasicValue');
function Ap(e, t, r, n, i, s) {
  if (i.includes(e)) return '[Circular]';
  ((i = [...i]), i.push(e));
  const a = ++n > t.maxDepth,
    c = t.min;
  if (t.callToJSON && !a && e.toJSON && typeof e.toJSON == 'function' && !s)
    return br(e.toJSON(), t, r, n, i, !0);
  const d = kT.call(e);
  return d === '[object Arguments]'
    ? a
      ? '[Arguments]'
      : `${c ? '' : 'Arguments '}[${Ni(e, t, r, n, i, br)}]`
    : BT(d)
      ? a
        ? `[${e.constructor.name}]`
        : `${c || (!t.printBasicPrototype && e.constructor.name === 'Array') ? '' : `${e.constructor.name} `}[${Ni(e, t, r, n, i, br)}]`
      : d === '[object Map]'
        ? a
          ? '[Map]'
          : `Map {${Eo(e.entries(), t, r, n, i, br, ' => ')}}`
        : d === '[object Set]'
          ? a
            ? '[Set]'
            : `Set {${Ga(e.values(), t, r, n, i, br)}}`
          : a || DT(e)
            ? `[${gi(e)}]`
            : `${c || (!t.printBasicPrototype && gi(e) === 'Object') ? '' : `${gi(e)} `}{${za(e, t, r, n, i, br)}}`;
}
o(Ap, 'printComplexValue');
var C1 = {
  test: o((e) => e && e instanceof Error, 'test'),
  serialize(e, t, r, n, i, s) {
    if (i.includes(e)) return '[Circular]';
    i = [...i, e];
    const a = ++n > t.maxDepth,
      { message: c, cause: d, ...u } = e,
      p = {
        message: c,
        ...(typeof d < 'u' ? { cause: d } : {}),
        ...(e instanceof AggregateError ? { errors: e.errors } : {}),
        ...u,
      },
      f = e.name !== 'Error' ? e.name : gi(e);
    return a ? `[${f}]` : `${f} {${Eo(Object.entries(p).values(), t, r, n, i, s)}}`;
  },
};
function UT(e) {
  return e.serialize != null;
}
o(UT, 'isNewPlugin');
function Op(e, t, r, n, i, s) {
  let a;
  try {
    a = UT(e)
      ? e.serialize(t, r, n, i, s, br)
      : e.print(
          t,
          (c) => br(c, r, n, i, s),
          (c) => {
            const d = n + r.indent;
            return (
              d +
              c.replaceAll(
                O1,
                `
${d}`,
              )
            );
          },
          { edgeSpacing: r.spacingOuter, min: r.min, spacing: r.spacingInner },
          r.colors,
        );
  } catch (c) {
    throw new FT(c.message, c.stack);
  }
  if (typeof a != 'string')
    throw new TypeError(
      `pretty-format: Plugin must return type "string" but instead returned "${typeof a}".`,
    );
  return a;
}
o(Op, 'printPlugin');
function Cp(e, t) {
  for (const r of e)
    try {
      if (r.test(t)) return r;
    } catch (n) {
      throw new FT(n.message, n.stack);
    }
  return null;
}
o(Cp, 'findPlugin');
function br(e, t, r, n, i, s) {
  const a = Cp(t.plugins, e);
  if (a !== null) return Op(a, e, t, r, n, i);
  const c = Pp(e, t.printFunctionName, t.escapeRegex, t.escapeString);
  return c !== null ? c : Ap(e, t, r, n, i, s);
}
o(br, 'printer');
var xp = { comment: 'gray', content: 'reset', prop: 'yellow', tag: 'cyan', value: 'green' },
  VT = Object.keys(xp),
  Ut = {
    callToJSON: !0,
    compareKeys: void 0,
    escapeRegex: !1,
    escapeString: !0,
    highlight: !1,
    indent: 2,
    maxDepth: Number.POSITIVE_INFINITY,
    maxWidth: Number.POSITIVE_INFINITY,
    min: !1,
    plugins: [],
    printBasicPrototype: !0,
    printFunctionName: !0,
    theme: xp,
  };
function HT(e) {
  for (const t of Object.keys(e))
    if (!Object.prototype.hasOwnProperty.call(Ut, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  if (e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
o(HT, 'validateOptions');
function GT() {
  return VT.reduce((e, t) => {
    const r = xp[t],
      n = r && Ue[r];
    if (n && typeof n.close == 'string' && typeof n.open == 'string') e[t] = n;
    else
      throw new Error(
        `pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`,
      );
    return e;
  }, Object.create(null));
}
o(GT, 'getColorsHighlight');
function zT() {
  return VT.reduce((e, t) => ((e[t] = { close: '', open: '' }), e), Object.create(null));
}
o(zT, 'getColorsEmpty');
function Np(e) {
  return e?.printFunctionName ?? Ut.printFunctionName;
}
o(Np, 'getPrintFunctionName');
function Ip(e) {
  return e?.escapeRegex ?? Ut.escapeRegex;
}
o(Ip, 'getEscapeRegex');
function Mp(e) {
  return e?.escapeString ?? Ut.escapeString;
}
o(Mp, 'getEscapeString');
function nu(e) {
  return {
    callToJSON: e?.callToJSON ?? Ut.callToJSON,
    colors: e?.highlight ? GT() : zT(),
    compareKeys:
      typeof e?.compareKeys == 'function' || e?.compareKeys === null
        ? e.compareKeys
        : Ut.compareKeys,
    escapeRegex: Ip(e),
    escapeString: Mp(e),
    indent: e?.min ? '' : WT(e?.indent ?? Ut.indent),
    maxDepth: e?.maxDepth ?? Ut.maxDepth,
    maxWidth: e?.maxWidth ?? Ut.maxWidth,
    min: e?.min ?? Ut.min,
    plugins: e?.plugins ?? Ut.plugins,
    printBasicPrototype: e?.printBasicPrototype ?? !0,
    printFunctionName: Np(e),
    spacingInner: e?.min
      ? ' '
      : `
`,
    spacingOuter: e?.min
      ? ''
      : `
`,
  };
}
o(nu, 'getConfig');
function WT(e) {
  return Array.from({ length: e + 1 }).join(' ');
}
o(WT, 'createIndent');
function Ht(e, t) {
  if (t && (HT(t), t.plugins)) {
    const n = Cp(t.plugins, e);
    if (n !== null) return Op(n, e, nu(t), '', 0, []);
  }
  const r = Pp(e, Np(t), Ip(t), Mp(t));
  return r !== null ? r : Ap(e, nu(t), '', 0, []);
}
o(Ht, 'format');
var qp = {
    AsymmetricMatcher: HL,
    DOMCollection: YL,
    DOMElement: t1,
    Immutable: p1,
    ReactElement: E1,
    ReactTestComponent: _1,
    Error: C1,
  },
  Ch = {
    bold: ['1', '22'],
    dim: ['2', '22'],
    italic: ['3', '23'],
    underline: ['4', '24'],
    inverse: ['7', '27'],
    hidden: ['8', '28'],
    strike: ['9', '29'],
    black: ['30', '39'],
    red: ['31', '39'],
    green: ['32', '39'],
    yellow: ['33', '39'],
    blue: ['34', '39'],
    magenta: ['35', '39'],
    cyan: ['36', '39'],
    white: ['37', '39'],
    brightblack: ['30;1', '39'],
    brightred: ['31;1', '39'],
    brightgreen: ['32;1', '39'],
    brightyellow: ['33;1', '39'],
    brightblue: ['34;1', '39'],
    brightmagenta: ['35;1', '39'],
    brightcyan: ['36;1', '39'],
    brightwhite: ['37;1', '39'],
    grey: ['90', '39'],
  },
  x1 = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red',
  },
  no = '';
function KT(e, t) {
  const r = Ch[x1[t]] || Ch[t] || '';
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
o(KT, 'colorise');
function YT(
  {
    showHidden: e = !1,
    depth: t = 2,
    colors: r = !1,
    customInspect: n = !0,
    showProxy: i = !1,
    maxArrayLength: s = 1 / 0,
    breakLength: a = 1 / 0,
    seen: c = [],
    truncate: d = 1 / 0,
    stylize: u = String,
  } = {},
  p,
) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!i,
    maxArrayLength: Number(s),
    breakLength: Number(a),
    truncate: Number(d),
    seen: c,
    inspect: p,
    stylize: u,
  };
  return (f.colors && (f.stylize = KT), f);
}
o(YT, 'normaliseOptions');
function XT(e) {
  return e >= '\uD800' && e <= '\uDBFF';
}
o(XT, 'isHighSurrogate');
function Pr(e, t, r = no) {
  e = String(e);
  const n = r.length,
    i = e.length;
  if (n > t && i > n) return r;
  if (i > t && i > n) {
    let s = t - n;
    return (s > 0 && XT(e[s - 1]) && (s = s - 1), `${e.slice(0, s)}${r}`);
  }
  return e;
}
o(Pr, 'truncate');
function Lt(e, t, r, n = ', ') {
  r = r || t.inspect;
  const i = e.length;
  if (i === 0) return '';
  const s = t.truncate;
  let a = '',
    c = '',
    d = '';
  for (let u = 0; u < i; u += 1) {
    const p = u + 1 === e.length,
      f = u + 2 === e.length;
    d = `${no}(${e.length - u})`;
    const y = e[u];
    t.truncate = s - a.length - (p ? 0 : n.length);
    const h = c || r(y, t) + (p ? '' : n),
      g = a.length + h.length,
      T = g + d.length;
    if (
      (p && g > s && a.length + d.length <= s) ||
      (!p && !f && T > s) ||
      ((c = p ? '' : r(e[u + 1], t) + (f ? '' : n)), !p && f && T > s && g + c.length > s)
    )
      break;
    if (((a += h), !p && !f && g + c.length >= s)) {
      d = `${no}(${e.length - u - 1})`;
      break;
    }
    d = '';
  }
  return `${a}${d}`;
}
o(Lt, 'inspectList');
function QT(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
    ? e
    : JSON.stringify(e)
        .replace(/'/g, "\\'")
        .replace(/\\"/g, '"')
        .replace(/(^"|"$)/g, "'");
}
o(QT, 'quoteComplexKey');
function oo([e, t], r) {
  return (
    (r.truncate -= 2),
    typeof e == 'string' ? (e = QT(e)) : typeof e != 'number' && (e = `[${r.inspect(e, r)}]`),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e}: ${t}`
  );
}
o(oo, 'inspectProperty');
function ZT(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length) return '[]';
  t.truncate -= 4;
  const n = Lt(e, t);
  t.truncate -= n.length;
  let i = '';
  return (
    r.length &&
      (i = Lt(
        r.map((s) => [s, e[s]]),
        t,
        oo,
      )),
    `[ ${n}${i ? `, ${i}` : ''} ]`
  );
}
o(ZT, 'inspectArray');
var N1 = o(
  (e) =>
    typeof Buffer == 'function' && e instanceof Buffer
      ? 'Buffer'
      : e[Symbol.toStringTag]
        ? e[Symbol.toStringTag]
        : e.constructor.name,
  'getArrayName',
);
function Yt(e, t) {
  const r = N1(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length) return `${r}[]`;
  let i = '';
  for (let a = 0; a < e.length; a++) {
    const c = `${t.stylize(Pr(e[a], t.truncate), 'number')}${a === e.length - 1 ? '' : ', '}`;
    if (((t.truncate -= c.length), e[a] !== e.length && t.truncate <= 3)) {
      i += `${no}(${e.length - e[a] + 1})`;
      break;
    }
    i += c;
  }
  let s = '';
  return (
    n.length &&
      (s = Lt(
        n.map((a) => [a, e[a]]),
        t,
        oo,
      )),
    `${r}[ ${i}${s ? `, ${s}` : ''} ]`
  );
}
o(Yt, 'inspectTypedArray');
function ew(e, t) {
  const r = e.toJSON();
  if (r === null) return 'Invalid Date';
  const n = r.split('T'),
    i = n[0];
  return t.stylize(`${i}T${Pr(n[1], t.truncate - i.length - 1)}`, 'date');
}
o(ew, 'inspectDate');
function ou(e, t) {
  const r = e[Symbol.toStringTag] || 'Function',
    n = e.name;
  return n
    ? t.stylize(`[${r} ${Pr(n, t.truncate - 11)}]`, 'special')
    : t.stylize(`[${r}]`, 'special');
}
o(ou, 'inspectFunction');
function tw([e, t], r) {
  return (
    (r.truncate -= 4),
    (e = r.inspect(e, r)),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e} => ${t}`
  );
}
o(tw, 'inspectMapEntry');
function rw(e) {
  const t = [];
  return (
    e.forEach((r, n) => {
      t.push([n, r]);
    }),
    t
  );
}
o(rw, 'mapToEntries');
function nw(e, t) {
  return e.size === 0 ? 'Map{}' : ((t.truncate -= 7), `Map{ ${Lt(rw(e), t, tw)} }`);
}
o(nw, 'inspectMap');
var I1 = Number.isNaN || ((e) => e !== e);
function iu(e, t) {
  return I1(e)
    ? t.stylize('NaN', 'number')
    : e === 1 / 0
      ? t.stylize('Infinity', 'number')
      : e === -1 / 0
        ? t.stylize('-Infinity', 'number')
        : e === 0
          ? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
          : t.stylize(Pr(String(e), t.truncate), 'number');
}
o(iu, 'inspectNumber');
function su(e, t) {
  let r = Pr(e.toString(), t.truncate - 1);
  return (r !== no && (r += 'n'), t.stylize(r, 'bigint'));
}
o(su, 'inspectBigInt');
function ow(e, t) {
  const r = e.toString().split('/')[2],
    n = t.truncate - (2 + r.length),
    i = e.source;
  return t.stylize(`/${Pr(i, n)}/${r}`, 'regexp');
}
o(ow, 'inspectRegExp');
function iw(e) {
  const t = [];
  return (
    e.forEach((r) => {
      t.push(r);
    }),
    t
  );
}
o(iw, 'arrayFromSet');
function sw(e, t) {
  return e.size === 0 ? 'Set{}' : ((t.truncate -= 7), `Set{ ${Lt(iw(e), t)} }`);
}
o(sw, 'inspectSet');
var xh = new RegExp(
    "['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
    'g',
  ),
  M1 = { '\b': '\\b', '	': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '\\': '\\\\' },
  q1 = 16;
function aw(e) {
  return M1[e] || `\\u${`0000${e.charCodeAt(0).toString(q1)}`.slice(-4)}`;
}
o(aw, 'escape');
function au(e, t) {
  return (xh.test(e) && (e = e.replace(xh, aw)), t.stylize(`'${Pr(e, t.truncate - 2)}'`, 'string'));
}
o(au, 'inspectString');
function lu(e) {
  return 'description' in Symbol.prototype
    ? e.description
      ? `Symbol(${e.description})`
      : 'Symbol()'
    : e.toString();
}
o(lu, 'inspectSymbol');
var j1 = o(() => 'Promise{}', 'getPromiseValue'),
  k1 = j1;
function bi(e, t) {
  const r = Object.getOwnPropertyNames(e),
    n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0) return '{}';
  if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e))) return '[Circular]';
  t.seen.push(e);
  const i = Lt(
      r.map((c) => [c, e[c]]),
      t,
      oo,
    ),
    s = Lt(
      n.map((c) => [c, e[c]]),
      t,
      oo,
    );
  t.seen.pop();
  let a = '';
  return (i && s && (a = ', '), `{ ${i}${a}${s} }`);
}
o(bi, 'inspectObject');
var Sc = typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1;
function lw(e, t) {
  let r = '';
  return (
    Sc && Sc in e && (r = e[Sc]),
    (r = r || e.constructor.name),
    (!r || r === '_class') && (r = '<Anonymous Class>'),
    (t.truncate -= r.length),
    `${r}${bi(e, t)}`
  );
}
o(lw, 'inspectClass');
function cw(e, t) {
  return e.length === 0 ? 'Arguments[]' : ((t.truncate -= 13), `Arguments[ ${Lt(e, t)} ]`);
}
o(cw, 'inspectArguments');
var D1 = [
  'stack',
  'line',
  'column',
  'name',
  'message',
  'fileName',
  'lineNumber',
  'columnNumber',
  'number',
  'description',
  'cause',
];
function uw(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((a) => D1.indexOf(a) === -1),
    n = e.name;
  t.truncate -= n.length;
  let i = '';
  if (
    (typeof e.message == 'string' ? (i = Pr(e.message, t.truncate)) : r.unshift('message'),
    (i = i ? `: ${i}` : ''),
    (t.truncate -= i.length + 5),
    (t.seen = t.seen || []),
    t.seen.includes(e))
  )
    return '[Circular]';
  t.seen.push(e);
  const s = Lt(
    r.map((a) => [a, e[a]]),
    t,
    oo,
  );
  return `${n}${i}${s ? ` { ${s} }` : ''}`;
}
o(uw, 'inspectObject');
function dw([e, t], r) {
  return (
    (r.truncate -= 3),
    t
      ? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
      : `${r.stylize(String(e), 'yellow')}`
  );
}
o(dw, 'inspectAttribute');
function Hs(e, t) {
  return Lt(
    e,
    t,
    pw,
    `
`,
  );
}
o(Hs, 'inspectNodeCollection');
function pw(e, t) {
  switch (e.nodeType) {
    case 1:
      return jp(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
o(pw, 'inspectNode');
function jp(e, t) {
  const r = e.getAttributeNames(),
    n = e.tagName.toLowerCase(),
    i = t.stylize(`<${n}`, 'special'),
    s = t.stylize('>', 'special'),
    a = t.stylize(`</${n}>`, 'special');
  t.truncate -= n.length * 2 + 5;
  let c = '';
  (r.length > 0 &&
    ((c += ' '),
    (c += Lt(
      r.map((p) => [p, e.getAttribute(p)]),
      t,
      dw,
      ' ',
    ))),
    (t.truncate -= c.length));
  const d = t.truncate;
  let u = Hs(e.children, t);
  return (u && u.length > d && (u = `${no}(${e.children.length})`), `${i}${c}${s}${u}${a}`);
}
o(jp, 'inspectHTML');
var L1 = typeof Symbol == 'function' && typeof Symbol.for == 'function',
  _c = L1 ? Symbol.for('chai/inspect') : '@@chai/inspect',
  Rc = Symbol.for('nodejs.util.inspect.custom'),
  Nh = new WeakMap(),
  Ih = {},
  Mh = {
    undefined: o((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
    null: o((e, t) => t.stylize('null', 'null'), 'null'),
    boolean: o((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
    Boolean: o((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
    number: iu,
    Number: iu,
    bigint: su,
    BigInt: su,
    string: au,
    String: au,
    function: ou,
    Function: ou,
    symbol: lu,
    Symbol: lu,
    Array: ZT,
    Date: ew,
    Map: nw,
    Set: sw,
    RegExp: ow,
    Promise: k1,
    WeakSet: o((e, t) => t.stylize('WeakSet{}', 'special'), 'WeakSet'),
    WeakMap: o((e, t) => t.stylize('WeakMap{}', 'special'), 'WeakMap'),
    Arguments: cw,
    Int8Array: Yt,
    Uint8Array: Yt,
    Uint8ClampedArray: Yt,
    Int16Array: Yt,
    Uint16Array: Yt,
    Int32Array: Yt,
    Uint32Array: Yt,
    Float32Array: Yt,
    Float64Array: Yt,
    Generator: o(() => '', 'Generator'),
    DataView: o(() => '', 'DataView'),
    ArrayBuffer: o(() => '', 'ArrayBuffer'),
    Error: uw,
    HTMLCollection: Hs,
    NodeList: Hs,
  },
  F1 = o(
    (e, t, r, n) =>
      _c in e && typeof e[_c] == 'function'
        ? e[_c](t)
        : Rc in e && typeof e[Rc] == 'function'
          ? e[Rc](t.depth, t, n)
          : 'inspect' in e && typeof e.inspect == 'function'
            ? e.inspect(t.depth, t)
            : 'constructor' in e && Nh.has(e.constructor)
              ? Nh.get(e.constructor)(e, t)
              : Ih[r]
                ? Ih[r](e, t)
                : '',
    'inspectCustom',
  ),
  B1 = Object.prototype.toString;
function vi(e, t = {}) {
  const r = YT(t, vi),
    { customInspect: n } = r;
  let i = e === null ? 'null' : typeof e;
  if ((i === 'object' && (i = B1.call(e).slice(8, -1)), i in Mh)) return Mh[i](e, r);
  if (n && e) {
    const a = F1(e, r, i, vi);
    if (a) return typeof a == 'string' ? a : vi(a, r);
  }
  const s = e ? Object.getPrototypeOf(e) : !1;
  return s === Object.prototype || s === null
    ? bi(e, r)
    : e && typeof HTMLElement == 'function' && e instanceof HTMLElement
      ? jp(e, r)
      : 'constructor' in e
        ? e.constructor !== Object
          ? lw(e, r)
          : bi(e, r)
        : e === Object(e)
          ? bi(e, r)
          : r.stylize(String(e), i);
}
o(vi, 'inspect');
var {
    AsymmetricMatcher: J1,
    DOMCollection: $1,
    DOMElement: U1,
    Immutable: V1,
    ReactElement: H1,
    ReactTestComponent: G1,
  } = qp,
  qh = [G1, H1, U1, $1, V1, J1];
function bt(e, t = 10, { maxLength: r, ...n } = {}) {
  const i = r ?? 1e4;
  let s;
  try {
    s = Ht(e, { maxDepth: t, escapeString: !1, plugins: qh, ...n });
  } catch {
    s = Ht(e, { callToJSON: !1, maxDepth: t, escapeString: !1, plugins: qh, ...n });
  }
  return s.length >= i && t > 1
    ? bt(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), { maxLength: r, ...n })
    : s;
}
o(bt, 'stringify');
var z1 = /%[sdjifoOc%]/g;
function fw(...e) {
  if (typeof e[0] != 'string') {
    const s = [];
    for (let a = 0; a < e.length; a++) s.push(Ln(e[a], { depth: 0, colors: !1 }));
    return s.join(' ');
  }
  const t = e.length;
  let r = 1;
  const n = e[0];
  let i = String(n).replace(z1, (s) => {
    if (s === '%%') return '%';
    if (r >= t) return s;
    switch (s) {
      case '%s': {
        const a = e[r++];
        return typeof a == 'bigint'
          ? `${a.toString()}n`
          : typeof a == 'number' && a === 0 && 1 / a < 0
            ? '-0'
            : typeof a == 'object' && a !== null
              ? typeof a.toString == 'function' && a.toString !== Object.prototype.toString
                ? a.toString()
                : Ln(a, { depth: 0, colors: !1 })
              : String(a);
      }
      case '%d': {
        const a = e[r++];
        return typeof a == 'bigint' ? `${a.toString()}n` : Number(a).toString();
      }
      case '%i': {
        const a = e[r++];
        return typeof a == 'bigint' ? `${a.toString()}n` : Number.parseInt(String(a)).toString();
      }
      case '%f':
        return Number.parseFloat(String(e[r++])).toString();
      case '%o':
        return Ln(e[r++], { showHidden: !0, showProxy: !0 });
      case '%O':
        return Ln(e[r++]);
      case '%c':
        return (r++, '');
      case '%j':
        try {
          return JSON.stringify(e[r++]);
        } catch (a) {
          const c = a.message;
          if (
            c.includes('circular structure') ||
            c.includes('cyclic structures') ||
            c.includes('cyclic object')
          )
            return '[Circular]';
          throw a;
        }
      default:
        return s;
    }
  });
  for (let s = e[r]; r < t; s = e[++r])
    s === null || typeof s != 'object' ? (i += ` ${s}`) : (i += ` ${Ln(s)}`);
  return i;
}
o(fw, 'format');
function Ln(e, t = {}) {
  return (t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), vi(e, t));
}
o(Ln, 'inspect');
function kp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
o(kp, 'getDefaultExportFromCjs');
function Xt(e, t, r) {
  const n = typeof e;
  if (!r.includes(n)) throw new TypeError(`${t} value must be ${r.join(' or ')}, received "${n}"`);
}
o(Xt, 'assertTypes');
function Ei(e) {
  return e != null && typeof e == 'object' && !Array.isArray(e);
}
o(Ei, 'isObject');
function mw(e) {
  return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
o(mw, 'isFinalObj');
function Mi(e) {
  return Object.prototype.toString.apply(e).slice(8, -1);
}
o(Mi, 'getType');
function yw(e, t) {
  const r = typeof t == 'function' ? t : (n) => t.add(n);
  (Object.getOwnPropertyNames(e).forEach(r), Object.getOwnPropertySymbols(e).forEach(r));
}
o(yw, 'collectOwnProperties');
function Dp(e) {
  const t = new Set();
  return mw(e) ? [] : (yw(e, t), Array.from(t));
}
o(Dp, 'getOwnProperties');
var hw = { forceWritable: !1 };
function cu(e, t = hw) {
  return Gs(e, new WeakMap(), t);
}
o(cu, 'deepClone');
function Gs(e, t, r = hw) {
  let n, i;
  if (t.has(e)) return t.get(e);
  if (Array.isArray(e)) {
    for (i = Array.from({ length: (n = e.length) }), t.set(e, i); n--; ) i[n] = Gs(e[n], t, r);
    return i;
  }
  if (Object.prototype.toString.call(e) === '[object Object]') {
    ((i = Object.create(Object.getPrototypeOf(e))), t.set(e, i));
    const s = Dp(e);
    for (const a of s) {
      const c = Object.getOwnPropertyDescriptor(e, a);
      if (!c) continue;
      const d = Gs(e[a], t, r);
      r.forceWritable
        ? Object.defineProperty(i, a, {
            enumerable: c.enumerable,
            configurable: !0,
            writable: !0,
            value: d,
          })
        : 'get' in c
          ? Object.defineProperty(i, a, {
              ...c,
              get() {
                return d;
              },
            })
          : Object.defineProperty(i, a, { ...c, value: d });
    }
    return i;
  }
  return e;
}
o(Gs, 'clone');
function gw() {}
o(gw, 'noop');
var ht = -1,
  at = 1,
  $e = 0,
  bw = class {
    constructor(t, r) {
      Le(this, 0);
      Le(this, 1);
      ((this[0] = t), (this[1] = r));
    }
  };
o(bw, 'Diff');
var Be = bw;
function vw(e, t) {
  if (!e || !t || e.charAt(0) !== t.charAt(0)) return 0;
  let r = 0,
    n = Math.min(e.length, t.length),
    i = n,
    s = 0;
  for (; r < i; )
    (e.substring(s, i) === t.substring(s, i) ? ((r = i), (s = r)) : (n = i),
      (i = Math.floor((n - r) / 2 + r)));
  return i;
}
o(vw, 'diff_commonPrefix');
function Lp(e, t) {
  if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1)) return 0;
  let r = 0,
    n = Math.min(e.length, t.length),
    i = n,
    s = 0;
  for (; r < i; )
    (e.substring(e.length - i, e.length - s) === t.substring(t.length - i, t.length - s)
      ? ((r = i), (s = r))
      : (n = i),
      (i = Math.floor((n - r) / 2 + r)));
  return i;
}
o(Lp, 'diff_commonSuffix');
function uu(e, t) {
  const r = e.length,
    n = t.length;
  if (r === 0 || n === 0) return 0;
  r > n ? (e = e.substring(r - n)) : r < n && (t = t.substring(0, r));
  const i = Math.min(r, n);
  if (e === t) return i;
  let s = 0,
    a = 1;
  for (;;) {
    const c = e.substring(i - a),
      d = t.indexOf(c);
    if (d === -1) return s;
    ((a += d), (d === 0 || e.substring(i - a) === t.substring(0, a)) && ((s = a), a++));
  }
}
o(uu, 'diff_commonOverlap_');
function Ew(e) {
  let t = !1;
  const r = [];
  let n = 0,
    i = null,
    s = 0,
    a = 0,
    c = 0,
    d = 0,
    u = 0;
  for (; s < e.length; )
    (e[s][0] === $e
      ? ((r[n++] = s), (a = d), (c = u), (d = 0), (u = 0), (i = e[s][1]))
      : (e[s][0] === at ? (d += e[s][1].length) : (u += e[s][1].length),
        i &&
          i.length <= Math.max(a, c) &&
          i.length <= Math.max(d, u) &&
          (e.splice(r[n - 1], 0, new Be(ht, i)),
          (e[r[n - 1] + 1][0] = at),
          n--,
          n--,
          (s = n > 0 ? r[n - 1] : -1),
          (a = 0),
          (c = 0),
          (d = 0),
          (u = 0),
          (i = null),
          (t = !0))),
      s++);
  for (t && Fp(e), Tw(e), s = 1; s < e.length; ) {
    if (e[s - 1][0] === ht && e[s][0] === at) {
      const p = e[s - 1][1],
        f = e[s][1],
        y = uu(p, f),
        h = uu(f, p);
      (y >= h
        ? (y >= p.length / 2 || y >= f.length / 2) &&
          (e.splice(s, 0, new Be($e, f.substring(0, y))),
          (e[s - 1][1] = p.substring(0, p.length - y)),
          (e[s + 1][1] = f.substring(y)),
          s++)
        : (h >= p.length / 2 || h >= f.length / 2) &&
          (e.splice(s, 0, new Be($e, p.substring(0, h))),
          (e[s - 1][0] = at),
          (e[s - 1][1] = f.substring(0, f.length - h)),
          (e[s + 1][0] = ht),
          (e[s + 1][1] = p.substring(h)),
          s++),
        s++);
    }
    s++;
  }
}
o(Ew, 'diff_cleanupSemantic');
var jh = /[^a-z0-9]/i,
  kh = /\s/,
  Dh = /[\r\n]/,
  W1 = /\n\r?\n$/,
  K1 = /^\r?\n\r?\n/;
function Tw(e) {
  let t = 1;
  for (; t < e.length - 1; ) {
    if (e[t - 1][0] === $e && e[t + 1][0] === $e) {
      let r = e[t - 1][1],
        n = e[t][1],
        i = e[t + 1][1];
      const s = Lp(r, n);
      if (s) {
        const p = n.substring(n.length - s);
        ((r = r.substring(0, r.length - s)), (n = p + n.substring(0, n.length - s)), (i = p + i));
      }
      let a = r,
        c = n,
        d = i,
        u = li(r, n) + li(n, i);
      for (; n.charAt(0) === i.charAt(0); ) {
        ((r += n.charAt(0)), (n = n.substring(1) + i.charAt(0)), (i = i.substring(1)));
        const p = li(r, n) + li(n, i);
        p >= u && ((u = p), (a = r), (c = n), (d = i));
      }
      e[t - 1][1] !== a &&
        (a ? (e[t - 1][1] = a) : (e.splice(t - 1, 1), t--),
        (e[t][1] = c),
        d ? (e[t + 1][1] = d) : (e.splice(t + 1, 1), t--));
    }
    t++;
  }
}
o(Tw, 'diff_cleanupSemanticLossless');
function Fp(e) {
  e.push(new Be($e, ''));
  let t = 0,
    r = 0,
    n = 0,
    i = '',
    s = '',
    a;
  for (; t < e.length; )
    switch (e[t][0]) {
      case at:
        (n++, (s += e[t][1]), t++);
        break;
      case ht:
        (r++, (i += e[t][1]), t++);
        break;
      case $e:
        (r + n > 1
          ? (r !== 0 &&
              n !== 0 &&
              ((a = vw(s, i)),
              a !== 0 &&
                (t - r - n > 0 && e[t - r - n - 1][0] === $e
                  ? (e[t - r - n - 1][1] += s.substring(0, a))
                  : (e.splice(0, 0, new Be($e, s.substring(0, a))), t++),
                (s = s.substring(a)),
                (i = i.substring(a))),
              (a = Lp(s, i)),
              a !== 0 &&
                ((e[t][1] = s.substring(s.length - a) + e[t][1]),
                (s = s.substring(0, s.length - a)),
                (i = i.substring(0, i.length - a)))),
            (t -= r + n),
            e.splice(t, r + n),
            i.length && (e.splice(t, 0, new Be(ht, i)), t++),
            s.length && (e.splice(t, 0, new Be(at, s)), t++),
            t++)
          : t !== 0 && e[t - 1][0] === $e
            ? ((e[t - 1][1] += e[t][1]), e.splice(t, 1))
            : t++,
          (n = 0),
          (r = 0),
          (i = ''),
          (s = ''));
        break;
    }
  e[e.length - 1][1] === '' && e.pop();
  let c = !1;
  for (t = 1; t < e.length - 1; )
    (e[t - 1][0] === $e &&
      e[t + 1][0] === $e &&
      (e[t][1].substring(e[t][1].length - e[t - 1][1].length) === e[t - 1][1]
        ? ((e[t][1] = e[t - 1][1] + e[t][1].substring(0, e[t][1].length - e[t - 1][1].length)),
          (e[t + 1][1] = e[t - 1][1] + e[t + 1][1]),
          e.splice(t - 1, 1),
          (c = !0))
        : e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] &&
          ((e[t - 1][1] += e[t + 1][1]),
          (e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1]),
          e.splice(t + 1, 1),
          (c = !0))),
      t++);
  c && Fp(e);
}
o(Fp, 'diff_cleanupMerge');
function li(e, t) {
  if (!e || !t) return 6;
  const r = e.charAt(e.length - 1),
    n = t.charAt(0),
    i = r.match(jh),
    s = n.match(jh),
    a = i && r.match(kh),
    c = s && n.match(kh),
    d = a && r.match(Dh),
    u = c && n.match(Dh),
    p = d && e.match(W1),
    f = u && t.match(K1);
  return p || f ? 5 : d || u ? 4 : i && !a && c ? 3 : a || c ? 2 : i || s ? 1 : 0;
}
o(li, 'diff_cleanupSemanticScore_');
var ww = 'Compared values have no visual difference.',
  Y1 =
    'Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.',
  Ts = {},
  Lh;
function Sw() {
  if (Lh) return Ts;
  ((Lh = 1), Object.defineProperty(Ts, '__esModule', { value: !0 }), (Ts.default = y));
  const e = 'diff-sequences',
    t = 0,
    r = o((h, g, T, E, v) => {
      let S = 0;
      for (; h < g && T < E && v(h, T); ) ((h += 1), (T += 1), (S += 1));
      return S;
    }, 'countCommonItemsF'),
    n = o((h, g, T, E, v) => {
      let S = 0;
      for (; h <= g && T <= E && v(g, E); ) ((g -= 1), (E -= 1), (S += 1));
      return S;
    }, 'countCommonItemsR'),
    i = o((h, g, T, E, v, S, A) => {
      let N = 0,
        j = -h,
        C = S[N],
        R = C;
      S[N] += r(C + 1, g, E + C - j + 1, T, v);
      const w = h < A ? h : A;
      for (N += 1, j += 2; N <= w; N += 1, j += 2) {
        if (N !== h && R < S[N]) C = S[N];
        else if (((C = R + 1), g <= C)) return N - 1;
        ((R = S[N]), (S[N] = C + r(C + 1, g, E + C - j + 1, T, v)));
      }
      return A;
    }, 'extendPathsF'),
    s = o((h, g, T, E, v, S, A) => {
      let N = 0,
        j = h,
        C = S[N],
        R = C;
      S[N] -= n(g, C - 1, T, E + C - j - 1, v);
      const w = h < A ? h : A;
      for (N += 1, j -= 2; N <= w; N += 1, j -= 2) {
        if (N !== h && S[N] < R) C = S[N];
        else if (((C = R - 1), C < g)) return N - 1;
        ((R = S[N]), (S[N] = C - n(g, C - 1, T, E + C - j - 1, v)));
      }
      return A;
    }, 'extendPathsR'),
    a = o((h, g, T, E, v, S, A, N, j, C, R) => {
      const w = E - g,
        _ = T - g,
        I = v - E - _,
        V = -I - (h - 1),
        H = -I + (h - 1);
      let P = t;
      const L = h < N ? h : N;
      for (let B = 0, D = -h; B <= L; B += 1, D += 2) {
        const K = B === 0 || (B !== h && P < A[B]),
          X = K ? A[B] : P,
          ie = K ? X : X + 1,
          se = w + ie - D,
          W = r(ie + 1, T, se + 1, v, S),
          ae = ie + W;
        if (((P = A[B]), (A[B] = ae), V <= D && D <= H)) {
          const be = (h - 1 - (D + I)) / 2;
          if (be <= C && j[be] - 1 <= ae) {
            const ue = w + X - (K ? D + 1 : D - 1),
              ee = n(g, X, E, ue, S),
              Ae = X - ee,
              Oe = ue - ee,
              He = Ae + 1,
              Ke = Oe + 1;
            ((R.nChangePreceding = h - 1),
              h - 1 === He + Ke - g - E
                ? ((R.aEndPreceding = g), (R.bEndPreceding = E))
                : ((R.aEndPreceding = He), (R.bEndPreceding = Ke)),
              (R.nCommonPreceding = ee),
              ee !== 0 && ((R.aCommonPreceding = He), (R.bCommonPreceding = Ke)),
              (R.nCommonFollowing = W),
              W !== 0 && ((R.aCommonFollowing = ie + 1), (R.bCommonFollowing = se + 1)));
            const $ = ae + 1,
              Q = se + W + 1;
            return (
              (R.nChangeFollowing = h - 1),
              h - 1 === T + v - $ - Q
                ? ((R.aStartFollowing = T), (R.bStartFollowing = v))
                : ((R.aStartFollowing = $), (R.bStartFollowing = Q)),
              !0
            );
          }
        }
      }
      return !1;
    }, 'extendOverlappablePathsF'),
    c = o((h, g, T, E, v, S, A, N, j, C, R) => {
      const w = v - T,
        _ = T - g,
        I = v - E - _,
        V = I - h,
        H = I + h;
      let P = t;
      const L = h < C ? h : C;
      for (let B = 0, D = h; B <= L; B += 1, D -= 2) {
        const K = B === 0 || (B !== h && j[B] < P),
          X = K ? j[B] : P,
          ie = K ? X : X - 1,
          se = w + ie - D,
          W = n(g, ie - 1, E, se - 1, S),
          ae = ie - W;
        if (((P = j[B]), (j[B] = ae), V <= D && D <= H)) {
          const be = (h + (D - I)) / 2;
          if (be <= N && ae - 1 <= A[be]) {
            const ue = se - W;
            if (
              ((R.nChangePreceding = h),
              h === ae + ue - g - E
                ? ((R.aEndPreceding = g), (R.bEndPreceding = E))
                : ((R.aEndPreceding = ae), (R.bEndPreceding = ue)),
              (R.nCommonPreceding = W),
              W !== 0 && ((R.aCommonPreceding = ae), (R.bCommonPreceding = ue)),
              (R.nChangeFollowing = h - 1),
              h === 1)
            )
              ((R.nCommonFollowing = 0), (R.aStartFollowing = T), (R.bStartFollowing = v));
            else {
              const ee = w + X - (K ? D - 1 : D + 1),
                Ae = r(X, T, ee, v, S);
              ((R.nCommonFollowing = Ae),
                Ae !== 0 && ((R.aCommonFollowing = X), (R.bCommonFollowing = ee)));
              const Oe = X + Ae,
                He = ee + Ae;
              h - 1 === T + v - Oe - He
                ? ((R.aStartFollowing = T), (R.bStartFollowing = v))
                : ((R.aStartFollowing = Oe), (R.bStartFollowing = He));
            }
            return !0;
          }
        }
      }
      return !1;
    }, 'extendOverlappablePathsR'),
    d = o((h, g, T, E, v, S, A, N, j) => {
      const C = E - g,
        R = v - T,
        w = T - g,
        _ = v - E,
        k = _ - w;
      let I = w,
        V = w;
      if (((A[0] = g - 1), (N[0] = T), k % 2 === 0)) {
        const H = (h || k) / 2,
          P = (w + _) / 2;
        for (let L = 1; L <= P; L += 1)
          if (((I = i(L, T, v, C, S, A, I)), L < H)) V = s(L, g, E, R, S, N, V);
          else if (c(L, g, T, E, v, S, A, I, N, V, j)) return;
      } else {
        const H = ((h || k) + 1) / 2,
          P = (w + _ + 1) / 2;
        let L = 1;
        for (I = i(L, T, v, C, S, A, I), L += 1; L <= P; L += 1)
          if (((V = s(L - 1, g, E, R, S, N, V)), L < H)) I = i(L, T, v, C, S, A, I);
          else if (a(L, g, T, E, v, S, A, I, N, V, j)) return;
      }
      throw new Error(`${e}: no overlap aStart=${g} aEnd=${T} bStart=${E} bEnd=${v}`);
    }, 'divide'),
    u = o((h, g, T, E, v, S, A, N, j, C) => {
      if (v - E < T - g) {
        if (((S = !S), S && A.length === 1)) {
          const { foundSubsequence: ae, isCommon: be } = A[0];
          A[1] = {
            foundSubsequence: o((ue, ee, Ae) => {
              ae(ue, Ae, ee);
            }, 'foundSubsequence'),
            isCommon: o((ue, ee) => be(ee, ue), 'isCommon'),
          };
        }
        const se = g,
          W = T;
        ((g = E), (T = v), (E = se), (v = W));
      }
      const { foundSubsequence: R, isCommon: w } = A[S ? 1 : 0];
      d(h, g, T, E, v, w, N, j, C);
      const {
        nChangePreceding: _,
        aEndPreceding: k,
        bEndPreceding: I,
        nCommonPreceding: V,
        aCommonPreceding: H,
        bCommonPreceding: P,
        nCommonFollowing: L,
        aCommonFollowing: B,
        bCommonFollowing: D,
        nChangeFollowing: K,
        aStartFollowing: X,
        bStartFollowing: ie,
      } = C;
      (g < k && E < I && u(_, g, k, E, I, S, A, N, j, C),
        V !== 0 && R(V, H, P),
        L !== 0 && R(L, B, D),
        X < T && ie < v && u(K, X, T, ie, v, S, A, N, j, C));
    }, 'findSubsequences'),
    p = o((h, g) => {
      if (typeof g != 'number')
        throw new TypeError(`${e}: ${h} typeof ${typeof g} is not a number`);
      if (!Number.isSafeInteger(g))
        throw new RangeError(`${e}: ${h} value ${g} is not a safe integer`);
      if (g < 0) throw new RangeError(`${e}: ${h} value ${g} is a negative integer`);
    }, 'validateLength'),
    f = o((h, g) => {
      const T = typeof g;
      if (T !== 'function') throw new TypeError(`${e}: ${h} typeof ${T} is not a function`);
    }, 'validateCallback');
  function y(h, g, T, E) {
    (p('aLength', h), p('bLength', g), f('isCommon', T), f('foundSubsequence', E));
    const v = r(0, h, 0, g, T);
    if ((v !== 0 && E(v, 0, 0), h !== v || g !== v)) {
      const S = v,
        A = v,
        N = n(S, h - 1, A, g - 1, T),
        j = h - N,
        C = g - N,
        R = v + N;
      (h !== R &&
        g !== R &&
        u(0, S, j, A, C, !1, [{ foundSubsequence: E, isCommon: T }], [t], [t], {
          aCommonFollowing: t,
          aCommonPreceding: t,
          aEndPreceding: t,
          aStartFollowing: t,
          bCommonFollowing: t,
          bCommonPreceding: t,
          bEndPreceding: t,
          bStartFollowing: t,
          nChangeFollowing: t,
          nChangePreceding: t,
          nCommonFollowing: t,
          nCommonPreceding: t,
        }),
        N !== 0 && E(N, j, C));
    }
  }
  return (o(y, 'diffSequence'), Ts);
}
o(Sw, 'requireBuild');
var X1 = Sw(),
  _w = kp(X1);
function Rw(e, t) {
  return e.replace(/\s+$/, (r) => t(r));
}
o(Rw, 'formatTrailingSpaces');
function Za(e, t, r, n, i, s) {
  return e.length !== 0
    ? r(`${n} ${Rw(e, i)}`)
    : n !== ' '
      ? r(n)
      : t && s.length !== 0
        ? r(`${n} ${s}`)
        : '';
}
o(Za, 'printDiffLine');
function Bp(
  e,
  t,
  { aColor: r, aIndicator: n, changeLineTrailingSpaceColor: i, emptyFirstOrLastLinePlaceholder: s },
) {
  return Za(e, t, r, n, i, s);
}
o(Bp, 'printDeleteLine');
function Jp(
  e,
  t,
  { bColor: r, bIndicator: n, changeLineTrailingSpaceColor: i, emptyFirstOrLastLinePlaceholder: s },
) {
  return Za(e, t, r, n, i, s);
}
o(Jp, 'printInsertLine');
function $p(
  e,
  t,
  {
    commonColor: r,
    commonIndicator: n,
    commonLineTrailingSpaceColor: i,
    emptyFirstOrLastLinePlaceholder: s,
  },
) {
  return Za(e, t, r, n, i, s);
}
o($p, 'printCommonLine');
function du(e, t, r, n, { patchColor: i }) {
  return i(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`);
}
o(du, 'createPatchMark');
function Pw(e, t) {
  const r = e.length,
    n = t.contextLines,
    i = n + n;
  let s = r,
    a = !1,
    c = 0,
    d = 0;
  for (; d !== r; ) {
    const N = d;
    for (; d !== r && e[d][0] === $e; ) d += 1;
    if (N !== d)
      if (N === 0) d > n && ((s -= d - n), (a = !0));
      else if (d === r) {
        const j = d - N;
        j > n && ((s -= j - n), (a = !0));
      } else {
        const j = d - N;
        j > i && ((s -= j - i), (c += 1));
      }
    for (; d !== r && e[d][0] !== $e; ) d += 1;
  }
  const u = c !== 0 || a;
  c !== 0 ? (s += c + 1) : a && (s += 1);
  const p = s - 1,
    f = [];
  let y = 0;
  u && f.push('');
  let h = 0,
    g = 0,
    T = 0,
    E = 0;
  const v = o((N) => {
      const j = f.length;
      (f.push($p(N, j === 0 || j === p, t)), (T += 1), (E += 1));
    }, 'pushCommonLine'),
    S = o((N) => {
      const j = f.length;
      (f.push(Bp(N, j === 0 || j === p, t)), (T += 1));
    }, 'pushDeleteLine'),
    A = o((N) => {
      const j = f.length;
      (f.push(Jp(N, j === 0 || j === p, t)), (E += 1));
    }, 'pushInsertLine');
  for (d = 0; d !== r; ) {
    let N = d;
    for (; d !== r && e[d][0] === $e; ) d += 1;
    if (N !== d)
      if (N === 0) {
        d > n && ((N = d - n), (h = N), (g = N), (T = h), (E = g));
        for (let j = N; j !== d; j += 1) v(e[j][1]);
      } else if (d === r) {
        const j = d - N > n ? N + n : d;
        for (let C = N; C !== j; C += 1) v(e[C][1]);
      } else {
        const j = d - N;
        if (j > i) {
          const C = N + n;
          for (let w = N; w !== C; w += 1) v(e[w][1]);
          ((f[y] = du(h, T, g, E, t)), (y = f.length), f.push(''));
          const R = j - i;
          ((h = T + R), (g = E + R), (T = h), (E = g));
          for (let w = d - n; w !== d; w += 1) v(e[w][1]);
        } else for (let C = N; C !== d; C += 1) v(e[C][1]);
      }
    for (; d !== r && e[d][0] === ht; ) (S(e[d][1]), (d += 1));
    for (; d !== r && e[d][0] === at; ) (A(e[d][1]), (d += 1));
  }
  return (
    u && (f[y] = du(h, T, g, E, t)),
    f.join(`
`)
  );
}
o(Pw, 'joinAlignedDiffsNoExpand');
function Aw(e, t) {
  return e.map((r, n, i) => {
    const s = r[1],
      a = n === 0 || n === i.length - 1;
    switch (r[0]) {
      case ht:
        return Bp(s, a, t);
      case at:
        return Jp(s, a, t);
      default:
        return $p(s, a, t);
    }
  }).join(`
`);
}
o(Aw, 'joinAlignedDiffsExpand');
var Pc = o((e) => e, 'noColor'),
  Ow = 5,
  Q1 = 0;
function Cw() {
  return {
    aAnnotation: 'Expected',
    aColor: Ue.green,
    aIndicator: '-',
    bAnnotation: 'Received',
    bColor: Ue.red,
    bIndicator: '+',
    changeColor: Ue.inverse,
    changeLineTrailingSpaceColor: Pc,
    commonColor: Ue.dim,
    commonIndicator: ' ',
    commonLineTrailingSpaceColor: Pc,
    compareKeys: void 0,
    contextLines: Ow,
    emptyFirstOrLastLinePlaceholder: '',
    expand: !1,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: Ue.yellow,
    printBasicPrototype: !1,
    truncateThreshold: Q1,
    truncateAnnotation: '... Diff result is truncated',
    truncateAnnotationColor: Pc,
  };
}
o(Cw, 'getDefaultOptions');
function xw(e) {
  return e && typeof e == 'function' ? e : void 0;
}
o(xw, 'getCompareKeys');
function Nw(e) {
  return typeof e == 'number' && Number.isSafeInteger(e) && e >= 0 ? e : Ow;
}
o(Nw, 'getContextLines');
function Wr(e = {}) {
  return { ...Cw(), ...e, compareKeys: xw(e.compareKeys), contextLines: Nw(e.contextLines) };
}
o(Wr, 'normalizeDiffOptions');
function an(e) {
  return e.length === 1 && e[0].length === 0;
}
o(an, 'isEmptyString');
function Iw(e) {
  let t = 0,
    r = 0;
  return (
    e.forEach((n) => {
      switch (n[0]) {
        case ht:
          t += 1;
          break;
        case at:
          r += 1;
          break;
      }
    }),
    { a: t, b: r }
  );
}
o(Iw, 'countChanges');
function Mw(
  {
    aAnnotation: e,
    aColor: t,
    aIndicator: r,
    bAnnotation: n,
    bColor: i,
    bIndicator: s,
    includeChangeCounts: a,
    omitAnnotationLines: c,
  },
  d,
) {
  if (c) return '';
  let u = '',
    p = '';
  if (a) {
    const h = String(d.a),
      g = String(d.b),
      T = n.length - e.length,
      E = ' '.repeat(Math.max(0, T)),
      v = ' '.repeat(Math.max(0, -T)),
      S = g.length - h.length,
      A = ' '.repeat(Math.max(0, S)),
      N = ' '.repeat(Math.max(0, -S));
    ((u = `${E}  ${r} ${A}${h}`), (p = `${v}  ${s} ${N}${g}`));
  }
  const f = `${r} ${e}${u}`,
    y = `${s} ${n}${p}`;
  return `${t(f)}
${i(y)}

`;
}
o(Mw, 'printAnnotation');
function el(e, t, r) {
  return (
    Mw(r, Iw(e)) +
    (r.expand ? Aw(e, r) : Pw(e, r)) +
    (t
      ? r.truncateAnnotationColor(`
${r.truncateAnnotation}`)
      : '')
  );
}
o(el, 'printDiffLines');
function ts(e, t, r) {
  const n = Wr(r),
    [i, s] = Up(an(e) ? [] : e, an(t) ? [] : t, n);
  return el(i, s, n);
}
o(ts, 'diffLinesUnified');
function qw(e, t, r, n, i) {
  if (
    (an(e) && an(r) && ((e = []), (r = [])),
    an(t) && an(n) && ((t = []), (n = [])),
    e.length !== r.length || t.length !== n.length)
  )
    return ts(e, t, i);
  const [s, a] = Up(r, n, i);
  let c = 0,
    d = 0;
  return (
    s.forEach((u) => {
      switch (u[0]) {
        case ht:
          ((u[1] = e[c]), (c += 1));
          break;
        case at:
          ((u[1] = t[d]), (d += 1));
          break;
        default:
          ((u[1] = t[d]), (c += 1), (d += 1));
      }
    }),
    el(s, a, Wr(i))
  );
}
o(qw, 'diffLinesUnified2');
function Up(e, t, r) {
  const n = r?.truncateThreshold ?? !1,
    i = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0),
    s = n ? Math.min(e.length, i) : e.length,
    a = n ? Math.min(t.length, i) : t.length,
    c = s !== e.length || a !== t.length,
    d = o((h, g) => e[h] === t[g], 'isCommon'),
    u = [];
  let p = 0,
    f = 0;
  for (
    _w(
      s,
      a,
      d,
      o((h, g, T) => {
        for (; p !== g; p += 1) u.push(new Be(ht, e[p]));
        for (; f !== T; f += 1) u.push(new Be(at, t[f]));
        for (; h !== 0; h -= 1, p += 1, f += 1) u.push(new Be($e, t[f]));
      }, 'foundSubsequence'),
    );
    p !== s;
    p += 1
  )
    u.push(new Be(ht, e[p]));
  for (; f !== a; f += 1) u.push(new Be(at, t[f]));
  return [u, c];
}
o(Up, 'diffLinesRaw');
function pu(e) {
  if (e === void 0) return 'undefined';
  if (e === null) return 'null';
  if (Array.isArray(e)) return 'array';
  if (typeof e == 'boolean') return 'boolean';
  if (typeof e == 'function') return 'function';
  if (typeof e == 'number') return 'number';
  if (typeof e == 'string') return 'string';
  if (typeof e == 'bigint') return 'bigint';
  if (typeof e == 'object') {
    if (e != null) {
      if (e.constructor === RegExp) return 'regexp';
      if (e.constructor === Map) return 'map';
      if (e.constructor === Set) return 'set';
      if (e.constructor === Date) return 'date';
    }
    return 'object';
  } else if (typeof e == 'symbol') return 'symbol';
  throw new Error(`value of unknown type: ${e}`);
}
o(pu, 'getType');
function fu(e) {
  return e.includes(`\r
`)
    ? `\r
`
    : `
`;
}
o(fu, 'getNewLineSymbol');
function jw(e, t, r) {
  const n = r?.truncateThreshold ?? !1,
    i = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0);
  let s = e.length,
    a = t.length;
  if (n) {
    const h = e.includes(`
`),
      g = t.includes(`
`),
      T = fu(e),
      E = fu(t),
      v = h
        ? `${e.split(T, i).join(T)}
`
        : e,
      S = g
        ? `${t.split(E, i).join(E)}
`
        : t;
    ((s = v.length), (a = S.length));
  }
  const c = s !== e.length || a !== t.length,
    d = o((h, g) => e[h] === t[g], 'isCommon');
  let u = 0,
    p = 0;
  const f = [];
  return (
    _w(
      s,
      a,
      d,
      o((h, g, T) => {
        (u !== g && f.push(new Be(ht, e.slice(u, g))),
          p !== T && f.push(new Be(at, t.slice(p, T))),
          (u = g + h),
          (p = T + h),
          f.push(new Be($e, t.slice(T, p))));
      }, 'foundSubsequence'),
    ),
    u !== s && f.push(new Be(ht, e.slice(u))),
    p !== a && f.push(new Be(at, t.slice(p))),
    [f, c]
  );
}
o(jw, 'diffStrings');
function kw(e, t, r) {
  return t.reduce(
    (n, i) => n + (i[0] === $e ? i[1] : i[0] === e && i[1].length !== 0 ? r(i[1]) : ''),
    '',
  );
}
o(kw, 'concatenateRelevantDiffs');
var Dw = class {
  constructor(t, r) {
    Le(this, 'op');
    Le(this, 'line');
    Le(this, 'lines');
    Le(this, 'changeColor');
    ((this.op = t), (this.line = []), (this.lines = []), (this.changeColor = r));
  }
  pushSubstring(t) {
    this.pushDiff(new Be(this.op, t));
  }
  pushLine() {
    (this.lines.push(
      this.line.length !== 1
        ? new Be(this.op, kw(this.op, this.line, this.changeColor))
        : this.line[0][0] === this.op
          ? this.line[0]
          : new Be(this.op, this.line[0][1]),
    ),
      (this.line.length = 0));
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  pushDiff(t) {
    this.line.push(t);
  }
  align(t) {
    const r = t[1];
    if (
      r.includes(`
`)
    ) {
      const n = r.split(`
`),
        i = n.length - 1;
      n.forEach((s, a) => {
        a < i ? (this.pushSubstring(s), this.pushLine()) : s.length !== 0 && this.pushSubstring(s);
      });
    } else this.pushDiff(t);
  }
  moveLinesTo(t) {
    (this.isLineEmpty() || this.pushLine(), t.push(...this.lines), (this.lines.length = 0));
  }
};
o(Dw, 'ChangeBuffer');
var Fh = Dw,
  Lw = class {
    constructor(t, r) {
      Le(this, 'deleteBuffer');
      Le(this, 'insertBuffer');
      Le(this, 'lines');
      ((this.deleteBuffer = t), (this.insertBuffer = r), (this.lines = []));
    }
    pushDiffCommonLine(t) {
      this.lines.push(t);
    }
    pushDiffChangeLines(t) {
      const r = t[1].length === 0;
      ((!r || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(t),
        (!r || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(t));
    }
    flushChangeLines() {
      (this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines));
    }
    align(t) {
      const r = t[0],
        n = t[1];
      if (
        n.includes(`
`)
      ) {
        const i = n.split(`
`),
          s = i.length - 1;
        i.forEach((a, c) => {
          if (c === 0) {
            const d = new Be(r, a);
            this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()
              ? (this.flushChangeLines(), this.pushDiffCommonLine(d))
              : (this.pushDiffChangeLines(d), this.flushChangeLines());
          } else
            c < s
              ? this.pushDiffCommonLine(new Be(r, a))
              : a.length !== 0 && this.pushDiffChangeLines(new Be(r, a));
        });
      } else this.pushDiffChangeLines(t);
    }
    getLines() {
      return (this.flushChangeLines(), this.lines);
    }
  };
o(Lw, 'CommonBuffer');
var Z1 = Lw;
function Fw(e, t) {
  const r = new Fh(ht, t),
    n = new Fh(at, t),
    i = new Z1(r, n);
  return (
    e.forEach((s) => {
      switch (s[0]) {
        case ht:
          r.align(s);
          break;
        case at:
          n.align(s);
          break;
        default:
          i.align(s);
      }
    }),
    i.getLines()
  );
}
o(Fw, 'getAlignedDiffs');
function Bw(e, t) {
  if (t) {
    const r = e.length - 1;
    return e.some(
      (n, i) =>
        n[0] === $e &&
        (i !== r ||
          n[1] !==
            `
`),
    );
  }
  return e.some((r) => r[0] === $e);
}
o(Bw, 'hasCommonDiff');
function Jw(e, t, r) {
  if (e !== t && e.length !== 0 && t.length !== 0) {
    const n =
        e.includes(`
`) ||
        t.includes(`
`),
      [i, s] = Vp(
        n
          ? `${e}
`
          : e,
        n
          ? `${t}
`
          : t,
        !0,
        r,
      );
    if (Bw(i, n)) {
      const a = Wr(r),
        c = Fw(i, a.changeColor);
      return el(c, s, a);
    }
  }
  return ts(
    e.split(`
`),
    t.split(`
`),
    r,
  );
}
o(Jw, 'diffStringsUnified');
function Vp(e, t, r, n) {
  const [i, s] = jw(e, t, n);
  return (r && Ew(i), [i, s]);
}
o(Vp, 'diffStringsRaw');
function zs(e, t) {
  const { commonColor: r } = Wr(t);
  return r(e);
}
o(zs, 'getCommonMessage');
var {
    AsymmetricMatcher: eF,
    DOMCollection: tF,
    DOMElement: rF,
    Immutable: nF,
    ReactElement: oF,
    ReactTestComponent: iF,
  } = qp,
  $w = [iF, oF, rF, tF, nF, eF, qp.Error],
  mu = { maxDepth: 20, plugins: $w },
  Uw = { callToJSON: !1, maxDepth: 8, plugins: $w };
function Nn(e, t, r) {
  if (Object.is(e, t)) return '';
  const n = pu(e);
  let i = n,
    s = !1;
  if (n === 'object' && typeof e.asymmetricMatch == 'function') {
    if (
      e.$$typeof !== Symbol.for('jest.asymmetricMatcher') ||
      typeof e.getExpectedType != 'function'
    )
      return;
    ((i = e.getExpectedType()), (s = i === 'string'));
  }
  if (i !== pu(t)) {
    let a = function (A) {
      return A.length <= E ? A : `${A.slice(0, E)}...`;
    };
    o(a, 'truncate');
    const {
        aAnnotation: c,
        aColor: d,
        aIndicator: u,
        bAnnotation: p,
        bColor: f,
        bIndicator: y,
      } = Wr(r),
      h = Ws(Uw, r);
    let g = Ht(e, h),
      T = Ht(t, h);
    const E = 1e5;
    ((g = a(g)), (T = a(T)));
    const v = `${d(`${u} ${c}:`)} 
${g}`,
      S = `${f(`${y} ${p}:`)} 
${T}`;
    return `${v}

${S}`;
  }
  if (!s)
    switch (n) {
      case 'string':
        return ts(
          e.split(`
`),
          t.split(`
`),
          r,
        );
      case 'boolean':
      case 'number':
        return Vw(e, t, r);
      case 'map':
        return Cs(yu(e), yu(t), r);
      case 'set':
        return Cs(hu(e), hu(t), r);
      default:
        return Cs(e, t, r);
    }
}
o(Nn, 'diff');
function Vw(e, t, r) {
  const n = Ht(e, mu),
    i = Ht(t, mu);
  return n === i
    ? ''
    : ts(
        n.split(`
`),
        i.split(`
`),
        r,
      );
}
o(Vw, 'comparePrimitive');
function yu(e) {
  return new Map(Array.from(e.entries()).sort());
}
o(yu, 'sortMap');
function hu(e) {
  return new Set(Array.from(e.values()).sort());
}
o(hu, 'sortSet');
function Cs(e, t, r) {
  let n,
    i = !1;
  try {
    const a = Ws(mu, r);
    n = gu(e, t, a, r);
  } catch {
    i = !0;
  }
  const s = zs(ww, r);
  if (n === void 0 || n === s) {
    const a = Ws(Uw, r);
    ((n = gu(e, t, a, r)),
      n !== s &&
        !i &&
        (n = `${zs(Y1, r)}

${n}`));
  }
  return n;
}
o(Cs, 'compareObjects');
function Ws(e, t) {
  const { compareKeys: r, printBasicPrototype: n, maxDepth: i } = Wr(t);
  return { ...e, compareKeys: r, printBasicPrototype: n, maxDepth: i ?? e.maxDepth };
}
o(Ws, 'getFormatOptions');
function gu(e, t, r, n) {
  const i = { ...r, indent: 0 },
    s = Ht(e, i),
    a = Ht(t, i);
  if (s === a) return zs(ww, n);
  {
    const c = Ht(e, r),
      d = Ht(t, r);
    return qw(
      c.split(`
`),
      d.split(`
`),
      s.split(`
`),
      a.split(`
`),
      n,
    );
  }
}
o(gu, 'getObjectsDifference');
var Bh = 2e4;
function bu(e) {
  return Mi(e) === 'Object' && typeof e.asymmetricMatch == 'function';
}
o(bu, 'isAsymmetricMatcher');
function vu(e, t) {
  const r = Mi(e),
    n = Mi(t);
  return r === n && (r === 'Object' || r === 'Array');
}
o(vu, 'isReplaceable');
function Hp(e, t, r) {
  const { aAnnotation: n, bAnnotation: i } = Wr(r);
  if (
    typeof t == 'string' &&
    typeof e == 'string' &&
    t.length > 0 &&
    e.length > 0 &&
    t.length <= Bh &&
    e.length <= Bh &&
    t !== e
  ) {
    if (
      t.includes(`
`) ||
      e.includes(`
`)
    )
      return Jw(t, e, r);
    const [p] = Vp(t, e, !0),
      f = p.some((T) => T[0] === $e),
      y = Hw(n, i),
      h = y(n) + zw(Eu(p, ht, f)),
      g = y(i) + Gw(Eu(p, at, f));
    return `${h}
${g}`;
  }
  const s = cu(t, { forceWritable: !0 }),
    a = cu(e, { forceWritable: !0 }),
    { replacedExpected: c, replacedActual: d } = Gp(a, s);
  return Nn(c, d, r);
}
o(Hp, 'printDiffOrStringify');
function Gp(e, t, r = new WeakSet(), n = new WeakSet()) {
  return e instanceof Error && t instanceof Error && typeof e.cause < 'u' && typeof t.cause > 'u'
    ? (delete e.cause, { replacedActual: e, replacedExpected: t })
    : vu(e, t)
      ? r.has(e) || n.has(t)
        ? { replacedActual: e, replacedExpected: t }
        : (r.add(e),
          n.add(t),
          Dp(t).forEach((i) => {
            const s = t[i],
              a = e[i];
            if (bu(s)) s.asymmetricMatch(a) && (e[i] = s);
            else if (bu(a)) a.asymmetricMatch(s) && (t[i] = a);
            else if (vu(a, s)) {
              const c = Gp(a, s, r, n);
              ((e[i] = c.replacedActual), (t[i] = c.replacedExpected));
            }
          }),
          { replacedActual: e, replacedExpected: t })
      : { replacedActual: e, replacedExpected: t };
}
o(Gp, 'replaceAsymmetricMatcher');
function Hw(...e) {
  const t = e.reduce((r, n) => (n.length > r ? n.length : r), 0);
  return (r) => `${r}: ${' '.repeat(t - r.length)}`;
}
o(Hw, 'getLabelPrinter');
var sF = '';
function zp(e) {
  return e.replace(/\s+$/gm, (t) => sF.repeat(t.length));
}
o(zp, 'replaceTrailingSpaces');
function Gw(e) {
  return Ue.red(zp(bt(e)));
}
o(Gw, 'printReceived');
function zw(e) {
  return Ue.green(zp(bt(e)));
}
o(zw, 'printExpected');
function Eu(e, t, r) {
  return e.reduce(
    (n, i) => n + (i[0] === $e ? i[1] : i[0] === t ? (r ? Ue.inverse(i[1]) : i[1]) : ''),
    '',
  );
}
o(Eu, 'getCommonAndChangedSubstrings');
var aF = '@@__IMMUTABLE_RECORD__@@',
  lF = '@@__IMMUTABLE_ITERABLE__@@';
function Ww(e) {
  return e && (e[lF] || e[aF]);
}
o(Ww, 'isImmutable');
var cF = Object.getPrototypeOf({});
function Tu(e) {
  return e instanceof Error
    ? `<unserializable>: ${e.message}`
    : typeof e == 'string'
      ? `<unserializable>: ${e}`
      : '<unserializable>';
}
o(Tu, 'getUnserializableMessage');
function vr(e, t = new WeakMap()) {
  if (!e || typeof e == 'string') return e;
  if (e instanceof Error && 'toJSON' in e && typeof e.toJSON == 'function') {
    const r = e.toJSON();
    return (
      r &&
        r !== e &&
        typeof r == 'object' &&
        (typeof e.message == 'string' && ci(() => r.message ?? (r.message = e.message)),
        typeof e.stack == 'string' && ci(() => r.stack ?? (r.stack = e.stack)),
        typeof e.name == 'string' && ci(() => r.name ?? (r.name = e.name)),
        e.cause != null && ci(() => r.cause ?? (r.cause = vr(e.cause, t)))),
      vr(r, t)
    );
  }
  if (typeof e == 'function') return `Function<${e.name || 'anonymous'}>`;
  if (typeof e == 'symbol') return e.toString();
  if (typeof e != 'object') return e;
  if (typeof Buffer < 'u' && e instanceof Buffer) return `<Buffer(${e.length}) ...>`;
  if (typeof Uint8Array < 'u' && e instanceof Uint8Array) return `<Uint8Array(${e.length}) ...>`;
  if (Ww(e)) return vr(e.toJSON(), t);
  if (e instanceof Promise || (e.constructor && e.constructor.prototype === 'AsyncFunction'))
    return 'Promise';
  if (typeof Element < 'u' && e instanceof Element) return e.tagName;
  if (typeof e.asymmetricMatch == 'function') return `${e.toString()} ${fw(e.sample)}`;
  if (typeof e.toJSON == 'function') return vr(e.toJSON(), t);
  if (t.has(e)) return t.get(e);
  if (Array.isArray(e)) {
    const r = new Array(e.length);
    return (
      t.set(e, r),
      e.forEach((n, i) => {
        try {
          r[i] = vr(n, t);
        } catch (s) {
          r[i] = Tu(s);
        }
      }),
      r
    );
  } else {
    const r = Object.create(null);
    t.set(e, r);
    let n = e;
    for (; n && n !== cF; )
      (Object.getOwnPropertyNames(n).forEach((i) => {
        if (!(i in r))
          try {
            r[i] = vr(e[i], t);
          } catch (s) {
            (delete r[i], (r[i] = Tu(s)));
          }
      }),
        (n = Object.getPrototypeOf(n)));
    return r;
  }
}
o(vr, 'serializeValue');
function ci(e) {
  try {
    return e();
  } catch {}
}
o(ci, 'safe');
function Kw(e) {
  return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, '');
}
o(Kw, 'normalizeErrorMessage');
function tl(e, t, r = new WeakSet()) {
  if (!e || typeof e != 'object') return { message: String(e) };
  const n = e;
  ((n.showDiff || (n.showDiff === void 0 && n.expected !== void 0 && n.actual !== void 0)) &&
    (n.diff = Hp(n.actual, n.expected, { ...t, ...n.diffOptions })),
    'expected' in n && typeof n.expected != 'string' && (n.expected = bt(n.expected, 10)),
    'actual' in n && typeof n.actual != 'string' && (n.actual = bt(n.actual, 10)));
  try {
    typeof n.message == 'string' && (n.message = Kw(n.message));
  } catch {}
  try {
    !r.has(n) && typeof n.cause == 'object' && (r.add(n), (n.cause = tl(n.cause, t, r)));
  } catch {}
  try {
    return vr(n);
  } catch (i) {
    return vr(
      new Error(`Failed to fully serialize error: ${i?.message}
Inner error message: ${n?.message}`),
    );
  }
}
o(tl, 'processError');
var pr = {
    CALL: 'storybook/instrumenter/call',
    SYNC: 'storybook/instrumenter/sync',
    START: 'storybook/instrumenter/start',
    BACK: 'storybook/instrumenter/back',
    GOTO: 'storybook/instrumenter/goto',
    NEXT: 'storybook/instrumenter/next',
    END: 'storybook/instrumenter/end',
  },
  Ac = globalThis.__STORYBOOK_ADDONS_PREVIEW,
  uF = new Error(
    'This function ran after the play function completed. Did you forget to `await` it?',
  ),
  Jh = o((e) => Object.prototype.toString.call(e) === '[object Object]', 'isObject'),
  dF = o((e) => Object.prototype.toString.call(e) === '[object Module]', 'isModule'),
  pF = o((e) => {
    if (!Jh(e) && !dF(e)) return !1;
    if (e.constructor === void 0) return !0;
    const t = e.constructor.prototype;
    return !!Jh(t);
  }, 'isInstrumentable'),
  fF = o((e) => {
    try {
      return new e.constructor();
    } catch {
      return {};
    }
  }, 'construct'),
  Oc = o(
    () => ({
      renderPhase: 'preparing',
      isDebugging: !1,
      isPlaying: !1,
      isLocked: !1,
      cursor: 0,
      calls: [],
      shadowCalls: [],
      callRefsByResult: new Map(),
      chainedCallIds: new Set(),
      ancestors: [],
      playUntil: void 0,
      resolvers: {},
      syncTimeout: void 0,
    }),
    'getInitialState',
  ),
  $h = o((e, t = !1) => {
    const r = (t ? e.shadowCalls : e.calls).filter((i) => i.retain);
    if (!r.length) return;
    const n = new Map(Array.from(e.callRefsByResult.entries()).filter(([, i]) => i.retain));
    return { cursor: r.length, calls: r, callRefsByResult: n };
  }, 'getRetainedState'),
  Yw = class {
    constructor() {
      ((this.detached = !1),
        (this.initialized = !1),
        (this.state = {}),
        (this.loadParentWindowState = o(() => {
          try {
            this.state =
              te.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
          } catch {
            this.detached = !0;
          }
        }, 'loadParentWindowState')),
        (this.updateParentWindowState = o(() => {
          try {
            te.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
          } catch {
            this.detached = !0;
          }
        }, 'updateParentWindowState')),
        this.loadParentWindowState());
      const t = o(({ storyId: d, renderPhase: u, isPlaying: p = !0, isDebugging: f = !1 }) => {
          const y = this.getState(d);
          (this.setState(d, {
            ...Oc(),
            ...$h(y, f),
            renderPhase: u || y.renderPhase,
            shadowCalls: f ? y.shadowCalls : [],
            chainedCallIds: f ? y.chainedCallIds : new Set(),
            playUntil: f ? y.playUntil : void 0,
            isPlaying: p,
            isDebugging: f,
          }),
            this.sync(d));
        }, 'resetState'),
        r = o(
          (d) =>
            ({ storyId: u, playUntil: p }) => {
              this.getState(u).isDebugging ||
                this.setState(u, ({ calls: y }) => ({
                  calls: [],
                  shadowCalls: y.map((h) => ({ ...h, status: 'waiting' })),
                  isDebugging: !0,
                }));
              const f = this.getLog(u);
              (this.setState(u, ({ shadowCalls: y }) => {
                if (p || !f.length) return { playUntil: p };
                const h = y.findIndex((g) => g.id === f[0].callId);
                return {
                  playUntil: y
                    .slice(0, h)
                    .filter((g) => g.interceptable && !g.ancestors?.length)
                    .slice(-1)[0]?.id,
                };
              }),
                d.emit(Us, { storyId: u, isDebugging: !0 }));
            },
          'start',
        ),
        n = o(
          (d) =>
            ({ storyId: u }) => {
              const p = this.getLog(u).filter((y) => !y.ancestors?.length),
                f = p.reduceRight((y, h, g) => (y >= 0 || h.status === 'waiting' ? y : g), -1);
              r(d)({ storyId: u, playUntil: p[f - 1]?.callId });
            },
          'back',
        ),
        i = o(
          (d) =>
            ({ storyId: u, callId: p }) => {
              const { calls: f, shadowCalls: y, resolvers: h } = this.getState(u),
                g = f.find(({ id: E }) => E === p),
                T = y.find(({ id: E }) => E === p);
              if (!g && T && Object.values(h).length > 0) {
                const E = this.getLog(u).find((v) => v.status === 'waiting')?.callId;
                (T.id !== E && this.setState(u, { playUntil: T.id }),
                  Object.values(h).forEach((v) => v()));
              } else r(d)({ storyId: u, playUntil: p });
            },
          'goto',
        ),
        s = o(
          (d) =>
            ({ storyId: u }) => {
              const { resolvers: p } = this.getState(u);
              if (Object.values(p).length > 0) Object.values(p).forEach((f) => f());
              else {
                const f = this.getLog(u).find((y) => y.status === 'waiting')?.callId;
                f ? r(d)({ storyId: u, playUntil: f }) : a({ storyId: u });
              }
            },
          'next',
        ),
        a = o(({ storyId: d }) => {
          (this.setState(d, { playUntil: void 0, isDebugging: !1 }),
            Object.values(this.getState(d).resolvers).forEach((u) => u()));
        }, 'end'),
        c = o(({ storyId: d, newPhase: u }) => {
          const { isDebugging: p } = this.getState(d);
          if (u === 'preparing' && p) return t({ storyId: d, renderPhase: u, isDebugging: p });
          if (u === 'playing') return t({ storyId: d, renderPhase: u, isDebugging: p });
          (u === 'played'
            ? this.setState(d, { renderPhase: u, isLocked: !1, isPlaying: !1, isDebugging: !1 })
            : u === 'errored'
              ? this.setState(d, { renderPhase: u, isLocked: !1, isPlaying: !1 })
              : u === 'aborted'
                ? this.setState(d, { renderPhase: u, isLocked: !0, isPlaying: !1 })
                : this.setState(d, { renderPhase: u }),
            this.sync(d));
        }, 'renderPhaseChanged');
      Ac &&
        Ac.ready().then(() => {
          ((this.channel = Ac.getChannel()),
            this.channel.on(Us, t),
            this.channel.on(gn, c),
            this.channel.on(Xd, () => {
              this.initialized ? this.cleanup() : (this.initialized = !0);
            }),
            this.channel.on(pr.START, r(this.channel)),
            this.channel.on(pr.BACK, n(this.channel)),
            this.channel.on(pr.GOTO, i(this.channel)),
            this.channel.on(pr.NEXT, s(this.channel)),
            this.channel.on(pr.END, a));
        });
    }
    getState(t) {
      return this.state[t] || Oc();
    }
    setState(t, r) {
      if (t) {
        const n = this.getState(t),
          i = typeof r == 'function' ? r(n) : r;
        ((this.state = { ...this.state, [t]: { ...n, ...i } }), this.updateParentWindowState());
      }
    }
    cleanup() {
      this.state = Object.entries(this.state).reduce((n, [i, s]) => {
        const a = $h(s);
        return (a && (n[i] = Object.assign(Oc(), a)), n);
      }, {});
      const r = {
        controlStates: {
          detached: this.detached,
          start: !1,
          back: !1,
          goto: !1,
          next: !1,
          end: !1,
        },
        logItems: [],
      };
      (this.channel?.emit(pr.SYNC, r), this.updateParentWindowState());
    }
    getLog(t) {
      const { calls: r, shadowCalls: n } = this.getState(t),
        i = [...n];
      r.forEach((a, c) => {
        i[c] = a;
      });
      const s = new Set();
      return i.reduceRight(
        (a, c) => (
          c.args.forEach((d) => {
            d?.__callId__ && s.add(d.__callId__);
          }),
          c.path.forEach((d) => {
            d.__callId__ && s.add(d.__callId__);
          }),
          (c.interceptable || c.exception) &&
            !s.has(c.id) &&
            (a.unshift({ callId: c.id, status: c.status, ancestors: c.ancestors }), s.add(c.id)),
          a
        ),
        [],
      );
    }
    instrument(t, r, n = 0) {
      if (!pF(t)) return t;
      const { mutate: i = !1, path: s = [] } = r,
        a = r.getKeys ? r.getKeys(t, n) : Object.keys(t);
      return (
        (n += 1),
        a.reduce(
          (c, d) => {
            const u = Xw(t, d);
            if (typeof u?.get == 'function') {
              if (u.configurable) {
                const f = o(() => u?.get?.bind(t)?.(), 'getter');
                Object.defineProperty(c, d, {
                  get: o(() => this.instrument(f(), { ...r, path: s.concat(d) }, n), 'get'),
                });
              }
              return c;
            }
            const p = t[d];
            return typeof p != 'function'
              ? ((c[d] = this.instrument(p, { ...r, path: s.concat(d) }, n)), c)
              : '__originalFn__' in p && typeof p.__originalFn__ == 'function'
                ? ((c[d] = p), c)
                : ((c[d] = (...f) => this.track(d, p, t, f, r)),
                  (c[d].__originalFn__ = p),
                  Object.defineProperty(c[d], 'name', { value: d, writable: !1 }),
                  Object.keys(p).length > 0 &&
                    Object.assign(c[d], this.instrument({ ...p }, { ...r, path: s.concat(d) }, n)),
                  c);
          },
          i ? t : fF(t),
        )
      );
    }
    track(t, r, n, i, s) {
      const a = i?.[0]?.__storyId__ || te.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId,
        { cursor: c, ancestors: d } = this.getState(a);
      this.setState(a, { cursor: c + 1 });
      const u = `${d.slice(-1)[0] || a} [${c}] ${t}`,
        { path: p = [], intercept: f = !1, retain: y = !1 } = s,
        h = typeof f == 'function' ? f(t, p) : f,
        g = {
          id: u,
          cursor: c,
          storyId: a,
          ancestors: d,
          path: p,
          method: t,
          args: i,
          interceptable: h,
          retain: y,
        },
        E = (h && !d.length ? this.intercept : this.invoke).call(this, r, n, g, s);
      return this.instrument(E, { ...s, mutate: !0, path: [{ __callId__: g.id }] });
    }
    intercept(t, r, n, i) {
      const { chainedCallIds: s, isDebugging: a, playUntil: c } = this.getState(n.storyId),
        d = s.has(n.id);
      return !a || d || c
        ? (c === n.id && this.setState(n.storyId, { playUntil: void 0 }), this.invoke(t, r, n, i))
        : new Promise((u) => {
            this.setState(n.storyId, ({ resolvers: p }) => ({
              isLocked: !1,
              resolvers: { ...p, [n.id]: u },
            }));
          }).then(
            () => (
              this.setState(n.storyId, (u) => {
                const { [n.id]: p, ...f } = u.resolvers;
                return { isLocked: !0, resolvers: f };
              }),
              this.invoke(t, r, n, i)
            ),
          );
    }
    invoke(t, r, n, i) {
      const { callRefsByResult: s, renderPhase: a } = this.getState(n.storyId),
        c = 25,
        d = o((f, y, h) => {
          if (h.includes(f)) return '[Circular]';
          if (((h = [...h, f]), y > c)) return '...';
          if (s.has(f)) return s.get(f);
          if (f instanceof Array) return f.map((g) => d(g, ++y, h));
          if (f instanceof Date) return { __date__: { value: f.toISOString() } };
          if (f instanceof Error) {
            const { name: g, message: T, stack: E } = f;
            return { __error__: { name: g, message: T, stack: E } };
          }
          if (f instanceof RegExp) {
            const { flags: g, source: T } = f;
            return { __regexp__: { flags: g, source: T } };
          }
          if (f instanceof te.window?.HTMLElement) {
            const { prefix: g, localName: T, id: E, classList: v, innerText: S } = f,
              A = Array.from(v);
            return { __element__: { prefix: g, localName: T, id: E, classNames: A, innerText: S } };
          }
          return typeof f == 'function'
            ? { __function__: { name: 'getMockName' in f ? f.getMockName() : f.name } }
            : typeof f == 'symbol'
              ? { __symbol__: { description: f.description } }
              : typeof f == 'object' && f?.constructor?.name && f?.constructor?.name !== 'Object'
                ? { __class__: { name: f.constructor.name } }
                : Object.prototype.toString.call(f) === '[object Object]'
                  ? Object.fromEntries(Object.entries(f).map(([g, T]) => [g, d(T, ++y, h)]))
                  : f;
        }, 'serializeValues'),
        u = { ...n, args: n.args.map((f) => d(f, 0, [])) };
      n.path.forEach((f) => {
        f?.__callId__ &&
          this.setState(n.storyId, ({ chainedCallIds: y }) => ({
            chainedCallIds: new Set(Array.from(y).concat(f.__callId__)),
          }));
      });
      const p = o((f) => {
        if (f instanceof Error) {
          const { name: y, message: h, stack: g, callId: T = n.id } = f,
            {
              showDiff: E = void 0,
              diff: v = void 0,
              actual: S = void 0,
              expected: A = void 0,
            } = f.name === 'AssertionError' ? tl(f) : f,
            N = {
              name: y,
              message: h,
              stack: g,
              callId: T,
              showDiff: E,
              diff: v,
              actual: S,
              expected: A,
            };
          if (
            (this.update({ ...u, status: 'error', exception: N }),
            this.setState(n.storyId, (j) => ({
              callRefsByResult: new Map([
                ...Array.from(j.callRefsByResult.entries()),
                [f, { __callId__: n.id, retain: n.retain }],
              ]),
            })),
            n.ancestors?.length)
          )
            throw (
              Object.prototype.hasOwnProperty.call(f, 'callId') ||
                Object.defineProperty(f, 'callId', { value: n.id }),
              f
            );
        }
        throw f;
      }, 'handleException');
      try {
        if (a === 'played' && !n.retain) throw uF;
        const y = (i.getArgs ? i.getArgs(n, this.getState(n.storyId)) : n.args).map((g) =>
            typeof g != 'function' || Qw(g) || Object.keys(g).length
              ? g
              : (...T) => {
                  const { cursor: E, ancestors: v } = this.getState(n.storyId);
                  this.setState(n.storyId, { cursor: 0, ancestors: [...v, n.id] });
                  const S = o(
                    () => this.setState(n.storyId, { cursor: E, ancestors: v }),
                    'restore',
                  );
                  let A = !1;
                  try {
                    const N = g(...T);
                    return N instanceof Promise ? ((A = !0), N.finally(S)) : N;
                  } finally {
                    A || S();
                  }
                },
          ),
          h = t.apply(r, y);
        return (
          h &&
            ['object', 'function', 'symbol'].includes(typeof h) &&
            this.setState(n.storyId, (g) => ({
              callRefsByResult: new Map([
                ...Array.from(g.callRefsByResult.entries()),
                [h, { __callId__: n.id, retain: n.retain }],
              ]),
            })),
          this.update({ ...u, status: h instanceof Promise ? 'active' : 'done' }),
          h instanceof Promise ? h.then((g) => (this.update({ ...u, status: 'done' }), g), p) : h
        );
      } catch (f) {
        return p(f);
      }
    }
    update(t) {
      (this.channel?.emit(pr.CALL, t),
        this.setState(t.storyId, ({ calls: r }) => {
          const n = r.concat(t).reduce((i, s) => Object.assign(i, { [s.id]: s }), {});
          return {
            calls: Object.values(n).sort((i, s) =>
              i.id.localeCompare(s.id, void 0, { numeric: !0 }),
            ),
          };
        }),
        this.sync(t.storyId));
    }
    sync(t) {
      const r = o(() => {
        const { isLocked: n, isPlaying: i } = this.getState(t),
          s = this.getLog(t),
          a = s.filter(({ ancestors: f }) => !f.length).find((f) => f.status === 'waiting')?.callId,
          c = s.some((f) => f.status === 'active');
        if (this.detached || n || c || s.length === 0) {
          const y = {
            controlStates: {
              detached: this.detached,
              start: !1,
              back: !1,
              goto: !1,
              next: !1,
              end: !1,
            },
            logItems: s,
          };
          this.channel?.emit(pr.SYNC, y);
          return;
        }
        const d = s.some((f) => f.status === 'done' || f.status === 'error'),
          p = {
            controlStates: {
              detached: this.detached,
              start: d,
              back: d,
              goto: !0,
              next: i,
              end: i,
            },
            logItems: s,
            pausedAt: a,
          };
        this.channel?.emit(pr.SYNC, p);
      }, 'synchronize');
      this.setState(
        t,
        ({ syncTimeout: n }) => (clearTimeout(n), { syncTimeout: setTimeout(r, 0) }),
      );
    }
  };
o(Yw, 'Instrumenter');
var mF = Yw;
function To(e, t = {}) {
  try {
    let r = !1,
      n = !1;
    return (
      te.window?.location?.search?.includes('instrument=true')
        ? (r = !0)
        : te.window?.location?.search?.includes('instrument=false') && (n = !0),
      (te.window?.parent === te.window && !r) || n
        ? e
        : (te.window &&
            !te.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ &&
            (te.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new mF()),
          (te.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(e, t))
    );
  } catch (r) {
    return (Ve.warn(r), e);
  }
}
o(To, 'instrument');
function Xw(e, t) {
  let r = e;
  for (; r != null; ) {
    const n = Object.getOwnPropertyDescriptor(r, t);
    if (n) return n;
    r = Object.getPrototypeOf(r);
  }
}
o(Xw, 'getPropertyDescriptor');
function Qw(e) {
  if (typeof e != 'function') return !1;
  const t = Object.getOwnPropertyDescriptor(e, 'prototype');
  return t ? !t.writable : !1;
}
o(Qw, 'isClass');
var Zw = Object.defineProperty,
  G = o((e, t) => Zw(e, 'name', { value: t, configurable: !0 }), '__name'),
  Wp = o((e, t) => {
    for (var r in t) Zw(e, r, { get: t[r], enumerable: !0 });
  }, '__export'),
  Zt = {};
Wp(Zt, {
  addChainableMethod: o(() => fl, 'addChainableMethod'),
  addLengthGuard: o(() => _o, 'addLengthGuard'),
  addMethod: o(() => ul, 'addMethod'),
  addProperty: o(() => cl, 'addProperty'),
  checkError: o(() => _t, 'checkError'),
  compareByInspect: o(() => Di, 'compareByInspect'),
  eql: o(() => tS, 'eql'),
  expectTypes: o(() => tf, 'expectTypes'),
  flag: o(() => me, 'flag'),
  getActual: o(() => ns, 'getActual'),
  getMessage: o(() => ol, 'getMessage'),
  getName: o(() => is, 'getName'),
  getOperator: o(() => gl, 'getOperator'),
  getOwnEnumerableProperties: o(() => hl, 'getOwnEnumerableProperties'),
  getOwnEnumerablePropertySymbols: o(() => yl, 'getOwnEnumerablePropertySymbols'),
  getPathInfo: o(() => ll, 'getPathInfo'),
  hasProperty: o(() => os, 'hasProperty'),
  inspect: o(() => Se, 'inspect'),
  isNaN: o(() => ca, 'isNaN'),
  isNumeric: o(() => rt, 'isNumeric'),
  isProxyEnabled: o(() => So, 'isProxyEnabled'),
  isRegExp: o(() => Li, 'isRegExp'),
  objDisplay: o(() => kr, 'objDisplay'),
  overwriteChainableMethod: o(() => ml, 'overwriteChainableMethod'),
  overwriteMethod: o(() => pl, 'overwriteMethod'),
  overwriteProperty: o(() => dl, 'overwriteProperty'),
  proxify: o(() => In, 'proxify'),
  test: o(() => rl, 'test'),
  transferFlags: o(() => Ft, 'transferFlags'),
  type: o(() => xe, 'type'),
});
var _t = {};
Wp(_t, {
  compatibleConstructor: o(() => Xp, 'compatibleConstructor'),
  compatibleInstance: o(() => Yp, 'compatibleInstance'),
  compatibleMessage: o(() => Qp, 'compatibleMessage'),
  getConstructorName: o(() => Zp, 'getConstructorName'),
  getMessage: o(() => ef, 'getMessage'),
});
function rs(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === '[object Error]';
}
o(rs, 'isErrorInstance');
G(rs, 'isErrorInstance');
function Kp(e) {
  return Object.prototype.toString.call(e) === '[object RegExp]';
}
o(Kp, 'isRegExp');
G(Kp, 'isRegExp');
function Yp(e, t) {
  return rs(t) && e === t;
}
o(Yp, 'compatibleInstance');
G(Yp, 'compatibleInstance');
function Xp(e, t) {
  return rs(t)
    ? e.constructor === t.constructor || e instanceof t.constructor
    : (typeof t == 'object' || typeof t == 'function') && t.prototype
      ? e.constructor === t || e instanceof t
      : !1;
}
o(Xp, 'compatibleConstructor');
G(Xp, 'compatibleConstructor');
function Qp(e, t) {
  const r = typeof e == 'string' ? e : e.message;
  return Kp(t) ? t.test(r) : typeof t == 'string' ? r.indexOf(t) !== -1 : !1;
}
o(Qp, 'compatibleMessage');
G(Qp, 'compatibleMessage');
function Zp(e) {
  let t = e;
  return (
    rs(e)
      ? (t = e.constructor.name)
      : typeof e == 'function' && ((t = e.name), t === '' && (t = new e().name || t)),
    t
  );
}
o(Zp, 'getConstructorName');
G(Zp, 'getConstructorName');
function ef(e) {
  let t = '';
  return (e && e.message ? (t = e.message) : typeof e == 'string' && (t = e), t);
}
o(ef, 'getMessage');
G(ef, 'getMessage');
function me(e, t, r) {
  let n = e.__flags || (e.__flags = Object.create(null));
  if (arguments.length === 3) n[t] = r;
  else return n[t];
}
o(me, 'flag');
G(me, 'flag');
function rl(e, t) {
  let r = me(e, 'negate'),
    n = t[0];
  return r ? !n : n;
}
o(rl, 'test');
G(rl, 'test');
function xe(e) {
  if (typeof e > 'u') return 'undefined';
  if (e === null) return 'null';
  const t = e[Symbol.toStringTag];
  return typeof t == 'string' ? t : Object.prototype.toString.call(e).slice(8, -1);
}
o(xe, 'type');
G(xe, 'type');
var yF = 'captureStackTrace' in Error,
  oi,
  Pe =
    ((oi = class extends Error {
      constructor(t = 'Unspecified AssertionError', r, n) {
        super(t);
        Le(this, 'message');
        ((this.message = t), yF && Error.captureStackTrace(this, n || oi));
        for (const i in r) i in this || (this[i] = r[i]);
      }
      get name() {
        return 'AssertionError';
      }
      get ok() {
        return !1;
      }
      toJSON(t) {
        return {
          ...this,
          name: this.name,
          message: this.message,
          ok: !1,
          stack: t !== !1 ? this.stack : void 0,
        };
      }
    }),
    o(oi, '_AssertionError'),
    G(oi, 'AssertionError'),
    oi);
function tf(e, t) {
  let r = me(e, 'message'),
    n = me(e, 'ssfi');
  ((r = r ? r + ': ' : ''),
    (e = me(e, 'object')),
    (t = t.map(function (a) {
      return a.toLowerCase();
    })),
    t.sort());
  let i = t
      .map(function (a, c) {
        let d = ~['a', 'e', 'i', 'o', 'u'].indexOf(a.charAt(0)) ? 'an' : 'a';
        return (t.length > 1 && c === t.length - 1 ? 'or ' : '') + d + ' ' + a;
      })
      .join(', '),
    s = xe(e).toLowerCase();
  if (
    !t.some(function (a) {
      return s === a;
    })
  )
    throw new Pe(r + 'object tested must be ' + i + ', but ' + s + ' given', void 0, n);
}
o(tf, 'expectTypes');
G(tf, 'expectTypes');
function ns(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
o(ns, 'getActual');
G(ns, 'getActual');
var Uh = {
    bold: ['1', '22'],
    dim: ['2', '22'],
    italic: ['3', '23'],
    underline: ['4', '24'],
    inverse: ['7', '27'],
    hidden: ['8', '28'],
    strike: ['9', '29'],
    black: ['30', '39'],
    red: ['31', '39'],
    green: ['32', '39'],
    yellow: ['33', '39'],
    blue: ['34', '39'],
    magenta: ['35', '39'],
    cyan: ['36', '39'],
    white: ['37', '39'],
    brightblack: ['30;1', '39'],
    brightred: ['31;1', '39'],
    brightgreen: ['32;1', '39'],
    brightyellow: ['33;1', '39'],
    brightblue: ['34;1', '39'],
    brightmagenta: ['35;1', '39'],
    brightcyan: ['36;1', '39'],
    brightwhite: ['37;1', '39'],
    grey: ['90', '39'],
  },
  hF = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red',
  },
  io = '';
function rf(e, t) {
  const r = Uh[hF[t]] || Uh[t] || '';
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
o(rf, 'colorise');
G(rf, 'colorise');
function nf(
  {
    showHidden: e = !1,
    depth: t = 2,
    colors: r = !1,
    customInspect: n = !0,
    showProxy: i = !1,
    maxArrayLength: s = 1 / 0,
    breakLength: a = 1 / 0,
    seen: c = [],
    truncate: d = 1 / 0,
    stylize: u = String,
  } = {},
  p,
) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!i,
    maxArrayLength: Number(s),
    breakLength: Number(a),
    truncate: Number(d),
    seen: c,
    inspect: p,
    stylize: u,
  };
  return (f.colors && (f.stylize = rf), f);
}
o(nf, 'normaliseOptions');
G(nf, 'normaliseOptions');
function of(e) {
  return e >= '\uD800' && e <= '\uDBFF';
}
o(of, 'isHighSurrogate');
G(of, 'isHighSurrogate');
function ir(e, t, r = io) {
  e = String(e);
  const n = r.length,
    i = e.length;
  if (n > t && i > n) return r;
  if (i > t && i > n) {
    let s = t - n;
    return (s > 0 && of(e[s - 1]) && (s = s - 1), `${e.slice(0, s)}${r}`);
  }
  return e;
}
o(ir, 'truncate');
G(ir, 'truncate');
function Ct(e, t, r, n = ', ') {
  r = r || t.inspect;
  const i = e.length;
  if (i === 0) return '';
  const s = t.truncate;
  let a = '',
    c = '',
    d = '';
  for (let u = 0; u < i; u += 1) {
    const p = u + 1 === e.length,
      f = u + 2 === e.length;
    d = `${io}(${e.length - u})`;
    const y = e[u];
    t.truncate = s - a.length - (p ? 0 : n.length);
    const h = c || r(y, t) + (p ? '' : n),
      g = a.length + h.length,
      T = g + d.length;
    if (
      (p && g > s && a.length + d.length <= s) ||
      (!p && !f && T > s) ||
      ((c = p ? '' : r(e[u + 1], t) + (f ? '' : n)), !p && f && T > s && g + c.length > s)
    )
      break;
    if (((a += h), !p && !f && g + c.length >= s)) {
      d = `${io}(${e.length - u - 1})`;
      break;
    }
    d = '';
  }
  return `${a}${d}`;
}
o(Ct, 'inspectList');
G(Ct, 'inspectList');
function sf(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
    ? e
    : JSON.stringify(e)
        .replace(/'/g, "\\'")
        .replace(/\\"/g, '"')
        .replace(/(^"|"$)/g, "'");
}
o(sf, 'quoteComplexKey');
G(sf, 'quoteComplexKey');
function bn([e, t], r) {
  return (
    (r.truncate -= 2),
    typeof e == 'string' ? (e = sf(e)) : typeof e != 'number' && (e = `[${r.inspect(e, r)}]`),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e}: ${t}`
  );
}
o(bn, 'inspectProperty');
G(bn, 'inspectProperty');
function af(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length) return '[]';
  t.truncate -= 4;
  const n = Ct(e, t);
  t.truncate -= n.length;
  let i = '';
  return (
    r.length &&
      (i = Ct(
        r.map((s) => [s, e[s]]),
        t,
        bn,
      )),
    `[ ${n}${i ? `, ${i}` : ''} ]`
  );
}
o(af, 'inspectArray');
G(af, 'inspectArray');
var gF = G(
  (e) =>
    typeof Buffer == 'function' && e instanceof Buffer
      ? 'Buffer'
      : e[Symbol.toStringTag]
        ? e[Symbol.toStringTag]
        : e.constructor.name,
  'getArrayName',
);
function $t(e, t) {
  const r = gF(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length) return `${r}[]`;
  let i = '';
  for (let a = 0; a < e.length; a++) {
    const c = `${t.stylize(ir(e[a], t.truncate), 'number')}${a === e.length - 1 ? '' : ', '}`;
    if (((t.truncate -= c.length), e[a] !== e.length && t.truncate <= 3)) {
      i += `${io}(${e.length - e[a] + 1})`;
      break;
    }
    i += c;
  }
  let s = '';
  return (
    n.length &&
      (s = Ct(
        n.map((a) => [a, e[a]]),
        t,
        bn,
      )),
    `${r}[ ${i}${s ? `, ${s}` : ''} ]`
  );
}
o($t, 'inspectTypedArray');
G($t, 'inspectTypedArray');
function lf(e, t) {
  const r = e.toJSON();
  if (r === null) return 'Invalid Date';
  const n = r.split('T'),
    i = n[0];
  return t.stylize(`${i}T${ir(n[1], t.truncate - i.length - 1)}`, 'date');
}
o(lf, 'inspectDate');
G(lf, 'inspectDate');
function Ks(e, t) {
  const r = e[Symbol.toStringTag] || 'Function',
    n = e.name;
  return n
    ? t.stylize(`[${r} ${ir(n, t.truncate - 11)}]`, 'special')
    : t.stylize(`[${r}]`, 'special');
}
o(Ks, 'inspectFunction');
G(Ks, 'inspectFunction');
function cf([e, t], r) {
  return (
    (r.truncate -= 4),
    (e = r.inspect(e, r)),
    (r.truncate -= e.length),
    (t = r.inspect(t, r)),
    `${e} => ${t}`
  );
}
o(cf, 'inspectMapEntry');
G(cf, 'inspectMapEntry');
function uf(e) {
  const t = [];
  return (
    e.forEach((r, n) => {
      t.push([n, r]);
    }),
    t
  );
}
o(uf, 'mapToEntries');
G(uf, 'mapToEntries');
function df(e, t) {
  return e.size === 0 ? 'Map{}' : ((t.truncate -= 7), `Map{ ${Ct(uf(e), t, cf)} }`);
}
o(df, 'inspectMap');
G(df, 'inspectMap');
var bF = Number.isNaN || ((e) => e !== e);
function Ys(e, t) {
  return bF(e)
    ? t.stylize('NaN', 'number')
    : e === 1 / 0
      ? t.stylize('Infinity', 'number')
      : e === -1 / 0
        ? t.stylize('-Infinity', 'number')
        : e === 0
          ? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
          : t.stylize(ir(String(e), t.truncate), 'number');
}
o(Ys, 'inspectNumber');
G(Ys, 'inspectNumber');
function Xs(e, t) {
  let r = ir(e.toString(), t.truncate - 1);
  return (r !== io && (r += 'n'), t.stylize(r, 'bigint'));
}
o(Xs, 'inspectBigInt');
G(Xs, 'inspectBigInt');
function pf(e, t) {
  const r = e.toString().split('/')[2],
    n = t.truncate - (2 + r.length),
    i = e.source;
  return t.stylize(`/${ir(i, n)}/${r}`, 'regexp');
}
o(pf, 'inspectRegExp');
G(pf, 'inspectRegExp');
function ff(e) {
  const t = [];
  return (
    e.forEach((r) => {
      t.push(r);
    }),
    t
  );
}
o(ff, 'arrayFromSet');
G(ff, 'arrayFromSet');
function mf(e, t) {
  return e.size === 0 ? 'Set{}' : ((t.truncate -= 7), `Set{ ${Ct(ff(e), t)} }`);
}
o(mf, 'inspectSet');
G(mf, 'inspectSet');
var Vh = new RegExp(
    "['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
    'g',
  ),
  vF = { '\b': '\\b', '	': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '\\': '\\\\' },
  EF = 16;
function yf(e) {
  return vF[e] || `\\u${`0000${e.charCodeAt(0).toString(EF)}`.slice(-4)}`;
}
o(yf, 'escape');
G(yf, 'escape');
function Qs(e, t) {
  return (Vh.test(e) && (e = e.replace(Vh, yf)), t.stylize(`'${ir(e, t.truncate - 2)}'`, 'string'));
}
o(Qs, 'inspectString');
G(Qs, 'inspectString');
function Zs(e) {
  return 'description' in Symbol.prototype
    ? e.description
      ? `Symbol(${e.description})`
      : 'Symbol()'
    : e.toString();
}
o(Zs, 'inspectSymbol');
G(Zs, 'inspectSymbol');
var TF = G(() => 'Promise{}', 'getPromiseValue'),
  wF = TF;
function zn(e, t) {
  const r = Object.getOwnPropertyNames(e),
    n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0) return '{}';
  if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e))) return '[Circular]';
  t.seen.push(e);
  const i = Ct(
      r.map((c) => [c, e[c]]),
      t,
      bn,
    ),
    s = Ct(
      n.map((c) => [c, e[c]]),
      t,
      bn,
    );
  t.seen.pop();
  let a = '';
  return (i && s && (a = ', '), `{ ${i}${a}${s} }`);
}
o(zn, 'inspectObject');
G(zn, 'inspectObject');
var Cc = typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1;
function hf(e, t) {
  let r = '';
  return (
    Cc && Cc in e && (r = e[Cc]),
    (r = r || e.constructor.name),
    (!r || r === '_class') && (r = '<Anonymous Class>'),
    (t.truncate -= r.length),
    `${r}${zn(e, t)}`
  );
}
o(hf, 'inspectClass');
G(hf, 'inspectClass');
function gf(e, t) {
  return e.length === 0 ? 'Arguments[]' : ((t.truncate -= 13), `Arguments[ ${Ct(e, t)} ]`);
}
o(gf, 'inspectArguments');
G(gf, 'inspectArguments');
var SF = [
  'stack',
  'line',
  'column',
  'name',
  'message',
  'fileName',
  'lineNumber',
  'columnNumber',
  'number',
  'description',
  'cause',
];
function bf(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((a) => SF.indexOf(a) === -1),
    n = e.name;
  t.truncate -= n.length;
  let i = '';
  if (
    (typeof e.message == 'string' ? (i = ir(e.message, t.truncate)) : r.unshift('message'),
    (i = i ? `: ${i}` : ''),
    (t.truncate -= i.length + 5),
    (t.seen = t.seen || []),
    t.seen.includes(e))
  )
    return '[Circular]';
  t.seen.push(e);
  const s = Ct(
    r.map((a) => [a, e[a]]),
    t,
    bn,
  );
  return `${n}${i}${s ? ` { ${s} }` : ''}`;
}
o(bf, 'inspectObject2');
G(bf, 'inspectObject');
function vf([e, t], r) {
  return (
    (r.truncate -= 3),
    t
      ? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
      : `${r.stylize(String(e), 'yellow')}`
  );
}
o(vf, 'inspectAttribute');
G(vf, 'inspectAttribute');
function qi(e, t) {
  return Ct(
    e,
    t,
    Ef,
    `
`,
  );
}
o(qi, 'inspectNodeCollection');
G(qi, 'inspectNodeCollection');
function Ef(e, t) {
  switch (e.nodeType) {
    case 1:
      return nl(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
o(Ef, 'inspectNode');
G(Ef, 'inspectNode');
function nl(e, t) {
  const r = e.getAttributeNames(),
    n = e.tagName.toLowerCase(),
    i = t.stylize(`<${n}`, 'special'),
    s = t.stylize('>', 'special'),
    a = t.stylize(`</${n}>`, 'special');
  t.truncate -= n.length * 2 + 5;
  let c = '';
  (r.length > 0 &&
    ((c += ' '),
    (c += Ct(
      r.map((p) => [p, e.getAttribute(p)]),
      t,
      vf,
      ' ',
    ))),
    (t.truncate -= c.length));
  const d = t.truncate;
  let u = qi(e.children, t);
  return (u && u.length > d && (u = `${io}(${e.children.length})`), `${i}${c}${s}${u}${a}`);
}
o(nl, 'inspectHTML');
G(nl, 'inspectHTML');
var _F = typeof Symbol == 'function' && typeof Symbol.for == 'function',
  xc = _F ? Symbol.for('chai/inspect') : '@@chai/inspect',
  Nc = Symbol.for('nodejs.util.inspect.custom'),
  Hh = new WeakMap(),
  Gh = {},
  zh = {
    undefined: G((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
    null: G((e, t) => t.stylize('null', 'null'), 'null'),
    boolean: G((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
    Boolean: G((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
    number: Ys,
    Number: Ys,
    bigint: Xs,
    BigInt: Xs,
    string: Qs,
    String: Qs,
    function: Ks,
    Function: Ks,
    symbol: Zs,
    Symbol: Zs,
    Array: af,
    Date: lf,
    Map: df,
    Set: mf,
    RegExp: pf,
    Promise: wF,
    WeakSet: G((e, t) => t.stylize('WeakSet{}', 'special'), 'WeakSet'),
    WeakMap: G((e, t) => t.stylize('WeakMap{}', 'special'), 'WeakMap'),
    Arguments: gf,
    Int8Array: $t,
    Uint8Array: $t,
    Uint8ClampedArray: $t,
    Int16Array: $t,
    Uint16Array: $t,
    Int32Array: $t,
    Uint32Array: $t,
    Float32Array: $t,
    Float64Array: $t,
    Generator: G(() => '', 'Generator'),
    DataView: G(() => '', 'DataView'),
    ArrayBuffer: G(() => '', 'ArrayBuffer'),
    Error: bf,
    HTMLCollection: qi,
    NodeList: qi,
  },
  RF = G(
    (e, t, r) =>
      xc in e && typeof e[xc] == 'function'
        ? e[xc](t)
        : Nc in e && typeof e[Nc] == 'function'
          ? e[Nc](t.depth, t)
          : 'inspect' in e && typeof e.inspect == 'function'
            ? e.inspect(t.depth, t)
            : 'constructor' in e && Hh.has(e.constructor)
              ? Hh.get(e.constructor)(e, t)
              : Gh[r]
                ? Gh[r](e, t)
                : '',
    'inspectCustom',
  ),
  PF = Object.prototype.toString;
function ji(e, t = {}) {
  const r = nf(t, ji),
    { customInspect: n } = r;
  let i = e === null ? 'null' : typeof e;
  if ((i === 'object' && (i = PF.call(e).slice(8, -1)), i in zh)) return zh[i](e, r);
  if (n && e) {
    const a = RF(e, r, i);
    if (a) return typeof a == 'string' ? a : ji(a, r);
  }
  const s = e ? Object.getPrototypeOf(e) : !1;
  return s === Object.prototype || s === null
    ? zn(e, r)
    : e && typeof HTMLElement == 'function' && e instanceof HTMLElement
      ? nl(e, r)
      : 'constructor' in e
        ? e.constructor !== Object
          ? hf(e, r)
          : zn(e, r)
        : e === Object(e)
          ? zn(e, r)
          : r.stylize(String(e), i);
}
o(ji, 'inspect');
G(ji, 'inspect');
var gt = {
  includeStack: !1,
  showDiff: !0,
  truncateThreshold: 40,
  useProxy: !0,
  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON'],
  deepEqual: null,
};
function Se(e, t, r, n) {
  let i = {
    colors: n,
    depth: typeof r > 'u' ? 2 : r,
    showHidden: t,
    truncate: gt.truncateThreshold ? gt.truncateThreshold : 1 / 0,
  };
  return ji(e, i);
}
o(Se, 'inspect2');
G(Se, 'inspect');
function kr(e) {
  let t = Se(e),
    r = Object.prototype.toString.call(e);
  if (gt.truncateThreshold && t.length >= gt.truncateThreshold) {
    if (r === '[object Function]')
      return !e.name || e.name === '' ? '[Function]' : '[Function: ' + e.name + ']';
    if (r === '[object Array]') return '[ Array(' + e.length + ') ]';
    if (r === '[object Object]') {
      let n = Object.keys(e);
      return (
        '{ Object (' + (n.length > 2 ? n.splice(0, 2).join(', ') + ', ...' : n.join(', ')) + ') }'
      );
    } else return t;
  } else return t;
}
o(kr, 'objDisplay');
G(kr, 'objDisplay');
function ol(e, t) {
  let r = me(e, 'negate'),
    n = me(e, 'object'),
    i = t[3],
    s = ns(e, t),
    a = r ? t[2] : t[1],
    c = me(e, 'message');
  return (
    typeof a == 'function' && (a = a()),
    (a = a || ''),
    (a = a
      .replace(/#\{this\}/g, function () {
        return kr(n);
      })
      .replace(/#\{act\}/g, function () {
        return kr(s);
      })
      .replace(/#\{exp\}/g, function () {
        return kr(i);
      })),
    c ? c + ': ' + a : a
  );
}
o(ol, 'getMessage2');
G(ol, 'getMessage');
function Ft(e, t, r) {
  let n = e.__flags || (e.__flags = Object.create(null));
  (t.__flags || (t.__flags = Object.create(null)), (r = arguments.length === 3 ? r : !0));
  for (let i in n)
    (r || (i !== 'object' && i !== 'ssfi' && i !== 'lockSsfi' && i != 'message')) &&
      (t.__flags[i] = n[i]);
}
o(Ft, 'transferFlags');
G(Ft, 'transferFlags');
function ea(e) {
  if (typeof e > 'u') return 'undefined';
  if (e === null) return 'null';
  const t = e[Symbol.toStringTag];
  return typeof t == 'string' ? t : Object.prototype.toString.call(e).slice(8, -1);
}
o(ea, 'type2');
G(ea, 'type');
function il() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}
o(il, 'FakeMap');
G(il, 'FakeMap');
il.prototype = {
  get: G(
    o(function (t) {
      return t[this._key];
    }, 'get'),
    'get',
  ),
  set: G(
    o(function (t, r) {
      Object.isExtensible(t) && Object.defineProperty(t, this._key, { value: r, configurable: !0 });
    }, 'set'),
    'set',
  ),
};
var eS = typeof WeakMap == 'function' ? WeakMap : il;
function ta(e, t, r) {
  if (!r || Ur(e) || Ur(t)) return null;
  var n = r.get(e);
  if (n) {
    var i = n.get(t);
    if (typeof i == 'boolean') return i;
  }
  return null;
}
o(ta, 'memoizeCompare');
G(ta, 'memoizeCompare');
function $n(e, t, r, n) {
  if (!(!r || Ur(e) || Ur(t))) {
    var i = r.get(e);
    i ? i.set(t, n) : ((i = new eS()), i.set(t, n), r.set(e, i));
  }
}
o($n, 'memoizeSet');
G($n, 'memoizeSet');
var tS = wo;
function wo(e, t, r) {
  if (r && r.comparator) return ra(e, t, r);
  var n = sl(e, t);
  return n !== null ? n : ra(e, t, r);
}
o(wo, 'deepEqual');
G(wo, 'deepEqual');
function sl(e, t) {
  return e === t
    ? e !== 0 || 1 / e === 1 / t
    : e !== e && t !== t
      ? !0
      : Ur(e) || Ur(t)
        ? !1
        : null;
}
o(sl, 'simpleEqual');
G(sl, 'simpleEqual');
function ra(e, t, r) {
  ((r = r || {}), (r.memoize = r.memoize === !1 ? !1 : r.memoize || new eS()));
  var n = r && r.comparator,
    i = ta(e, t, r.memoize);
  if (i !== null) return i;
  var s = ta(t, e, r.memoize);
  if (s !== null) return s;
  if (n) {
    var a = n(e, t);
    if (a === !1 || a === !0) return ($n(e, t, r.memoize, a), a);
    var c = sl(e, t);
    if (c !== null) return c;
  }
  var d = ea(e);
  if (d !== ea(t)) return ($n(e, t, r.memoize, !1), !1);
  $n(e, t, r.memoize, !0);
  var u = Tf(e, t, d, r);
  return ($n(e, t, r.memoize, u), u);
}
o(ra, 'extensiveDeepEqual');
G(ra, 'extensiveDeepEqual');
function Tf(e, t, r, n) {
  switch (r) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      return wo(e.valueOf(), t.valueOf());
    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
      return e === t;
    case 'Error':
      return al(e, t, ['name', 'message', 'code'], n);
    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return Sr(e, t, n);
    case 'RegExp':
      return wf(e, t);
    case 'Generator':
      return Sf(e, t, n);
    case 'DataView':
      return Sr(new Uint8Array(e.buffer), new Uint8Array(t.buffer), n);
    case 'ArrayBuffer':
      return Sr(new Uint8Array(e), new Uint8Array(t), n);
    case 'Set':
      return na(e, t, n);
    case 'Map':
      return na(e, t, n);
    case 'Temporal.PlainDate':
    case 'Temporal.PlainTime':
    case 'Temporal.PlainDateTime':
    case 'Temporal.Instant':
    case 'Temporal.ZonedDateTime':
    case 'Temporal.PlainYearMonth':
    case 'Temporal.PlainMonthDay':
      return e.equals(t);
    case 'Temporal.Duration':
      return e.total('nanoseconds') === t.total('nanoseconds');
    case 'Temporal.TimeZone':
    case 'Temporal.Calendar':
      return e.toString() === t.toString();
    default:
      return Rf(e, t, n);
  }
}
o(Tf, 'extensiveDeepEqualByType');
G(Tf, 'extensiveDeepEqualByType');
function wf(e, t) {
  return e.toString() === t.toString();
}
o(wf, 'regexpEqual');
G(wf, 'regexpEqual');
function na(e, t, r) {
  try {
    if (e.size !== t.size) return !1;
    if (e.size === 0) return !0;
  } catch {
    return !1;
  }
  var n = [],
    i = [];
  return (
    e.forEach(
      G(
        o(function (a, c) {
          n.push([a, c]);
        }, 'gatherEntries'),
        'gatherEntries',
      ),
    ),
    t.forEach(
      G(
        o(function (a, c) {
          i.push([a, c]);
        }, 'gatherEntries'),
        'gatherEntries',
      ),
    ),
    Sr(n.sort(), i.sort(), r)
  );
}
o(na, 'entriesEqual');
G(na, 'entriesEqual');
function Sr(e, t, r) {
  var n = e.length;
  if (n !== t.length) return !1;
  if (n === 0) return !0;
  for (var i = -1; ++i < n; ) if (wo(e[i], t[i], r) === !1) return !1;
  return !0;
}
o(Sr, 'iterableEqual');
G(Sr, 'iterableEqual');
function Sf(e, t, r) {
  return Sr(ki(e), ki(t), r);
}
o(Sf, 'generatorEqual');
G(Sf, 'generatorEqual');
function _f(e) {
  return (
    typeof Symbol < 'u' &&
    typeof e == 'object' &&
    typeof Symbol.iterator < 'u' &&
    typeof e[Symbol.iterator] == 'function'
  );
}
o(_f, 'hasIteratorFunction');
G(_f, 'hasIteratorFunction');
function oa(e) {
  if (_f(e))
    try {
      return ki(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
o(oa, 'getIteratorEntries');
G(oa, 'getIteratorEntries');
function ki(e) {
  for (var t = e.next(), r = [t.value]; t.done === !1; ) ((t = e.next()), r.push(t.value));
  return r;
}
o(ki, 'getGeneratorEntries');
G(ki, 'getGeneratorEntries');
function ia(e) {
  var t = [];
  for (var r in e) t.push(r);
  return t;
}
o(ia, 'getEnumerableKeys');
G(ia, 'getEnumerableKeys');
function sa(e) {
  for (var t = [], r = Object.getOwnPropertySymbols(e), n = 0; n < r.length; n += 1) {
    var i = r[n];
    Object.getOwnPropertyDescriptor(e, i).enumerable && t.push(i);
  }
  return t;
}
o(sa, 'getEnumerableSymbols');
G(sa, 'getEnumerableSymbols');
function al(e, t, r, n) {
  var i = r.length;
  if (i === 0) return !0;
  for (var s = 0; s < i; s += 1) if (wo(e[r[s]], t[r[s]], n) === !1) return !1;
  return !0;
}
o(al, 'keysEqual');
G(al, 'keysEqual');
function Rf(e, t, r) {
  var n = ia(e),
    i = ia(t),
    s = sa(e),
    a = sa(t);
  if (((n = n.concat(s)), (i = i.concat(a)), n.length && n.length === i.length))
    return Sr(aa(n).sort(), aa(i).sort()) === !1 ? !1 : al(e, t, n, r);
  var c = oa(e),
    d = oa(t);
  return c.length && c.length === d.length
    ? (c.sort(), d.sort(), Sr(c, d, r))
    : n.length === 0 && c.length === 0 && i.length === 0 && d.length === 0;
}
o(Rf, 'objectEqual');
G(Rf, 'objectEqual');
function Ur(e) {
  return e === null || typeof e != 'object';
}
o(Ur, 'isPrimitive');
G(Ur, 'isPrimitive');
function aa(e) {
  return e.map(
    G(
      o(function (r) {
        return typeof r == 'symbol' ? r.toString() : r;
      }, 'mapSymbol'),
      'mapSymbol',
    ),
  );
}
o(aa, 'mapSymbols');
G(aa, 'mapSymbols');
function os(e, t) {
  return typeof e > 'u' || e === null ? !1 : t in Object(e);
}
o(os, 'hasProperty');
G(os, 'hasProperty');
function Pf(e) {
  return e
    .replace(/([^\\])\[/g, '$1.[')
    .match(/(\\\.|[^.]+?)+/g)
    .map((n) => {
      if (n === 'constructor' || n === '__proto__' || n === 'prototype') return {};
      const s = /^\[(\d+)\]$/.exec(n);
      let a = null;
      return (s ? (a = { i: parseFloat(s[1]) }) : (a = { p: n.replace(/\\([.[\]])/g, '$1') }), a);
    });
}
o(Pf, 'parsePath');
G(Pf, 'parsePath');
function la(e, t, r) {
  let n = e,
    i = null;
  r = typeof r > 'u' ? t.length : r;
  for (let s = 0; s < r; s++) {
    const a = t[s];
    n && (typeof a.p > 'u' ? (n = n[a.i]) : (n = n[a.p]), s === r - 1 && (i = n));
  }
  return i;
}
o(la, 'internalGetPathValue');
G(la, 'internalGetPathValue');
function ll(e, t) {
  const r = Pf(t),
    n = r[r.length - 1],
    i = { parent: r.length > 1 ? la(e, r, r.length - 1) : e, name: n.p || n.i, value: la(e, r) };
  return ((i.exists = os(i.parent, i.name)), i);
}
o(ll, 'getPathInfo');
G(ll, 'getPathInfo');
var ii,
  q =
    ((ii = class {
      constructor(e, t, r, n) {
        Le(this, '__flags', {});
        return (
          me(this, 'ssfi', r || ii),
          me(this, 'lockSsfi', n),
          me(this, 'object', e),
          me(this, 'message', t),
          me(this, 'eql', gt.deepEqual || tS),
          In(this)
        );
      }
      static get includeStack() {
        return (
          console.warn(
            'Assertion.includeStack is deprecated, use chai.config.includeStack instead.',
          ),
          gt.includeStack
        );
      }
      static set includeStack(e) {
        (console.warn(
          'Assertion.includeStack is deprecated, use chai.config.includeStack instead.',
        ),
          (gt.includeStack = e));
      }
      static get showDiff() {
        return (
          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.'),
          gt.showDiff
        );
      }
      static set showDiff(e) {
        (console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.'),
          (gt.showDiff = e));
      }
      static addProperty(e, t) {
        cl(this.prototype, e, t);
      }
      static addMethod(e, t) {
        ul(this.prototype, e, t);
      }
      static addChainableMethod(e, t, r) {
        fl(this.prototype, e, t, r);
      }
      static overwriteProperty(e, t) {
        dl(this.prototype, e, t);
      }
      static overwriteMethod(e, t) {
        pl(this.prototype, e, t);
      }
      static overwriteChainableMethod(e, t, r) {
        ml(this.prototype, e, t, r);
      }
      assert(e, t, r, n, i, s) {
        const a = rl(this, arguments);
        if (
          (s !== !1 && (s = !0),
          n === void 0 && i === void 0 && (s = !1),
          gt.showDiff !== !0 && (s = !1),
          !a)
        ) {
          t = ol(this, arguments);
          const d = { actual: ns(this, arguments), expected: n, showDiff: s },
            u = gl(this, arguments);
          throw (
            u && (d.operator = u),
            new Pe(t, d, gt.includeStack ? this.assert : me(this, 'ssfi'))
          );
        }
      }
      get _obj() {
        return me(this, 'object');
      }
      set _obj(e) {
        me(this, 'object', e);
      }
    }),
    o(ii, '_Assertion'),
    G(ii, 'Assertion'),
    ii);
function So() {
  return gt.useProxy && typeof Proxy < 'u' && typeof Reflect < 'u';
}
o(So, 'isProxyEnabled');
G(So, 'isProxyEnabled');
function cl(e, t, r) {
  ((r = r === void 0 ? function () {} : r),
    Object.defineProperty(e, t, {
      get: G(
        o(function n() {
          !So() && !me(this, 'lockSsfi') && me(this, 'ssfi', n);
          let i = r.call(this);
          if (i !== void 0) return i;
          let s = new q();
          return (Ft(this, s), s);
        }, 'propertyGetter'),
        'propertyGetter',
      ),
      configurable: !0,
    }));
}
o(cl, 'addProperty');
G(cl, 'addProperty');
var AF = Object.getOwnPropertyDescriptor(function () {}, 'length');
function _o(e, t, r) {
  return (
    AF.configurable &&
      Object.defineProperty(e, 'length', {
        get: G(function () {
          throw Error(
            r
              ? 'Invalid Chai property: ' +
                  t +
                  '.length. Due to a compatibility issue, "length" cannot directly follow "' +
                  t +
                  '". Use "' +
                  t +
                  '.lengthOf" instead.'
              : 'Invalid Chai property: ' +
                  t +
                  '.length. See docs for proper usage of "' +
                  t +
                  '".',
          );
        }, 'get'),
      }),
    e
  );
}
o(_o, 'addLengthGuard');
G(_o, 'addLengthGuard');
function Af(e) {
  let t = Object.getOwnPropertyNames(e);
  function r(i) {
    t.indexOf(i) === -1 && t.push(i);
  }
  (o(r, 'addProperty2'), G(r, 'addProperty'));
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) (Object.getOwnPropertyNames(n).forEach(r), (n = Object.getPrototypeOf(n)));
  return t;
}
o(Af, 'getProperties');
G(Af, 'getProperties');
var Wh = ['__flags', '__methods', '_obj', 'assert'];
function In(e, t) {
  return So()
    ? new Proxy(e, {
        get: G(
          o(function r(n, i) {
            if (
              typeof i == 'string' &&
              gt.proxyExcludedKeys.indexOf(i) === -1 &&
              !Reflect.has(n, i)
            ) {
              if (t)
                throw Error(
                  'Invalid Chai property: ' +
                    t +
                    '.' +
                    i +
                    '. See docs for proper usage of "' +
                    t +
                    '".',
                );
              let s = null,
                a = 4;
              throw (
                Af(n).forEach(function (c) {
                  if (!Object.prototype.hasOwnProperty(c) && Wh.indexOf(c) === -1) {
                    let d = Of(i, c, a);
                    d < a && ((s = c), (a = d));
                  }
                }),
                Error(
                  s !== null
                    ? 'Invalid Chai property: ' + i + '. Did you mean "' + s + '"?'
                    : 'Invalid Chai property: ' + i,
                )
              );
            }
            return (
              Wh.indexOf(i) === -1 && !me(n, 'lockSsfi') && me(n, 'ssfi', r),
              Reflect.get(n, i)
            );
          }, 'proxyGetter'),
          'proxyGetter',
        ),
      })
    : e;
}
o(In, 'proxify');
G(In, 'proxify');
function Of(e, t, r) {
  if (Math.abs(e.length - t.length) >= r) return r;
  let n = [];
  for (let i = 0; i <= e.length; i++) ((n[i] = Array(t.length + 1).fill(0)), (n[i][0] = i));
  for (let i = 0; i < t.length; i++) n[0][i] = i;
  for (let i = 1; i <= e.length; i++) {
    let s = e.charCodeAt(i - 1);
    for (let a = 1; a <= t.length; a++) {
      if (Math.abs(i - a) >= r) {
        n[i][a] = r;
        continue;
      }
      n[i][a] = Math.min(
        n[i - 1][a] + 1,
        n[i][a - 1] + 1,
        n[i - 1][a - 1] + (s === t.charCodeAt(a - 1) ? 0 : 1),
      );
    }
  }
  return n[e.length][t.length];
}
o(Of, 'stringDistanceCapped');
G(Of, 'stringDistanceCapped');
function ul(e, t, r) {
  let n = G(function () {
    me(this, 'lockSsfi') || me(this, 'ssfi', n);
    let i = r.apply(this, arguments);
    if (i !== void 0) return i;
    let s = new q();
    return (Ft(this, s), s);
  }, 'methodWrapper');
  (_o(n, t, !1), (e[t] = In(n, t)));
}
o(ul, 'addMethod');
G(ul, 'addMethod');
function dl(e, t, r) {
  let n = Object.getOwnPropertyDescriptor(e, t),
    i = G(function () {}, '_super');
  (n && typeof n.get == 'function' && (i = n.get),
    Object.defineProperty(e, t, {
      get: G(
        o(function s() {
          !So() && !me(this, 'lockSsfi') && me(this, 'ssfi', s);
          let a = me(this, 'lockSsfi');
          me(this, 'lockSsfi', !0);
          let c = r(i).call(this);
          if ((me(this, 'lockSsfi', a), c !== void 0)) return c;
          let d = new q();
          return (Ft(this, d), d);
        }, 'overwritingPropertyGetter'),
        'overwritingPropertyGetter',
      ),
      configurable: !0,
    }));
}
o(dl, 'overwriteProperty');
G(dl, 'overwriteProperty');
function pl(e, t, r) {
  let n = e[t],
    i = G(function () {
      throw new Error(t + ' is not a function');
    }, '_super');
  n && typeof n == 'function' && (i = n);
  let s = G(function () {
    me(this, 'lockSsfi') || me(this, 'ssfi', s);
    let a = me(this, 'lockSsfi');
    me(this, 'lockSsfi', !0);
    let c = r(i).apply(this, arguments);
    if ((me(this, 'lockSsfi', a), c !== void 0)) return c;
    let d = new q();
    return (Ft(this, d), d);
  }, 'overwritingMethodWrapper');
  (_o(s, t, !1), (e[t] = In(s, t)));
}
o(pl, 'overwriteMethod');
G(pl, 'overwriteMethod');
var OF = typeof Object.setPrototypeOf == 'function',
  Kh = G(function () {}, 'testFn'),
  CF = Object.getOwnPropertyNames(Kh).filter(function (e) {
    let t = Object.getOwnPropertyDescriptor(Kh, e);
    return typeof t != 'object' ? !0 : !t.configurable;
  }),
  xF = Function.prototype.call,
  NF = Function.prototype.apply;
function fl(e, t, r, n) {
  typeof n != 'function' && (n = G(function () {}, 'chainingBehavior'));
  let i = { method: r, chainingBehavior: n };
  (e.__methods || (e.__methods = {}),
    (e.__methods[t] = i),
    Object.defineProperty(e, t, {
      get: G(
        o(function () {
          i.chainingBehavior.call(this);
          let a = G(function () {
            me(this, 'lockSsfi') || me(this, 'ssfi', a);
            let c = i.method.apply(this, arguments);
            if (c !== void 0) return c;
            let d = new q();
            return (Ft(this, d), d);
          }, 'chainableMethodWrapper');
          if ((_o(a, t, !0), OF)) {
            let c = Object.create(this);
            ((c.call = xF), (c.apply = NF), Object.setPrototypeOf(a, c));
          } else
            Object.getOwnPropertyNames(e).forEach(function (d) {
              if (CF.indexOf(d) !== -1) return;
              let u = Object.getOwnPropertyDescriptor(e, d);
              Object.defineProperty(a, d, u);
            });
          return (Ft(this, a), In(a));
        }, 'chainableMethodGetter'),
        'chainableMethodGetter',
      ),
      configurable: !0,
    }));
}
o(fl, 'addChainableMethod');
G(fl, 'addChainableMethod');
function ml(e, t, r, n) {
  let i = e.__methods[t],
    s = i.chainingBehavior;
  i.chainingBehavior = G(
    o(function () {
      let d = n(s).call(this);
      if (d !== void 0) return d;
      let u = new q();
      return (Ft(this, u), u);
    }, 'overwritingChainableMethodGetter'),
    'overwritingChainableMethodGetter',
  );
  let a = i.method;
  i.method = G(
    o(function () {
      let d = r(a).apply(this, arguments);
      if (d !== void 0) return d;
      let u = new q();
      return (Ft(this, u), u);
    }, 'overwritingChainableMethodWrapper'),
    'overwritingChainableMethodWrapper',
  );
}
o(ml, 'overwriteChainableMethod');
G(ml, 'overwriteChainableMethod');
function Di(e, t) {
  return Se(e) < Se(t) ? -1 : 1;
}
o(Di, 'compareByInspect');
G(Di, 'compareByInspect');
function yl(e) {
  return typeof Object.getOwnPropertySymbols != 'function'
    ? []
    : Object.getOwnPropertySymbols(e).filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable;
      });
}
o(yl, 'getOwnEnumerablePropertySymbols');
G(yl, 'getOwnEnumerablePropertySymbols');
function hl(e) {
  return Object.keys(e).concat(yl(e));
}
o(hl, 'getOwnEnumerableProperties');
G(hl, 'getOwnEnumerableProperties');
var ca = Number.isNaN;
function Cf(e) {
  let t = xe(e);
  return ['Array', 'Object', 'Function'].indexOf(t) !== -1;
}
o(Cf, 'isObjectType');
G(Cf, 'isObjectType');
function gl(e, t) {
  let r = me(e, 'operator'),
    n = me(e, 'negate'),
    i = t[3],
    s = n ? t[2] : t[1];
  if (r) return r;
  if ((typeof s == 'function' && (s = s()), (s = s || ''), !s || /\shave\s/.test(s))) return;
  let a = Cf(i);
  return /\snot\s/.test(s)
    ? a
      ? 'notDeepStrictEqual'
      : 'notStrictEqual'
    : a
      ? 'deepStrictEqual'
      : 'strictEqual';
}
o(gl, 'getOperator');
G(gl, 'getOperator');
function is(e) {
  return e.name;
}
o(is, 'getName');
G(is, 'getName');
function Li(e) {
  return Object.prototype.toString.call(e) === '[object RegExp]';
}
o(Li, 'isRegExp2');
G(Li, 'isRegExp');
function rt(e) {
  return ['Number', 'BigInt'].includes(xe(e));
}
o(rt, 'isNumeric');
G(rt, 'isNumeric');
var { flag: U } = Zt;
[
  'to',
  'be',
  'been',
  'is',
  'and',
  'has',
  'have',
  'with',
  'that',
  'which',
  'at',
  'of',
  'same',
  'but',
  'does',
  'still',
  'also',
].forEach(function (e) {
  q.addProperty(e);
});
q.addProperty('not', function () {
  U(this, 'negate', !0);
});
q.addProperty('deep', function () {
  U(this, 'deep', !0);
});
q.addProperty('nested', function () {
  U(this, 'nested', !0);
});
q.addProperty('own', function () {
  U(this, 'own', !0);
});
q.addProperty('ordered', function () {
  U(this, 'ordered', !0);
});
q.addProperty('any', function () {
  (U(this, 'any', !0), U(this, 'all', !1));
});
q.addProperty('all', function () {
  (U(this, 'all', !0), U(this, 'any', !1));
});
var Yh = {
  function: ['function', 'asyncfunction', 'generatorfunction', 'asyncgeneratorfunction'],
  asyncfunction: ['asyncfunction', 'asyncgeneratorfunction'],
  generatorfunction: ['generatorfunction', 'asyncgeneratorfunction'],
  asyncgeneratorfunction: ['asyncgeneratorfunction'],
};
function bl(e, t) {
  (t && U(this, 'message', t), (e = e.toLowerCase()));
  let r = U(this, 'object'),
    n = ~['a', 'e', 'i', 'o', 'u'].indexOf(e.charAt(0)) ? 'an ' : 'a ';
  const i = xe(r).toLowerCase();
  Yh.function.includes(e)
    ? this.assert(
        Yh[e].includes(i),
        'expected #{this} to be ' + n + e,
        'expected #{this} not to be ' + n + e,
      )
    : this.assert(
        e === i,
        'expected #{this} to be ' + n + e,
        'expected #{this} not to be ' + n + e,
      );
}
o(bl, 'an');
G(bl, 'an');
q.addChainableMethod('an', bl);
q.addChainableMethod('a', bl);
function xf(e, t) {
  return (ca(e) && ca(t)) || e === t;
}
o(xf, 'SameValueZero');
G(xf, 'SameValueZero');
function Ro() {
  U(this, 'contains', !0);
}
o(Ro, 'includeChainingBehavior');
G(Ro, 'includeChainingBehavior');
function Po(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = xe(r).toLowerCase(),
    i = U(this, 'message'),
    s = U(this, 'negate'),
    a = U(this, 'ssfi'),
    c = U(this, 'deep'),
    d = c ? 'deep ' : '',
    u = c ? U(this, 'eql') : xf;
  i = i ? i + ': ' : '';
  let p = !1;
  switch (n) {
    case 'string':
      p = r.indexOf(e) !== -1;
      break;
    case 'weakset':
      if (c) throw new Pe(i + 'unable to use .deep.include with WeakSet', void 0, a);
      p = r.has(e);
      break;
    case 'map':
      r.forEach(function (f) {
        p = p || u(f, e);
      });
      break;
    case 'set':
      c
        ? r.forEach(function (f) {
            p = p || u(f, e);
          })
        : (p = r.has(e));
      break;
    case 'array':
      c
        ? (p = r.some(function (f) {
            return u(f, e);
          }))
        : (p = r.indexOf(e) !== -1);
      break;
    default: {
      if (e !== Object(e))
        throw new Pe(
          i +
            'the given combination of arguments (' +
            n +
            ' and ' +
            xe(e).toLowerCase() +
            ') is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a ' +
            xe(e).toLowerCase(),
          void 0,
          a,
        );
      let f = Object.keys(e),
        y = null,
        h = 0;
      if (
        (f.forEach(function (g) {
          let T = new q(r);
          if ((Ft(this, T, !0), U(T, 'lockSsfi', !0), !s || f.length === 1)) {
            T.property(g, e[g]);
            return;
          }
          try {
            T.property(g, e[g]);
          } catch (E) {
            if (!_t.compatibleConstructor(E, Pe)) throw E;
            (y === null && (y = E), h++);
          }
        }, this),
        s && f.length > 1 && h === f.length)
      )
        throw y;
      return;
    }
  }
  this.assert(
    p,
    'expected #{this} to ' + d + 'include ' + Se(e),
    'expected #{this} to not ' + d + 'include ' + Se(e),
  );
}
o(Po, 'include');
G(Po, 'include');
q.addChainableMethod('include', Po, Ro);
q.addChainableMethod('contain', Po, Ro);
q.addChainableMethod('contains', Po, Ro);
q.addChainableMethod('includes', Po, Ro);
q.addProperty('ok', function () {
  this.assert(U(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
});
q.addProperty('true', function () {
  this.assert(
    U(this, 'object') === !0,
    'expected #{this} to be true',
    'expected #{this} to be false',
    !U(this, 'negate'),
  );
});
q.addProperty('numeric', function () {
  const e = U(this, 'object');
  this.assert(
    ['Number', 'BigInt'].includes(xe(e)),
    'expected #{this} to be numeric',
    'expected #{this} to not be numeric',
    !U(this, 'negate'),
  );
});
q.addProperty('callable', function () {
  const e = U(this, 'object'),
    t = U(this, 'ssfi'),
    r = U(this, 'message'),
    n = r ? `${r}: ` : '',
    i = U(this, 'negate'),
    s = i
      ? `${n}expected ${Se(e)} not to be a callable function`
      : `${n}expected ${Se(e)} to be a callable function`,
    a = ['Function', 'AsyncFunction', 'GeneratorFunction', 'AsyncGeneratorFunction'].includes(
      xe(e),
    );
  if ((a && i) || (!a && !i)) throw new Pe(s, void 0, t);
});
q.addProperty('false', function () {
  this.assert(
    U(this, 'object') === !1,
    'expected #{this} to be false',
    'expected #{this} to be true',
    !!U(this, 'negate'),
  );
});
q.addProperty('null', function () {
  this.assert(
    U(this, 'object') === null,
    'expected #{this} to be null',
    'expected #{this} not to be null',
  );
});
q.addProperty('undefined', function () {
  this.assert(
    U(this, 'object') === void 0,
    'expected #{this} to be undefined',
    'expected #{this} not to be undefined',
  );
});
q.addProperty('NaN', function () {
  this.assert(
    ca(U(this, 'object')),
    'expected #{this} to be NaN',
    'expected #{this} not to be NaN',
  );
});
function vl() {
  let e = U(this, 'object');
  this.assert(e != null, 'expected #{this} to exist', 'expected #{this} to not exist');
}
o(vl, 'assertExist');
G(vl, 'assertExist');
q.addProperty('exist', vl);
q.addProperty('exists', vl);
q.addProperty('empty', function () {
  let e = U(this, 'object'),
    t = U(this, 'ssfi'),
    r = U(this, 'message'),
    n;
  switch (((r = r ? r + ': ' : ''), xe(e).toLowerCase())) {
    case 'array':
    case 'string':
      n = e.length;
      break;
    case 'map':
    case 'set':
      n = e.size;
      break;
    case 'weakmap':
    case 'weakset':
      throw new Pe(r + '.empty was passed a weak collection', void 0, t);
    case 'function': {
      const i = r + '.empty was passed a function ' + is(e);
      throw new Pe(i.trim(), void 0, t);
    }
    default:
      if (e !== Object(e))
        throw new Pe(r + '.empty was passed non-string primitive ' + Se(e), void 0, t);
      n = Object.keys(e).length;
  }
  this.assert(n === 0, 'expected #{this} to be empty', 'expected #{this} not to be empty');
});
function El() {
  let e = U(this, 'object'),
    t = xe(e);
  this.assert(
    t === 'Arguments',
    'expected #{this} to be arguments but got ' + t,
    'expected #{this} to not be arguments',
  );
}
o(El, 'checkArguments');
G(El, 'checkArguments');
q.addProperty('arguments', El);
q.addProperty('Arguments', El);
function ss(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object');
  if (U(this, 'deep')) {
    let n = U(this, 'lockSsfi');
    (U(this, 'lockSsfi', !0), this.eql(e), U(this, 'lockSsfi', n));
  } else
    this.assert(
      e === r,
      'expected #{this} to equal #{exp}',
      'expected #{this} to not equal #{exp}',
      e,
      this._obj,
      !0,
    );
}
o(ss, 'assertEqual');
G(ss, 'assertEqual');
q.addMethod('equal', ss);
q.addMethod('equals', ss);
q.addMethod('eq', ss);
function Tl(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'eql');
  this.assert(
    r(e, U(this, 'object')),
    'expected #{this} to deeply equal #{exp}',
    'expected #{this} to not deeply equal #{exp}',
    e,
    this._obj,
    !0,
  );
}
o(Tl, 'assertEql');
G(Tl, 'assertEql');
q.addMethod('eql', Tl);
q.addMethod('eqls', Tl);
function as(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    i = U(this, 'message'),
    s = i ? i + ': ' : '',
    a = U(this, 'ssfi'),
    c = xe(r).toLowerCase(),
    d = xe(e).toLowerCase();
  if (
    (n && c !== 'map' && c !== 'set' && new q(r, i, a, !0).to.have.property('length'),
    !n && c === 'date' && d !== 'date')
  )
    throw new Pe(s + 'the argument to above must be a date', void 0, a);
  if (!rt(e) && (n || rt(r))) throw new Pe(s + 'the argument to above must be a number', void 0, a);
  if (!n && c !== 'date' && !rt(r)) {
    let u = c === 'string' ? "'" + r + "'" : r;
    throw new Pe(s + 'expected ' + u + ' to be a number or a date', void 0, a);
  }
  if (n) {
    let u = 'length',
      p;
    (c === 'map' || c === 'set' ? ((u = 'size'), (p = r.size)) : (p = r.length),
      this.assert(
        p > e,
        'expected #{this} to have a ' + u + ' above #{exp} but got #{act}',
        'expected #{this} to not have a ' + u + ' above #{exp}',
        e,
        p,
      ));
  } else
    this.assert(
      r > e,
      'expected #{this} to be above #{exp}',
      'expected #{this} to be at most #{exp}',
      e,
    );
}
o(as, 'assertAbove');
G(as, 'assertAbove');
q.addMethod('above', as);
q.addMethod('gt', as);
q.addMethod('greaterThan', as);
function ls(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    i = U(this, 'message'),
    s = i ? i + ': ' : '',
    a = U(this, 'ssfi'),
    c = xe(r).toLowerCase(),
    d = xe(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && c !== 'map' && c !== 'set' && new q(r, i, a, !0).to.have.property('length'),
    !n && c === 'date' && d !== 'date')
  )
    u = s + 'the argument to least must be a date';
  else if (!rt(e) && (n || rt(r))) u = s + 'the argument to least must be a number';
  else if (!n && c !== 'date' && !rt(r)) {
    let f = c === 'string' ? "'" + r + "'" : r;
    u = s + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Pe(u, void 0, a);
  if (n) {
    let f = 'length',
      y;
    (c === 'map' || c === 'set' ? ((f = 'size'), (y = r.size)) : (y = r.length),
      this.assert(
        y >= e,
        'expected #{this} to have a ' + f + ' at least #{exp} but got #{act}',
        'expected #{this} to have a ' + f + ' below #{exp}',
        e,
        y,
      ));
  } else
    this.assert(
      r >= e,
      'expected #{this} to be at least #{exp}',
      'expected #{this} to be below #{exp}',
      e,
    );
}
o(ls, 'assertLeast');
G(ls, 'assertLeast');
q.addMethod('least', ls);
q.addMethod('gte', ls);
q.addMethod('greaterThanOrEqual', ls);
function cs(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    i = U(this, 'message'),
    s = i ? i + ': ' : '',
    a = U(this, 'ssfi'),
    c = xe(r).toLowerCase(),
    d = xe(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && c !== 'map' && c !== 'set' && new q(r, i, a, !0).to.have.property('length'),
    !n && c === 'date' && d !== 'date')
  )
    u = s + 'the argument to below must be a date';
  else if (!rt(e) && (n || rt(r))) u = s + 'the argument to below must be a number';
  else if (!n && c !== 'date' && !rt(r)) {
    let f = c === 'string' ? "'" + r + "'" : r;
    u = s + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Pe(u, void 0, a);
  if (n) {
    let f = 'length',
      y;
    (c === 'map' || c === 'set' ? ((f = 'size'), (y = r.size)) : (y = r.length),
      this.assert(
        y < e,
        'expected #{this} to have a ' + f + ' below #{exp} but got #{act}',
        'expected #{this} to not have a ' + f + ' below #{exp}',
        e,
        y,
      ));
  } else
    this.assert(
      r < e,
      'expected #{this} to be below #{exp}',
      'expected #{this} to be at least #{exp}',
      e,
    );
}
o(cs, 'assertBelow');
G(cs, 'assertBelow');
q.addMethod('below', cs);
q.addMethod('lt', cs);
q.addMethod('lessThan', cs);
function us(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'doLength'),
    i = U(this, 'message'),
    s = i ? i + ': ' : '',
    a = U(this, 'ssfi'),
    c = xe(r).toLowerCase(),
    d = xe(e).toLowerCase(),
    u,
    p = !0;
  if (
    (n && c !== 'map' && c !== 'set' && new q(r, i, a, !0).to.have.property('length'),
    !n && c === 'date' && d !== 'date')
  )
    u = s + 'the argument to most must be a date';
  else if (!rt(e) && (n || rt(r))) u = s + 'the argument to most must be a number';
  else if (!n && c !== 'date' && !rt(r)) {
    let f = c === 'string' ? "'" + r + "'" : r;
    u = s + 'expected ' + f + ' to be a number or a date';
  } else p = !1;
  if (p) throw new Pe(u, void 0, a);
  if (n) {
    let f = 'length',
      y;
    (c === 'map' || c === 'set' ? ((f = 'size'), (y = r.size)) : (y = r.length),
      this.assert(
        y <= e,
        'expected #{this} to have a ' + f + ' at most #{exp} but got #{act}',
        'expected #{this} to have a ' + f + ' above #{exp}',
        e,
        y,
      ));
  } else
    this.assert(
      r <= e,
      'expected #{this} to be at most #{exp}',
      'expected #{this} to be above #{exp}',
      e,
    );
}
o(us, 'assertMost');
G(us, 'assertMost');
q.addMethod('most', us);
q.addMethod('lte', us);
q.addMethod('lessThanOrEqual', us);
q.addMethod('within', function (e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    i = U(this, 'doLength'),
    s = U(this, 'message'),
    a = s ? s + ': ' : '',
    c = U(this, 'ssfi'),
    d = xe(n).toLowerCase(),
    u = xe(e).toLowerCase(),
    p = xe(t).toLowerCase(),
    f,
    y = !0,
    h = u === 'date' && p === 'date' ? e.toISOString() + '..' + t.toISOString() : e + '..' + t;
  if (
    (i && d !== 'map' && d !== 'set' && new q(n, s, c, !0).to.have.property('length'),
    !i && d === 'date' && (u !== 'date' || p !== 'date'))
  )
    f = a + 'the arguments to within must be dates';
  else if ((!rt(e) || !rt(t)) && (i || rt(n))) f = a + 'the arguments to within must be numbers';
  else if (!i && d !== 'date' && !rt(n)) {
    let g = d === 'string' ? "'" + n + "'" : n;
    f = a + 'expected ' + g + ' to be a number or a date';
  } else y = !1;
  if (y) throw new Pe(f, void 0, c);
  if (i) {
    let g = 'length',
      T;
    (d === 'map' || d === 'set' ? ((g = 'size'), (T = n.size)) : (T = n.length),
      this.assert(
        T >= e && T <= t,
        'expected #{this} to have a ' + g + ' within ' + h,
        'expected #{this} to not have a ' + g + ' within ' + h,
      ));
  } else
    this.assert(
      n >= e && n <= t,
      'expected #{this} to be within ' + h,
      'expected #{this} to not be within ' + h,
    );
});
function wl(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'ssfi'),
    i = U(this, 'message'),
    s;
  try {
    s = r instanceof e;
  } catch (c) {
    throw c instanceof TypeError
      ? ((i = i ? i + ': ' : ''),
        new Pe(
          i + 'The instanceof assertion needs a constructor but ' + xe(e) + ' was given.',
          void 0,
          n,
        ))
      : c;
  }
  let a = is(e);
  (a == null && (a = 'an unnamed constructor'),
    this.assert(
      s,
      'expected #{this} to be an instance of ' + a,
      'expected #{this} to not be an instance of ' + a,
    ));
}
o(wl, 'assertInstanceOf');
G(wl, 'assertInstanceOf');
q.addMethod('instanceof', wl);
q.addMethod('instanceOf', wl);
function Sl(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'nested'),
    i = U(this, 'own'),
    s = U(this, 'message'),
    a = U(this, 'object'),
    c = U(this, 'ssfi'),
    d = typeof e;
  if (((s = s ? s + ': ' : ''), n)) {
    if (d !== 'string')
      throw new Pe(
        s + 'the argument to property must be a string when using nested syntax',
        void 0,
        c,
      );
  } else if (d !== 'string' && d !== 'number' && d !== 'symbol')
    throw new Pe(s + 'the argument to property must be a string, number, or symbol', void 0, c);
  if (n && i) throw new Pe(s + 'The "nested" and "own" flags cannot be combined.', void 0, c);
  if (a == null) throw new Pe(s + 'Target cannot be null or undefined.', void 0, c);
  let u = U(this, 'deep'),
    p = U(this, 'negate'),
    f = n ? ll(a, e) : null,
    y = n ? f.value : a[e],
    h = u ? U(this, 'eql') : (E, v) => E === v,
    g = '';
  (u && (g += 'deep '), i && (g += 'own '), n && (g += 'nested '), (g += 'property '));
  let T;
  (i ? (T = Object.prototype.hasOwnProperty.call(a, e)) : n ? (T = f.exists) : (T = os(a, e)),
    (!p || arguments.length === 1) &&
      this.assert(
        T,
        'expected #{this} to have ' + g + Se(e),
        'expected #{this} to not have ' + g + Se(e),
      ),
    arguments.length > 1 &&
      this.assert(
        T && h(t, y),
        'expected #{this} to have ' + g + Se(e) + ' of #{exp}, but got #{act}',
        'expected #{this} to not have ' + g + Se(e) + ' of #{act}',
        t,
        y,
      ),
    U(this, 'object', y));
}
o(Sl, 'assertProperty');
G(Sl, 'assertProperty');
q.addMethod('property', Sl);
function _l(e, t, r) {
  (U(this, 'own', !0), Sl.apply(this, arguments));
}
o(_l, 'assertOwnProperty');
G(_l, 'assertOwnProperty');
q.addMethod('ownProperty', _l);
q.addMethod('haveOwnProperty', _l);
function Rl(e, t, r) {
  (typeof t == 'string' && ((r = t), (t = null)), r && U(this, 'message', r));
  let n = U(this, 'object'),
    i = Object.getOwnPropertyDescriptor(Object(n), e),
    s = U(this, 'eql');
  (i && t
    ? this.assert(
        s(t, i),
        'expected the own property descriptor for ' +
          Se(e) +
          ' on #{this} to match ' +
          Se(t) +
          ', got ' +
          Se(i),
        'expected the own property descriptor for ' + Se(e) + ' on #{this} to not match ' + Se(t),
        t,
        i,
        !0,
      )
    : this.assert(
        i,
        'expected #{this} to have an own property descriptor for ' + Se(e),
        'expected #{this} to not have an own property descriptor for ' + Se(e),
      ),
    U(this, 'object', i));
}
o(Rl, 'assertOwnPropertyDescriptor');
G(Rl, 'assertOwnPropertyDescriptor');
q.addMethod('ownPropertyDescriptor', Rl);
q.addMethod('haveOwnPropertyDescriptor', Rl);
function Pl() {
  U(this, 'doLength', !0);
}
o(Pl, 'assertLengthChain');
G(Pl, 'assertLengthChain');
function Al(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = xe(r).toLowerCase(),
    i = U(this, 'message'),
    s = U(this, 'ssfi'),
    a = 'length',
    c;
  switch (n) {
    case 'map':
    case 'set':
      ((a = 'size'), (c = r.size));
      break;
    default:
      (new q(r, i, s, !0).to.have.property('length'), (c = r.length));
  }
  this.assert(
    c == e,
    'expected #{this} to have a ' + a + ' of #{exp} but got #{act}',
    'expected #{this} to not have a ' + a + ' of #{act}',
    e,
    c,
  );
}
o(Al, 'assertLength');
G(Al, 'assertLength');
q.addChainableMethod('length', Al, Pl);
q.addChainableMethod('lengthOf', Al, Pl);
function Ol(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object');
  this.assert(e.exec(r), 'expected #{this} to match ' + e, 'expected #{this} not to match ' + e);
}
o(Ol, 'assertMatch');
G(Ol, 'assertMatch');
q.addMethod('match', Ol);
q.addMethod('matches', Ol);
q.addMethod('string', function (e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    i = U(this, 'ssfi');
  (new q(r, n, i, !0).is.a('string'),
    this.assert(
      ~r.indexOf(e),
      'expected #{this} to contain ' + Se(e),
      'expected #{this} to not contain ' + Se(e),
    ));
});
function Cl(e) {
  let t = U(this, 'object'),
    r = xe(t),
    n = xe(e),
    i = U(this, 'ssfi'),
    s = U(this, 'deep'),
    a,
    c = '',
    d,
    u = !0,
    p = U(this, 'message');
  p = p ? p + ': ' : '';
  let f =
    p +
    'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';
  if (r === 'Map' || r === 'Set')
    ((c = s ? 'deeply ' : ''),
      (d = []),
      t.forEach(function (v, S) {
        d.push(S);
      }),
      n !== 'Array' && (e = Array.prototype.slice.call(arguments)));
  else {
    switch (((d = hl(t)), n)) {
      case 'Array':
        if (arguments.length > 1) throw new Pe(f, void 0, i);
        break;
      case 'Object':
        if (arguments.length > 1) throw new Pe(f, void 0, i);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function (v) {
      return typeof v == 'symbol' ? v : String(v);
    });
  }
  if (!e.length) throw new Pe(p + 'keys required', void 0, i);
  let y = e.length,
    h = U(this, 'any'),
    g = U(this, 'all'),
    T = e,
    E = s ? U(this, 'eql') : (v, S) => v === S;
  if (
    (!h && !g && (g = !0),
    h &&
      (u = T.some(function (v) {
        return d.some(function (S) {
          return E(v, S);
        });
      })),
    g &&
      ((u = T.every(function (v) {
        return d.some(function (S) {
          return E(v, S);
        });
      })),
      U(this, 'contains') || (u = u && e.length == d.length)),
    y > 1)
  ) {
    e = e.map(function (S) {
      return Se(S);
    });
    let v = e.pop();
    (g && (a = e.join(', ') + ', and ' + v), h && (a = e.join(', ') + ', or ' + v));
  } else a = Se(e[0]);
  ((a = (y > 1 ? 'keys ' : 'key ') + a),
    (a = (U(this, 'contains') ? 'contain ' : 'have ') + a),
    this.assert(
      u,
      'expected #{this} to ' + c + a,
      'expected #{this} to not ' + c + a,
      T.slice(0).sort(Di),
      d.sort(Di),
      !0,
    ));
}
o(Cl, 'assertKeys');
G(Cl, 'assertKeys');
q.addMethod('keys', Cl);
q.addMethod('key', Cl);
function ds(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    i = U(this, 'ssfi'),
    s = U(this, 'message'),
    a = U(this, 'negate') || !1;
  (new q(n, s, i, !0).is.a('function'), (Li(e) || typeof e == 'string') && ((t = e), (e = null)));
  let c,
    d = !1;
  try {
    n();
  } catch (h) {
    ((d = !0), (c = h));
  }
  let u = e === void 0 && t === void 0,
    p = !!(e && t),
    f = !1,
    y = !1;
  if (u || (!u && !a)) {
    let h = 'an error';
    e instanceof Error ? (h = '#{exp}') : e && (h = _t.getConstructorName(e));
    let g = c;
    if (c instanceof Error) g = c.toString();
    else if (typeof c == 'string') g = c;
    else if (c && (typeof c == 'object' || typeof c == 'function'))
      try {
        g = _t.getConstructorName(c);
      } catch {}
    this.assert(
      d,
      'expected #{this} to throw ' + h,
      'expected #{this} to not throw an error but #{act} was thrown',
      e && e.toString(),
      g,
    );
  }
  if (
    (e &&
      c &&
      (e instanceof Error &&
        _t.compatibleInstance(c, e) === a &&
        (p && a
          ? (f = !0)
          : this.assert(
              a,
              'expected #{this} to throw #{exp} but #{act} was thrown',
              'expected #{this} to not throw #{exp}' + (c && !a ? ' but #{act} was thrown' : ''),
              e.toString(),
              c.toString(),
            )),
      _t.compatibleConstructor(c, e) === a &&
        (p && a
          ? (f = !0)
          : this.assert(
              a,
              'expected #{this} to throw #{exp} but #{act} was thrown',
              'expected #{this} to not throw #{exp}' + (c ? ' but #{act} was thrown' : ''),
              e instanceof Error ? e.toString() : e && _t.getConstructorName(e),
              c instanceof Error ? c.toString() : c && _t.getConstructorName(c),
            ))),
    c && t !== void 0 && t !== null)
  ) {
    let h = 'including';
    (Li(t) && (h = 'matching'),
      _t.compatibleMessage(c, t) === a &&
        (p && a
          ? (y = !0)
          : this.assert(
              a,
              'expected #{this} to throw error ' + h + ' #{exp} but got #{act}',
              'expected #{this} to throw error not ' + h + ' #{exp}',
              t,
              _t.getMessage(c),
            )));
  }
  (f &&
    y &&
    this.assert(
      a,
      'expected #{this} to throw #{exp} but #{act} was thrown',
      'expected #{this} to not throw #{exp}' + (c ? ' but #{act} was thrown' : ''),
      e instanceof Error ? e.toString() : e && _t.getConstructorName(e),
      c instanceof Error ? c.toString() : c && _t.getConstructorName(c),
    ),
    U(this, 'object', c));
}
o(ds, 'assertThrows');
G(ds, 'assertThrows');
q.addMethod('throw', ds);
q.addMethod('throws', ds);
q.addMethod('Throw', ds);
function xl(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'itself'),
    i = typeof r == 'function' && !n ? r.prototype[e] : r[e];
  this.assert(
    typeof i == 'function',
    'expected #{this} to respond to ' + Se(e),
    'expected #{this} to not respond to ' + Se(e),
  );
}
o(xl, 'respondTo');
G(xl, 'respondTo');
q.addMethod('respondTo', xl);
q.addMethod('respondsTo', xl);
q.addProperty('itself', function () {
  U(this, 'itself', !0);
});
function Nl(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = e(r);
  this.assert(
    n,
    'expected #{this} to satisfy ' + kr(e),
    'expected #{this} to not satisfy' + kr(e),
    !U(this, 'negate'),
    n,
  );
}
o(Nl, 'satisfy');
G(Nl, 'satisfy');
q.addMethod('satisfy', Nl);
q.addMethod('satisfies', Nl);
function Il(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    i = U(this, 'message'),
    s = U(this, 'ssfi');
  new q(n, i, s, !0).is.numeric;
  let a = 'A `delta` value is required for `closeTo`';
  if (t == null) throw new Pe(i ? `${i}: ${a}` : a, void 0, s);
  if (
    (new q(t, i, s, !0).is.numeric, (a = 'A `expected` value is required for `closeTo`'), e == null)
  )
    throw new Pe(i ? `${i}: ${a}` : a, void 0, s);
  new q(e, i, s, !0).is.numeric;
  const c = G((u) => (u < 0n ? -u : u), 'abs'),
    d = G((u) => parseFloat(parseFloat(u).toPrecision(12)), 'strip');
  this.assert(
    d(c(n - e)) <= t,
    'expected #{this} to be close to ' + e + ' +/- ' + t,
    'expected #{this} not to be close to ' + e + ' +/- ' + t,
  );
}
o(Il, 'closeTo');
G(Il, 'closeTo');
q.addMethod('closeTo', Il);
q.addMethod('approximately', Il);
function Nf(e, t, r, n, i) {
  let s = Array.from(t),
    a = Array.from(e);
  if (!n) {
    if (a.length !== s.length) return !1;
    s = s.slice();
  }
  return a.every(function (c, d) {
    if (i) return r ? r(c, s[d]) : c === s[d];
    if (!r) {
      let u = s.indexOf(c);
      return u === -1 ? !1 : (n || s.splice(u, 1), !0);
    }
    return s.some(function (u, p) {
      return r(c, u) ? (n || s.splice(p, 1), !0) : !1;
    });
  });
}
o(Nf, 'isSubsetOf');
G(Nf, 'isSubsetOf');
q.addMethod('members', function (e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    i = U(this, 'ssfi');
  (new q(r, n, i, !0).to.be.iterable, new q(e, n, i, !0).to.be.iterable);
  let s = U(this, 'contains'),
    a = U(this, 'ordered'),
    c,
    d,
    u;
  s
    ? ((c = a ? 'an ordered superset' : 'a superset'),
      (d = 'expected #{this} to be ' + c + ' of #{exp}'),
      (u = 'expected #{this} to not be ' + c + ' of #{exp}'))
    : ((c = a ? 'ordered members' : 'members'),
      (d = 'expected #{this} to have the same ' + c + ' as #{exp}'),
      (u = 'expected #{this} to not have the same ' + c + ' as #{exp}'));
  let p = U(this, 'deep') ? U(this, 'eql') : void 0;
  this.assert(Nf(e, r, p, s, a), d, u, e, r, !0);
});
q.addProperty('iterable', function (e) {
  e && U(this, 'message', e);
  let t = U(this, 'object');
  this.assert(
    t != null && t[Symbol.iterator],
    'expected #{this} to be an iterable',
    'expected #{this} to not be an iterable',
    t,
  );
});
function If(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'object'),
    n = U(this, 'message'),
    i = U(this, 'ssfi'),
    s = U(this, 'contains'),
    a = U(this, 'deep'),
    c = U(this, 'eql');
  (new q(e, n, i, !0).to.be.an('array'),
    s
      ? this.assert(
          e.some(function (d) {
            return r.indexOf(d) > -1;
          }),
          'expected #{this} to contain one of #{exp}',
          'expected #{this} to not contain one of #{exp}',
          e,
          r,
        )
      : a
        ? this.assert(
            e.some(function (d) {
              return c(r, d);
            }),
            'expected #{this} to deeply equal one of #{exp}',
            'expected #{this} to deeply equal one of #{exp}',
            e,
            r,
          )
        : this.assert(
            e.indexOf(r) > -1,
            'expected #{this} to be one of #{exp}',
            'expected #{this} to not be one of #{exp}',
            e,
            r,
          ));
}
o(If, 'oneOf');
G(If, 'oneOf');
q.addMethod('oneOf', If);
function Ml(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    i = U(this, 'message'),
    s = U(this, 'ssfi');
  new q(n, i, s, !0).is.a('function');
  let a;
  (t
    ? (new q(e, i, s, !0).to.have.property(t), (a = e[t]))
    : (new q(e, i, s, !0).is.a('function'), (a = e())),
    n());
  let c = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', c),
    U(this, 'deltaBehavior', 'change'),
    U(this, 'realDelta', c !== a),
    this.assert(a !== c, 'expected ' + d + ' to change', 'expected ' + d + ' to not change'));
}
o(Ml, 'assertChanges');
G(Ml, 'assertChanges');
q.addMethod('change', Ml);
q.addMethod('changes', Ml);
function ql(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    i = U(this, 'message'),
    s = U(this, 'ssfi');
  new q(n, i, s, !0).is.a('function');
  let a;
  (t
    ? (new q(e, i, s, !0).to.have.property(t), (a = e[t]))
    : (new q(e, i, s, !0).is.a('function'), (a = e())),
    new q(a, i, s, !0).is.a('number'),
    n());
  let c = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', c),
    U(this, 'deltaBehavior', 'increase'),
    U(this, 'realDelta', c - a),
    this.assert(c - a > 0, 'expected ' + d + ' to increase', 'expected ' + d + ' to not increase'));
}
o(ql, 'assertIncreases');
G(ql, 'assertIncreases');
q.addMethod('increase', ql);
q.addMethod('increases', ql);
function jl(e, t, r) {
  r && U(this, 'message', r);
  let n = U(this, 'object'),
    i = U(this, 'message'),
    s = U(this, 'ssfi');
  new q(n, i, s, !0).is.a('function');
  let a;
  (t
    ? (new q(e, i, s, !0).to.have.property(t), (a = e[t]))
    : (new q(e, i, s, !0).is.a('function'), (a = e())),
    new q(a, i, s, !0).is.a('number'),
    n());
  let c = t == null ? e() : e[t],
    d = t == null ? a : '.' + t;
  (U(this, 'deltaMsgObj', d),
    U(this, 'initialDeltaValue', a),
    U(this, 'finalDeltaValue', c),
    U(this, 'deltaBehavior', 'decrease'),
    U(this, 'realDelta', a - c),
    this.assert(c - a < 0, 'expected ' + d + ' to decrease', 'expected ' + d + ' to not decrease'));
}
o(jl, 'assertDecreases');
G(jl, 'assertDecreases');
q.addMethod('decrease', jl);
q.addMethod('decreases', jl);
function Mf(e, t) {
  t && U(this, 'message', t);
  let r = U(this, 'deltaMsgObj'),
    n = U(this, 'initialDeltaValue'),
    i = U(this, 'finalDeltaValue'),
    s = U(this, 'deltaBehavior'),
    a = U(this, 'realDelta'),
    c;
  (s === 'change' ? (c = Math.abs(i - n) === Math.abs(e)) : (c = a === Math.abs(e)),
    this.assert(
      c,
      'expected ' + r + ' to ' + s + ' by ' + e,
      'expected ' + r + ' to not ' + s + ' by ' + e,
    ));
}
o(Mf, 'assertDelta');
G(Mf, 'assertDelta');
q.addMethod('by', Mf);
q.addProperty('extensible', function () {
  let e = U(this, 'object'),
    t = e === Object(e) && Object.isExtensible(e);
  this.assert(t, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
});
q.addProperty('sealed', function () {
  let e = U(this, 'object'),
    t = e === Object(e) ? Object.isSealed(e) : !0;
  this.assert(t, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
});
q.addProperty('frozen', function () {
  let e = U(this, 'object'),
    t = e === Object(e) ? Object.isFrozen(e) : !0;
  this.assert(t, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
});
q.addProperty('finite', function (e) {
  let t = U(this, 'object');
  this.assert(
    typeof t == 'number' && isFinite(t),
    'expected #{this} to be a finite number',
    'expected #{this} to not be a finite number',
  );
});
function Fi(e, t) {
  return e === t
    ? !0
    : typeof t != typeof e
      ? !1
      : typeof e != 'object' || e === null
        ? e === t
        : t
          ? Array.isArray(e)
            ? Array.isArray(t)
              ? e.every(function (r) {
                  return t.some(function (n) {
                    return Fi(r, n);
                  });
                })
              : !1
            : e instanceof Date
              ? t instanceof Date
                ? e.getTime() === t.getTime()
                : !1
              : Object.keys(e).every(function (r) {
                  let n = e[r],
                    i = t[r];
                  return typeof n == 'object' && n !== null && i !== null
                    ? Fi(n, i)
                    : typeof n == 'function'
                      ? n(i)
                      : i === n;
                })
          : !1;
}
o(Fi, 'compareSubset');
G(Fi, 'compareSubset');
q.addMethod('containSubset', function (e) {
  const t = me(this, 'object'),
    r = gt.showDiff;
  this.assert(
    Fi(e, t),
    'expected #{act} to contain subset #{exp}',
    'expected #{act} to not contain subset #{exp}',
    e,
    t,
    r,
  );
});
function Dr(e, t) {
  return new q(e, t);
}
o(Dr, 'expect');
G(Dr, 'expect');
Dr.fail = function (e, t, r, n) {
  throw (
    arguments.length < 2 && ((r = e), (e = void 0)),
    (r = r || 'expect.fail()'),
    new Pe(r, { actual: e, expected: t, operator: n }, Dr.fail)
  );
};
var rS = {};
Wp(rS, { Should: o(() => MF, 'Should'), should: o(() => IF, 'should') });
function kl() {
  function e() {
    return this instanceof String ||
      this instanceof Number ||
      this instanceof Boolean ||
      (typeof Symbol == 'function' && this instanceof Symbol) ||
      (typeof BigInt == 'function' && this instanceof BigInt)
      ? new q(this.valueOf(), null, e)
      : new q(this, null, e);
  }
  (o(e, 'shouldGetter'), G(e, 'shouldGetter'));
  function t(n) {
    Object.defineProperty(this, 'should', {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0,
    });
  }
  (o(t, 'shouldSetter'),
    G(t, 'shouldSetter'),
    Object.defineProperty(Object.prototype, 'should', { set: t, get: e, configurable: !0 }));
  let r = {};
  return (
    (r.fail = function (n, i, s, a) {
      throw (
        arguments.length < 2 && ((s = n), (n = void 0)),
        (s = s || 'should.fail()'),
        new Pe(s, { actual: n, expected: i, operator: a }, r.fail)
      );
    }),
    (r.equal = function (n, i, s) {
      new q(n, s).to.equal(i);
    }),
    (r.Throw = function (n, i, s, a) {
      new q(n, a).to.Throw(i, s);
    }),
    (r.exist = function (n, i) {
      new q(n, i).to.exist;
    }),
    (r.not = {}),
    (r.not.equal = function (n, i, s) {
      new q(n, s).to.not.equal(i);
    }),
    (r.not.Throw = function (n, i, s, a) {
      new q(n, a).to.not.Throw(i, s);
    }),
    (r.not.exist = function (n, i) {
      new q(n, i).to.not.exist;
    }),
    (r.throw = r.Throw),
    (r.not.throw = r.not.Throw),
    r
  );
}
o(kl, 'loadShould');
G(kl, 'loadShould');
var IF = kl,
  MF = kl;
function M(e, t) {
  new q(null, null, M, !0).assert(e, t, '[ negation message unavailable ]');
}
o(M, 'assert');
G(M, 'assert');
M.fail = function (e, t, r, n) {
  throw (
    arguments.length < 2 && ((r = e), (e = void 0)),
    (r = r || 'assert.fail()'),
    new Pe(r, { actual: e, expected: t, operator: n }, M.fail)
  );
};
M.isOk = function (e, t) {
  new q(e, t, M.isOk, !0).is.ok;
};
M.isNotOk = function (e, t) {
  new q(e, t, M.isNotOk, !0).is.not.ok;
};
M.equal = function (e, t, r) {
  let n = new q(e, r, M.equal, !0);
  n.assert(
    t == me(n, 'object'),
    'expected #{this} to equal #{exp}',
    'expected #{this} to not equal #{act}',
    t,
    e,
    !0,
  );
};
M.notEqual = function (e, t, r) {
  let n = new q(e, r, M.notEqual, !0);
  n.assert(
    t != me(n, 'object'),
    'expected #{this} to not equal #{exp}',
    'expected #{this} to equal #{act}',
    t,
    e,
    !0,
  );
};
M.strictEqual = function (e, t, r) {
  new q(e, r, M.strictEqual, !0).to.equal(t);
};
M.notStrictEqual = function (e, t, r) {
  new q(e, r, M.notStrictEqual, !0).to.not.equal(t);
};
M.deepEqual = M.deepStrictEqual = function (e, t, r) {
  new q(e, r, M.deepEqual, !0).to.eql(t);
};
M.notDeepEqual = function (e, t, r) {
  new q(e, r, M.notDeepEqual, !0).to.not.eql(t);
};
M.isAbove = function (e, t, r) {
  new q(e, r, M.isAbove, !0).to.be.above(t);
};
M.isAtLeast = function (e, t, r) {
  new q(e, r, M.isAtLeast, !0).to.be.least(t);
};
M.isBelow = function (e, t, r) {
  new q(e, r, M.isBelow, !0).to.be.below(t);
};
M.isAtMost = function (e, t, r) {
  new q(e, r, M.isAtMost, !0).to.be.most(t);
};
M.isTrue = function (e, t) {
  new q(e, t, M.isTrue, !0).is.true;
};
M.isNotTrue = function (e, t) {
  new q(e, t, M.isNotTrue, !0).to.not.equal(!0);
};
M.isFalse = function (e, t) {
  new q(e, t, M.isFalse, !0).is.false;
};
M.isNotFalse = function (e, t) {
  new q(e, t, M.isNotFalse, !0).to.not.equal(!1);
};
M.isNull = function (e, t) {
  new q(e, t, M.isNull, !0).to.equal(null);
};
M.isNotNull = function (e, t) {
  new q(e, t, M.isNotNull, !0).to.not.equal(null);
};
M.isNaN = function (e, t) {
  new q(e, t, M.isNaN, !0).to.be.NaN;
};
M.isNotNaN = function (e, t) {
  new q(e, t, M.isNotNaN, !0).not.to.be.NaN;
};
M.exists = function (e, t) {
  new q(e, t, M.exists, !0).to.exist;
};
M.notExists = function (e, t) {
  new q(e, t, M.notExists, !0).to.not.exist;
};
M.isUndefined = function (e, t) {
  new q(e, t, M.isUndefined, !0).to.equal(void 0);
};
M.isDefined = function (e, t) {
  new q(e, t, M.isDefined, !0).to.not.equal(void 0);
};
M.isCallable = function (e, t) {
  new q(e, t, M.isCallable, !0).is.callable;
};
M.isNotCallable = function (e, t) {
  new q(e, t, M.isNotCallable, !0).is.not.callable;
};
M.isObject = function (e, t) {
  new q(e, t, M.isObject, !0).to.be.a('object');
};
M.isNotObject = function (e, t) {
  new q(e, t, M.isNotObject, !0).to.not.be.a('object');
};
M.isArray = function (e, t) {
  new q(e, t, M.isArray, !0).to.be.an('array');
};
M.isNotArray = function (e, t) {
  new q(e, t, M.isNotArray, !0).to.not.be.an('array');
};
M.isString = function (e, t) {
  new q(e, t, M.isString, !0).to.be.a('string');
};
M.isNotString = function (e, t) {
  new q(e, t, M.isNotString, !0).to.not.be.a('string');
};
M.isNumber = function (e, t) {
  new q(e, t, M.isNumber, !0).to.be.a('number');
};
M.isNotNumber = function (e, t) {
  new q(e, t, M.isNotNumber, !0).to.not.be.a('number');
};
M.isNumeric = function (e, t) {
  new q(e, t, M.isNumeric, !0).is.numeric;
};
M.isNotNumeric = function (e, t) {
  new q(e, t, M.isNotNumeric, !0).is.not.numeric;
};
M.isFinite = function (e, t) {
  new q(e, t, M.isFinite, !0).to.be.finite;
};
M.isBoolean = function (e, t) {
  new q(e, t, M.isBoolean, !0).to.be.a('boolean');
};
M.isNotBoolean = function (e, t) {
  new q(e, t, M.isNotBoolean, !0).to.not.be.a('boolean');
};
M.typeOf = function (e, t, r) {
  new q(e, r, M.typeOf, !0).to.be.a(t);
};
M.notTypeOf = function (e, t, r) {
  new q(e, r, M.notTypeOf, !0).to.not.be.a(t);
};
M.instanceOf = function (e, t, r) {
  new q(e, r, M.instanceOf, !0).to.be.instanceOf(t);
};
M.notInstanceOf = function (e, t, r) {
  new q(e, r, M.notInstanceOf, !0).to.not.be.instanceOf(t);
};
M.include = function (e, t, r) {
  new q(e, r, M.include, !0).include(t);
};
M.notInclude = function (e, t, r) {
  new q(e, r, M.notInclude, !0).not.include(t);
};
M.deepInclude = function (e, t, r) {
  new q(e, r, M.deepInclude, !0).deep.include(t);
};
M.notDeepInclude = function (e, t, r) {
  new q(e, r, M.notDeepInclude, !0).not.deep.include(t);
};
M.nestedInclude = function (e, t, r) {
  new q(e, r, M.nestedInclude, !0).nested.include(t);
};
M.notNestedInclude = function (e, t, r) {
  new q(e, r, M.notNestedInclude, !0).not.nested.include(t);
};
M.deepNestedInclude = function (e, t, r) {
  new q(e, r, M.deepNestedInclude, !0).deep.nested.include(t);
};
M.notDeepNestedInclude = function (e, t, r) {
  new q(e, r, M.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
M.ownInclude = function (e, t, r) {
  new q(e, r, M.ownInclude, !0).own.include(t);
};
M.notOwnInclude = function (e, t, r) {
  new q(e, r, M.notOwnInclude, !0).not.own.include(t);
};
M.deepOwnInclude = function (e, t, r) {
  new q(e, r, M.deepOwnInclude, !0).deep.own.include(t);
};
M.notDeepOwnInclude = function (e, t, r) {
  new q(e, r, M.notDeepOwnInclude, !0).not.deep.own.include(t);
};
M.match = function (e, t, r) {
  new q(e, r, M.match, !0).to.match(t);
};
M.notMatch = function (e, t, r) {
  new q(e, r, M.notMatch, !0).to.not.match(t);
};
M.property = function (e, t, r) {
  new q(e, r, M.property, !0).to.have.property(t);
};
M.notProperty = function (e, t, r) {
  new q(e, r, M.notProperty, !0).to.not.have.property(t);
};
M.propertyVal = function (e, t, r, n) {
  new q(e, n, M.propertyVal, !0).to.have.property(t, r);
};
M.notPropertyVal = function (e, t, r, n) {
  new q(e, n, M.notPropertyVal, !0).to.not.have.property(t, r);
};
M.deepPropertyVal = function (e, t, r, n) {
  new q(e, n, M.deepPropertyVal, !0).to.have.deep.property(t, r);
};
M.notDeepPropertyVal = function (e, t, r, n) {
  new q(e, n, M.notDeepPropertyVal, !0).to.not.have.deep.property(t, r);
};
M.ownProperty = function (e, t, r) {
  new q(e, r, M.ownProperty, !0).to.have.own.property(t);
};
M.notOwnProperty = function (e, t, r) {
  new q(e, r, M.notOwnProperty, !0).to.not.have.own.property(t);
};
M.ownPropertyVal = function (e, t, r, n) {
  new q(e, n, M.ownPropertyVal, !0).to.have.own.property(t, r);
};
M.notOwnPropertyVal = function (e, t, r, n) {
  new q(e, n, M.notOwnPropertyVal, !0).to.not.have.own.property(t, r);
};
M.deepOwnPropertyVal = function (e, t, r, n) {
  new q(e, n, M.deepOwnPropertyVal, !0).to.have.deep.own.property(t, r);
};
M.notDeepOwnPropertyVal = function (e, t, r, n) {
  new q(e, n, M.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, r);
};
M.nestedProperty = function (e, t, r) {
  new q(e, r, M.nestedProperty, !0).to.have.nested.property(t);
};
M.notNestedProperty = function (e, t, r) {
  new q(e, r, M.notNestedProperty, !0).to.not.have.nested.property(t);
};
M.nestedPropertyVal = function (e, t, r, n) {
  new q(e, n, M.nestedPropertyVal, !0).to.have.nested.property(t, r);
};
M.notNestedPropertyVal = function (e, t, r, n) {
  new q(e, n, M.notNestedPropertyVal, !0).to.not.have.nested.property(t, r);
};
M.deepNestedPropertyVal = function (e, t, r, n) {
  new q(e, n, M.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, r);
};
M.notDeepNestedPropertyVal = function (e, t, r, n) {
  new q(e, n, M.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, r);
};
M.lengthOf = function (e, t, r) {
  new q(e, r, M.lengthOf, !0).to.have.lengthOf(t);
};
M.hasAnyKeys = function (e, t, r) {
  new q(e, r, M.hasAnyKeys, !0).to.have.any.keys(t);
};
M.hasAllKeys = function (e, t, r) {
  new q(e, r, M.hasAllKeys, !0).to.have.all.keys(t);
};
M.containsAllKeys = function (e, t, r) {
  new q(e, r, M.containsAllKeys, !0).to.contain.all.keys(t);
};
M.doesNotHaveAnyKeys = function (e, t, r) {
  new q(e, r, M.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
M.doesNotHaveAllKeys = function (e, t, r) {
  new q(e, r, M.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
M.hasAnyDeepKeys = function (e, t, r) {
  new q(e, r, M.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
M.hasAllDeepKeys = function (e, t, r) {
  new q(e, r, M.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
M.containsAllDeepKeys = function (e, t, r) {
  new q(e, r, M.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
M.doesNotHaveAnyDeepKeys = function (e, t, r) {
  new q(e, r, M.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
M.doesNotHaveAllDeepKeys = function (e, t, r) {
  new q(e, r, M.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
M.throws = function (e, t, r, n) {
  (typeof t == 'string' || t instanceof RegExp) && ((r = t), (t = null));
  let i = new q(e, n, M.throws, !0).to.throw(t, r);
  return me(i, 'object');
};
M.doesNotThrow = function (e, t, r, n) {
  ((typeof t == 'string' || t instanceof RegExp) && ((r = t), (t = null)),
    new q(e, n, M.doesNotThrow, !0).to.not.throw(t, r));
};
M.operator = function (e, t, r, n) {
  let i;
  switch (t) {
    case '==':
      i = e == r;
      break;
    case '===':
      i = e === r;
      break;
    case '>':
      i = e > r;
      break;
    case '>=':
      i = e >= r;
      break;
    case '<':
      i = e < r;
      break;
    case '<=':
      i = e <= r;
      break;
    case '!=':
      i = e != r;
      break;
    case '!==':
      i = e !== r;
      break;
    default:
      throw ((n = n && n + ': '), new Pe(n + 'Invalid operator "' + t + '"', void 0, M.operator));
  }
  let s = new q(i, n, M.operator, !0);
  s.assert(
    me(s, 'object') === !0,
    'expected ' + Se(e) + ' to be ' + t + ' ' + Se(r),
    'expected ' + Se(e) + ' to not be ' + t + ' ' + Se(r),
  );
};
M.closeTo = function (e, t, r, n) {
  new q(e, n, M.closeTo, !0).to.be.closeTo(t, r);
};
M.approximately = function (e, t, r, n) {
  new q(e, n, M.approximately, !0).to.be.approximately(t, r);
};
M.sameMembers = function (e, t, r) {
  new q(e, r, M.sameMembers, !0).to.have.same.members(t);
};
M.notSameMembers = function (e, t, r) {
  new q(e, r, M.notSameMembers, !0).to.not.have.same.members(t);
};
M.sameDeepMembers = function (e, t, r) {
  new q(e, r, M.sameDeepMembers, !0).to.have.same.deep.members(t);
};
M.notSameDeepMembers = function (e, t, r) {
  new q(e, r, M.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
M.sameOrderedMembers = function (e, t, r) {
  new q(e, r, M.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
M.notSameOrderedMembers = function (e, t, r) {
  new q(e, r, M.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
M.sameDeepOrderedMembers = function (e, t, r) {
  new q(e, r, M.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
M.notSameDeepOrderedMembers = function (e, t, r) {
  new q(e, r, M.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
M.includeMembers = function (e, t, r) {
  new q(e, r, M.includeMembers, !0).to.include.members(t);
};
M.notIncludeMembers = function (e, t, r) {
  new q(e, r, M.notIncludeMembers, !0).to.not.include.members(t);
};
M.includeDeepMembers = function (e, t, r) {
  new q(e, r, M.includeDeepMembers, !0).to.include.deep.members(t);
};
M.notIncludeDeepMembers = function (e, t, r) {
  new q(e, r, M.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
M.includeOrderedMembers = function (e, t, r) {
  new q(e, r, M.includeOrderedMembers, !0).to.include.ordered.members(t);
};
M.notIncludeOrderedMembers = function (e, t, r) {
  new q(e, r, M.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
M.includeDeepOrderedMembers = function (e, t, r) {
  new q(e, r, M.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
M.notIncludeDeepOrderedMembers = function (e, t, r) {
  new q(e, r, M.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
M.oneOf = function (e, t, r) {
  new q(e, r, M.oneOf, !0).to.be.oneOf(t);
};
M.isIterable = function (e, t) {
  if (e == null || !e[Symbol.iterator])
    throw (
      (t = t ? `${t} expected ${Se(e)} to be an iterable` : `expected ${Se(e)} to be an iterable`),
      new Pe(t, void 0, M.isIterable)
    );
};
M.changes = function (e, t, r, n) {
  (arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new q(e, n, M.changes, !0).to.change(t, r));
};
M.changesBy = function (e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == 'function') {
    let s = n;
    ((n = r), (i = s));
  } else arguments.length === 3 && ((n = r), (r = null));
  new q(e, i, M.changesBy, !0).to.change(t, r).by(n);
};
M.doesNotChange = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new q(e, n, M.doesNotChange, !0).to.not.change(t, r)
  );
};
M.changesButNotBy = function (e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == 'function') {
    let s = n;
    ((n = r), (i = s));
  } else arguments.length === 3 && ((n = r), (r = null));
  new q(e, i, M.changesButNotBy, !0).to.change(t, r).but.not.by(n);
};
M.increases = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new q(e, n, M.increases, !0).to.increase(t, r)
  );
};
M.increasesBy = function (e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == 'function') {
    let s = n;
    ((n = r), (i = s));
  } else arguments.length === 3 && ((n = r), (r = null));
  new q(e, i, M.increasesBy, !0).to.increase(t, r).by(n);
};
M.doesNotIncrease = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new q(e, n, M.doesNotIncrease, !0).to.not.increase(t, r)
  );
};
M.increasesButNotBy = function (e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == 'function') {
    let s = n;
    ((n = r), (i = s));
  } else arguments.length === 3 && ((n = r), (r = null));
  new q(e, i, M.increasesButNotBy, !0).to.increase(t, r).but.not.by(n);
};
M.decreases = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new q(e, n, M.decreases, !0).to.decrease(t, r)
  );
};
M.decreasesBy = function (e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == 'function') {
    let s = n;
    ((n = r), (i = s));
  } else arguments.length === 3 && ((n = r), (r = null));
  new q(e, i, M.decreasesBy, !0).to.decrease(t, r).by(n);
};
M.doesNotDecrease = function (e, t, r, n) {
  return (
    arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
    new q(e, n, M.doesNotDecrease, !0).to.not.decrease(t, r)
  );
};
M.doesNotDecreaseBy = function (e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == 'function') {
    let s = n;
    ((n = r), (i = s));
  } else arguments.length === 3 && ((n = r), (r = null));
  return new q(e, i, M.doesNotDecreaseBy, !0).to.not.decrease(t, r).by(n);
};
M.decreasesButNotBy = function (e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == 'function') {
    let s = n;
    ((n = r), (i = s));
  } else arguments.length === 3 && ((n = r), (r = null));
  new q(e, i, M.decreasesButNotBy, !0).to.decrease(t, r).but.not.by(n);
};
M.ifError = function (e) {
  if (e) throw e;
};
M.isExtensible = function (e, t) {
  new q(e, t, M.isExtensible, !0).to.be.extensible;
};
M.isNotExtensible = function (e, t) {
  new q(e, t, M.isNotExtensible, !0).to.not.be.extensible;
};
M.isSealed = function (e, t) {
  new q(e, t, M.isSealed, !0).to.be.sealed;
};
M.isNotSealed = function (e, t) {
  new q(e, t, M.isNotSealed, !0).to.not.be.sealed;
};
M.isFrozen = function (e, t) {
  new q(e, t, M.isFrozen, !0).to.be.frozen;
};
M.isNotFrozen = function (e, t) {
  new q(e, t, M.isNotFrozen, !0).to.not.be.frozen;
};
M.isEmpty = function (e, t) {
  new q(e, t, M.isEmpty, !0).to.be.empty;
};
M.isNotEmpty = function (e, t) {
  new q(e, t, M.isNotEmpty, !0).to.not.be.empty;
};
M.containsSubset = function (e, t, r) {
  new q(e, r).to.containSubset(t);
};
M.doesNotContainSubset = function (e, t, r) {
  new q(e, r).to.not.containSubset(t);
};
var qF = [
  ['isOk', 'ok'],
  ['isNotOk', 'notOk'],
  ['throws', 'throw'],
  ['throws', 'Throw'],
  ['isExtensible', 'extensible'],
  ['isNotExtensible', 'notExtensible'],
  ['isSealed', 'sealed'],
  ['isNotSealed', 'notSealed'],
  ['isFrozen', 'frozen'],
  ['isNotFrozen', 'notFrozen'],
  ['isEmpty', 'empty'],
  ['isNotEmpty', 'notEmpty'],
  ['isCallable', 'isFunction'],
  ['isNotCallable', 'isNotFunction'],
  ['containsSubset', 'containSubset'],
];
for (const [e, t] of qF) M[t] = M[e];
var Xh = [];
function dn(e) {
  const t = {
    use: dn,
    AssertionError: Pe,
    util: Zt,
    config: gt,
    expect: Dr,
    assert: M,
    Assertion: q,
    ...rS,
  };
  return (~Xh.indexOf(e) || (e(t, Zt), Xh.push(e)), t);
}
o(dn, 'use');
G(dn, 'use');
var nS = {};
Et(nS, {
  toAppearAfter: () => j_,
  toAppearBefore: () => ga,
  toBeChecked: () => mm,
  toBeDisabled: () => sm,
  toBeEmpty: () => Hf,
  toBeEmptyDOMElement: () => Gf,
  toBeEnabled: () => am,
  toBeInTheDOM: () => da,
  toBeInTheDocument: () => Vf,
  toBeInvalid: () => um,
  toBePartiallyChecked: () => hm,
  toBePartiallyPressed: () => Tm,
  toBePressed: () => Em,
  toBeRequired: () => lm,
  toBeValid: () => dm,
  toBeVisible: () => tm,
  toContainElement: () => pa,
  toContainHTML: () => zf,
  toHaveAccessibleDescription: () => fa,
  toHaveAccessibleErrorMessage: () => Kf,
  toHaveAccessibleName: () => ya,
  toHaveAttribute: () => Yf,
  toHaveClass: () => Xf,
  toHaveDescription: () => gm,
  toHaveDisplayValue: () => fm,
  toHaveErrorMessage: () => bm,
  toHaveFocus: () => Qf,
  toHaveFormValues: () => Zf,
  toHaveRole: () => ma,
  toHaveSelection: () => vm,
  toHaveStyle: () => ha,
  toHaveTextContent: () => Wf,
  toHaveValue: () => pm,
});
var Qh = ze(ib(), 1),
  oS = class extends Error {
    constructor(r, n, i, s, a) {
      super(`${r}:${i}:${s}: ${n}`);
      Le(this, 'reason');
      Le(this, 'filename');
      Le(this, 'line');
      Le(this, 'column');
      Le(this, 'source');
      ((this.reason = n),
        (this.filename = r),
        (this.line = i),
        (this.column = s),
        (this.source = a));
    }
  };
o(oS, 't');
var jF = oS,
  iS = class {
    constructor(t, r, n) {
      Le(this, 'start');
      Le(this, 'end');
      Le(this, 'source');
      ((this.start = t), (this.end = r), (this.source = n));
    }
  };
o(iS, 'e');
var kF = iS,
  Ze;
(function (e) {
  ((e.stylesheet = 'stylesheet'),
    (e.rule = 'rule'),
    (e.declaration = 'declaration'),
    (e.comment = 'comment'),
    (e.container = 'container'),
    (e.charset = 'charset'),
    (e.document = 'document'),
    (e.customMedia = 'custom-media'),
    (e.fontFace = 'font-face'),
    (e.host = 'host'),
    (e.import = 'import'),
    (e.keyframes = 'keyframes'),
    (e.keyframe = 'keyframe'),
    (e.layer = 'layer'),
    (e.media = 'media'),
    (e.namespace = 'namespace'),
    (e.page = 'page'),
    (e.startingStyle = 'starting-style'),
    (e.supports = 'supports'));
})(Ze || (Ze = {}));
var Zh = o((e, t, r) => {
    let n = r,
      i = 1e4;
    do {
      const s = t.map((d) => e.indexOf(d, n));
      s.push(e.indexOf('\\', n));
      const a = s.filter((d) => d !== -1);
      if (a.length === 0) return -1;
      const c = Math.min(...a);
      if (e[c] !== '\\') return c;
      ((n = c + 2), i--);
    } while (i > 0);
    throw new Error('Too many escaping');
  }, 's'),
  wu = o((e, t, r) => {
    let n = r,
      i = 1e4;
    do {
      const s = t.map((d) => e.indexOf(d, n));
      (s.push(e.indexOf('(', n)),
        s.push(e.indexOf('"', n)),
        s.push(e.indexOf("'", n)),
        s.push(e.indexOf('\\', n)));
      const a = s.filter((d) => d !== -1);
      if (a.length === 0) return -1;
      const c = Math.min(...a);
      switch (e[c]) {
        case '\\':
          n = c + 2;
          break;
        case '(':
          {
            const d = wu(e, [')'], c + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        case '"':
          {
            const d = Zh(e, ['"'], c + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        case "'":
          {
            const d = Zh(e, ["'"], c + 1);
            if (d === -1) return -1;
            n = d + 1;
          }
          break;
        default:
          return c;
      }
      i--;
    } while (i > 0);
    throw new Error('Too many escaping');
  }, 'n'),
  Ic = /\/\*[^]*?(?:\*\/|$)/g;
function wt(e) {
  return e ? e.trim() : '';
}
o(wt, 'o');
function ua(e, t) {
  const r = e && typeof e.type == 'string',
    n = r ? e : t;
  for (const i in e) {
    const s = e[i];
    Array.isArray(s)
      ? s.forEach((a) => {
          ua(a, n);
        })
      : s && typeof s == 'object' && ua(s, n);
  }
  return (
    r &&
      Object.defineProperty(e, 'parent', {
        configurable: !0,
        writable: !0,
        enumerable: !1,
        value: t || null,
      }),
    e
  );
}
o(ua, 'c');
var DF = o((e, t) => {
    t = t || {};
    let r = 1,
      n = 1;
    function i() {
      const w = { line: r, column: n };
      return (_) => ((_.position = new kF(w, { line: r, column: n }, t?.source || '')), f(), _);
    }
    o(i, 'u');
    const s = [];
    function a(w) {
      const _ = new jF(t?.source || '', w, r, n, e);
      if (!t?.silent) throw _;
      s.push(_);
    }
    o(a, 'l');
    function c() {
      const w = /^{\s*/.exec(e);
      return !!w && (p(w), !0);
    }
    o(c, 'f');
    function d() {
      const w = /^}/.exec(e);
      return !!w && (p(w), !0);
    }
    o(d, 'd');
    function u() {
      let w;
      const _ = [];
      for (f(), y(_); e.length && e.charAt(0) !== '}' && ((w = C() || R()), w); ) (_.push(w), y(_));
      return _;
    }
    o(u, 'y');
    function p(w) {
      const _ = w[0];
      return (
        (function (k) {
          const I = k.match(/\n/g);
          I && (r += I.length);
          const V = k.lastIndexOf(`
`);
          n = ~V ? k.length - V : n + k.length;
        })(_),
        (e = e.slice(_.length)),
        w
      );
    }
    o(p, 'g');
    function f() {
      const w = /^\s*/.exec(e);
      w && p(w);
    }
    o(f, '$');
    function y(w) {
      w = w || [];
      let _ = h();
      for (; _; ) (w.push(_), (_ = h()));
      return w;
    }
    o(y, 'x');
    function h() {
      const w = i();
      if (e.charAt(0) !== '/' || e.charAt(1) !== '*') return;
      const _ = /^\/\*[^]*?\*\//.exec(e);
      return _
        ? (p(_), w({ type: Ze.comment, comment: _[0].slice(2, -2) }))
        : a('End of comment missing');
    }
    o(h, 'V');
    function g() {
      const w = /^([^{]+)/.exec(e);
      if (w)
        return (
          p(w),
          ((_, k) => {
            const I = [];
            let V = 0;
            for (; V < _.length; ) {
              const H = wu(_, k, V);
              if (H === -1) return (I.push(_.substring(V)), I);
              (I.push(_.substring(V, H)), (V = H + 1));
            }
            return I;
          })(wt(w[0]).replace(Ic, ''), [',']).map((_) => wt(_))
        );
    }
    o(g, 'k');
    function T() {
      const w = i(),
        _ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(e);
      if (!_) return;
      p(_);
      const k = wt(_[0]),
        I = /^:\s*/.exec(e);
      if (!I) return a("property missing ':'");
      p(I);
      let V = '';
      const H = wu(e, [';', '}']);
      H !== -1 && ((V = e.substring(0, H)), p([V]), (V = wt(V).replace(Ic, '')));
      const P = w({ type: Ze.declaration, property: k.replace(Ic, ''), value: V }),
        L = /^[;\s]*/.exec(e);
      return (L && p(L), P);
    }
    o(T, 'v');
    function E() {
      const w = [];
      if (!c()) return a("missing '{'");
      y(w);
      let _ = T();
      for (; _; ) (w.push(_), y(w), (_ = T()));
      return d() ? w : a("missing '}'");
    }
    o(E, 'w');
    function v() {
      const w = [],
        _ = i();
      let k = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
      for (; k; ) {
        const I = p(k);
        w.push(I[1]);
        const V = /^,\s*/.exec(e);
        (V && p(V), (k = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e)));
      }
      if (w.length) return _({ type: Ze.keyframe, values: w, declarations: E() || [] });
    }
    o(v, 'b');
    const S = j('import'),
      A = j('charset'),
      N = j('namespace');
    function j(w) {
      const _ = new RegExp(
        '^@' + w + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`,
      );
      return () => {
        const k = i(),
          I = _.exec(e);
        if (!I) return;
        const V = p(I),
          H = { type: w };
        return ((H[w] = V[1].trim()), k(H));
      };
    }
    o(j, 'M');
    function C() {
      if (e[0] === '@')
        return (
          (function () {
            const w = i(),
              _ = /^@([-\w]+)?keyframes\s*/.exec(e);
            if (!_) return;
            const k = p(_)[1],
              I = /^([-\w]+)\s*/.exec(e);
            if (!I) return a('@keyframes missing name');
            const V = p(I)[1];
            if (!c()) return a("@keyframes missing '{'");
            let H = y(),
              P = v();
            for (; P; ) (H.push(P), (H = H.concat(y())), (P = v()));
            return d()
              ? w({ type: Ze.keyframes, name: V, vendor: k, keyframes: H })
              : a("@keyframes missing '}'");
          })() ||
          (function () {
            const w = i(),
              _ = /^@media *([^{]+)/.exec(e);
            if (!_) return;
            const k = wt(p(_)[1]);
            if (!c()) return a("@media missing '{'");
            const I = y().concat(u());
            return d() ? w({ type: Ze.media, media: k, rules: I }) : a("@media missing '}'");
          })() ||
          (function () {
            const w = i(),
              _ = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(e);
            if (!_) return;
            const k = p(_);
            return w({ type: Ze.customMedia, name: wt(k[1]), media: wt(k[2]) });
          })() ||
          (function () {
            const w = i(),
              _ = /^@supports *([^{]+)/.exec(e);
            if (!_) return;
            const k = wt(p(_)[1]);
            if (!c()) return a("@supports missing '{'");
            const I = y().concat(u());
            return d()
              ? w({ type: Ze.supports, supports: k, rules: I })
              : a("@supports missing '}'");
          })() ||
          S() ||
          A() ||
          N() ||
          (function () {
            const w = i(),
              _ = /^@([-\w]+)?document *([^{]+)/.exec(e);
            if (!_) return;
            const k = p(_),
              I = wt(k[1]),
              V = wt(k[2]);
            if (!c()) return a("@document missing '{'");
            const H = y().concat(u());
            return d()
              ? w({ type: Ze.document, document: V, vendor: I, rules: H })
              : a("@document missing '}'");
          })() ||
          (function () {
            const w = i(),
              _ = /^@page */.exec(e);
            if (!_) return;
            p(_);
            const k = g() || [];
            if (!c()) return a("@page missing '{'");
            let I = y(),
              V = T();
            for (; V; ) (I.push(V), (I = I.concat(y())), (V = T()));
            return d()
              ? w({ type: Ze.page, selectors: k, declarations: I })
              : a("@page missing '}'");
          })() ||
          (function () {
            const w = i(),
              _ = /^@host\s*/.exec(e);
            if (!_) return;
            if ((p(_), !c())) return a("@host missing '{'");
            const k = y().concat(u());
            return d() ? w({ type: Ze.host, rules: k }) : a("@host missing '}'");
          })() ||
          (function () {
            const w = i(),
              _ = /^@font-face\s*/.exec(e);
            if (!_) return;
            if ((p(_), !c())) return a("@font-face missing '{'");
            let k = y(),
              I = T();
            for (; I; ) (k.push(I), (k = k.concat(y())), (I = T()));
            return d() ? w({ type: Ze.fontFace, declarations: k }) : a("@font-face missing '}'");
          })() ||
          (function () {
            const w = i(),
              _ = /^@container *([^{]+)/.exec(e);
            if (!_) return;
            const k = wt(p(_)[1]);
            if (!c()) return a("@container missing '{'");
            const I = y().concat(u());
            return d()
              ? w({ type: Ze.container, container: k, rules: I })
              : a("@container missing '}'");
          })() ||
          (function () {
            const w = i(),
              _ = /^@starting-style\s*/.exec(e);
            if (!_) return;
            if ((p(_), !c())) return a("@starting-style missing '{'");
            const k = y().concat(u());
            return d() ? w({ type: Ze.startingStyle, rules: k }) : a("@starting-style missing '}'");
          })() ||
          (function () {
            const w = i(),
              _ = /^@layer *([^{;@]+)/.exec(e);
            if (!_) return;
            const k = wt(p(_)[1]);
            if (!c()) {
              const V = /^[;\s]*/.exec(e);
              return (V && p(V), w({ type: Ze.layer, layer: k }));
            }
            const I = y().concat(u());
            return d() ? w({ type: Ze.layer, layer: k, rules: I }) : a("@layer missing '}'");
          })()
        );
    }
    o(C, 'A');
    function R() {
      const w = i(),
        _ = g();
      return _
        ? (y(), w({ type: Ze.rule, selectors: _, declarations: E() || [] }))
        : a('selector missing');
    }
    return (
      o(R, 'S'),
      ua(
        (function () {
          const w = u();
          return {
            type: Ze.stylesheet,
            stylesheet: { source: t?.source, rules: w, parsingErrors: s },
          };
        })(),
      )
    );
  }, 'm'),
  LF = Object.prototype.toString;
function Su(e) {
  return typeof e == 'function' || LF.call(e) === '[object Function]';
}
o(Su, 'isCallable');
function sS(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
o(sS, 'toInteger');
var FF = Math.pow(2, 53) - 1;
function aS(e) {
  var t = sS(e);
  return Math.min(Math.max(t, 0), FF);
}
o(aS, 'toLength');
function qt(e, t) {
  var r = Array,
    n = Object(e);
  if (e == null)
    throw new TypeError('Array.from requires an array-like object - not null or undefined');
  if (typeof t < 'u' && !Su(t))
    throw new TypeError('Array.from: when provided, the second argument must be a function');
  for (var i = aS(n.length), s = Su(r) ? Object(new r(i)) : new Array(i), a = 0, c; a < i; )
    ((c = n[a]), t ? (s[a] = t(c, a)) : (s[a] = c), (a += 1));
  return ((s.length = i), s);
}
o(qt, 'arrayFrom');
function so(e) {
  '@babel/helpers - typeof';
  return (
    (so =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    so(e)
  );
}
o(so, '_typeof');
function lS(e, t) {
  if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
o(lS, '_classCallCheck');
function _u(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    ((n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      'value' in n && (n.writable = !0),
      Object.defineProperty(e, qf(n.key), n));
  }
}
o(_u, '_defineProperties');
function cS(e, t, r) {
  return (
    t && _u(e.prototype, t),
    r && _u(e, r),
    Object.defineProperty(e, 'prototype', { writable: !1 }),
    e
  );
}
o(cS, '_createClass');
function uS(e, t, r) {
  return (
    (t = qf(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(uS, '_defineProperty');
function qf(e) {
  var t = dS(e, 'string');
  return so(t) === 'symbol' ? t : String(t);
}
o(qf, '_toPropertyKey');
function dS(e, t) {
  if (so(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (so(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
o(dS, '_toPrimitive');
var BF = (function () {
    function e() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      (lS(this, e), uS(this, 'items', void 0), (this.items = t));
    }
    return (
      o(e, 'SetLike'),
      cS(e, [
        {
          key: 'add',
          value: o(function (r) {
            return (this.has(r) === !1 && this.items.push(r), this);
          }, 'add'),
        },
        {
          key: 'clear',
          value: o(function () {
            this.items = [];
          }, 'clear'),
        },
        {
          key: 'delete',
          value: o(function (r) {
            var n = this.items.length;
            return (
              (this.items = this.items.filter(function (i) {
                return i !== r;
              })),
              n !== this.items.length
            );
          }, '_delete'),
        },
        {
          key: 'forEach',
          value: o(function (r) {
            var n = this;
            this.items.forEach(function (i) {
              r(i, i, n);
            });
          }, 'forEach'),
        },
        {
          key: 'has',
          value: o(function (r) {
            return this.items.indexOf(r) !== -1;
          }, 'has'),
        },
        {
          key: 'size',
          get: o(function () {
            return this.items.length;
          }, 'get'),
        },
      ]),
      e
    );
  })(),
  JF = typeof Set > 'u' ? Set : BF;
function lt(e) {
  var t;
  return (t = e.localName) !== null && t !== void 0 ? t : e.tagName.toLowerCase();
}
o(lt, 'getLocalName');
var $F = {
    article: 'article',
    aside: 'complementary',
    button: 'button',
    datalist: 'listbox',
    dd: 'definition',
    details: 'group',
    dialog: 'dialog',
    dt: 'term',
    fieldset: 'group',
    figure: 'figure',
    form: 'form',
    footer: 'contentinfo',
    h1: 'heading',
    h2: 'heading',
    h3: 'heading',
    h4: 'heading',
    h5: 'heading',
    h6: 'heading',
    header: 'banner',
    hr: 'separator',
    html: 'document',
    legend: 'legend',
    li: 'listitem',
    math: 'math',
    main: 'main',
    menu: 'list',
    nav: 'navigation',
    ol: 'list',
    optgroup: 'group',
    option: 'option',
    output: 'status',
    progress: 'progressbar',
    section: 'region',
    summary: 'button',
    table: 'table',
    tbody: 'rowgroup',
    textarea: 'textbox',
    tfoot: 'rowgroup',
    td: 'cell',
    th: 'columnheader',
    thead: 'rowgroup',
    tr: 'row',
    ul: 'list',
  },
  UF = {
    caption: new Set(['aria-label', 'aria-labelledby']),
    code: new Set(['aria-label', 'aria-labelledby']),
    deletion: new Set(['aria-label', 'aria-labelledby']),
    emphasis: new Set(['aria-label', 'aria-labelledby']),
    generic: new Set(['aria-label', 'aria-labelledby', 'aria-roledescription']),
    insertion: new Set(['aria-label', 'aria-labelledby']),
    none: new Set(['aria-label', 'aria-labelledby']),
    paragraph: new Set(['aria-label', 'aria-labelledby']),
    presentation: new Set(['aria-label', 'aria-labelledby']),
    strong: new Set(['aria-label', 'aria-labelledby']),
    subscript: new Set(['aria-label', 'aria-labelledby']),
    superscript: new Set(['aria-label', 'aria-labelledby']),
  };
function pS(e, t) {
  return [
    'aria-atomic',
    'aria-busy',
    'aria-controls',
    'aria-current',
    'aria-description',
    'aria-describedby',
    'aria-details',
    'aria-dropeffect',
    'aria-flowto',
    'aria-grabbed',
    'aria-hidden',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-live',
    'aria-owns',
    'aria-relevant',
    'aria-roledescription',
  ].some(function (r) {
    var n;
    return e.hasAttribute(r) && !((n = UF[t]) !== null && n !== void 0 && n.has(r));
  });
}
o(pS, 'hasGlobalAriaAttributes');
function jf(e, t) {
  return pS(e, t);
}
o(jf, 'ignorePresentationalRole');
function fS(e) {
  var t = yS(e);
  if (t === null || Ru.indexOf(t) !== -1) {
    var r = mS(e);
    if (Ru.indexOf(t || '') === -1 || jf(e, r || '')) return r;
  }
  return t;
}
o(fS, 'getRole');
function mS(e) {
  var t = $F[lt(e)];
  if (t !== void 0) return t;
  switch (lt(e)) {
    case 'a':
    case 'area':
    case 'link':
      if (e.hasAttribute('href')) return 'link';
      break;
    case 'img':
      return e.getAttribute('alt') === '' && !jf(e, 'img') ? 'presentation' : 'img';
    case 'input': {
      var r = e,
        n = r.type;
      switch (n) {
        case 'button':
        case 'image':
        case 'reset':
        case 'submit':
          return 'button';
        case 'checkbox':
        case 'radio':
          return n;
        case 'range':
          return 'slider';
        case 'email':
        case 'tel':
        case 'text':
        case 'url':
          return e.hasAttribute('list') ? 'combobox' : 'textbox';
        case 'search':
          return e.hasAttribute('list') ? 'combobox' : 'searchbox';
        case 'number':
          return 'spinbutton';
        default:
          return null;
      }
    }
    case 'select':
      return e.hasAttribute('multiple') || e.size > 1 ? 'listbox' : 'combobox';
  }
  return null;
}
o(mS, 'getImplicitRole');
function yS(e) {
  var t = e.getAttribute('role');
  if (t !== null) {
    var r = t.trim().split(' ')[0];
    if (r.length > 0) return r;
  }
  return null;
}
o(yS, 'getExplicitRole');
var Ru = ['presentation', 'none'];
function je(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
o(je, 'isElement');
function kf(e) {
  return je(e) && lt(e) === 'caption';
}
o(kf, 'isHTMLTableCaptionElement');
function Ti(e) {
  return je(e) && lt(e) === 'input';
}
o(Ti, 'isHTMLInputElement');
function hS(e) {
  return je(e) && lt(e) === 'optgroup';
}
o(hS, 'isHTMLOptGroupElement');
function gS(e) {
  return je(e) && lt(e) === 'select';
}
o(gS, 'isHTMLSelectElement');
function bS(e) {
  return je(e) && lt(e) === 'table';
}
o(bS, 'isHTMLTableElement');
function vS(e) {
  return je(e) && lt(e) === 'textarea';
}
o(vS, 'isHTMLTextAreaElement');
function ES(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument,
    r = t.defaultView;
  if (r === null) throw new TypeError('no window available');
  return r;
}
o(ES, 'safeWindow');
function TS(e) {
  return je(e) && lt(e) === 'fieldset';
}
o(TS, 'isHTMLFieldSetElement');
function wS(e) {
  return je(e) && lt(e) === 'legend';
}
o(wS, 'isHTMLLegendElement');
function SS(e) {
  return je(e) && lt(e) === 'slot';
}
o(SS, 'isHTMLSlotElement');
function _S(e) {
  return je(e) && e.ownerSVGElement !== void 0;
}
o(_S, 'isSVGElement');
function RS(e) {
  return je(e) && lt(e) === 'svg';
}
o(RS, 'isSVGSVGElement');
function PS(e) {
  return _S(e) && lt(e) === 'title';
}
o(PS, 'isSVGTitleElement');
function Bi(e, t) {
  if (je(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(' '),
      n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r
      .map(function (i) {
        return n.getElementById(i);
      })
      .filter(function (i) {
        return i !== null;
      });
  }
  return [];
}
o(Bi, 'queryIdRefs');
function er(e, t) {
  return je(e) ? t.indexOf(fS(e)) !== -1 : !1;
}
o(er, 'hasAnyConcreteRoles');
function AS(e) {
  return e.trim().replace(/\s\s+/g, ' ');
}
o(AS, 'asFlatString');
function OS(e, t) {
  if (!je(e)) return !1;
  if (e.hasAttribute('hidden') || e.getAttribute('aria-hidden') === 'true') return !0;
  var r = t(e);
  return r.getPropertyValue('display') === 'none' || r.getPropertyValue('visibility') === 'hidden';
}
o(OS, 'isHidden');
function CS(e) {
  return er(e, ['button', 'combobox', 'listbox', 'textbox']) || Df(e, 'range');
}
o(CS, 'isControl');
function Df(e, t) {
  if (!je(e)) return !1;
  switch (t) {
    case 'range':
      return er(e, ['meter', 'progressbar', 'scrollbar', 'slider', 'spinbutton']);
    default:
      throw new TypeError(
        "No knowledge about abstract role '".concat(t, "'. This is likely a bug :("),
      );
  }
}
o(Df, 'hasAbstractRole');
function Pu(e, t) {
  var r = qt(e.querySelectorAll(t));
  return (
    Bi(e, 'aria-owns').forEach(function (n) {
      r.push.apply(r, qt(n.querySelectorAll(t)));
    }),
    r
  );
}
o(Pu, 'querySelectorAllSubtree');
function xS(e) {
  return gS(e) ? e.selectedOptions || Pu(e, '[selected]') : Pu(e, '[aria-selected="true"]');
}
o(xS, 'querySelectedOptions');
function NS(e) {
  return er(e, Ru);
}
o(NS, 'isMarkedPresentational');
function IS(e) {
  return kf(e);
}
o(IS, 'isNativeHostLanguageTextAlternativeElement');
function MS(e) {
  return er(e, [
    'button',
    'cell',
    'checkbox',
    'columnheader',
    'gridcell',
    'heading',
    'label',
    'legend',
    'link',
    'menuitem',
    'menuitemcheckbox',
    'menuitemradio',
    'option',
    'radio',
    'row',
    'rowheader',
    'switch',
    'tab',
    'tooltip',
    'treeitem',
  ]);
}
o(MS, 'allowsNameFromContent');
function qS(e) {
  return !1;
}
o(qS, 'isDescendantOfNativeHostLanguageTextAlternativeElement');
function jS(e) {
  return Ti(e) || vS(e) ? e.value : e.textContent || '';
}
o(jS, 'getValueOfTextbox');
function Au(e) {
  var t = e.getPropertyValue('content');
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : '';
}
o(Au, 'getTextualContent');
function Lf(e) {
  var t = lt(e);
  return (
    t === 'button' ||
    (t === 'input' && e.getAttribute('type') !== 'hidden') ||
    t === 'meter' ||
    t === 'output' ||
    t === 'progress' ||
    t === 'select' ||
    t === 'textarea'
  );
}
o(Lf, 'isLabelableElement');
function Ff(e) {
  if (Lf(e)) return e;
  var t = null;
  return (
    e.childNodes.forEach(function (r) {
      if (t === null && je(r)) {
        var n = Ff(r);
        n !== null && (t = n);
      }
    }),
    t
  );
}
o(Ff, 'findLabelableElement');
function kS(e) {
  if (e.control !== void 0) return e.control;
  var t = e.getAttribute('for');
  return t !== null ? e.ownerDocument.getElementById(t) : Ff(e);
}
o(kS, 'getControlOfLabel');
function DS(e) {
  var t = e.labels;
  if (t === null) return t;
  if (t !== void 0) return qt(t);
  if (!Lf(e)) return null;
  var r = e.ownerDocument;
  return qt(r.querySelectorAll('label')).filter(function (n) {
    return kS(n) === e;
  });
}
o(DS, 'getLabels');
function LS(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? qt(e.childNodes) : t;
}
o(LS, 'getSlotContents');
function Bf(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = new JF(),
    n = ES(e),
    i = t.compute,
    s = i === void 0 ? 'name' : i,
    a = t.computedStyleSupportsPseudoElements,
    c = a === void 0 ? t.getComputedStyle !== void 0 : a,
    d = t.getComputedStyle,
    u = d === void 0 ? n.getComputedStyle.bind(n) : d,
    p = t.hidden,
    f = p === void 0 ? !1 : p;
  function y(v, S) {
    var A = '';
    if (je(v) && c) {
      var N = u(v, '::before'),
        j = Au(N);
      A = ''.concat(j, ' ').concat(A);
    }
    var C = SS(v) ? LS(v) : qt(v.childNodes).concat(Bi(v, 'aria-owns'));
    if (
      (C.forEach(function (_) {
        var k = E(_, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !1, recursion: !0 }),
          I = je(_) ? u(_).getPropertyValue('display') : 'inline',
          V = I !== 'inline' ? ' ' : '';
        A += ''.concat(V).concat(k).concat(V);
      }),
      je(v) && c)
    ) {
      var R = u(v, '::after'),
        w = Au(R);
      A = ''.concat(A, ' ').concat(w);
    }
    return A.trim();
  }
  o(y, 'computeMiscTextAlternative');
  function h(v, S) {
    var A = v.getAttributeNode(S);
    return A !== null && !r.has(A) && A.value.trim() !== '' ? (r.add(A), A.value) : null;
  }
  o(h, 'useAttribute');
  function g(v) {
    return je(v) ? h(v, 'title') : null;
  }
  o(g, 'computeTooltipAttributeValue');
  function T(v) {
    if (!je(v)) return null;
    if (TS(v)) {
      r.add(v);
      for (var S = qt(v.childNodes), A = 0; A < S.length; A += 1) {
        var N = S[A];
        if (wS(N)) return E(N, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (bS(v)) {
      r.add(v);
      for (var j = qt(v.childNodes), C = 0; C < j.length; C += 1) {
        var R = j[C];
        if (kf(R)) return E(R, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (RS(v)) {
      r.add(v);
      for (var w = qt(v.childNodes), _ = 0; _ < w.length; _ += 1) {
        var k = w[_];
        if (PS(k)) return k.textContent;
      }
      return null;
    } else if (lt(v) === 'img' || lt(v) === 'area') {
      var I = h(v, 'alt');
      if (I !== null) return I;
    } else if (hS(v)) {
      var V = h(v, 'label');
      if (V !== null) return V;
    }
    if (Ti(v) && (v.type === 'button' || v.type === 'submit' || v.type === 'reset')) {
      var H = h(v, 'value');
      if (H !== null) return H;
      if (v.type === 'submit') return 'Submit';
      if (v.type === 'reset') return 'Reset';
    }
    var P = DS(v);
    if (P !== null && P.length !== 0)
      return (
        r.add(v),
        qt(P)
          .map(function (K) {
            return E(K, { isEmbeddedInLabel: !0, isReferenced: !1, recursion: !0 });
          })
          .filter(function (K) {
            return K.length > 0;
          })
          .join(' ')
      );
    if (Ti(v) && v.type === 'image') {
      var L = h(v, 'alt');
      if (L !== null) return L;
      var B = h(v, 'title');
      return B !== null ? B : 'Submit Query';
    }
    if (er(v, ['button'])) {
      var D = y(v, { isEmbeddedInLabel: !1 });
      if (D !== '') return D;
    }
    return null;
  }
  o(T, 'computeElementTextAlternative');
  function E(v, S) {
    if (r.has(v)) return '';
    if (!f && OS(v, u) && !S.isReferenced) return (r.add(v), '');
    var A = je(v) ? v.getAttributeNode('aria-labelledby') : null,
      N = A !== null && !r.has(A) ? Bi(v, 'aria-labelledby') : [];
    if (s === 'name' && !S.isReferenced && N.length > 0)
      return (
        r.add(A),
        N.map(function (I) {
          return E(I, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !0, recursion: !1 });
        }).join(' ')
      );
    var j = S.recursion && CS(v) && s === 'name';
    if (!j) {
      var C = ((je(v) && v.getAttribute('aria-label')) || '').trim();
      if (C !== '' && s === 'name') return (r.add(v), C);
      if (!NS(v)) {
        var R = T(v);
        if (R !== null) return (r.add(v), R);
      }
    }
    if (er(v, ['menu'])) return (r.add(v), '');
    if (j || S.isEmbeddedInLabel || S.isReferenced) {
      if (er(v, ['combobox', 'listbox'])) {
        r.add(v);
        var w = xS(v);
        return w.length === 0
          ? Ti(v)
            ? v.value
            : ''
          : qt(w)
              .map(function (I) {
                return E(I, {
                  isEmbeddedInLabel: S.isEmbeddedInLabel,
                  isReferenced: !1,
                  recursion: !0,
                });
              })
              .join(' ');
      }
      if (Df(v, 'range'))
        return (
          r.add(v),
          v.hasAttribute('aria-valuetext')
            ? v.getAttribute('aria-valuetext')
            : v.hasAttribute('aria-valuenow')
              ? v.getAttribute('aria-valuenow')
              : v.getAttribute('value') || ''
        );
      if (er(v, ['textbox'])) return (r.add(v), jS(v));
    }
    if (MS(v) || (je(v) && S.isReferenced) || IS(v) || qS()) {
      var _ = y(v, { isEmbeddedInLabel: S.isEmbeddedInLabel });
      if (_ !== '') return (r.add(v), _);
    }
    if (v.nodeType === v.TEXT_NODE) return (r.add(v), v.textContent || '');
    if (S.recursion) return (r.add(v), y(v, { isEmbeddedInLabel: S.isEmbeddedInLabel }));
    var k = g(v);
    return k !== null ? (r.add(v), k) : (r.add(v), '');
  }
  return (
    o(E, 'computeTextAlternative'),
    AS(E(e, { isEmbeddedInLabel: !1, isReferenced: s === 'description', recursion: !1 }))
  );
}
o(Bf, 'computeTextAlternative');
function ao(e) {
  '@babel/helpers - typeof';
  return (
    (ao =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    ao(e)
  );
}
o(ao, '_typeof');
function Ou(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    (t &&
      (n = n.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable;
      })),
      r.push.apply(r, n));
  }
  return r;
}
o(Ou, 'ownKeys');
function Cu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? Ou(Object(r), !0).forEach(function (n) {
          FS(e, n, r[n]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : Ou(Object(r)).forEach(function (n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
          });
  }
  return e;
}
o(Cu, '_objectSpread');
function FS(e, t, r) {
  return (
    (t = BS(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(FS, '_defineProperty');
function BS(e) {
  var t = JS(e, 'string');
  return ao(t) === 'symbol' ? t : String(t);
}
o(BS, '_toPropertyKey');
function JS(e, t) {
  if (ao(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (ao(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
o(JS, '_toPrimitive');
function $S(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = Bi(e, 'aria-describedby')
      .map(function (s) {
        return Bf(s, Cu(Cu({}, t), {}, { compute: 'description' }));
      })
      .join(' ');
  if (r === '') {
    var n = e.getAttribute('aria-description');
    r = n === null ? '' : n;
  }
  if (r === '') {
    var i = e.getAttribute('title');
    r = i === null ? '' : i;
  }
  return r;
}
o($S, 'computeAccessibleDescription');
function US(e) {
  return er(e, [
    'caption',
    'code',
    'deletion',
    'emphasis',
    'generic',
    'insertion',
    'none',
    'paragraph',
    'presentation',
    'strong',
    'subscript',
    'superscript',
  ]);
}
o(US, 'prohibitsNaming');
function VS(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return US(e) ? '' : Bf(e, t);
}
o(VS, 'computeAccessibleName');
var Jf = ze($d(), 1),
  VF = ze(sb(), 1),
  HF = ze(ab(), 1),
  HS = class extends Error {
    constructor(t, r, n, i) {
      (super(), Error.captureStackTrace && Error.captureStackTrace(this, n));
      let s = '';
      try {
        s = i.utils.printWithType('Received', r, i.utils.printReceived);
      } catch {}
      this.message = [
        i.utils.matcherHint(`${i.isNot ? '.not' : ''}.${n.name}`, 'received', ''),
        '',
        `${i.utils.RECEIVED_COLOR('received')} value must ${t}.`,
        s,
      ].join(`
`);
    }
  };
o(HS, 'GenericTypeError');
var GS = HS,
  zS = class extends GS {
    constructor(...t) {
      super('be an HTMLElement or an SVGElement', ...t);
    }
  };
o(zS, 'HtmlElementTypeError');
var eg = zS,
  WS = class extends GS {
    constructor(...t) {
      super('be a Node', ...t);
    }
  };
o(WS, 'NodeTypeError');
var tg = WS;
function $f(e, t, ...r) {
  if (!e || !e.ownerDocument || !e.ownerDocument.defaultView) throw new t(e, ...r);
}
o($f, 'checkHasWindow');
function KS(e, ...t) {
  $f(e, tg, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.Node)) throw new tg(e, ...t);
}
o(KS, 'checkNode');
function we(e, ...t) {
  $f(e, eg, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.HTMLElement) && !(e instanceof r.SVGElement)) throw new eg(e, ...t);
}
o(we, 'checkHtmlElement');
var YS = class extends Error {
  constructor(t, r, n) {
    (super(),
      Error.captureStackTrace && Error.captureStackTrace(this, r),
      (this.message = [
        t.message,
        '',
        n.utils.RECEIVED_COLOR('Failing css:'),
        n.utils.RECEIVED_COLOR(`${t.css}`),
      ].join(`
`)));
  }
};
o(YS, 'InvalidCSSError');
var GF = YS;
function XS(e, ...t) {
  const r = DF(`selector { ${e} }`, { silent: !0 }).stylesheet;
  if (r.parsingErrors && r.parsingErrors.length > 0) {
    const { reason: i, line: s } = r.parsingErrors[0];
    throw new GF(
      { css: e, message: `Syntax error parsing expected css: ${i} on line: ${s}` },
      ...t,
    );
  }
  return r.rules[0].declarations
    .filter((i) => i.type === 'declaration')
    .reduce((i, { property: s, value: a }) => Object.assign(i, { [s]: a }), {});
}
o(XS, 'parseCSS');
function xu(e, t) {
  return typeof t == 'string' ? t : e.utils.stringify(t);
}
o(xu, 'display');
function Ge(e, t, r, n, i, s) {
  return [
    `${t}
`,
    `${r}:
${e.utils.EXPECTED_COLOR((0, Qh.default)(xu(e, n), 2))}`,
    `${i}:
${e.utils.RECEIVED_COLOR((0, Qh.default)(xu(e, s), 2))}`,
  ].join(`
`);
}
o(Ge, 'getMessage');
function QS(e, t) {
  return t instanceof RegExp ? t.test(e) : e.includes(String(t));
}
o(QS, 'matches');
function ps(e, t) {
  console.warn(`Warning: ${e} has been deprecated and will be removed in future updates.`, t);
}
o(ps, 'deprecate');
function fs(e) {
  return e.replace(/\s+/g, ' ').trim();
}
o(fs, 'normalize');
function _r(e) {
  return e.tagName && e.tagName.toLowerCase();
}
o(_r, 'getTag');
function ZS({ multiple: e, options: t }) {
  const r = [...t].filter((n) => n.selected);
  if (e) return [...r].map((n) => n.value);
  if (r.length !== 0) return r[0].value;
}
o(ZS, 'getSelectValue');
function e_(e) {
  switch (e.type) {
    case 'number':
      return e.value === '' ? null : Number(e.value);
    case 'checkbox':
      return e.checked;
    default:
      return e.value;
  }
}
o(e_, 'getInputValue');
var zF = ['meter', 'progressbar', 'slider', 'spinbutton'];
function t_(e) {
  if (zF.includes(e.getAttribute('role'))) return Number(e.getAttribute('aria-valuenow'));
}
o(t_, 'getAccessibleValue');
function Uf(e) {
  if (e)
    switch (e.tagName.toLowerCase()) {
      case 'input':
        return e_(e);
      case 'select':
        return ZS(e);
      default:
        return e.value ?? t_(e);
    }
}
o(Uf, 'getSingleElementValue');
function r_(e, { wordConnector: t = ', ', lastWordConnector: r = ' and ' } = {}) {
  return [e.slice(0, -1).join(t), e[e.length - 1]].join(e.length > 1 ? r : '');
}
o(r_, 'toSentence');
function Dl(e, t) {
  return Array.isArray(e) && Array.isArray(t)
    ? [...new Set(e)].every((r) => new Set(t).has(r))
    : e === t;
}
o(Dl, 'compareAsSet');
function da(e, t) {
  return (
    ps(
      'toBeInTheDOM',
      'Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container.',
    ),
    e && we(e, da, this),
    t && we(t, da, this),
    {
      pass: t ? t.contains(e) : !!e,
      message: o(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInTheDOM`, 'element', ''),
            '',
            'Received:',
            `  ${this.utils.printReceived(e && e.cloneNode(!1))}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
o(da, 'toBeInTheDOM');
function Vf(e) {
  (e !== null || !this.isNot) && we(e, Vf, this);
  const t = e === null ? !1 : e.ownerDocument === e.getRootNode({ composed: !0 }),
    r = o(
      () =>
        `expected document not to contain element, found ${this.utils.stringify(e.cloneNode(!0))} instead`,
      'errorFound',
    ),
    n = o(() => 'element could not be found in the document', 'errorNotFound');
  return {
    pass: t,
    message: o(
      () =>
        [
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInTheDocument`, 'element', ''),
          '',
          this.utils.RECEIVED_COLOR(this.isNot ? r() : n()),
        ].join(`
`),
      'message',
    ),
  };
}
o(Vf, 'toBeInTheDocument');
function Hf(e) {
  return (
    ps('toBeEmpty', 'Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM.'),
    we(e, Hf, this),
    {
      pass: e.innerHTML === '',
      message: o(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeEmpty`, 'element', ''),
            '',
            'Received:',
            `  ${this.utils.printReceived(e.innerHTML)}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
o(Hf, 'toBeEmpty');
function Gf(e) {
  return (
    we(e, Gf, this),
    {
      pass: n_(e),
      message: o(
        () =>
          [
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toBeEmptyDOMElement`,
              'element',
              '',
            ),
            '',
            'Received:',
            `  ${this.utils.printReceived(e.innerHTML)}`,
          ].join(`
`),
        'message',
      ),
    }
  );
}
o(Gf, 'toBeEmptyDOMElement');
function n_(e) {
  return [...e.childNodes].filter((r) => r.nodeType !== 8).length === 0;
}
o(n_, 'isEmptyElement');
function pa(e, t) {
  return (
    we(e, pa, this),
    t !== null && we(t, pa, this),
    {
      pass: e.contains(t),
      message: o(
        () =>
          [
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toContainElement`,
              'element',
              'element',
            ),
            '',
            this.utils
              .RECEIVED_COLOR(`${this.utils.stringify(e.cloneNode(!1))} ${this.isNot ? 'contains:' : 'does not contain:'} ${this.utils.stringify(t && t.cloneNode(!1))}
        `),
          ].join(`
`),
        'message',
      ),
    }
  );
}
o(pa, 'toContainElement');
function o_(e, t) {
  const r = e.ownerDocument.createElement('div');
  return ((r.innerHTML = t), r.innerHTML);
}
o(o_, 'getNormalizedHtml');
function zf(e, t) {
  if ((we(e, zf, this), typeof t != 'string'))
    throw new Error(`.toContainHTML() expects a string value, got ${t}`);
  return {
    pass: e.outerHTML.includes(o_(e, t)),
    message: o(
      () =>
        [
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toContainHTML`, 'element', ''),
          'Expected:',
          `  ${this.utils.EXPECTED_COLOR(t)}`,
          'Received:',
          `  ${this.utils.printReceived(e.cloneNode(!0))}`,
        ].join(`
`),
      'message',
    ),
  };
}
o(zf, 'toContainHTML');
function Wf(e, t, r = { normalizeWhitespace: !0 }) {
  KS(e, Wf, this);
  const n = r.normalizeWhitespace ? fs(e.textContent) : e.textContent.replace(/\u00a0/g, ' '),
    i = n !== '' && t === '';
  return {
    pass: !i && QS(n, t),
    message: o(() => {
      const s = this.isNot ? 'not to' : 'to';
      return Ge(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveTextContent`, 'element', ''),
        i
          ? 'Checking with empty string will always match, use .toBeEmptyDOMElement() instead'
          : `Expected element ${s} have text content`,
        t,
        'Received',
        n,
      );
    }, 'message'),
  };
}
o(Wf, 'toHaveTextContent');
function fa(e, t) {
  we(e, fa, this);
  const r = $S(e),
    n = arguments.length === 1;
  let i = !1;
  return (
    n ? (i = r !== '') : (i = t instanceof RegExp ? t.test(r) : this.equals(r, t)),
    {
      pass: i,
      message: o(() => {
        const s = this.isNot ? 'not to' : 'to';
        return Ge(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${fa.name}`, 'element', ''),
          `Expected element ${s} have accessible description`,
          t,
          'Received',
          r,
        );
      }, 'message'),
    }
  );
}
o(fa, 'toHaveAccessibleDescription');
var si = 'aria-invalid',
  WF = ['false'];
function Kf(e, t) {
  we(e, Kf, this);
  const r = this.isNot ? 'not to' : 'to',
    n = this.isNot ? '.not.toHaveAccessibleErrorMessage' : '.toHaveAccessibleErrorMessage',
    i = e.getAttribute('aria-errormessage');
  if (!!i && /\s+/.test(i))
    return {
      pass: !1,
      message: o(
        () =>
          Ge(
            this,
            this.utils.matcherHint(n, 'element'),
            "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
            '',
            'Received',
            `aria-errormessage="${i}"`,
          ),
        'message',
      ),
    };
  const a = e.getAttribute(si);
  if (!e.hasAttribute(si) || WF.includes(a))
    return {
      pass: !1,
      message: o(
        () =>
          Ge(
            this,
            this.utils.matcherHint(n, 'element'),
            'Expected element to be marked as invalid with attribute',
            `${si}="${String(!0)}"`,
            'Received',
            e.hasAttribute('aria-invalid') ? `${si}="${e.getAttribute(si)}` : null,
          ),
        'message',
      ),
    };
  const d = fs(e.ownerDocument.getElementById(i)?.textContent ?? '');
  return {
    pass: t === void 0 ? !!d : t instanceof RegExp ? t.test(d) : this.equals(d, t),
    message: o(
      () =>
        Ge(
          this,
          this.utils.matcherHint(n, 'element'),
          `Expected element ${r} have accessible error message`,
          t ?? '',
          'Received',
          d,
        ),
      'message',
    ),
  };
}
o(Kf, 'toHaveAccessibleErrorMessage');
var KF = a_(Jf.elementRoles);
function ma(e, t) {
  we(e, ma, this);
  const r = i_(e);
  return {
    pass: r.some((i) => i === t),
    message: o(() => {
      const i = this.isNot ? 'not to' : 'to';
      return Ge(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${ma.name}`, 'element', ''),
        `Expected element ${i} have role`,
        t,
        'Received',
        r.join(', '),
      );
    }, 'message'),
  };
}
o(ma, 'toHaveRole');
function i_(e) {
  return e.hasAttribute('role') ? e.getAttribute('role').split(' ').filter(Boolean) : s_(e);
}
o(i_, 'getExplicitOrImplicitRoles');
function s_(e) {
  for (const { match: t, roles: r } of KF) if (t(e)) return [...r];
  return [];
}
o(s_, 'getImplicitAriaRoles');
function a_(e) {
  function t({ name: a, attributes: c }) {
    return `${a}${c.map(({ name: d, value: u, constraints: p = [] }) => (p.indexOf('undefined') !== -1 ? `:not([${d}])` : u ? `[${d}="${u}"]` : `[${d}]`)).join('')}`;
  }
  o(t, 'makeElementSelector');
  function r({ attributes: a = [] }) {
    return a.length;
  }
  o(r, 'getSelectorSpecificity');
  function n({ specificity: a }, { specificity: c }) {
    return c - a;
  }
  o(n, 'bySelectorSpecificity');
  function i(a) {
    let { attributes: c = [] } = a;
    const d = c.findIndex((p) => p.value && p.name === 'type' && p.value === 'text');
    d >= 0 && (c = [...c.slice(0, d), ...c.slice(d + 1)]);
    const u = t({ ...a, attributes: c });
    return (p) => (d >= 0 && p.type !== 'text' ? !1 : p.matches(u));
  }
  o(i, 'match');
  let s = [];
  for (const [a, c] of e.entries())
    s = [...s, { match: i(a), roles: Array.from(c), specificity: r(a) }];
  return s.sort(n);
}
o(a_, 'buildElementRoleList');
function ya(e, t) {
  we(e, ya, this);
  const r = VS(e),
    n = arguments.length === 1;
  let i = !1;
  return (
    n ? (i = r !== '') : (i = t instanceof RegExp ? t.test(r) : this.equals(r, t)),
    {
      pass: i,
      message: o(() => {
        const s = this.isNot ? 'not to' : 'to';
        return Ge(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${ya.name}`, 'element', ''),
          `Expected element ${s} have accessible name`,
          t,
          'Received',
          r,
        );
      }, 'message'),
    }
  );
}
o(ya, 'toHaveAccessibleName');
function Nu(e, t, r) {
  return r === void 0 ? t : `${t}=${e(r)}`;
}
o(Nu, 'printAttribute');
function l_(e, t, r) {
  return r === void 0
    ? `element.hasAttribute(${e(t)})`
    : `element.getAttribute(${e(t)}) === ${e(r)}`;
}
o(l_, 'getAttributeComment');
function Yf(e, t, r) {
  we(e, Yf, this);
  const n = r !== void 0,
    i = e.hasAttribute(t),
    s = e.getAttribute(t);
  return {
    pass: n ? i && this.equals(s, r) : i,
    message: o(() => {
      const a = this.isNot ? 'not to' : 'to',
        c = i ? Nu(this.utils.stringify, t, s) : null,
        d = this.utils.matcherHint(
          `${this.isNot ? '.not' : ''}.toHaveAttribute`,
          'element',
          this.utils.printExpected(t),
          {
            secondArgument: n ? this.utils.printExpected(r) : void 0,
            comment: l_(this.utils.stringify, t, r),
          },
        );
      return Ge(
        this,
        d,
        `Expected the element ${a} have attribute`,
        Nu(this.utils.stringify, t, r),
        'Received',
        c,
      );
    }, 'message'),
  };
}
o(Yf, 'toHaveAttribute');
function c_(e) {
  const t = e.pop();
  let r, n;
  return (
    typeof t == 'object' && !(t instanceof RegExp)
      ? ((r = e), (n = t))
      : ((r = e.concat(t)), (n = { exact: !1 })),
    { expectedClassNames: r, options: n }
  );
}
o(c_, 'getExpectedClassNamesAndOptions');
function Iu(e) {
  return e ? e.split(/\s+/).filter((t) => t.length > 0) : [];
}
o(Iu, 'splitClassNames');
function Mu(e, t) {
  return e.every((r) => (typeof r == 'string' ? t.includes(r) : t.some((n) => r.test(n))));
}
o(Mu, 'isSubset$1');
function Xf(e, ...t) {
  we(e, Xf, this);
  const { expectedClassNames: r, options: n } = c_(t),
    i = Iu(e.getAttribute('class')),
    s = r.reduce((c, d) => c.concat(typeof d == 'string' || !d ? Iu(d) : d), []),
    a = s.some((c) => c instanceof RegExp);
  if (n.exact && a) throw new Error('Exact option does not support RegExp expected class names');
  return n.exact
    ? {
        pass: Mu(s, i) && s.length === i.length,
        message: o(() => {
          const c = this.isNot ? 'not to' : 'to';
          return Ge(
            this,
            this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toHaveClass`,
              'element',
              this.utils.printExpected(s.join(' ')),
            ),
            `Expected the element ${c} have EXACTLY defined classes`,
            s.join(' '),
            'Received',
            i.join(' '),
          );
        }, 'message'),
      }
    : s.length > 0
      ? {
          pass: Mu(s, i),
          message: o(() => {
            const c = this.isNot ? 'not to' : 'to';
            return Ge(
              this,
              this.utils.matcherHint(
                `${this.isNot ? '.not' : ''}.toHaveClass`,
                'element',
                this.utils.printExpected(s.join(' ')),
              ),
              `Expected the element ${c} have class`,
              s.join(' '),
              'Received',
              i.join(' '),
            );
          }, 'message'),
        }
      : {
          pass: this.isNot ? i.length > 0 : !1,
          message: o(
            () =>
              this.isNot
                ? Ge(
                    this,
                    this.utils.matcherHint('.not.toHaveClass', 'element', ''),
                    'Expected the element to have classes',
                    '(none)',
                    'Received',
                    i.join(' '),
                  )
                : [
                    this.utils.matcherHint('.toHaveClass', 'element'),
                    'At least one expected class must be provided.',
                  ].join(`
`),
            'message',
          ),
        };
}
o(Xf, 'toHaveClass');
function u_(e, t) {
  const r = {},
    n = e.createElement('div');
  return (
    Object.keys(t).forEach((i) => {
      ((n.style[i] = t[i]), (r[i] = n.style[i]));
    }),
    r
  );
}
o(u_, 'getStyleDeclaration');
function d_(e, t) {
  return (
    !!Object.keys(e).length &&
    Object.entries(e).every(([r, n]) => {
      const i = r.startsWith('--'),
        s = [r];
      return (
        i || s.push(r.toLowerCase()),
        s.some((a) => t[a] === n || t.getPropertyValue(a) === n)
      );
    })
  );
}
o(d_, 'isSubset');
function qu(e) {
  return Object.keys(e)
    .sort()
    .map((t) => `${t}: ${e[t]};`).join(`
`);
}
o(qu, 'printoutStyles');
function p_(e, t, r) {
  const n = Array.from(r)
    .filter((s) => t[s] !== void 0)
    .reduce((s, a) => Object.assign(s, { [a]: r.getPropertyValue(a) }), {});
  return e(qu(t), qu(n)).replace(
    `${VF.default.red('+ Received')}
`,
    '',
  );
}
o(p_, 'expectedDiff');
function ha(e, t) {
  we(e, ha, this);
  const r = typeof t == 'object' ? t : XS(t, ha, this),
    { getComputedStyle: n } = e.ownerDocument.defaultView,
    i = u_(e.ownerDocument, r),
    s = n(e);
  return {
    pass: d_(i, s),
    message: o(() => {
      const a = `${this.isNot ? '.not' : ''}.toHaveStyle`;
      return [this.utils.matcherHint(a, 'element', ''), p_(this.utils.diff, i, s)].join(`

`);
    }, 'message'),
  };
}
o(ha, 'toHaveStyle');
function Qf(e) {
  return (
    we(e, Qf, this),
    {
      pass: e.ownerDocument.activeElement === e,
      message: o(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveFocus`, 'element', ''),
            '',
            ...(this.isNot
              ? ['Received element is focused:', `  ${this.utils.printReceived(e)}`]
              : [
                  'Expected element with focus:',
                  `  ${this.utils.printExpected(e)}`,
                  'Received element with focus:',
                  `  ${this.utils.printReceived(e.ownerDocument.activeElement)}`,
                ]),
          ].join(`
`),
        'message',
      ),
    }
  );
}
o(Qf, 'toHaveFocus');
function f_(e) {
  const t = [...new Set(e.map((r) => r.type))];
  if (t.length !== 1)
    throw new Error('Multiple form elements with the same name must be of the same type');
  switch (t[0]) {
    case 'radio': {
      const r = e.find((n) => n.checked);
      return r ? r.value : void 0;
    }
    case 'checkbox':
      return e.filter((r) => r.checked).map((r) => r.value);
    default:
      return e.map((r) => r.value);
  }
}
o(f_, 'getMultiElementValue');
function m_(e, t) {
  const r = [...e.querySelectorAll(`[name="${(0, HF.default)(t)}"]`)];
  if (r.length !== 0)
    switch (r.length) {
      case 1:
        return Uf(r[0]);
      default:
        return f_(r);
    }
}
o(m_, 'getFormValue');
function y_(e) {
  return /\[\]$/.test(e) ? e.slice(0, -2) : e;
}
o(y_, 'getPureName');
function h_(e) {
  return Array.from(e.elements)
    .map((r) => r.name)
    .reduce((r, n) => ({ ...r, [y_(n)]: m_(e, n) }), {});
}
o(h_, 'getAllFormValues');
function Zf(e, t) {
  if ((we(e, Zf, this), !e.elements))
    throw new Error('toHaveFormValues must be called on a form or a fieldset');
  const r = h_(e);
  return {
    pass: Object.entries(t).every(([n, i]) => Dl(r[n], i)),
    message: o(() => {
      const n = this.isNot ? 'not to' : 'to',
        i = `${this.isNot ? '.not' : ''}.toHaveFormValues`,
        s = Object.keys(r)
          .filter((a) => t.hasOwnProperty(a))
          .reduce((a, c) => ({ ...a, [c]: r[c] }), {});
      return [
        this.utils.matcherHint(i, 'element', ''),
        `Expected the element ${n} have form values`,
        this.utils.diff(t, s),
      ].join(`

`);
    }, 'message'),
  };
}
o(Zf, 'toHaveFormValues');
function g_(e) {
  const { getComputedStyle: t } = e.ownerDocument.defaultView,
    { display: r, visibility: n, opacity: i } = t(e);
  return r !== 'none' && n !== 'hidden' && n !== 'collapse' && i !== '0' && i !== 0;
}
o(g_, 'isStyleVisible');
function b_(e, t) {
  let r;
  return (
    t
      ? (r = e.nodeName === 'DETAILS' && t.nodeName !== 'SUMMARY' ? e.hasAttribute('open') : !0)
      : (r = e.nodeName === 'DETAILS' ? e.hasAttribute('open') : !0),
    !e.hasAttribute('hidden') && r
  );
}
o(b_, 'isAttributeVisible');
function em(e, t) {
  return g_(e) && b_(e, t) && (!e.parentElement || em(e.parentElement, e));
}
o(em, 'isElementVisible');
function tm(e) {
  we(e, tm, this);
  const t = e.ownerDocument === e.getRootNode({ composed: !0 }),
    r = t && em(e);
  return {
    pass: r,
    message: o(() => {
      const n = r ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeVisible`, 'element', ''),
        '',
        `Received element ${n} visible${t ? '' : ' (element is not in the document)'}:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
o(tm, 'toBeVisible');
var YF = ['fieldset', 'input', 'select', 'optgroup', 'option', 'button', 'textarea'];
function v_(e, t) {
  return (
    _r(e) === 'legend' &&
    _r(t) === 'fieldset' &&
    e.isSameNode(Array.from(t.children).find((r) => _r(r) === 'legend'))
  );
}
o(v_, 'isFirstLegendChildOfFieldset');
function E_(e, t) {
  return nm(t) && !v_(e, t);
}
o(E_, 'isElementDisabledByParent');
function T_(e) {
  return e.includes('-');
}
o(T_, 'isCustomElement');
function rm(e) {
  const t = _r(e);
  return YF.includes(t) || T_(t);
}
o(rm, 'canElementBeDisabled');
function nm(e) {
  return rm(e) && e.hasAttribute('disabled');
}
o(nm, 'isElementDisabled');
function om(e) {
  const t = e.parentElement;
  return !!t && (E_(e, t) || om(t));
}
o(om, 'isAncestorDisabled');
function im(e) {
  return rm(e) && (nm(e) || om(e));
}
o(im, 'isElementOrAncestorDisabled');
function sm(e) {
  we(e, sm, this);
  const t = im(e);
  return {
    pass: t,
    message: o(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeDisabled`, 'element', ''),
        '',
        `Received element ${r} disabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
o(sm, 'toBeDisabled');
function am(e) {
  we(e, am, this);
  const t = !im(e);
  return {
    pass: t,
    message: o(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeEnabled`, 'element', ''),
        '',
        `Received element ${r} enabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
o(am, 'toBeEnabled');
var XF = ['select', 'textarea'],
  QF = ['input', 'select', 'textarea'],
  ZF = ['color', 'hidden', 'range', 'submit', 'image', 'reset'],
  eB = [
    'checkbox',
    'combobox',
    'gridcell',
    'listbox',
    'radiogroup',
    'spinbutton',
    'textbox',
    'tree',
  ];
function w_(e) {
  return XF.includes(_r(e)) && e.hasAttribute('required');
}
o(w_, 'isRequiredOnFormTagsExceptInput');
function S_(e) {
  return (
    _r(e) === 'input' &&
    e.hasAttribute('required') &&
    ((e.hasAttribute('type') && !ZF.includes(e.getAttribute('type'))) || !e.hasAttribute('type'))
  );
}
o(S_, 'isRequiredOnSupportedInput');
function __(e) {
  return (
    e.hasAttribute('aria-required') &&
    e.getAttribute('aria-required') === 'true' &&
    (QF.includes(_r(e)) || (e.hasAttribute('role') && eB.includes(e.getAttribute('role'))))
  );
}
o(__, 'isElementRequiredByARIA');
function lm(e) {
  we(e, lm, this);
  const t = w_(e) || S_(e) || __(e);
  return {
    pass: t,
    message: o(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeRequired`, 'element', ''),
        '',
        `Received element ${r} required:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
o(lm, 'toBeRequired');
var tB = ['form', 'input', 'select', 'textarea'];
function R_(e) {
  return e.hasAttribute('aria-invalid') && e.getAttribute('aria-invalid') !== 'false';
}
o(R_, 'isElementHavingAriaInvalid');
function P_(e) {
  return tB.includes(_r(e));
}
o(P_, 'isSupportsValidityMethod');
function cm(e) {
  const t = R_(e);
  return P_(e) ? t || !e.checkValidity() : t;
}
o(cm, 'isElementInvalid');
function um(e) {
  we(e, um, this);
  const t = cm(e);
  return {
    pass: t,
    message: o(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInvalid`, 'element', ''),
        '',
        `Received element ${r} currently invalid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
o(um, 'toBeInvalid');
function dm(e) {
  we(e, dm, this);
  const t = !cm(e);
  return {
    pass: t,
    message: o(() => {
      const r = t ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeValid`, 'element', ''),
        '',
        `Received element ${r} currently valid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
o(dm, 'toBeValid');
function pm(e, t) {
  if (
    (we(e, pm, this), e.tagName.toLowerCase() === 'input' && ['checkbox', 'radio'].includes(e.type))
  )
    throw new Error(
      'input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead',
    );
  const r = Uf(e),
    n = t !== void 0;
  let i = t,
    s = r;
  return (
    t == r && t !== r && ((i = `${t} (${typeof t})`), (s = `${r} (${typeof r})`)),
    {
      pass: n ? Dl(r, t) : !!r,
      message: o(() => {
        const a = this.isNot ? 'not to' : 'to',
          c = this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveValue`, 'element', t);
        return Ge(this, c, `Expected the element ${a} have value`, n ? i : '(any)', 'Received', s);
      }, 'message'),
    }
  );
}
o(pm, 'toHaveValue');
function fm(e, t) {
  we(e, fm, this);
  const r = e.tagName.toLowerCase();
  if (!['select', 'input', 'textarea'].includes(r))
    throw new Error(
      '.toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead.',
    );
  if (r === 'input' && ['radio', 'checkbox'].includes(e.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${e.type}"], try with another matcher instead.`,
    );
  const n = A_(r, e),
    i = O_(t),
    s = i.filter((d) =>
      n.some((u) => (d instanceof RegExp ? d.test(u) : this.equals(u, String(d)))),
    ).length,
    a = s === n.length,
    c = s === i.length;
  return {
    pass: a && c,
    message: o(
      () =>
        Ge(
          this,
          this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveDisplayValue`, 'element', ''),
          `Expected element ${this.isNot ? 'not ' : ''}to have display value`,
          t,
          'Received',
          n,
        ),
      'message',
    ),
  };
}
o(fm, 'toHaveDisplayValue');
function A_(e, t) {
  return e === 'select'
    ? Array.from(t)
        .filter((r) => r.selected)
        .map((r) => r.textContent)
    : [t.value];
}
o(A_, 'getValues');
function O_(e) {
  return e instanceof Array ? e : [e];
}
o(O_, 'getExpectedValues');
function mm(e) {
  we(e, mm, this);
  const t = o(
      () => e.tagName.toLowerCase() === 'input' && ['checkbox', 'radio'].includes(e.type),
      'isValidInput',
    ),
    r = o(
      () =>
        ym(e.getAttribute('role')) && ['true', 'false'].includes(e.getAttribute('aria-checked')),
      'isValidAriaElement',
    );
  if (!t() && !r())
    return {
      pass: !1,
      message: o(
        () =>
          `only inputs with type="checkbox" or type="radio" or elements with ${C_()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`,
        'message',
      ),
    };
  const n = o(() => (t() ? e.checked : e.getAttribute('aria-checked') === 'true'), 'isChecked');
  return {
    pass: n(),
    message: o(() => {
      const i = n() ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeChecked`, 'element', ''),
        '',
        `Received element ${i} checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
o(mm, 'toBeChecked');
function C_() {
  return r_(
    x_().map((e) => `role="${e}"`),
    { lastWordConnector: ' or ' },
  );
}
o(C_, 'supportedRolesSentence');
function x_() {
  return Jf.roles.keys().filter(ym);
}
o(x_, 'supportedRoles');
function ym(e) {
  return Jf.roles.get(e)?.props['aria-checked'] !== void 0;
}
o(ym, 'roleSupportsChecked');
function hm(e) {
  we(e, hm, this);
  const t = o(() => e.tagName.toLowerCase() === 'input' && e.type === 'checkbox', 'isValidInput'),
    r = o(() => e.getAttribute('role') === 'checkbox', 'isValidAriaElement');
  if (!t() && !r())
    return {
      pass: !1,
      message: o(
        () =>
          'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead',
        'message',
      ),
    };
  const n = o(() => {
    const i = e.getAttribute('aria-checked') === 'mixed';
    return (t() && e.indeterminate) || i;
  }, 'isPartiallyChecked');
  return {
    pass: n(),
    message: o(() => {
      const i = n() ? 'is' : 'is not';
      return [
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBePartiallyChecked`, 'element', ''),
        '',
        `Received element ${i} partially checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`,
      ].join(`
`);
    }, 'message'),
  };
}
o(hm, 'toBePartiallyChecked');
function gm(e, t) {
  (ps('toHaveDescription', 'Please use toHaveAccessibleDescription.'), we(e, gm, this));
  const r = t !== void 0,
    i = (e.getAttribute('aria-describedby') || '').split(/\s+/).filter(Boolean);
  let s = '';
  if (i.length > 0) {
    const a = e.ownerDocument,
      c = i.map((d) => a.getElementById(d)).filter(Boolean);
    s = fs(c.map((d) => d.textContent).join(' '));
  }
  return {
    pass: r ? (t instanceof RegExp ? t.test(s) : this.equals(s, t)) : !!s,
    message: o(() => {
      const a = this.isNot ? 'not to' : 'to';
      return Ge(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveDescription`, 'element', ''),
        `Expected the element ${a} have description`,
        this.utils.printExpected(t),
        'Received',
        this.utils.printReceived(s),
      );
    }, 'message'),
  };
}
o(gm, 'toHaveDescription');
function bm(e, t) {
  if (
    (ps('toHaveErrorMessage', 'Please use toHaveAccessibleErrorMessage.'),
    we(e, bm, this),
    !e.hasAttribute('aria-invalid') || e.getAttribute('aria-invalid') === 'false')
  ) {
    const a = this.isNot ? '.not' : '';
    return {
      pass: !1,
      message: o(
        () =>
          Ge(
            this,
            this.utils.matcherHint(`${a}.toHaveErrorMessage`, 'element', ''),
            'Expected the element to have invalid state indicated by',
            'aria-invalid="true"',
            'Received',
            e.hasAttribute('aria-invalid')
              ? `aria-invalid="${e.getAttribute('aria-invalid')}"`
              : this.utils.printReceived(''),
          ),
        'message',
      ),
    };
  }
  const r = t !== void 0,
    i = (e.getAttribute('aria-errormessage') || '').split(/\s+/).filter(Boolean);
  let s = '';
  if (i.length > 0) {
    const a = e.ownerDocument,
      c = i.map((d) => a.getElementById(d)).filter(Boolean);
    s = fs(c.map((d) => d.textContent).join(' '));
  }
  return {
    pass: r ? (t instanceof RegExp ? t.test(s) : this.equals(s, t)) : !!s,
    message: o(() => {
      const a = this.isNot ? 'not to' : 'to';
      return Ge(
        this,
        this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveErrorMessage`, 'element', ''),
        `Expected the element ${a} have error message`,
        this.utils.printExpected(t),
        'Received',
        this.utils.printReceived(s),
      );
    }, 'message'),
  };
}
o(bm, 'toHaveErrorMessage');
function N_(e) {
  const t = e.ownerDocument.getSelection();
  if (['input', 'textarea'].includes(e.tagName.toLowerCase()))
    return ['radio', 'checkbox'].includes(e.type)
      ? ''
      : e.value.toString().substring(e.selectionStart, e.selectionEnd);
  if (t.anchorNode === null || t.focusNode === null) return '';
  const r = t.getRangeAt(0),
    n = e.ownerDocument.createRange();
  if (t.containsNode(e, !1)) (n.selectNodeContents(e), t.removeAllRanges(), t.addRange(n));
  else if (!(e.contains(t.anchorNode) && e.contains(t.focusNode))) {
    const s = e === r.startContainer || e.contains(r.startContainer),
      a = e === r.endContainer || e.contains(r.endContainer);
    (t.removeAllRanges(),
      (s || a) &&
        (n.selectNodeContents(e),
        s && n.setStart(r.startContainer, r.startOffset),
        a && n.setEnd(r.endContainer, r.endOffset),
        t.addRange(n)));
  }
  const i = t.toString();
  return (t.removeAllRanges(), t.addRange(r), i);
}
o(N_, 'getSelection');
function vm(e, t) {
  we(e, vm, this);
  const r = t !== void 0;
  if (r && typeof t != 'string')
    throw new Error('expected selection must be a string or undefined');
  const n = N_(e);
  return {
    pass: r ? Dl(n, t) : !!n,
    message: o(() => {
      const i = this.isNot ? 'not to' : 'to',
        s = this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveSelection`, 'element', t);
      return Ge(
        this,
        s,
        `Expected the element ${i} have selection`,
        r ? t : '(any)',
        'Received',
        n,
      );
    }, 'message'),
  };
}
o(vm, 'toHaveSelection');
function Em(e) {
  we(e, Em, this);
  const t = (e.getAttribute('role') || '').split(' ').map((a) => a.trim()),
    r =
      e.tagName.toLowerCase() === 'button' ||
      (e.tagName.toLowerCase() === 'input' && e.type === 'button') ||
      t.includes('button'),
    n = e.getAttribute('aria-pressed');
  return !r || !(n === 'true' || n === 'false')
    ? {
        pass: !1,
        message: o(
          () =>
            'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()',
          'message',
        ),
      }
    : {
        pass: r && n === 'true',
        message: o(() => {
          const a = this.utils.matcherHint(
            `${this.isNot ? '.not' : ''}.toBePressed`,
            'element',
            '',
          );
          return Ge(
            this,
            a,
            'Expected element to have',
            `aria-pressed="${this.isNot ? 'false' : 'true'}"`,
            'Received',
            `aria-pressed="${n}"`,
          );
        }, 'message'),
      };
}
o(Em, 'toBePressed');
function Tm(e) {
  we(e, Tm, this);
  const t = (e.getAttribute('role') || '').split(' ').map((a) => a.trim()),
    r =
      e.tagName.toLowerCase() === 'button' ||
      (e.tagName.toLowerCase() === 'input' && e.type === 'button') ||
      t.includes('button'),
    n = e.getAttribute('aria-pressed');
  return !r || !(n === 'true' || n === 'false' || n === 'mixed')
    ? {
        pass: !1,
        message: o(
          () =>
            'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()',
          'message',
        ),
      }
    : {
        pass: r && n === 'mixed',
        message: o(() => {
          const a = this.isNot ? 'not to' : 'to',
            c = this.utils.matcherHint(
              `${this.isNot ? '.not' : ''}.toBePartiallyPressed`,
              'element',
              '',
            );
          return Ge(
            this,
            c,
            `Expected element ${a} have`,
            'aria-pressed="mixed"',
            'Received',
            `aria-pressed="${n}"`,
          );
        }, 'message'),
      };
}
o(Tm, 'toBePartiallyPressed');
var rB = 1,
  I_ = 2,
  M_ = 4,
  nB = 8,
  oB = 16,
  iB = 32,
  rg = {
    [rB]: 'Node.DOCUMENT_POSITION_DISCONNECTED',
    [I_]: 'Node.DOCUMENT_POSITION_PRECEDING',
    [M_]: 'Node.DOCUMENT_POSITION_FOLLOWING',
    [nB]: 'Node.DOCUMENT_POSITION_CONTAINS',
    [oB]: 'Node.DOCUMENT_POSITION_CONTAINED_BY',
    [iB]: 'Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
  };
function q_(e) {
  return e in rg ? `${rg[e]} (${e})` : `Unknown document position (${e})`;
}
o(q_, 'makeDocumentPositionErrorString');
function wm(e, t) {
  return function (r, n) {
    (we(r, ga, this), we(n, ga, this));
    const i = r.compareDocumentPosition(n);
    return {
      pass: i === t,
      message: o(
        () =>
          [
            this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${e}`, 'element', 'secondElement'),
            '',
            `Received: ${q_(i)}`,
          ].join(`
`),
        'message',
      ),
    };
  };
}
o(wm, 'checkToAppear');
function ga(e, t) {
  return wm('toAppearBefore', M_).apply(this, [e, t]);
}
o(ga, 'toAppearBefore');
function j_(e, t) {
  return wm('toAppearAfter', I_).apply(this, [e, t]);
}
o(j_, 'toAppearAfter');
ze(ib(), 1);
ze($d(), 1);
ze(sb(), 1);
ze(ab(), 1);
var Mc, ng;
function k_() {
  if (ng) return Mc;
  ng = 1;
  var e, t, r, n, i, s, a, c, d, u, p, f, y, h, g, T, E, v, S;
  return (
    (y =
      /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy),
    (f =
      /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y),
    (e =
      /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy),
    (g = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y),
    (p =
      /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y),
    (T = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y),
    (S = /[\t\v\f\ufeff\p{Zs}]+/uy),
    (c = /\r?\n|[\r\u2028\u2029]/y),
    (d = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y),
    (h = /\/\/.*/y),
    (r = /[<>.:={}]|\/(?![\/*])/y),
    (t = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy),
    (n = /(['"])(?:(?!\1)[^])*(\1)?/y),
    (i = /[^<>{}]+/y),
    (v =
      /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/),
    (E = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/),
    (s = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/),
    (a = /^(?:return|throw|yield)$/),
    (u = RegExp(c.source)),
    (Mc = o(function* (A, { jsx: N = !1 } = {}) {
      var j, C, R, w, _, k, I, V, H, P, L, B, D, K;
      for ({ length: k } = A, w = 0, _ = '', K = [{ tag: 'JS' }], j = [], L = 0, B = !1; w < k; ) {
        switch (((V = K[K.length - 1]), V.tag)) {
          case 'JS':
          case 'JSNonExpressionParen':
          case 'InterpolationInTemplate':
          case 'InterpolationInJSX':
            if (A[w] === '/' && (v.test(_) || s.test(_)) && ((y.lastIndex = w), (I = y.exec(A)))) {
              ((w = y.lastIndex),
                (_ = I[0]),
                (B = !0),
                yield {
                  type: 'RegularExpressionLiteral',
                  value: I[0],
                  closed: I[1] !== void 0 && I[1] !== '\\',
                });
              continue;
            }
            if (((f.lastIndex = w), (I = f.exec(A)))) {
              switch (((D = I[0]), (H = f.lastIndex), (P = D), D)) {
                case '(':
                  (_ === '?NonExpressionParenKeyword' &&
                    K.push({ tag: 'JSNonExpressionParen', nesting: L }),
                    L++,
                    (B = !1));
                  break;
                case ')':
                  (L--,
                    (B = !0),
                    V.tag === 'JSNonExpressionParen' &&
                      L === V.nesting &&
                      (K.pop(), (P = '?NonExpressionParenEnd'), (B = !1)));
                  break;
                case '{':
                  ((f.lastIndex = 0),
                    (R = !E.test(_) && (v.test(_) || s.test(_))),
                    j.push(R),
                    (B = !1));
                  break;
                case '}':
                  switch (V.tag) {
                    case 'InterpolationInTemplate':
                      if (j.length === V.nesting) {
                        ((T.lastIndex = w),
                          (I = T.exec(A)),
                          (w = T.lastIndex),
                          (_ = I[0]),
                          I[1] === '${'
                            ? ((_ = '?InterpolationInTemplate'),
                              (B = !1),
                              yield { type: 'TemplateMiddle', value: I[0] })
                            : (K.pop(),
                              (B = !0),
                              yield { type: 'TemplateTail', value: I[0], closed: I[1] === '`' }));
                        continue;
                      }
                      break;
                    case 'InterpolationInJSX':
                      if (j.length === V.nesting) {
                        (K.pop(), (w += 1), (_ = '}'), yield { type: 'JSXPunctuator', value: '}' });
                        continue;
                      }
                  }
                  ((B = j.pop()), (P = B ? '?ExpressionBraceEnd' : '}'));
                  break;
                case ']':
                  B = !0;
                  break;
                case '++':
                case '--':
                  P = B ? '?PostfixIncDec' : '?UnaryIncDec';
                  break;
                case '<':
                  if (N && (v.test(_) || s.test(_))) {
                    (K.push({ tag: 'JSXTag' }),
                      (w += 1),
                      (_ = '<'),
                      yield { type: 'JSXPunctuator', value: D });
                    continue;
                  }
                  B = !1;
                  break;
                default:
                  B = !1;
              }
              ((w = H), (_ = P), yield { type: 'Punctuator', value: D });
              continue;
            }
            if (((e.lastIndex = w), (I = e.exec(A)))) {
              switch (((w = e.lastIndex), (P = I[0]), I[0])) {
                case 'for':
                case 'if':
                case 'while':
                case 'with':
                  _ !== '.' && _ !== '?.' && (P = '?NonExpressionParenKeyword');
              }
              ((_ = P),
                (B = !s.test(I[0])),
                yield { type: I[1] === '#' ? 'PrivateIdentifier' : 'IdentifierName', value: I[0] });
              continue;
            }
            if (((g.lastIndex = w), (I = g.exec(A)))) {
              ((w = g.lastIndex),
                (_ = I[0]),
                (B = !0),
                yield { type: 'StringLiteral', value: I[0], closed: I[2] !== void 0 });
              continue;
            }
            if (((p.lastIndex = w), (I = p.exec(A)))) {
              ((w = p.lastIndex),
                (_ = I[0]),
                (B = !0),
                yield { type: 'NumericLiteral', value: I[0] });
              continue;
            }
            if (((T.lastIndex = w), (I = T.exec(A)))) {
              ((w = T.lastIndex),
                (_ = I[0]),
                I[1] === '${'
                  ? ((_ = '?InterpolationInTemplate'),
                    K.push({ tag: 'InterpolationInTemplate', nesting: j.length }),
                    (B = !1),
                    yield { type: 'TemplateHead', value: I[0] })
                  : ((B = !0),
                    yield { type: 'NoSubstitutionTemplate', value: I[0], closed: I[1] === '`' }));
              continue;
            }
            break;
          case 'JSXTag':
          case 'JSXTagEnd':
            if (((r.lastIndex = w), (I = r.exec(A)))) {
              switch (((w = r.lastIndex), (P = I[0]), I[0])) {
                case '<':
                  K.push({ tag: 'JSXTag' });
                  break;
                case '>':
                  (K.pop(),
                    _ === '/' || V.tag === 'JSXTagEnd'
                      ? ((P = '?JSX'), (B = !0))
                      : K.push({ tag: 'JSXChildren' }));
                  break;
                case '{':
                  (K.push({ tag: 'InterpolationInJSX', nesting: j.length }),
                    (P = '?InterpolationInJSX'),
                    (B = !1));
                  break;
                case '/':
                  _ === '<' &&
                    (K.pop(),
                    K[K.length - 1].tag === 'JSXChildren' && K.pop(),
                    K.push({ tag: 'JSXTagEnd' }));
              }
              ((_ = P), yield { type: 'JSXPunctuator', value: I[0] });
              continue;
            }
            if (((t.lastIndex = w), (I = t.exec(A)))) {
              ((w = t.lastIndex), (_ = I[0]), yield { type: 'JSXIdentifier', value: I[0] });
              continue;
            }
            if (((n.lastIndex = w), (I = n.exec(A)))) {
              ((w = n.lastIndex),
                (_ = I[0]),
                yield { type: 'JSXString', value: I[0], closed: I[2] !== void 0 });
              continue;
            }
            break;
          case 'JSXChildren':
            if (((i.lastIndex = w), (I = i.exec(A)))) {
              ((w = i.lastIndex), (_ = I[0]), yield { type: 'JSXText', value: I[0] });
              continue;
            }
            switch (A[w]) {
              case '<':
                (K.push({ tag: 'JSXTag' }),
                  w++,
                  (_ = '<'),
                  yield { type: 'JSXPunctuator', value: '<' });
                continue;
              case '{':
                (K.push({ tag: 'InterpolationInJSX', nesting: j.length }),
                  w++,
                  (_ = '?InterpolationInJSX'),
                  (B = !1),
                  yield { type: 'JSXPunctuator', value: '{' });
                continue;
            }
        }
        if (((S.lastIndex = w), (I = S.exec(A)))) {
          ((w = S.lastIndex), yield { type: 'WhiteSpace', value: I[0] });
          continue;
        }
        if (((c.lastIndex = w), (I = c.exec(A)))) {
          ((w = c.lastIndex),
            (B = !1),
            a.test(_) && (_ = '?NoLineTerminatorHere'),
            yield { type: 'LineTerminatorSequence', value: I[0] });
          continue;
        }
        if (((d.lastIndex = w), (I = d.exec(A)))) {
          ((w = d.lastIndex),
            u.test(I[0]) && ((B = !1), a.test(_) && (_ = '?NoLineTerminatorHere')),
            yield { type: 'MultiLineComment', value: I[0], closed: I[1] !== void 0 });
          continue;
        }
        if (((h.lastIndex = w), (I = h.exec(A)))) {
          ((w = h.lastIndex), (B = !1), yield { type: 'SingleLineComment', value: I[0] });
          continue;
        }
        ((C = String.fromCodePoint(A.codePointAt(w))),
          (w += C.length),
          (_ = C),
          (B = !1),
          yield { type: V.tag.startsWith('JSX') ? 'JSXInvalid' : 'Invalid', value: C });
      }
    }, 'jsTokens_1')),
    Mc
  );
}
o(k_, 'requireJsTokens');
var sB = k_();
kp(sB);
var D_ = {
  keyword: [
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
  ],
  strict: [
    'implements',
    'interface',
    'let',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
  ],
};
new Set(D_.keyword);
new Set(D_.strict);
function wi(e, t) {
  if (!e) throw new Error(t);
}
o(wi, 'S');
function ln(e, t) {
  return typeof t === e;
}
o(ln, 'f');
function L_(e) {
  return e instanceof Promise;
}
o(L_, 'w');
function lo(e, t, r) {
  Object.defineProperty(e, t, r);
}
o(lo, 'u');
function pn(e, t, r) {
  lo(e, t, { value: r, configurable: !0, writable: !0 });
}
o(pn, 'l');
var Lr = Symbol.for('tinyspy:spy'),
  aB = new Set(),
  lB = o((e) => {
    ((e.called = !1),
      (e.callCount = 0),
      (e.calls = []),
      (e.results = []),
      (e.resolves = []),
      (e.next = []));
  }, 'h'),
  cB = o((e) => (lo(e, Lr, { value: { reset: o(() => lB(e[Lr]), 'reset') } }), e[Lr]), 'k'),
  ju = o((e) => e[Lr] || cB(e), 'T');
function F_(e) {
  wi(ln('function', e) || ln('undefined', e), 'cannot spy on a non-function value');
  let t = o(function (...n) {
    let i = ju(t);
    ((i.called = !0), i.callCount++, i.calls.push(n));
    let s = i.next.shift();
    if (s) {
      i.results.push(s);
      let [p, f] = s;
      if (p === 'ok') return f;
      throw f;
    }
    let a,
      c = 'ok',
      d = i.results.length;
    if (i.impl)
      try {
        (new.target ? (a = Reflect.construct(i.impl, n, new.target)) : (a = i.impl.apply(this, n)),
          (c = 'ok'));
      } catch (p) {
        throw ((a = p), (c = 'error'), i.results.push([c, p]), p);
      }
    let u = [c, a];
    return (
      L_(a) &&
        a.then(
          (p) => (i.resolves[d] = ['ok', p]),
          (p) => (i.resolves[d] = ['error', p]),
        ),
      i.results.push(u),
      a
    );
  }, 't');
  (pn(t, '_isMockFunction', !0),
    pn(t, 'length', e ? e.length : 0),
    pn(t, 'name', (e && e.name) || 'spy'));
  let r = ju(t);
  return (r.reset(), (r.impl = e), t);
}
o(F_, 'R');
function B_(e) {
  return !!e && e._isMockFunction === !0;
}
o(B_, 'v');
var J_ = o((e, t) => {
    let r = Object.getOwnPropertyDescriptor(e, t);
    if (r) return [e, r];
    let n = Object.getPrototypeOf(e);
    for (; n !== null; ) {
      let i = Object.getOwnPropertyDescriptor(n, t);
      if (i) return [n, i];
      n = Object.getPrototypeOf(n);
    }
  }, 'b'),
  og = o((e, t) => {
    t != null &&
      typeof t == 'function' &&
      t.prototype != null &&
      Object.setPrototypeOf(e.prototype, t.prototype);
  }, 'P');
function Sm(e, t, r) {
  (wi(!ln('undefined', e), 'spyOn could not find an object to spy upon'),
    wi(ln('object', e) || ln('function', e), 'cannot spyOn on a primitive value'));
  let [n, i] = (() => {
      if (!ln('object', t)) return [t, 'value'];
      if ('getter' in t && 'setter' in t) throw new Error('cannot spy on both getter and setter');
      if ('getter' in t) return [t.getter, 'get'];
      if ('setter' in t) return [t.setter, 'set'];
      throw new Error('specify getter or setter to spy on');
    })(),
    [s, a] = J_(e, n) || [];
  wi(a || n in e, `${String(n)} does not exist`);
  let c = !1;
  i === 'value' && a && !a.value && a.get && ((i = 'get'), (c = !0), (r = a.get()));
  let d;
  (a ? (d = a[i]) : i !== 'value' ? (d = o(() => e[n], 'p')) : (d = e[n]),
    d && V_(d) && (d = d[Lr].getOriginal()));
  let u = o((h) => {
      let { value: g, ...T } = a || { configurable: !0, writable: !0 };
      (i !== 'value' && delete T.writable, (T[i] = h), lo(e, n, T));
    }, 'g'),
    p = o(() => {
      s !== e ? Reflect.deleteProperty(e, n) : a && !d ? lo(e, n, a) : u(d);
    }, 'a');
  r || (r = d);
  let f = U_(F_(r), r);
  i === 'value' && og(f, d);
  let y = f[Lr];
  return (
    pn(y, 'restore', p),
    pn(y, 'getOriginal', () => (c ? d() : d)),
    pn(y, 'willCall', (h) => ((y.impl = h), f)),
    u(c ? () => (og(f, r), f) : f),
    aB.add(f),
    f
  );
}
o(Sm, 'M');
var uB = new Set(['length', 'name', 'prototype']);
function $_(e) {
  let t = new Set(),
    r = {};
  for (; e && e !== Object.prototype && e !== Function.prototype; ) {
    let n = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
    for (let i of n)
      r[i] || uB.has(i) || (t.add(i), (r[i] = Object.getOwnPropertyDescriptor(e, i)));
    e = Object.getPrototypeOf(e);
  }
  return { properties: t, descriptors: r };
}
o($_, 'D');
function U_(e, t) {
  if (!t || Lr in t) return e;
  let { properties: r, descriptors: n } = $_(t);
  for (let i of r) {
    let s = n[i];
    J_(e, i) || lo(e, i, s);
  }
  return e;
}
o(U_, 'E');
function V_(e) {
  return B_(e) && 'getOriginal' in e[Lr];
}
o(V_, 'j');
var ms = new Set();
function fn(e) {
  return typeof e == 'function' && '_isMockFunction' in e && e._isMockFunction;
}
o(fn, 'isMockFunction');
function H_(e, t, r) {
  const i = r ? { [{ get: 'getter', set: 'setter' }[r]]: t } : t;
  let s;
  const a = G_(e, t),
    c = a && a[r || 'value'];
  fn(c) && (s = c.mock._state());
  try {
    const d = Sm(e, i),
      u = _m(d);
    return (s && u.mock._state(s), u);
  } catch (d) {
    throw d instanceof TypeError &&
      Symbol.toStringTag &&
      e[Symbol.toStringTag] === 'Module' &&
      (d.message.includes('Cannot redefine property') ||
        d.message.includes('Cannot replace module namespace') ||
        d.message.includes("can't redefine non-configurable property"))
      ? new TypeError(
          `Cannot spy on export "${String(i)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`,
          { cause: d },
        )
      : d;
  }
}
o(H_, 'spyOn');
var dB = 0;
function _m(e) {
  const t = e;
  let r,
    n = [],
    i = !1,
    s = [],
    a = [],
    c = [];
  const d = ju(e),
    u = {
      get calls() {
        return d.calls;
      },
      get contexts() {
        return a;
      },
      get instances() {
        return s;
      },
      get invocationCallOrder() {
        return c;
      },
      get results() {
        return d.results.map(([h, g]) => ({ type: h === 'error' ? 'throw' : 'return', value: g }));
      },
      get settledResults() {
        return d.resolves.map(([h, g]) => ({
          type: h === 'error' ? 'rejected' : 'fulfilled',
          value: g,
        }));
      },
      get lastCall() {
        return d.calls[d.calls.length - 1];
      },
      _state(h) {
        return (
          h &&
            ((r = h.implementation),
            (n = h.onceImplementations),
            (i = h.implementationChangedTemporarily)),
          { implementation: r, onceImplementations: n, implementationChangedTemporarily: i }
        );
      },
    };
  function p(...h) {
    return (
      s.push(this),
      a.push(this),
      c.push(++dB),
      (i ? r : n.shift() || r || d.getOriginal() || (() => {})).apply(this, h)
    );
  }
  o(p, 'mockCall');
  let f = t.name;
  ((t.getMockName = () => f || 'vi.fn()'),
    (t.mockName = (h) => ((f = h), t)),
    (t.mockClear = () => (d.reset(), (s = []), (a = []), (c = []), t)),
    (t.mockReset = () => (t.mockClear(), (r = void 0), (n = []), t)),
    (t.mockRestore = () => (t.mockReset(), d.restore(), t)),
    Symbol.dispose && (t[Symbol.dispose] = () => t.mockRestore()),
    (t.getMockImplementation = () => (i ? r : n.at(0) || r)),
    (t.mockImplementation = (h) => ((r = h), d.willCall(p), t)),
    (t.mockImplementationOnce = (h) => (n.push(h), t)));
  function y(h, g) {
    const T = r;
    ((r = h), d.willCall(p), (i = !0));
    const E = o(() => {
        ((r = T), (i = !1));
      }, 'reset'),
      v = g();
    return typeof v == 'object' && v && typeof v.then == 'function'
      ? v.then(() => (E(), t))
      : (E(), t);
  }
  return (
    o(y, 'withImplementation'),
    (t.withImplementation = y),
    (t.mockReturnThis = () =>
      t.mockImplementation(function () {
        return this;
      })),
    (t.mockReturnValue = (h) => t.mockImplementation(() => h)),
    (t.mockReturnValueOnce = (h) => t.mockImplementationOnce(() => h)),
    (t.mockResolvedValue = (h) => t.mockImplementation(() => Promise.resolve(h))),
    (t.mockResolvedValueOnce = (h) => t.mockImplementationOnce(() => Promise.resolve(h))),
    (t.mockRejectedValue = (h) => t.mockImplementation(() => Promise.reject(h))),
    (t.mockRejectedValueOnce = (h) => t.mockImplementationOnce(() => Promise.reject(h))),
    Object.defineProperty(t, 'mock', { get: o(() => u, 'get') }),
    d.willCall(p),
    ms.add(t),
    t
  );
}
o(_m, 'enhanceSpy');
function ku(e) {
  const t = _m(Sm({ spy: e || function () {} }, 'spy'));
  return (e && t.mockImplementation(e), t);
}
o(ku, 'fn');
function G_(e, t) {
  const r = Object.getOwnPropertyDescriptor(e, t);
  if (r) return r;
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    const i = Object.getOwnPropertyDescriptor(n, t);
    if (i) return i;
    n = Object.getPrototypeOf(n);
  }
}
o(G_, 'getDescriptor');
var Ji = Symbol.for('matchers-object'),
  $i = Symbol.for('$$jest-matchers-object-storybook'),
  Rm = Symbol.for('expect-global'),
  Du = Symbol.for('asymmetric-matchers-object'),
  pB = {
    toSatisfy(e, t, r) {
      const { printReceived: n, printExpected: i, matcherHint: s } = this.utils,
        a = t(e);
      return {
        pass: a,
        message: o(
          () =>
            a
              ? `${s('.not.toSatisfy', 'received', '')}

Expected value to not satisfy:
${r || i(t)}
Received:
${n(e)}`
              : `${s('.toSatisfy', 'received', '')}

Expected value to satisfy:
${r || i(t)}

Received:
${n(e)}`,
          'message',
        ),
      };
    },
    toBeOneOf(e, t) {
      const { equals: r, customTesters: n } = this,
        { printReceived: i, printExpected: s, matcherHint: a } = this.utils;
      if (!Array.isArray(t))
        throw new TypeError(`You must provide an array to ${a('.toBeOneOf')}, not '${typeof t}'.`);
      const c = t.length === 0 || t.some((d) => r(d, e, n));
      return {
        pass: c,
        message: o(
          () =>
            c
              ? `${a('.not.toBeOneOf', 'received', '')}

Expected value to not be one of:
${s(t)}
Received:
${i(e)}`
              : `${a('.toBeOneOf', 'received', '')}

Expected value to be one of:
${s(t)}

Received:
${i(e)}`,
          'message',
        ),
      };
    },
  },
  ba = Ue.green,
  Pm = Ue.red,
  fB = Ue.inverse,
  mB = Ue.bold,
  Cr = Ue.dim;
function z_(e, t = 'received', r = 'expected', n = {}) {
  const {
    comment: i = '',
    isDirectExpectCall: s = !1,
    isNot: a = !1,
    promise: c = '',
    secondArgument: d = '',
    expectedColor: u = ba,
    receivedColor: p = Pm,
    secondArgumentColor: f = ba,
  } = n;
  let y = '',
    h = 'expect';
  return (
    !s && t !== '' && ((y += Cr(`${h}(`) + p(t)), (h = ')')),
    c !== '' && ((y += Cr(`${h}.`) + c), (h = '')),
    a && ((y += `${Cr(`${h}.`)}not`), (h = '')),
    e.includes('.') ? (h += e) : ((y += Cr(`${h}.`) + e), (h = '')),
    r === '' ? (h += '()') : ((y += Cr(`${h}(`) + u(r)), d && (y += Cr(', ') + f(d)), (h = ')')),
    i !== '' && (h += ` // ${i}`),
    h !== '' && (y += Cr(h)),
    y
  );
}
o(z_, 'matcherHint');
var yB = '';
function Am(e) {
  return e.replace(/\s+$/gm, (t) => yB.repeat(t.length));
}
o(Am, 'replaceTrailingSpaces');
function W_(e) {
  return Pm(Am(bt(e)));
}
o(W_, 'printReceived');
function K_(e) {
  return ba(Am(bt(e)));
}
o(K_, 'printExpected');
function Om() {
  return {
    EXPECTED_COLOR: ba,
    RECEIVED_COLOR: Pm,
    INVERTED_COLOR: fB,
    BOLD_WEIGHT: mB,
    DIM_COLOR: Cr,
    diff: Nn,
    matcherHint: z_,
    printReceived: W_,
    printExpected: K_,
    printDiffOrStringify: Hp,
    printWithType: Y_,
  };
}
o(Om, 'getMatcherUtils');
function Y_(e, t, r) {
  const n = Mi(t),
    i =
      n !== 'null' && n !== 'undefined'
        ? `${e} has type:  ${n}
`
        : '',
    s = `${e} has value: ${r(t)}`;
  return i + s;
}
o(Y_, 'printWithType');
function Ll() {
  return globalThis[$i].customEqualityTesters;
}
o(Ll, 'getCustomEqualityTesters');
function Re(e, t, r, n) {
  return ((r = r || []), Wn(e, t, [], [], r, n ? Cm : Z_));
}
o(Re, 'equals');
function Lu(e) {
  return !!e && typeof e == 'object' && 'asymmetricMatch' in e && kt('Function', e.asymmetricMatch);
}
o(Lu, 'isAsymmetric');
function X_(e, t) {
  const r = Lu(e),
    n = Lu(t);
  if (!(r && n)) {
    if (r) return e.asymmetricMatch(t);
    if (n) return t.asymmetricMatch(e);
  }
}
o(X_, 'asymmetricMatch');
function Wn(e, t, r, n, i, s) {
  let a = !0;
  const c = X_(e, t);
  if (c !== void 0) return c;
  const d = { equals: Re };
  for (let g = 0; g < i.length; g++) {
    const T = i[g].call(d, e, t, i);
    if (T !== void 0) return T;
  }
  if (typeof URL == 'function' && e instanceof URL && t instanceof URL) return e.href === t.href;
  if (Object.is(e, t)) return !0;
  if (e === null || t === null) return e === t;
  const u = Object.prototype.toString.call(e);
  if (u !== Object.prototype.toString.call(t)) return !1;
  switch (u) {
    case '[object Boolean]':
    case '[object String]':
    case '[object Number]':
      return typeof e != typeof t
        ? !1
        : typeof e != 'object' && typeof t != 'object'
          ? Object.is(e, t)
          : Object.is(e.valueOf(), t.valueOf());
    case '[object Date]': {
      const g = +e,
        T = +t;
      return g === T || (Number.isNaN(g) && Number.isNaN(T));
    }
    case '[object RegExp]':
      return e.source === t.source && e.flags === t.flags;
    case '[object Temporal.Instant]':
    case '[object Temporal.ZonedDateTime]':
    case '[object Temporal.PlainDateTime]':
    case '[object Temporal.PlainDate]':
    case '[object Temporal.PlainTime]':
    case '[object Temporal.PlainYearMonth]':
    case '[object Temporal.PlainMonthDay]':
      return e.equals(t);
    case '[object Temporal.Duration]':
      return e.toString() === t.toString();
  }
  if (typeof e != 'object' || typeof t != 'object') return !1;
  if (Bu(e) && Bu(t)) return e.isEqualNode(t);
  let p = r.length;
  for (; p--; ) {
    if (r[p] === e) return n[p] === t;
    if (n[p] === t) return !1;
  }
  if ((r.push(e), n.push(t), u === '[object Array]' && e.length !== t.length)) return !1;
  if (e instanceof Error && t instanceof Error)
    try {
      return Q_(e, t, r, n, i, s);
    } finally {
      (r.pop(), n.pop());
    }
  const f = Fu(e, s);
  let y,
    h = f.length;
  if (Fu(t, s).length !== h) return !1;
  for (; h--; ) if (((y = f[h]), (a = s(t, y) && Wn(e[y], t[y], r, n, i, s)), !a)) return !1;
  return (r.pop(), n.pop(), a);
}
o(Wn, 'eq');
function Q_(e, t, r, n, i, s) {
  let a =
    Object.getPrototypeOf(e) === Object.getPrototypeOf(t) &&
    e.name === t.name &&
    e.message === t.message;
  return (
    typeof t.cause < 'u' && a && (a = Wn(e.cause, t.cause, r, n, i, s)),
    e instanceof AggregateError &&
      t instanceof AggregateError &&
      a &&
      (a = Wn(e.errors, t.errors, r, n, i, s)),
    a && (a = Wn({ ...e }, { ...t }, r, n, i, s)),
    a
  );
}
o(Q_, 'isErrorEqual');
function Fu(e, t) {
  const r = [];
  for (const n in e) t(e, n) && r.push(n);
  return r.concat(
    Object.getOwnPropertySymbols(e).filter((n) => Object.getOwnPropertyDescriptor(e, n).enumerable),
  );
}
o(Fu, 'keys');
function Z_(e, t) {
  return Cm(e, t) && e[t] !== void 0;
}
o(Z_, 'hasDefinedKey');
function Cm(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
o(Cm, 'hasKey');
function kt(e, t) {
  return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
o(kt, 'isA');
function Bu(e) {
  return (
    e !== null &&
    typeof e == 'object' &&
    'nodeType' in e &&
    typeof e.nodeType == 'number' &&
    'nodeName' in e &&
    typeof e.nodeName == 'string' &&
    'isEqualNode' in e &&
    typeof e.isEqualNode == 'function'
  );
}
o(Bu, 'isDomNode');
var e0 = '@@__IMMUTABLE_KEYED__@@',
  t0 = '@@__IMMUTABLE_SET__@@',
  hB = '@@__IMMUTABLE_LIST__@@',
  Fl = '@@__IMMUTABLE_ORDERED__@@',
  gB = '@@__IMMUTABLE_RECORD__@@';
function r0(e) {
  return !!(e && e[e0] && !e[Fl]);
}
o(r0, 'isImmutableUnorderedKeyed');
function n0(e) {
  return !!(e && e[t0] && !e[Fl]);
}
o(n0, 'isImmutableUnorderedSet');
function ys(e) {
  return e != null && typeof e == 'object' && !Array.isArray(e);
}
o(ys, 'isObjectLiteral');
function o0(e) {
  return !!(e && ys(e) && e[hB]);
}
o(o0, 'isImmutableList');
function i0(e) {
  return !!(e && ys(e) && e[e0] && e[Fl]);
}
o(i0, 'isImmutableOrderedKeyed');
function s0(e) {
  return !!(e && ys(e) && e[t0] && e[Fl]);
}
o(s0, 'isImmutableOrderedSet');
function a0(e) {
  return !!(e && ys(e) && e[gB]);
}
o(a0, 'isImmutableRecord');
var l0 = Symbol.iterator;
function Ju(e) {
  return !!(e != null && e[l0]);
}
o(Ju, 'hasIterator');
function At(e, t, r = [], n = [], i = []) {
  if (
    typeof e != 'object' ||
    typeof t != 'object' ||
    Array.isArray(e) ||
    Array.isArray(t) ||
    !Ju(e) ||
    !Ju(t)
  )
    return;
  if (e.constructor !== t.constructor) return !1;
  let s = n.length;
  for (; s--; ) if (n[s] === e) return i[s] === t;
  (n.push(e), i.push(t));
  const a = [...r.filter((u) => u !== At), c];
  function c(u, p) {
    return At(u, p, [...r], [...n], [...i]);
  }
  if ((o(c, 'iterableEqualityWithStack'), e.size !== void 0)) {
    if (e.size !== t.size) return !1;
    if (kt('Set', e) || n0(e)) {
      let u = !0;
      for (const p of e)
        if (!t.has(p)) {
          let f = !1;
          for (const y of t) Re(p, y, a) === !0 && (f = !0);
          if (f === !1) {
            u = !1;
            break;
          }
        }
      return (n.pop(), i.pop(), u);
    } else if (kt('Map', e) || r0(e)) {
      let u = !0;
      for (const p of e)
        if (!t.has(p[0]) || !Re(p[1], t.get(p[0]), a)) {
          let f = !1;
          for (const y of t) {
            const h = Re(p[0], y[0], a);
            let g = !1;
            (h === !0 && (g = Re(p[1], y[1], a)), g === !0 && (f = !0));
          }
          if (f === !1) {
            u = !1;
            break;
          }
        }
      return (n.pop(), i.pop(), u);
    }
  }
  const d = t[l0]();
  for (const u of e) {
    const p = d.next();
    if (p.done || !Re(u, p.value, a)) return !1;
  }
  if (!d.next().done) return !1;
  if (!o0(e) && !i0(e) && !s0(e) && !a0(e)) {
    const u = Object.entries(e),
      p = Object.entries(t);
    if (!Re(u, p, a)) return !1;
  }
  return (n.pop(), i.pop(), !0);
}
o(At, 'iterableEquality');
function Bl(e, t) {
  return !e || typeof e != 'object' || e === Object.prototype
    ? !1
    : Object.prototype.hasOwnProperty.call(e, t) || Bl(Object.getPrototypeOf(e), t);
}
o(Bl, 'hasPropertyInObject');
function c0(e) {
  return Ei(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
o(c0, 'isObjectWithKeys');
function Ao(e, t, r = []) {
  const n = r.filter((s) => s !== Ao),
    i = o(
      (s = new WeakMap()) =>
        (a, c) => {
          if (c0(c))
            return Object.keys(c).every((d) => {
              if (c[d] != null && typeof c[d] == 'object') {
                if (s.has(c[d])) return Re(a[d], c[d], n);
                s.set(c[d], !0);
              }
              const u = a != null && Bl(a, d) && Re(a[d], c[d], [...n, i(s)]);
              return (s.delete(c[d]), u);
            });
        },
      'subsetEqualityWithContext',
    );
  return i()(e, t);
}
o(Ao, 'subsetEquality');
function $u(e, t) {
  if (!(e == null || t == null || e.constructor === t.constructor)) return !1;
}
o($u, 'typeEquality');
function Uu(e, t) {
  let r = e,
    n = t;
  if (!(e instanceof DataView && t instanceof DataView)) {
    if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer)) return;
    try {
      ((r = new DataView(e)), (n = new DataView(t)));
    } catch {
      return;
    }
  }
  if (r.byteLength !== n.byteLength) return !1;
  for (let i = 0; i < r.byteLength; i++) if (r.getUint8(i) !== n.getUint8(i)) return !1;
  return !0;
}
o(Uu, 'arrayBufferEquality');
function va(e, t, r = []) {
  if (!Array.isArray(e) || !Array.isArray(t)) return;
  const n = Object.keys(e),
    i = Object.keys(t),
    s = r.filter((a) => a !== va);
  return Re(e, t, s, !0) && Re(n, i);
}
o(va, 'sparseArrayEquality');
function u0(e, t = '#{this}', r = '#{exp}') {
  const n = `expected ${t} to be ${r} // Object.is equality`;
  return ['toStrictEqual', 'toEqual'].includes(e)
    ? `${n}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
`
    : n;
}
o(u0, 'generateToBeMessage');
function d0(e, t) {
  return `${t} ${e}${t === 1 ? '' : 's'}`;
}
o(d0, 'pluralize');
function xs(e) {
  return [
    ...Object.keys(e),
    ...Object.getOwnPropertySymbols(e).filter((t) => {
      var r;
      return (r = Object.getOwnPropertyDescriptor(e, t)) === null || r === void 0
        ? void 0
        : r.enumerable;
    }),
  ];
}
o(xs, 'getObjectKeys');
function p0(e, t, r) {
  let n = 0;
  const i = o(
    (s = new WeakMap()) =>
      (a, c) => {
        if (Array.isArray(a)) {
          if (Array.isArray(c) && c.length === a.length) return c.map((d, u) => i(s)(a[u], d));
        } else {
          if (a instanceof Date) return a;
          if (Ei(a) && Ei(c)) {
            if (Re(a, c, [...r, At, Ao])) return c;
            const d = {};
            (s.set(a, d),
              typeof a.constructor == 'function' &&
                typeof a.constructor.name == 'string' &&
                Object.defineProperty(d, 'constructor', { enumerable: !1, value: a.constructor }));
            for (const u of xs(a))
              Bl(c, u)
                ? (d[u] = s.has(a[u]) ? s.get(a[u]) : i(s)(a[u], c[u]))
                : s.has(a[u]) || ((n += 1), Ei(a[u]) && (n += xs(a[u]).length), i(s)(a[u], c[u]));
            if (xs(d).length > 0) return d;
          }
        }
        return a;
      },
    'getObjectSubsetWithContext',
  );
  return { subset: i()(e, t), stripped: n };
}
o(p0, 'getObjectSubset');
if (!Object.prototype.hasOwnProperty.call(globalThis, Ji)) {
  const e = new WeakMap();
  Object.defineProperty(globalThis, Ji, { get: o(() => e, 'get') });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, $i)) {
  const e = Object.create(null),
    t = [];
  Object.defineProperty(globalThis, $i, {
    configurable: !0,
    get: o(
      () => ({ state: globalThis[Ji].get(globalThis[Rm]), matchers: e, customEqualityTesters: t }),
      'get',
    ),
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, Du)) {
  const e = Object.create(null);
  Object.defineProperty(globalThis, Du, { get: o(() => e, 'get') });
}
function Ui(e) {
  return globalThis[Ji].get(e);
}
o(Ui, 'getState');
function Ns(e, t) {
  const r = globalThis[Ji],
    n = r.get(t) || {},
    i = Object.defineProperties(n, {
      ...Object.getOwnPropertyDescriptors(n),
      ...Object.getOwnPropertyDescriptors(e),
    });
  r.set(t, i);
}
o(Ns, 'setState');
var f0 = class {
  constructor(t, r = !1) {
    Le(this, '$$typeof', Symbol.for('jest.asymmetricMatcher'));
    ((this.sample = t), (this.inverse = r));
  }
  getMatcherContext(t) {
    return {
      ...Ui(t || globalThis[Rm]),
      equals: Re,
      isNot: this.inverse,
      customTesters: Ll(),
      utils: { ...Om(), diff: Nn, stringify: bt, iterableEquality: At, subsetEquality: Ao },
    };
  }
};
o(f0, 'AsymmetricMatcher');
var Ar = f0;
Ar.prototype[Symbol.for('chai/inspect')] = function (e) {
  const t = bt(this, e.depth, { min: !0 });
  return t.length <= e.truncate ? t : `${this.toString()}{}`;
};
var m0 = class extends Ar {
  constructor(t, r = !1) {
    if (!kt('String', t)) throw new Error('Expected is not a string');
    super(t, r);
  }
  asymmetricMatch(t) {
    const r = kt('String', t) && t.includes(this.sample);
    return this.inverse ? !r : r;
  }
  toString() {
    return `String${this.inverse ? 'Not' : ''}Containing`;
  }
  getExpectedType() {
    return 'string';
  }
};
o(m0, 'StringContaining');
var ig = m0,
  y0 = class extends Ar {
    asymmetricMatch(t) {
      return t != null;
    }
    toString() {
      return 'Anything';
    }
    toAsymmetricMatcher() {
      return 'Anything';
    }
  };
o(y0, 'Anything');
var bB = y0,
  h0 = class extends Ar {
    constructor(t, r = !1) {
      super(t, r);
    }
    getPrototype(t) {
      return Object.getPrototypeOf
        ? Object.getPrototypeOf(t)
        : t.constructor.prototype === t
          ? null
          : t.constructor.prototype;
    }
    hasProperty(t, r) {
      return t
        ? Object.prototype.hasOwnProperty.call(t, r)
          ? !0
          : this.hasProperty(this.getPrototype(t), r)
        : !1;
    }
    asymmetricMatch(t) {
      if (typeof this.sample != 'object')
        throw new TypeError(
          `You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`,
        );
      let r = !0;
      const n = this.getMatcherContext();
      for (const i in this.sample)
        if (!this.hasProperty(t, i) || !Re(this.sample[i], t[i], n.customTesters)) {
          r = !1;
          break;
        }
      return this.inverse ? !r : r;
    }
    toString() {
      return `Object${this.inverse ? 'Not' : ''}Containing`;
    }
    getExpectedType() {
      return 'object';
    }
  };
o(h0, 'ObjectContaining');
var sg = h0,
  g0 = class extends Ar {
    constructor(t, r = !1) {
      super(t, r);
    }
    asymmetricMatch(t) {
      if (!Array.isArray(this.sample))
        throw new TypeError(
          `You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`,
        );
      const r = this.getMatcherContext(),
        n =
          this.sample.length === 0 ||
          (Array.isArray(t) && this.sample.every((i) => t.some((s) => Re(i, s, r.customTesters))));
      return this.inverse ? !n : n;
    }
    toString() {
      return `Array${this.inverse ? 'Not' : ''}Containing`;
    }
    getExpectedType() {
      return 'array';
    }
  };
o(g0, 'ArrayContaining');
var ag = g0,
  b0 = class extends Ar {
    constructor(t) {
      if (typeof t > 'u')
        throw new TypeError(
          'any() expects to be passed a constructor function. Please pass one or use anything() to match any object.',
        );
      super(t);
    }
    fnNameFor(t) {
      if (t.name) return t.name;
      const n = Function.prototype.toString
        .call(t)
        .match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
      return n ? n[1] : '<anonymous>';
    }
    asymmetricMatch(t) {
      return this.sample === String
        ? typeof t == 'string' || t instanceof String
        : this.sample === Number
          ? typeof t == 'number' || t instanceof Number
          : this.sample === Function
            ? typeof t == 'function' || typeof t == 'function'
            : this.sample === Boolean
              ? typeof t == 'boolean' || t instanceof Boolean
              : this.sample === BigInt
                ? typeof t == 'bigint' || t instanceof BigInt
                : this.sample === Symbol
                  ? typeof t == 'symbol' || t instanceof Symbol
                  : this.sample === Object
                    ? typeof t == 'object'
                    : t instanceof this.sample;
    }
    toString() {
      return 'Any';
    }
    getExpectedType() {
      return this.sample === String
        ? 'string'
        : this.sample === Number
          ? 'number'
          : this.sample === Function
            ? 'function'
            : this.sample === Object
              ? 'object'
              : this.sample === Boolean
                ? 'boolean'
                : this.fnNameFor(this.sample);
    }
    toAsymmetricMatcher() {
      return `Any<${this.fnNameFor(this.sample)}>`;
    }
  };
o(b0, 'Any');
var vB = b0,
  v0 = class extends Ar {
    constructor(t, r = !1) {
      if (!kt('String', t) && !kt('RegExp', t))
        throw new Error('Expected is not a String or a RegExp');
      super(new RegExp(t), r);
    }
    asymmetricMatch(t) {
      const r = kt('String', t) && this.sample.test(t);
      return this.inverse ? !r : r;
    }
    toString() {
      return `String${this.inverse ? 'Not' : ''}Matching`;
    }
    getExpectedType() {
      return 'string';
    }
  };
o(v0, 'StringMatching');
var lg = v0,
  E0 = class extends Ar {
    constructor(r, n = 2, i = !1) {
      if (!kt('Number', r)) throw new Error('Expected is not a Number');
      if (!kt('Number', n)) throw new Error('Precision is not a Number');
      super(r);
      Le(this, 'precision');
      ((this.inverse = i), (this.precision = n));
    }
    asymmetricMatch(r) {
      if (!kt('Number', r)) return !1;
      let n = !1;
      return (
        (r === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY) ||
        (r === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY)
          ? (n = !0)
          : (n = Math.abs(this.sample - r) < 10 ** -this.precision / 2),
        this.inverse ? !n : n
      );
    }
    toString() {
      return `Number${this.inverse ? 'Not' : ''}CloseTo`;
    }
    getExpectedType() {
      return 'number';
    }
    toAsymmetricMatcher() {
      return [this.toString(), this.sample, `(${d0('digit', this.precision)})`].join(' ');
    }
  };
o(E0, 'CloseTo');
var cg = E0,
  EB = o((e, t) => {
    (t.addMethod(e.expect, 'anything', () => new bB()),
      t.addMethod(e.expect, 'any', (r) => new vB(r)),
      t.addMethod(e.expect, 'stringContaining', (r) => new ig(r)),
      t.addMethod(e.expect, 'objectContaining', (r) => new sg(r)),
      t.addMethod(e.expect, 'arrayContaining', (r) => new ag(r)),
      t.addMethod(e.expect, 'stringMatching', (r) => new lg(r)),
      t.addMethod(e.expect, 'closeTo', (r, n) => new cg(r, n)),
      (e.expect.not = {
        stringContaining: o((r) => new ig(r, !0), 'stringContaining'),
        objectContaining: o((r) => new sg(r, !0), 'objectContaining'),
        arrayContaining: o((r) => new ag(r, !0), 'arrayContaining'),
        stringMatching: o((r) => new lg(r, !0), 'stringMatching'),
        closeTo: o((r, n) => new cg(r, n, !0), 'closeTo'),
      }));
  }, 'JestAsymmetricMatchers');
function Vu(e, t, r) {
  const n = e.flag(t, 'negate') ? 'not.' : '',
    i = `${e.flag(t, '_name')}(${r ? 'expected' : ''})`,
    s = e.flag(t, 'promise');
  return `expect(actual)${s ? `.${s}` : ''}.${n}${i}`;
}
o(Vu, 'createAssertionMessage');
function Hu(e, t, r, n) {
  const i = e;
  if (i && t instanceof Promise) {
    ((t = t.finally(() => {
      if (!i.promises) return;
      const a = i.promises.indexOf(t);
      a !== -1 && i.promises.splice(a, 1);
    })),
      i.promises || (i.promises = []),
      i.promises.push(t));
    let s = !1;
    return (
      i.onFinished ?? (i.onFinished = []),
      i.onFinished.push(() => {
        if (!s) {
          var a;
          const d = (
            ((a = globalThis.__vitest_worker__) === null || a === void 0
              ? void 0
              : a.onFilterStackTrace) || ((u) => u || '')
          )(n.stack);
          console.warn(
            [
              `Promise returned by \`${r}\` was not awaited. `,
              'Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ',
              `Please remember to await the assertion.
`,
              d,
            ].join(''),
          );
        }
      }),
      {
        then(a, c) {
          return ((s = !0), t.then(a, c));
        },
        catch(a) {
          return t.catch(a);
        },
        finally(a) {
          return t.finally(a);
        },
        [Symbol.toStringTag]: 'Promise',
      }
    );
  }
  return t;
}
o(Hu, 'recordAsyncExpect');
function Gu(e, t) {
  var r;
  (e.result || (e.result = { state: 'fail' }),
    (e.result.state = 'fail'),
    (r = e.result).errors || (r.errors = []),
    e.result.errors.push(tl(t)));
}
o(Gu, 'handleTestError');
function xm(e, t, r) {
  return function (...n) {
    if ((t !== 'withTest' && e.flag(this, '_name', t), !e.flag(this, 'soft')))
      return r.apply(this, n);
    const i = e.flag(this, 'vitest-test');
    if (!i) throw new Error('expect.soft() can only be used inside a test');
    try {
      const s = r.apply(this, n);
      return s && typeof s == 'object' && typeof s.then == 'function'
        ? s.then(gw, (a) => {
            Gu(i, a);
          })
        : s;
    } catch (s) {
      Gu(i, s);
    }
  };
}
o(xm, 'wrapAssertion');
var TB = o((e, t) => {
  const { AssertionError: r } = e,
    n = Ll();
  function i(u, p) {
    const f = o((y) => {
      const h = xm(t, y, p);
      (t.addMethod(e.Assertion.prototype, y, h), t.addMethod(globalThis[$i].matchers, y, h));
    }, 'addMethod');
    Array.isArray(u) ? u.forEach((y) => f(y)) : f(u);
  }
  (o(i, 'def'),
    ['throw', 'throws', 'Throw'].forEach((u) => {
      t.overwriteMethod(
        e.Assertion.prototype,
        u,
        (p) =>
          function (...f) {
            const y = t.flag(this, 'promise'),
              h = t.flag(this, 'object'),
              g = t.flag(this, 'negate');
            if (y === 'rejects')
              t.flag(this, 'object', () => {
                throw h;
              });
            else if (y === 'resolves' && typeof h != 'function') {
              if (g) return;
              {
                const T =
                    t.flag(this, 'message') || "expected promise to throw an error, but it didn't",
                  E = { showDiff: !1 };
                throw new r(T, E, t.flag(this, 'ssfi'));
              }
            }
            p.apply(this, f);
          },
      );
    }),
    i('withTest', function (u) {
      return (t.flag(this, 'vitest-test', u), this);
    }),
    i('toEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Re(p, u, [...n, At]);
      return this.assert(
        f,
        'expected #{this} to deeply equal #{exp}',
        'expected #{this} to not deeply equal #{exp}',
        u,
        p,
      );
    }),
    i('toStrictEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Re(p, u, [...n, At, $u, va, Uu], !0);
      return this.assert(
        f,
        'expected #{this} to strictly equal #{exp}',
        'expected #{this} to not strictly equal #{exp}',
        u,
        p,
      );
    }),
    i('toBe', function (u) {
      const p = this._obj,
        f = Object.is(p, u);
      let y = '';
      return (
        f ||
          (Re(p, u, [...n, At, $u, va, Uu], !0)
            ? (y = 'toStrictEqual')
            : Re(p, u, [...n, At]) && (y = 'toEqual')),
        this.assert(f, u0(y), 'expected #{this} not to be #{exp} // Object.is equality', u, p)
      );
    }),
    i('toMatchObject', function (u) {
      const p = this._obj,
        f = Re(p, u, [...n, At, Ao]),
        y = t.flag(this, 'negate'),
        { subset: h, stripped: g } = p0(p, u, n);
      if ((f && y) || (!f && !y)) {
        const T = t.getMessage(this, [
            f,
            'expected #{this} to match object #{exp}',
            'expected #{this} to not match object #{exp}',
            u,
            h,
            !1,
          ]),
          E =
            g === 0
              ? T
              : `${T}
(${g} matching ${g === 1 ? 'property' : 'properties'} omitted from actual)`;
        throw new r(E, { showDiff: !0, expected: u, actual: h });
      }
    }),
    i('toMatch', function (u) {
      const p = this._obj;
      if (typeof p != 'string')
        throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof p}`);
      return this.assert(
        typeof u == 'string' ? p.includes(u) : p.match(u),
        'expected #{this} to match #{exp}',
        'expected #{this} not to match #{exp}',
        u,
        p,
      );
    }),
    i('toContain', function (u) {
      const p = this._obj;
      if (typeof Node < 'u' && p instanceof Node) {
        if (!(u instanceof Node))
          throw new TypeError(
            `toContain() expected a DOM node as the argument, but got ${typeof u}`,
          );
        return this.assert(
          p.contains(u),
          'expected #{this} to contain element #{exp}',
          'expected #{this} not to contain element #{exp}',
          u,
          p,
        );
      }
      if (typeof DOMTokenList < 'u' && p instanceof DOMTokenList) {
        Xt(u, 'class name', ['string']);
        const y = t.flag(this, 'negate') ? p.value.replace(u, '').trim() : `${p.value} ${u}`;
        return this.assert(
          p.contains(u),
          `expected "${p.value}" to contain "${u}"`,
          `expected "${p.value}" not to contain "${u}"`,
          y,
          p.value,
        );
      }
      return typeof p == 'string' && typeof u == 'string'
        ? this.assert(
            p.includes(u),
            'expected #{this} to contain #{exp}',
            'expected #{this} not to contain #{exp}',
            u,
            p,
          )
        : (p != null && typeof p != 'string' && t.flag(this, 'object', Array.from(p)),
          this.contain(u));
    }),
    i('toContainEqual', function (u) {
      const p = t.flag(this, 'object'),
        f = Array.from(p).findIndex((y) => Re(y, u, n));
      this.assert(
        f !== -1,
        'expected #{this} to deep equally contain #{exp}',
        'expected #{this} to not deep equally contain #{exp}',
        u,
      );
    }),
    i('toBeTruthy', function () {
      const u = t.flag(this, 'object');
      this.assert(!!u, 'expected #{this} to be truthy', 'expected #{this} to not be truthy', !0, u);
    }),
    i('toBeFalsy', function () {
      const u = t.flag(this, 'object');
      this.assert(!u, 'expected #{this} to be falsy', 'expected #{this} to not be falsy', !1, u);
    }),
    i('toBeGreaterThan', function (u) {
      const p = this._obj;
      return (
        Xt(p, 'actual', ['number', 'bigint']),
        Xt(u, 'expected', ['number', 'bigint']),
        this.assert(
          p > u,
          `expected ${p} to be greater than ${u}`,
          `expected ${p} to be not greater than ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    i('toBeGreaterThanOrEqual', function (u) {
      const p = this._obj;
      return (
        Xt(p, 'actual', ['number', 'bigint']),
        Xt(u, 'expected', ['number', 'bigint']),
        this.assert(
          p >= u,
          `expected ${p} to be greater than or equal to ${u}`,
          `expected ${p} to be not greater than or equal to ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    i('toBeLessThan', function (u) {
      const p = this._obj;
      return (
        Xt(p, 'actual', ['number', 'bigint']),
        Xt(u, 'expected', ['number', 'bigint']),
        this.assert(
          p < u,
          `expected ${p} to be less than ${u}`,
          `expected ${p} to be not less than ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    i('toBeLessThanOrEqual', function (u) {
      const p = this._obj;
      return (
        Xt(p, 'actual', ['number', 'bigint']),
        Xt(u, 'expected', ['number', 'bigint']),
        this.assert(
          p <= u,
          `expected ${p} to be less than or equal to ${u}`,
          `expected ${p} to be not less than or equal to ${u}`,
          u,
          p,
          !1,
        )
      );
    }),
    i('toBeNaN', function () {
      const u = t.flag(this, 'object');
      this.assert(
        Number.isNaN(u),
        'expected #{this} to be NaN',
        'expected #{this} not to be NaN',
        Number.NaN,
        u,
      );
    }),
    i('toBeUndefined', function () {
      const u = t.flag(this, 'object');
      this.assert(
        u === void 0,
        'expected #{this} to be undefined',
        'expected #{this} not to be undefined',
        void 0,
        u,
      );
    }),
    i('toBeNull', function () {
      const u = t.flag(this, 'object');
      this.assert(
        u === null,
        'expected #{this} to be null',
        'expected #{this} not to be null',
        null,
        u,
      );
    }),
    i('toBeDefined', function () {
      const u = t.flag(this, 'object');
      this.assert(
        typeof u < 'u',
        'expected #{this} to be defined',
        'expected #{this} to be undefined',
        u,
      );
    }),
    i('toBeTypeOf', function (u) {
      const p = typeof this._obj,
        f = u === p;
      return this.assert(
        f,
        'expected #{this} to be type of #{exp}',
        'expected #{this} not to be type of #{exp}',
        u,
        p,
      );
    }),
    i('toBeInstanceOf', function (u) {
      return this.instanceOf(u);
    }),
    i('toHaveLength', function (u) {
      return this.have.length(u);
    }),
    i('toHaveProperty', function (...u) {
      Array.isArray(u[0]) &&
        (u[0] = u[0].map((S) => String(S).replace(/([.[\]])/g, '\\$1')).join('.'));
      const p = this._obj,
        [f, y] = u,
        h = o(
          () =>
            Object.prototype.hasOwnProperty.call(p, f)
              ? { value: p[f], exists: !0 }
              : t.getPathInfo(p, f),
          'getValue',
        ),
        { value: g, exists: T } = h(),
        E = T && (u.length === 1 || Re(y, g, n)),
        v = u.length === 1 ? '' : ` with value ${t.objDisplay(y)}`;
      return this.assert(
        E,
        `expected #{this} to have property "${f}"${v}`,
        `expected #{this} to not have property "${f}"${v}`,
        y,
        T ? g : void 0,
      );
    }),
    i('toBeCloseTo', function (u, p = 2) {
      const f = this._obj;
      let y = !1,
        h = 0,
        g = 0;
      return (
        (u === Number.POSITIVE_INFINITY && f === Number.POSITIVE_INFINITY) ||
        (u === Number.NEGATIVE_INFINITY && f === Number.NEGATIVE_INFINITY)
          ? (y = !0)
          : ((h = 10 ** -p / 2), (g = Math.abs(f - u)), (y = g < h)),
        this.assert(
          y,
          `expected #{this} to be close to #{exp}, received difference is ${g}, but expected ${h}`,
          `expected #{this} to not be close to #{exp}, received difference is ${g}, but expected ${h}`,
          u,
          f,
          !1,
        )
      );
    }));
  function s(u) {
    if (!fn(u._obj)) throw new TypeError(`${t.inspect(u._obj)} is not a spy or a call to a spy!`);
  }
  o(s, 'assertIsMock');
  function a(u) {
    return (s(u), u._obj);
  }
  (o(a, 'getSpy'),
    i(['toHaveBeenCalledTimes', 'toBeCalledTimes'], function (u) {
      const p = a(this),
        f = p.getMockName(),
        y = p.mock.calls.length;
      return this.assert(
        y === u,
        `expected "${f}" to be called #{exp} times, but got ${y} times`,
        `expected "${f}" to not be called #{exp} times`,
        u,
        y,
        !1,
      );
    }),
    i('toHaveBeenCalledOnce', function () {
      const u = a(this),
        p = u.getMockName(),
        f = u.mock.calls.length;
      return this.assert(
        f === 1,
        `expected "${p}" to be called once, but got ${f} times`,
        `expected "${p}" to not be called once`,
        1,
        f,
        !1,
      );
    }),
    i(['toHaveBeenCalled', 'toBeCalled'], function () {
      const u = a(this),
        p = u.getMockName(),
        f = u.mock.calls.length,
        y = f > 0,
        h = t.flag(this, 'negate');
      let g = t.getMessage(this, [
        y,
        `expected "${p}" to be called at least once`,
        `expected "${p}" to not be called at all, but actually been called ${f} times`,
        !0,
        y,
      ]);
      if ((y && h && (g = Is(u, g)), (y && h) || (!y && !h))) throw new r(g);
    }));
  function c(u, p) {
    return u.length === p.length && u.every((f, y) => Re(f, p[y], [...n, At]));
  }
  (o(c, 'equalsArgumentArray'),
    i(['toHaveBeenCalledWith', 'toBeCalledWith'], function (...u) {
      const p = a(this),
        f = p.getMockName(),
        y = p.mock.calls.some((T) => c(T, u)),
        h = t.flag(this, 'negate'),
        g = t.getMessage(this, [
          y,
          `expected "${f}" to be called with arguments: #{exp}`,
          `expected "${f}" to not be called with arguments: #{exp}`,
          u,
        ]);
      if ((y && h) || (!y && !h)) throw new r(Is(p, g, u));
    }),
    i('toHaveBeenCalledExactlyOnceWith', function (...u) {
      const p = a(this),
        f = p.getMockName(),
        y = p.mock.calls.length,
        g = p.mock.calls.some((v) => c(v, u)) && y === 1,
        T = t.flag(this, 'negate'),
        E = t.getMessage(this, [
          g,
          `expected "${f}" to be called once with arguments: #{exp}`,
          `expected "${f}" to not be called once with arguments: #{exp}`,
          u,
        ]);
      if ((g && T) || (!g && !T)) throw new r(Is(p, E, u));
    }),
    i(['toHaveBeenNthCalledWith', 'nthCalledWith'], function (u, ...p) {
      const f = a(this),
        y = f.getMockName(),
        h = f.mock.calls[u - 1],
        g = f.mock.calls.length,
        T = u <= g;
      this.assert(
        h && c(h, p),
        `expected ${Kn(u)} "${y}" call to have been called with #{exp}${T ? '' : `, but called only ${g} times`}`,
        `expected ${Kn(u)} "${y}" call to not have been called with #{exp}`,
        p,
        h,
        T,
      );
    }),
    i(['toHaveBeenLastCalledWith', 'lastCalledWith'], function (...u) {
      const p = a(this),
        f = p.getMockName(),
        y = p.mock.calls[p.mock.calls.length - 1];
      this.assert(
        y && c(y, u),
        `expected last "${f}" call to have been called with #{exp}`,
        `expected last "${f}" call to not have been called with #{exp}`,
        u,
        y,
      );
    }));
  function d(u, p, f) {
    const y = u.mock.invocationCallOrder,
      h = p.mock.invocationCallOrder;
    return y.length === 0 ? !f : h.length === 0 ? !1 : y[0] < h[0];
  }
  (o(d, 'isSpyCalledBeforeAnotherSpy'),
    i(['toHaveBeenCalledBefore'], function (u, p = !0) {
      const f = a(this);
      if (!fn(u)) throw new TypeError(`${t.inspect(u)} is not a spy or a call to a spy`);
      this.assert(
        d(f, u, p),
        `expected "${f.getMockName()}" to have been called before "${u.getMockName()}"`,
        `expected "${f.getMockName()}" to not have been called before "${u.getMockName()}"`,
        u,
        f,
      );
    }),
    i(['toHaveBeenCalledAfter'], function (u, p = !0) {
      const f = a(this);
      if (!fn(u)) throw new TypeError(`${t.inspect(u)} is not a spy or a call to a spy`);
      this.assert(
        d(u, f, p),
        `expected "${f.getMockName()}" to have been called after "${u.getMockName()}"`,
        `expected "${f.getMockName()}" to not have been called after "${u.getMockName()}"`,
        u,
        f,
      );
    }),
    i(['toThrow', 'toThrowError'], function (u) {
      if (typeof u == 'string' || typeof u > 'u' || u instanceof RegExp)
        return this.throws(u === '' ? /^$/ : u);
      const p = this._obj,
        f = t.flag(this, 'promise'),
        y = t.flag(this, 'negate');
      let h = null;
      if (f === 'rejects') h = p;
      else if (f === 'resolves' && typeof p != 'function') {
        if (y) return;
        {
          const g = t.flag(this, 'message') || "expected promise to throw an error, but it didn't",
            T = { showDiff: !1 };
          throw new r(g, T, t.flag(this, 'ssfi'));
        }
      } else {
        let g = !1;
        try {
          p();
        } catch (T) {
          ((g = !0), (h = T));
        }
        if (!g && !y) {
          const T = t.flag(this, 'message') || "expected function to throw an error, but it didn't",
            E = { showDiff: !1 };
          throw new r(T, E, t.flag(this, 'ssfi'));
        }
      }
      if (typeof u == 'function') {
        const g = u.name || u.prototype.constructor.name;
        return this.assert(
          h && h instanceof u,
          `expected error to be instance of ${g}`,
          `expected error not to be instance of ${g}`,
          u,
          h,
        );
      }
      if (u instanceof Error) {
        const g = Re(h, u, [...n, At]);
        return this.assert(
          g,
          'expected a thrown error to be #{exp}',
          'expected a thrown error not to be #{exp}',
          u,
          h,
        );
      }
      if (
        typeof u == 'object' &&
        'asymmetricMatch' in u &&
        typeof u.asymmetricMatch == 'function'
      ) {
        const g = u;
        return this.assert(
          h && g.asymmetricMatch(h),
          'expected error to match asymmetric matcher',
          'expected error not to match asymmetric matcher',
          g,
          h,
        );
      }
      throw new Error(
        `"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof u}"`,
      );
    }),
    [
      {
        name: 'toHaveResolved',
        condition: o(
          (u) =>
            u.mock.settledResults.length > 0 &&
            u.mock.settledResults.some(({ type: p }) => p === 'fulfilled'),
          'condition',
        ),
        action: 'resolved',
      },
      {
        name: ['toHaveReturned', 'toReturn'],
        condition: o(
          (u) => u.mock.calls.length > 0 && u.mock.results.some(({ type: p }) => p !== 'throw'),
          'condition',
        ),
        action: 'called',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      i(u, function () {
        const y = a(this),
          h = y.getMockName(),
          g = p(y);
        this.assert(
          g,
          `expected "${h}" to be successfully ${f} at least once`,
          `expected "${h}" to not be successfully ${f}`,
          g,
          !g,
          !1,
        );
      });
    }),
    [
      {
        name: 'toHaveResolvedTimes',
        condition: o(
          (u, p) =>
            u.mock.settledResults.reduce((f, { type: y }) => (y === 'fulfilled' ? ++f : f), 0) ===
            p,
          'condition',
        ),
        action: 'resolved',
      },
      {
        name: ['toHaveReturnedTimes', 'toReturnTimes'],
        condition: o(
          (u, p) => u.mock.results.reduce((f, { type: y }) => (y === 'throw' ? f : ++f), 0) === p,
          'condition',
        ),
        action: 'called',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      i(u, function (y) {
        const h = a(this),
          g = h.getMockName(),
          T = p(h, y);
        this.assert(
          T,
          `expected "${g}" to be successfully ${f} ${y} times`,
          `expected "${g}" to not be successfully ${f} ${y} times`,
          `expected resolved times: ${y}`,
          `received resolved times: ${T}`,
          !1,
        );
      });
    }),
    [
      {
        name: 'toHaveResolvedWith',
        condition: o(
          (u, p) =>
            u.mock.settledResults.some(({ type: f, value: y }) => f === 'fulfilled' && Re(p, y)),
          'condition',
        ),
        action: 'resolve',
      },
      {
        name: ['toHaveReturnedWith', 'toReturnWith'],
        condition: o(
          (u, p) => u.mock.results.some(({ type: f, value: y }) => f === 'return' && Re(p, y)),
          'condition',
        ),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      i(u, function (y) {
        const h = a(this),
          g = p(h, y),
          T = t.flag(this, 'negate');
        if ((g && T) || (!g && !T)) {
          const E = h.getMockName(),
            v = t.getMessage(this, [
              g,
              `expected "${E}" to ${f} with: #{exp} at least once`,
              `expected "${E}" to not ${f} with: #{exp}`,
              y,
            ]),
            S = f === 'return' ? h.mock.results : h.mock.settledResults;
          throw new r(T0(h, S, v, y));
        }
      });
    }),
    [
      {
        name: 'toHaveLastResolvedWith',
        condition: o((u, p) => {
          const f = u.mock.settledResults[u.mock.settledResults.length - 1];
          return f && f.type === 'fulfilled' && Re(f.value, p);
        }, 'condition'),
        action: 'resolve',
      },
      {
        name: ['toHaveLastReturnedWith', 'lastReturnedWith'],
        condition: o((u, p) => {
          const f = u.mock.results[u.mock.results.length - 1];
          return f && f.type === 'return' && Re(f.value, p);
        }, 'condition'),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      i(u, function (y) {
        const h = a(this),
          g = f === 'return' ? h.mock.results : h.mock.settledResults,
          T = g[g.length - 1],
          E = h.getMockName();
        this.assert(
          p(h, y),
          `expected last "${E}" call to ${f} #{exp}`,
          `expected last "${E}" call to not ${f} #{exp}`,
          y,
          T?.value,
        );
      });
    }),
    [
      {
        name: 'toHaveNthResolvedWith',
        condition: o((u, p, f) => {
          const y = u.mock.settledResults[p - 1];
          return y && y.type === 'fulfilled' && Re(y.value, f);
        }, 'condition'),
        action: 'resolve',
      },
      {
        name: ['toHaveNthReturnedWith', 'nthReturnedWith'],
        condition: o((u, p, f) => {
          const y = u.mock.results[p - 1];
          return y && y.type === 'return' && Re(y.value, f);
        }, 'condition'),
        action: 'return',
      },
    ].forEach(({ name: u, condition: p, action: f }) => {
      i(u, function (y, h) {
        const g = a(this),
          T = g.getMockName(),
          v = (f === 'return' ? g.mock.results : g.mock.settledResults)[y - 1],
          S = `${Kn(y)} call`;
        this.assert(
          p(g, y, h),
          `expected ${S} "${T}" call to ${f} #{exp}`,
          `expected ${S} "${T}" call to not ${f} #{exp}`,
          h,
          v?.value,
        );
      });
    }),
    i('withContext', function (u) {
      for (const p in u) t.flag(this, p, u[p]);
      return this;
    }),
    t.addProperty(
      e.Assertion.prototype,
      'resolves',
      o(function () {
        const p = new Error('resolves');
        (t.flag(this, 'promise', 'resolves'), t.flag(this, 'error', p));
        const f = t.flag(this, 'vitest-test'),
          y = t.flag(this, 'object');
        if (t.flag(this, 'poll'))
          throw new SyntaxError('expect.poll() is not supported in combination with .resolves');
        if (typeof y?.then != 'function')
          throw new TypeError(
            `You must provide a Promise to expect() when using .resolves, not '${typeof y}'.`,
          );
        const h = new Proxy(this, {
          get: o((g, T, E) => {
            const v = Reflect.get(g, T, E);
            return typeof v != 'function'
              ? v instanceof e.Assertion
                ? h
                : v
              : (...S) => {
                  t.flag(this, '_name', T);
                  const A = y.then(
                    (N) => (t.flag(this, 'object', N), v.call(this, ...S)),
                    (N) => {
                      const j = new r(`promise rejected "${t.inspect(N)}" instead of resolving`, {
                        showDiff: !1,
                      });
                      throw ((j.cause = N), (j.stack = p.stack.replace(p.message, j.message)), j);
                    },
                  );
                  return Hu(f, A, Vu(t, this, !!S.length), p);
                };
          }, 'get'),
        });
        return h;
      }, '__VITEST_RESOLVES__'),
    ),
    t.addProperty(
      e.Assertion.prototype,
      'rejects',
      o(function () {
        const p = new Error('rejects');
        (t.flag(this, 'promise', 'rejects'), t.flag(this, 'error', p));
        const f = t.flag(this, 'vitest-test'),
          y = t.flag(this, 'object'),
          h = typeof y == 'function' ? y() : y;
        if (t.flag(this, 'poll'))
          throw new SyntaxError('expect.poll() is not supported in combination with .rejects');
        if (typeof h?.then != 'function')
          throw new TypeError(
            `You must provide a Promise to expect() when using .rejects, not '${typeof h}'.`,
          );
        const g = new Proxy(this, {
          get: o((T, E, v) => {
            const S = Reflect.get(T, E, v);
            return typeof S != 'function'
              ? S instanceof e.Assertion
                ? g
                : S
              : (...A) => {
                  t.flag(this, '_name', E);
                  const N = h.then(
                    (j) => {
                      const C = new r(`promise resolved "${t.inspect(j)}" instead of rejecting`, {
                        showDiff: !0,
                        expected: new Error('rejected promise'),
                        actual: j,
                      });
                      throw ((C.stack = p.stack.replace(p.message, C.message)), C);
                    },
                    (j) => (t.flag(this, 'object', j), S.call(this, ...A)),
                  );
                  return Hu(f, N, Vu(t, this, !!A.length), p);
                };
          }, 'get'),
        });
        return g;
      }, '__VITEST_REJECTS__'),
    ));
}, 'JestChaiExpect');
function Kn(e) {
  const t = e % 10,
    r = e % 100;
  return t === 1 && r !== 11
    ? `${e}st`
    : t === 2 && r !== 12
      ? `${e}nd`
      : t === 3 && r !== 13
        ? `${e}rd`
        : `${e}th`;
}
o(Kn, 'ordinalOf');
function Is(e, t, r) {
  return (
    e.mock.calls.length &&
      (t += Ue.gray(`

Received: 

${e.mock.calls.map((n, i) => {
  let s = Ue.bold(`  ${Kn(i + 1)} ${e.getMockName()} call:

`);
  return (
    r
      ? (s += Nn(r, n, { omitAnnotationLines: !0 }))
      : (s += bt(n)
          .split(
            `
`,
          )
          .map((a) => `    ${a}`).join(`
`)),
    (s += `
`),
    s
  );
}).join(`
`)}`)),
    (t += Ue.gray(`

Number of calls: ${Ue.bold(e.mock.calls.length)}
`)),
    t
  );
}
o(Is, 'formatCalls');
function T0(e, t, r, n) {
  return (
    t.length &&
      (r += Ue.gray(`

Received: 

${t.map((i, s) => {
  let a = Ue.bold(`  ${Kn(s + 1)} ${e.getMockName()} call return:

`);
  return (
    n
      ? (a += Nn(n, i.value, { omitAnnotationLines: !0 }))
      : (a += bt(i)
          .split(
            `
`,
          )
          .map((c) => `    ${c}`).join(`
`)),
    (a += `
`),
    a
  );
}).join(`
`)}`)),
    (r += Ue.gray(`

Number of calls: ${Ue.bold(e.mock.calls.length)}
`)),
    r
  );
}
o(T0, 'formatReturns');
function w0(e, t) {
  const r = e._obj,
    n = Zt.flag(e, 'negate'),
    i = Zt.flag(e, 'promise') || '',
    s = { ...Om(), diff: Nn, stringify: bt, iterableEquality: At, subsetEquality: Ao };
  return {
    state: {
      ...Ui(t),
      customTesters: Ll(),
      isNot: n,
      utils: s,
      promise: i,
      equals: Re,
      suppressedErrors: [],
      soft: Zt.flag(e, 'soft'),
      poll: Zt.flag(e, 'poll'),
    },
    isNot: n,
    obj: r,
  };
}
o(w0, 'getMatcherState');
var S0 = class extends Error {
  constructor(t, r, n) {
    (super(t), (this.actual = r), (this.expected = n));
  }
};
o(S0, 'JestExtendError');
var ug = S0;
function _0(e, t, r) {
  return (n, i) => {
    Object.entries(r).forEach(([s, a]) => {
      function c(...y) {
        const { state: h, isNot: g, obj: T } = w0(this, t),
          E = a.call(h, T, ...y);
        if (E && typeof E == 'object' && typeof E.then == 'function')
          return E.then(({ pass: C, message: R, actual: w, expected: _ }) => {
            if ((C && g) || (!C && !g)) throw new ug(R(), w, _);
          });
        const { pass: v, message: S, actual: A, expected: N } = E;
        if ((v && g) || (!v && !g)) throw new ug(S(), A, N);
      }
      o(c, 'expectWrapper');
      const d = xm(i, s, c);
      (i.addMethod(globalThis[$i].matchers, s, d), i.addMethod(e.Assertion.prototype, s, d));
      const u = class extends Ar {
        constructor(h = !1, ...g) {
          super(g, h);
        }
        asymmetricMatch(h) {
          const { pass: g } = a.call(this.getMatcherContext(t), h, ...this.sample);
          return this.inverse ? !g : g;
        }
        toString() {
          return `${this.inverse ? 'not.' : ''}${s}`;
        }
        getExpectedType() {
          return 'any';
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((h) => bt(h)).join(', ')}>`;
        }
      };
      o(u, 'CustomMatcher');
      let p = u;
      const f = o((...y) => new p(!1, ...y), 'customMatcher');
      (Object.defineProperty(t, s, { configurable: !0, enumerable: !0, value: f, writable: !0 }),
        Object.defineProperty(t.not, s, {
          configurable: !0,
          enumerable: !0,
          value: o((...y) => new p(!0, ...y), 'value'),
          writable: !0,
        }),
        Object.defineProperty(globalThis[Du], s, {
          configurable: !0,
          enumerable: !0,
          value: f,
          writable: !0,
        }));
    });
  };
}
o(_0, 'JestExtendPlugin');
var wB = o((e, t) => {
  t.addMethod(e.expect, 'extend', (r, n) => {
    dn(_0(e, r, n));
  });
}, 'JestExtend');
function R0() {
  (dn(wB), dn(TB), dn(EB));
  const e = o((n, i) => {
    const { assertionCalls: s } = Ui(e);
    return (Ns({ assertionCalls: s + 1, soft: !1 }, e), Dr(n, i));
  }, 'expect');
  (Object.assign(e, Dr),
    (e.getState = () => Ui(e)),
    (e.setState = (n) => Ns(n, e)),
    (e.extend = (n) => Dr.extend(e, n)),
    (e.soft = (...n) => {
      const i = e(...n);
      return (e.setState({ soft: !0 }), i);
    }),
    e.extend(pB),
    (e.unreachable = (n) => {
      M.fail(`expected${n ? ` "${n}" ` : ' '}not to be reached`);
    }));
  function t(n) {
    const i = o(
      () =>
        new Error(
          `expected number of assertions to be ${n}, but got ${e.getState().assertionCalls}`,
        ),
      'errorGen',
    );
    ('captureStackTrace' in Error &&
      typeof Error.captureStackTrace == 'function' &&
      Error.captureStackTrace(i(), t),
      e.setState({ expectedAssertionsNumber: n, expectedAssertionsNumberErrorGen: i }));
  }
  o(t, 'assertions');
  function r() {
    const n = new Error('expected any number of assertion, but got none');
    ('captureStackTrace' in Error &&
      typeof Error.captureStackTrace == 'function' &&
      Error.captureStackTrace(n, r),
      e.setState({ isExpectingAssertions: !0, isExpectingAssertionsError: n }));
  }
  return (
    o(r, 'hasAssertions'),
    Ns(
      {
        assertionCalls: 0,
        isExpectingAssertions: !1,
        isExpectingAssertionsError: null,
        expectedAssertionsNumber: null,
        expectedAssertionsNumberErrorGen: null,
      },
      e,
    ),
    Zt.addMethod(e, 'assertions', t),
    Zt.addMethod(e, 'hasAssertions', r),
    e.extend(nS),
    e
  );
}
o(R0, 'createExpect');
var P0 = R0();
Object.defineProperty(globalThis, Rm, { value: P0, writable: !0, configurable: !0 });
function A0(e, t, r) {
  Object.defineProperty(e, t, r);
}
o(A0, 'f');
var Ms = Symbol.for('tinyspy:spy'),
  SB = o((e) => {
    ((e.called = !1),
      (e.callCount = 0),
      (e.calls = []),
      (e.results = []),
      (e.resolves = []),
      (e.next = []));
  }, 'P'),
  _B = o((e) => (A0(e, Ms, { value: { reset: o(() => SB(e[Ms]), 'reset') } }), e[Ms]), 'K'),
  RB = o((e) => e[Ms] || _B(e), 'T'),
  zu = new Set();
function Nm(e) {
  return (zu.add(e), () => void zu.delete(e));
}
o(Nm, 'onMockCall');
var PB = o((...e) => {
  const t = H_(...e);
  return Mm(t);
}, 'spyOn');
function Im(e) {
  const t = e ? ku(e) : ku();
  return Mm(t);
}
o(Im, 'fn');
function Mm(e) {
  const t = Wu(e),
    r = t.mockImplementation.bind(null);
  return ((t.mockImplementation = (n) => Wu(r(n))), t);
}
o(Mm, 'reactiveMock');
function Wu(e) {
  const t = RB(e),
    r = t.impl;
  return (
    t.willCall(function (...n) {
      return (zu.forEach((i) => i(e, n)), r?.apply(this, n));
    }),
    e
  );
}
o(Wu, 'listenWhenCalled');
function qm() {
  ms.forEach((e) => e.mockClear());
}
o(qm, 'clearAllMocks');
function jm() {
  ms.forEach((e) => e.mockReset());
}
o(jm, 'resetAllMocks');
function km() {
  ms.forEach((e) => e.mockRestore());
}
o(km, 'restoreAllMocks');
function O0(e, t = {}) {
  return e;
}
o(O0, 'mocked');
var C0 = {};
Et(C0, {
  buildQueries: () => ar,
  configure: () => AR,
  createEvent: () => _i,
  findAllByAltText: () => TP,
  findAllByDisplayValue: () => yP,
  findAllByLabelText: () => WR,
  findAllByPlaceholderText: () => nP,
  findAllByRole: () => jP,
  findAllByTestId: () => JP,
  findAllByText: () => cP,
  findAllByTitle: () => AP,
  findByAltText: () => wP,
  findByDisplayValue: () => hP,
  findByLabelText: () => KR,
  findByPlaceholderText: () => oP,
  findByRole: () => kP,
  findByTestId: () => $P,
  findByText: () => uP,
  findByTitle: () => OP,
  fireEvent: () => fo,
  getAllByAltText: () => vP,
  getAllByDisplayValue: () => fP,
  getAllByLabelText: () => YR,
  getAllByPlaceholderText: () => tP,
  getAllByRole: () => MP,
  getAllByTestId: () => FP,
  getAllByText: () => aP,
  getAllByTitle: () => RP,
  getByAltText: () => EP,
  getByDisplayValue: () => mP,
  getByLabelText: () => XR,
  getByPlaceholderText: () => rP,
  getByRole: () => qP,
  getByTestId: () => BP,
  getByText: () => lP,
  getByTitle: () => PP,
  getConfig: () => Te,
  getDefaultNormalizer: () => Ul,
  getElementError: () => gs,
  getMultipleElementsFoundError: () => bs,
  getNodeText: () => Oo,
  getQueriesForElement: () => wa,
  getRoles: () => ry,
  getSuggestedQuery: () => Hi,
  isInaccessible: () => hs,
  logDOM: () => td,
  logRoles: () => KB,
  makeFindQuery: () => En,
  makeGetAllQuery: () => Gl,
  makeSingleQuery: () => vn,
  prettyDOM: () => po,
  prettyFormat: () => Dm,
  queries: () => Ta,
  queryAllByAltText: () => gP,
  queryAllByAttribute: () => Yr,
  queryAllByDisplayValue: () => dP,
  queryAllByLabelText: () => QR,
  queryAllByPlaceholderText: () => ZR,
  queryAllByRole: () => NP,
  queryAllByTestId: () => DP,
  queryAllByText: () => iP,
  queryAllByTitle: () => SP,
  queryByAltText: () => bP,
  queryByAttribute: () => oy,
  queryByDisplayValue: () => pP,
  queryByLabelText: () => GR,
  queryByPlaceholderText: () => eP,
  queryByRole: () => IP,
  queryByTestId: () => LP,
  queryByText: () => sP,
  queryByTitle: () => _P,
  queryHelpers: () => YB,
  screen: () => hJ,
  waitFor: () => Hl,
  waitForElementToBeRemoved: () => VP,
  within: () => wa,
  wrapAllByQueryWithSuggestion: () => vt,
  wrapSingleQueryWithSuggestion: () => Fr,
});
var Dm = ze(pj()),
  AB = Object.prototype.toString;
function Ku(e) {
  return typeof e == 'function' || AB.call(e) === '[object Function]';
}
o(Ku, 'isCallable');
function x0(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
o(x0, 'toInteger');
var OB = Math.pow(2, 53) - 1;
function N0(e) {
  var t = x0(e);
  return Math.min(Math.max(t, 0), OB);
}
o(N0, 'toLength');
function jt(e, t) {
  var r = Array,
    n = Object(e);
  if (e == null)
    throw new TypeError('Array.from requires an array-like object - not null or undefined');
  if (typeof t < 'u' && !Ku(t))
    throw new TypeError('Array.from: when provided, the second argument must be a function');
  for (var i = N0(n.length), s = Ku(r) ? Object(new r(i)) : new Array(i), a = 0, c; a < i; )
    ((c = n[a]), t ? (s[a] = t(c, a)) : (s[a] = c), (a += 1));
  return ((s.length = i), s);
}
o(jt, 'arrayFrom');
function co(e) {
  '@babel/helpers - typeof';
  return (
    (co =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    co(e)
  );
}
o(co, '_typeof');
function I0(e, t) {
  if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
o(I0, '_classCallCheck');
function Yu(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    ((n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      'value' in n && (n.writable = !0),
      Object.defineProperty(e, Lm(n.key), n));
  }
}
o(Yu, '_defineProperties');
function M0(e, t, r) {
  return (
    t && Yu(e.prototype, t),
    r && Yu(e, r),
    Object.defineProperty(e, 'prototype', { writable: !1 }),
    e
  );
}
o(M0, '_createClass');
function q0(e, t, r) {
  return (
    (t = Lm(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(q0, '_defineProperty');
function Lm(e) {
  var t = j0(e, 'string');
  return co(t) === 'symbol' ? t : String(t);
}
o(Lm, '_toPropertyKey');
function j0(e, t) {
  if (co(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (co(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
o(j0, '_toPrimitive');
var CB = (function () {
    function e() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      (I0(this, e), q0(this, 'items', void 0), (this.items = t));
    }
    return (
      o(e, 'SetLike'),
      M0(e, [
        {
          key: 'add',
          value: o(function (r) {
            return (this.has(r) === !1 && this.items.push(r), this);
          }, 'add'),
        },
        {
          key: 'clear',
          value: o(function () {
            this.items = [];
          }, 'clear'),
        },
        {
          key: 'delete',
          value: o(function (r) {
            var n = this.items.length;
            return (
              (this.items = this.items.filter(function (i) {
                return i !== r;
              })),
              n !== this.items.length
            );
          }, '_delete'),
        },
        {
          key: 'forEach',
          value: o(function (r) {
            var n = this;
            this.items.forEach(function (i) {
              r(i, i, n);
            });
          }, 'forEach'),
        },
        {
          key: 'has',
          value: o(function (r) {
            return this.items.indexOf(r) !== -1;
          }, 'has'),
        },
        {
          key: 'size',
          get: o(function () {
            return this.items.length;
          }, 'get'),
        },
      ]),
      e
    );
  })(),
  xB = typeof Set > 'u' ? Set : CB;
function ct(e) {
  var t;
  return (t = e.localName) !== null && t !== void 0 ? t : e.tagName.toLowerCase();
}
o(ct, 'getLocalName');
var NB = {
    article: 'article',
    aside: 'complementary',
    button: 'button',
    datalist: 'listbox',
    dd: 'definition',
    details: 'group',
    dialog: 'dialog',
    dt: 'term',
    fieldset: 'group',
    figure: 'figure',
    form: 'form',
    footer: 'contentinfo',
    h1: 'heading',
    h2: 'heading',
    h3: 'heading',
    h4: 'heading',
    h5: 'heading',
    h6: 'heading',
    header: 'banner',
    hr: 'separator',
    html: 'document',
    legend: 'legend',
    li: 'listitem',
    math: 'math',
    main: 'main',
    menu: 'list',
    nav: 'navigation',
    ol: 'list',
    optgroup: 'group',
    option: 'option',
    output: 'status',
    progress: 'progressbar',
    section: 'region',
    summary: 'button',
    table: 'table',
    tbody: 'rowgroup',
    textarea: 'textbox',
    tfoot: 'rowgroup',
    td: 'cell',
    th: 'columnheader',
    thead: 'rowgroup',
    tr: 'row',
    ul: 'list',
  },
  IB = {
    caption: new Set(['aria-label', 'aria-labelledby']),
    code: new Set(['aria-label', 'aria-labelledby']),
    deletion: new Set(['aria-label', 'aria-labelledby']),
    emphasis: new Set(['aria-label', 'aria-labelledby']),
    generic: new Set(['aria-label', 'aria-labelledby', 'aria-roledescription']),
    insertion: new Set(['aria-label', 'aria-labelledby']),
    paragraph: new Set(['aria-label', 'aria-labelledby']),
    presentation: new Set(['aria-label', 'aria-labelledby']),
    strong: new Set(['aria-label', 'aria-labelledby']),
    subscript: new Set(['aria-label', 'aria-labelledby']),
    superscript: new Set(['aria-label', 'aria-labelledby']),
  };
function k0(e, t) {
  return [
    'aria-atomic',
    'aria-busy',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-dropeffect',
    'aria-flowto',
    'aria-grabbed',
    'aria-hidden',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-live',
    'aria-owns',
    'aria-relevant',
    'aria-roledescription',
  ].some(function (r) {
    var n;
    return e.hasAttribute(r) && !((n = IB[t]) !== null && n !== void 0 && n.has(r));
  });
}
o(k0, 'hasGlobalAriaAttributes');
function Fm(e, t) {
  return k0(e, t);
}
o(Fm, 'ignorePresentationalRole');
function D0(e) {
  var t = F0(e);
  if (t === null || t === 'presentation') {
    var r = L0(e);
    if (t !== 'presentation' || Fm(e, r || '')) return r;
  }
  return t;
}
o(D0, 'getRole');
function L0(e) {
  var t = NB[ct(e)];
  if (t !== void 0) return t;
  switch (ct(e)) {
    case 'a':
    case 'area':
    case 'link':
      if (e.hasAttribute('href')) return 'link';
      break;
    case 'img':
      return e.getAttribute('alt') === '' && !Fm(e, 'img') ? 'presentation' : 'img';
    case 'input': {
      var r = e,
        n = r.type;
      switch (n) {
        case 'button':
        case 'image':
        case 'reset':
        case 'submit':
          return 'button';
        case 'checkbox':
        case 'radio':
          return n;
        case 'range':
          return 'slider';
        case 'email':
        case 'tel':
        case 'text':
        case 'url':
          return e.hasAttribute('list') ? 'combobox' : 'textbox';
        case 'search':
          return e.hasAttribute('list') ? 'combobox' : 'searchbox';
        case 'number':
          return 'spinbutton';
        default:
          return null;
      }
    }
    case 'select':
      return e.hasAttribute('multiple') || e.size > 1 ? 'listbox' : 'combobox';
  }
  return null;
}
o(L0, 'getImplicitRole');
function F0(e) {
  var t = e.getAttribute('role');
  if (t !== null) {
    var r = t.trim().split(' ')[0];
    if (r.length > 0) return r;
  }
  return null;
}
o(F0, 'getExplicitRole');
function ke(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
o(ke, 'isElement');
function Bm(e) {
  return ke(e) && ct(e) === 'caption';
}
o(Bm, 'isHTMLTableCaptionElement');
function Si(e) {
  return ke(e) && ct(e) === 'input';
}
o(Si, 'isHTMLInputElement');
function B0(e) {
  return ke(e) && ct(e) === 'optgroup';
}
o(B0, 'isHTMLOptGroupElement');
function J0(e) {
  return ke(e) && ct(e) === 'select';
}
o(J0, 'isHTMLSelectElement');
function $0(e) {
  return ke(e) && ct(e) === 'table';
}
o($0, 'isHTMLTableElement');
function U0(e) {
  return ke(e) && ct(e) === 'textarea';
}
o(U0, 'isHTMLTextAreaElement');
function V0(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument,
    r = t.defaultView;
  if (r === null) throw new TypeError('no window available');
  return r;
}
o(V0, 'safeWindow');
function H0(e) {
  return ke(e) && ct(e) === 'fieldset';
}
o(H0, 'isHTMLFieldSetElement');
function G0(e) {
  return ke(e) && ct(e) === 'legend';
}
o(G0, 'isHTMLLegendElement');
function z0(e) {
  return ke(e) && ct(e) === 'slot';
}
o(z0, 'isHTMLSlotElement');
function W0(e) {
  return ke(e) && e.ownerSVGElement !== void 0;
}
o(W0, 'isSVGElement');
function K0(e) {
  return ke(e) && ct(e) === 'svg';
}
o(K0, 'isSVGSVGElement');
function Y0(e) {
  return W0(e) && ct(e) === 'title';
}
o(Y0, 'isSVGTitleElement');
function Vi(e, t) {
  if (ke(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(' '),
      n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r
      .map(function (i) {
        return n.getElementById(i);
      })
      .filter(function (i) {
        return i !== null;
      });
  }
  return [];
}
o(Vi, 'queryIdRefs');
function tr(e, t) {
  return ke(e) ? t.indexOf(D0(e)) !== -1 : !1;
}
o(tr, 'hasAnyConcreteRoles');
function X0(e) {
  return e.trim().replace(/\s\s+/g, ' ');
}
o(X0, 'asFlatString');
function Q0(e, t) {
  if (!ke(e)) return !1;
  if (e.hasAttribute('hidden') || e.getAttribute('aria-hidden') === 'true') return !0;
  var r = t(e);
  return r.getPropertyValue('display') === 'none' || r.getPropertyValue('visibility') === 'hidden';
}
o(Q0, 'isHidden');
function Z0(e) {
  return tr(e, ['button', 'combobox', 'listbox', 'textbox']) || Jm(e, 'range');
}
o(Z0, 'isControl');
function Jm(e, t) {
  if (!ke(e)) return !1;
  switch (t) {
    case 'range':
      return tr(e, ['meter', 'progressbar', 'scrollbar', 'slider', 'spinbutton']);
    default:
      throw new TypeError(
        "No knowledge about abstract role '".concat(t, "'. This is likely a bug :("),
      );
  }
}
o(Jm, 'hasAbstractRole');
function Xu(e, t) {
  var r = jt(e.querySelectorAll(t));
  return (
    Vi(e, 'aria-owns').forEach(function (n) {
      r.push.apply(r, jt(n.querySelectorAll(t)));
    }),
    r
  );
}
o(Xu, 'querySelectorAllSubtree');
function eR(e) {
  return J0(e) ? e.selectedOptions || Xu(e, '[selected]') : Xu(e, '[aria-selected="true"]');
}
o(eR, 'querySelectedOptions');
function tR(e) {
  return tr(e, ['none', 'presentation']);
}
o(tR, 'isMarkedPresentational');
function rR(e) {
  return Bm(e);
}
o(rR, 'isNativeHostLanguageTextAlternativeElement');
function nR(e) {
  return tr(e, [
    'button',
    'cell',
    'checkbox',
    'columnheader',
    'gridcell',
    'heading',
    'label',
    'legend',
    'link',
    'menuitem',
    'menuitemcheckbox',
    'menuitemradio',
    'option',
    'radio',
    'row',
    'rowheader',
    'switch',
    'tab',
    'tooltip',
    'treeitem',
  ]);
}
o(nR, 'allowsNameFromContent');
function oR(e) {
  return !1;
}
o(oR, 'isDescendantOfNativeHostLanguageTextAlternativeElement');
function iR(e) {
  return Si(e) || U0(e) ? e.value : e.textContent || '';
}
o(iR, 'getValueOfTextbox');
function Qu(e) {
  var t = e.getPropertyValue('content');
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : '';
}
o(Qu, 'getTextualContent');
function $m(e) {
  var t = ct(e);
  return (
    t === 'button' ||
    (t === 'input' && e.getAttribute('type') !== 'hidden') ||
    t === 'meter' ||
    t === 'output' ||
    t === 'progress' ||
    t === 'select' ||
    t === 'textarea'
  );
}
o($m, 'isLabelableElement');
function Um(e) {
  if ($m(e)) return e;
  var t = null;
  return (
    e.childNodes.forEach(function (r) {
      if (t === null && ke(r)) {
        var n = Um(r);
        n !== null && (t = n);
      }
    }),
    t
  );
}
o(Um, 'findLabelableElement');
function sR(e) {
  if (e.control !== void 0) return e.control;
  var t = e.getAttribute('for');
  return t !== null ? e.ownerDocument.getElementById(t) : Um(e);
}
o(sR, 'getControlOfLabel');
function aR(e) {
  var t = e.labels;
  if (t === null) return t;
  if (t !== void 0) return jt(t);
  if (!$m(e)) return null;
  var r = e.ownerDocument;
  return jt(r.querySelectorAll('label')).filter(function (n) {
    return sR(n) === e;
  });
}
o(aR, 'getLabels');
function lR(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? jt(e.childNodes) : t;
}
o(lR, 'getSlotContents');
function Vm(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = new xB(),
    n = V0(e),
    i = t.compute,
    s = i === void 0 ? 'name' : i,
    a = t.computedStyleSupportsPseudoElements,
    c = a === void 0 ? t.getComputedStyle !== void 0 : a,
    d = t.getComputedStyle,
    u = d === void 0 ? n.getComputedStyle.bind(n) : d,
    p = t.hidden,
    f = p === void 0 ? !1 : p;
  function y(v, S) {
    var A = '';
    if (ke(v) && c) {
      var N = u(v, '::before'),
        j = Qu(N);
      A = ''.concat(j, ' ').concat(A);
    }
    var C = z0(v) ? lR(v) : jt(v.childNodes).concat(Vi(v, 'aria-owns'));
    if (
      (C.forEach(function (_) {
        var k = E(_, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !1, recursion: !0 }),
          I = ke(_) ? u(_).getPropertyValue('display') : 'inline',
          V = I !== 'inline' ? ' ' : '';
        A += ''.concat(V).concat(k).concat(V);
      }),
      ke(v) && c)
    ) {
      var R = u(v, '::after'),
        w = Qu(R);
      A = ''.concat(A, ' ').concat(w);
    }
    return A.trim();
  }
  o(y, 'computeMiscTextAlternative');
  function h(v, S) {
    var A = v.getAttributeNode(S);
    return A !== null && !r.has(A) && A.value.trim() !== '' ? (r.add(A), A.value) : null;
  }
  o(h, 'useAttribute');
  function g(v) {
    return ke(v) ? h(v, 'title') : null;
  }
  o(g, 'computeTooltipAttributeValue');
  function T(v) {
    if (!ke(v)) return null;
    if (H0(v)) {
      r.add(v);
      for (var S = jt(v.childNodes), A = 0; A < S.length; A += 1) {
        var N = S[A];
        if (G0(N)) return E(N, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if ($0(v)) {
      r.add(v);
      for (var j = jt(v.childNodes), C = 0; C < j.length; C += 1) {
        var R = j[C];
        if (Bm(R)) return E(R, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
      }
    } else if (K0(v)) {
      r.add(v);
      for (var w = jt(v.childNodes), _ = 0; _ < w.length; _ += 1) {
        var k = w[_];
        if (Y0(k)) return k.textContent;
      }
      return null;
    } else if (ct(v) === 'img' || ct(v) === 'area') {
      var I = h(v, 'alt');
      if (I !== null) return I;
    } else if (B0(v)) {
      var V = h(v, 'label');
      if (V !== null) return V;
    }
    if (Si(v) && (v.type === 'button' || v.type === 'submit' || v.type === 'reset')) {
      var H = h(v, 'value');
      if (H !== null) return H;
      if (v.type === 'submit') return 'Submit';
      if (v.type === 'reset') return 'Reset';
    }
    var P = aR(v);
    if (P !== null && P.length !== 0)
      return (
        r.add(v),
        jt(P)
          .map(function (K) {
            return E(K, { isEmbeddedInLabel: !0, isReferenced: !1, recursion: !0 });
          })
          .filter(function (K) {
            return K.length > 0;
          })
          .join(' ')
      );
    if (Si(v) && v.type === 'image') {
      var L = h(v, 'alt');
      if (L !== null) return L;
      var B = h(v, 'title');
      return B !== null ? B : 'Submit Query';
    }
    if (tr(v, ['button'])) {
      var D = y(v, { isEmbeddedInLabel: !1 });
      if (D !== '') return D;
    }
    return null;
  }
  o(T, 'computeElementTextAlternative');
  function E(v, S) {
    if (r.has(v)) return '';
    if (!f && Q0(v, u) && !S.isReferenced) return (r.add(v), '');
    var A = ke(v) ? v.getAttributeNode('aria-labelledby') : null,
      N = A !== null && !r.has(A) ? Vi(v, 'aria-labelledby') : [];
    if (s === 'name' && !S.isReferenced && N.length > 0)
      return (
        r.add(A),
        N.map(function (I) {
          return E(I, { isEmbeddedInLabel: S.isEmbeddedInLabel, isReferenced: !0, recursion: !1 });
        }).join(' ')
      );
    var j = S.recursion && Z0(v) && s === 'name';
    if (!j) {
      var C = ((ke(v) && v.getAttribute('aria-label')) || '').trim();
      if (C !== '' && s === 'name') return (r.add(v), C);
      if (!tR(v)) {
        var R = T(v);
        if (R !== null) return (r.add(v), R);
      }
    }
    if (tr(v, ['menu'])) return (r.add(v), '');
    if (j || S.isEmbeddedInLabel || S.isReferenced) {
      if (tr(v, ['combobox', 'listbox'])) {
        r.add(v);
        var w = eR(v);
        return w.length === 0
          ? Si(v)
            ? v.value
            : ''
          : jt(w)
              .map(function (I) {
                return E(I, {
                  isEmbeddedInLabel: S.isEmbeddedInLabel,
                  isReferenced: !1,
                  recursion: !0,
                });
              })
              .join(' ');
      }
      if (Jm(v, 'range'))
        return (
          r.add(v),
          v.hasAttribute('aria-valuetext')
            ? v.getAttribute('aria-valuetext')
            : v.hasAttribute('aria-valuenow')
              ? v.getAttribute('aria-valuenow')
              : v.getAttribute('value') || ''
        );
      if (tr(v, ['textbox'])) return (r.add(v), iR(v));
    }
    if (nR(v) || (ke(v) && S.isReferenced) || rR(v) || oR()) {
      var _ = y(v, { isEmbeddedInLabel: S.isEmbeddedInLabel });
      if (_ !== '') return (r.add(v), _);
    }
    if (v.nodeType === v.TEXT_NODE) return (r.add(v), v.textContent || '');
    if (S.recursion) return (r.add(v), y(v, { isEmbeddedInLabel: S.isEmbeddedInLabel }));
    var k = g(v);
    return k !== null ? (r.add(v), k) : (r.add(v), '');
  }
  return (
    o(E, 'computeTextAlternative'),
    X0(E(e, { isEmbeddedInLabel: !1, isReferenced: s === 'description', recursion: !1 }))
  );
}
o(Vm, 'computeTextAlternative');
function uo(e) {
  '@babel/helpers - typeof';
  return (
    (uo =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    uo(e)
  );
}
o(uo, '_typeof');
function Zu(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    (t &&
      (n = n.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable;
      })),
      r.push.apply(r, n));
  }
  return r;
}
o(Zu, 'ownKeys');
function ed(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? Zu(Object(r), !0).forEach(function (n) {
          cR(e, n, r[n]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : Zu(Object(r)).forEach(function (n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
          });
  }
  return e;
}
o(ed, '_objectSpread');
function cR(e, t, r) {
  return (
    (t = uR(t)),
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(cR, '_defineProperty');
function uR(e) {
  var t = dR(e, 'string');
  return uo(t) === 'symbol' ? t : String(t);
}
o(uR, '_toPropertyKey');
function dR(e, t) {
  if (uo(e) !== 'object' || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || 'default');
    if (uo(n) !== 'object') return n;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (t === 'string' ? String : Number)(e);
}
o(dR, '_toPrimitive');
function Hm(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = Vi(e, 'aria-describedby')
      .map(function (i) {
        return Vm(i, ed(ed({}, t), {}, { compute: 'description' }));
      })
      .join(' ');
  if (r === '') {
    var n = e.getAttribute('title');
    r = n === null ? '' : n;
  }
  return r;
}
o(Hm, 'computeAccessibleDescription');
function pR(e) {
  return tr(e, [
    'caption',
    'code',
    'deletion',
    'emphasis',
    'generic',
    'insertion',
    'paragraph',
    'presentation',
    'strong',
    'subscript',
    'superscript',
  ]);
}
o(pR, 'prohibitsNaming');
function Jl(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return pR(e) ? '' : Vm(e, t);
}
o(Jl, 'computeAccessibleName');
var Mt = ze($d()),
  MB = ze(fj());
function Gm(e) {
  return e.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
o(Gm, 'escapeHTML');
var qB = o((e, t, r, n, i, s, a) => {
    const c = n + r.indent,
      d = r.colors;
    return e
      .map((u) => {
        const p = t[u];
        let f = a(p, r, c, i, s);
        return (
          typeof p != 'string' &&
            (f.indexOf(`
`) !== -1 && (f = r.spacingOuter + c + f + r.spacingOuter + n),
            (f = '{' + f + '}')),
          r.spacingInner +
            n +
            d.prop.open +
            u +
            d.prop.close +
            '=' +
            d.value.open +
            f +
            d.value.close
        );
      })
      .join('');
  }, 'printProps'),
  jB = 3,
  kB = o(
    (e, t, r, n, i, s) =>
      e
        .map((a) => {
          const c = typeof a == 'string' ? fR(a, t) : s(a, t, r, n, i);
          return c === '' && typeof a == 'object' && a !== null && a.nodeType !== jB
            ? ''
            : t.spacingOuter + r + c;
        })
        .join(''),
    'printChildren',
  ),
  fR = o((e, t) => {
    const r = t.colors.content;
    return r.open + Gm(e) + r.close;
  }, 'printText'),
  DB = o((e, t) => {
    const r = t.colors.comment;
    return r.open + '<!--' + Gm(e) + '-->' + r.close;
  }, 'printComment'),
  LB = o((e, t, r, n, i) => {
    const s = n.colors.tag;
    return (
      s.open +
      '<' +
      e +
      (t && s.close + t + n.spacingOuter + i + s.open) +
      (r
        ? '>' + s.close + r + n.spacingOuter + i + s.open + '</' + e
        : (t && !n.min ? '' : ' ') + '/') +
      '>' +
      s.close
    );
  }, 'printElement'),
  FB = o((e, t) => {
    const r = t.colors.tag;
    return r.open + '<' + e + r.close + ' ' + r.open + ' />' + r.close;
  }, 'printElementAsLeaf'),
  BB = 1,
  mR = 3,
  yR = 8,
  hR = 11,
  JB = /^((HTML|SVG)\w*)?Element$/,
  gR = o((e) => {
    const { tagName: t } = e;
    return !!(
      (typeof t == 'string' && t.includes('-')) ||
      (typeof e.hasAttribute == 'function' && e.hasAttribute('is'))
    );
  }, 'isCustomElement'),
  $B = o((e) => {
    const t = e.constructor.name,
      { nodeType: r } = e;
    return (
      (r === BB && (JB.test(t) || gR(e))) ||
      (r === mR && t === 'Text') ||
      (r === yR && t === 'Comment') ||
      (r === hR && t === 'DocumentFragment')
    );
  }, 'testNode');
function bR(e) {
  return e.nodeType === mR;
}
o(bR, 'nodeIsText');
function vR(e) {
  return e.nodeType === yR;
}
o(vR, 'nodeIsComment');
function qs(e) {
  return e.nodeType === hR;
}
o(qs, 'nodeIsFragment');
function ER(e) {
  return {
    test: o((t) => {
      var r;
      return ((t == null || (r = t.constructor) == null ? void 0 : r.name) || gR(t)) && $B(t);
    }, 'test'),
    serialize: o((t, r, n, i, s, a) => {
      if (bR(t)) return fR(t.data, r);
      if (vR(t)) return DB(t.data, r);
      const c = qs(t) ? 'DocumentFragment' : t.tagName.toLowerCase();
      return ++i > r.maxDepth
        ? FB(c, r)
        : LB(
            c,
            qB(
              qs(t)
                ? []
                : Array.from(t.attributes)
                    .map((d) => d.name)
                    .sort(),
              qs(t)
                ? {}
                : Array.from(t.attributes).reduce((d, u) => ((d[u.name] = u.value), d), {}),
              r,
              n + r.indent,
              i,
              s,
              a,
            ),
            kB(
              Array.prototype.slice.call(t.childNodes || t.children).filter(e),
              r,
              n + r.indent,
              i,
              s,
              a,
            ),
            r,
            n,
          );
    }, 'serialize'),
  };
}
o(ER, 'createDOMElementFilter');
var TR = null,
  zm = null,
  Wm = null;
try {
  const e = module && module.require;
  ((zm = e.call(module, 'fs').readFileSync),
    (Wm = e.call(module, '@babel/code-frame').codeFrameColumns),
    (TR = e.call(module, 'picocolors')));
} catch {}
function wR(e) {
  const t = e.indexOf('(') + 1,
    r = e.indexOf(')'),
    n = e.slice(t, r),
    i = n.split(':'),
    [s, a, c] = [i[0], parseInt(i[1], 10), parseInt(i[2], 10)];
  let d = '';
  try {
    d = zm(s, 'utf-8');
  } catch {
    return '';
  }
  const u = Wm(d, { start: { line: a, column: c } }, { highlightCode: !0, linesBelow: 0 });
  return (
    TR.dim(n) +
    `
` +
    u +
    `
`
  );
}
o(wR, 'getCodeFrame');
function SR() {
  if (!zm || !Wm) return '';
  const t = new Error().stack
    .split(
      `
`,
    )
    .slice(1)
    .find((r) => !r.includes('node_modules/'));
  return wR(t);
}
o(SR, 'getUserCodeFrame');
var _R = 3;
function js() {
  return typeof jest < 'u' && jest !== null
    ? setTimeout._isMockFunction === !0 || Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
    : !1;
}
o(js, 'jestFakeTimersAreEnabled');
function $l() {
  if (typeof window > 'u') throw new Error('Could not find default container');
  return window.document;
}
o($l, 'getDocument');
function Km(e) {
  if (e.defaultView) return e.defaultView;
  if (e.ownerDocument && e.ownerDocument.defaultView) return e.ownerDocument.defaultView;
  if (e.window) return e.window;
  throw e.ownerDocument && e.ownerDocument.defaultView === null
    ? new Error('It looks like the window object is not available for the provided node.')
    : e.then instanceof Function
      ? new Error(
          'It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?',
        )
      : Array.isArray(e)
        ? new Error(
            'It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?',
          )
        : typeof e.debug == 'function' && typeof e.logTestingPlaygroundURL == 'function'
          ? new Error(
              'It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?',
            )
          : new Error('The given node is not an Element, the node type is: ' + typeof e + '.');
}
o(Km, 'getWindowFromNode');
function sr(e) {
  if (!e || typeof e.querySelector != 'function' || typeof e.querySelectorAll != 'function')
    throw new TypeError(
      'Expected container to be an Element, a Document or a DocumentFragment but got ' + t(e) + '.',
    );
  function t(r) {
    return typeof r == 'object' ? (r === null ? 'null' : r.constructor.name) : typeof r;
  }
  o(t, 'getTypeName');
}
o(sr, 'checkContainerType');
var UB = o(() => {
    if (typeof process > 'u') return !1;
    let e;
    try {
      var t;
      const r = (t = $c) == null ? void 0 : t.COLORS;
      r && (e = JSON.parse(r));
    } catch {}
    return typeof e == 'boolean'
      ? e
      : process.versions !== void 0 && process.versions.node !== void 0;
  }, 'shouldHighlight'),
  { DOMCollection: VB } = Dm.plugins,
  HB = 1,
  GB = 8;
function RR(e) {
  return e.nodeType !== GB && (e.nodeType !== HB || !e.matches(Te().defaultIgnore));
}
o(RR, 'filterCommentsAndDefaultIgnoreTagsTags');
function po(e, t, r) {
  if (
    (r === void 0 && (r = {}),
    e || (e = $l().body),
    typeof t != 'number' &&
      (t = (typeof process < 'u' && typeof $c < 'u' && $c.DEBUG_PRINT_LIMIT) || 7e3),
    t === 0)
  )
    return '';
  e.documentElement && (e = e.documentElement);
  let n = typeof e;
  if ((n === 'object' ? (n = e.constructor.name) : (e = {}), !('outerHTML' in e)))
    throw new TypeError('Expected an element or document but got ' + n);
  const { filterNode: i = RR, ...s } = r,
    a = Dm.format(e, { plugins: [ER(i), VB], printFunctionName: !1, highlight: UB(), ...s });
  return t !== void 0 && e.outerHTML.length > t ? a.slice(0, t) + '...' : a;
}
o(po, 'prettyDOM');
var td = o(function () {
    const e = SR();
    console.log(
      e
        ? po(...arguments) +
            `

` +
            e
        : po(...arguments),
    );
  }, 'logDOM'),
  mn = {
    testIdAttribute: 'data-testid',
    asyncUtilTimeout: 1e3,
    asyncWrapper: o((e) => e(), 'asyncWrapper'),
    unstable_advanceTimersWrapper: o((e) => e(), 'unstable_advanceTimersWrapper'),
    eventWrapper: o((e) => e(), 'eventWrapper'),
    defaultHidden: !1,
    defaultIgnore: 'script, style',
    showOriginalStackTrace: !1,
    throwSuggestions: !1,
    getElementError(e, t) {
      const r = po(t),
        n = new Error(
          [
            e,
            'Ignored nodes: comments, ' +
              mn.defaultIgnore +
              `
` +
              r,
          ].filter(Boolean).join(`

`),
        );
      return ((n.name = 'TestingLibraryElementError'), n);
    },
    _disableExpensiveErrorDiagnostics: !1,
    computedStyleSupportsPseudoElements: !1,
  };
function PR(e) {
  try {
    return ((mn._disableExpensiveErrorDiagnostics = !0), e());
  } finally {
    mn._disableExpensiveErrorDiagnostics = !1;
  }
}
o(PR, 'runWithExpensiveErrorDiagnosticsDisabled');
function AR(e) {
  (typeof e == 'function' && (e = e(mn)), (mn = { ...mn, ...e }));
}
o(AR, 'configure');
function Te() {
  return mn;
}
o(Te, 'getConfig');
var zB = ['button', 'meter', 'output', 'progress', 'select', 'textarea', 'input'];
function Ym(e) {
  return zB.includes(e.nodeName.toLowerCase())
    ? ''
    : e.nodeType === _R
      ? e.textContent
      : Array.from(e.childNodes)
          .map((t) => Ym(t))
          .join('');
}
o(Ym, 'getTextContent');
function Ea(e) {
  let t;
  return (e.tagName.toLowerCase() === 'label' ? (t = Ym(e)) : (t = e.value || e.textContent), t);
}
o(Ea, 'getLabelContent');
function Xm(e) {
  if (e.labels !== void 0) {
    var t;
    return (t = e.labels) != null ? t : [];
  }
  if (!OR(e)) return [];
  const r = e.ownerDocument.querySelectorAll('label');
  return Array.from(r).filter((n) => n.control === e);
}
o(Xm, 'getRealLabels');
function OR(e) {
  return (
    /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) ||
    (e.tagName === 'INPUT' && e.getAttribute('type') !== 'hidden')
  );
}
o(OR, 'isLabelable');
function Qm(e, t, r) {
  let { selector: n = '*' } = r === void 0 ? {} : r;
  const i = t.getAttribute('aria-labelledby'),
    s = i ? i.split(' ') : [];
  return s.length
    ? s.map((a) => {
        const c = e.querySelector('[id="' + a + '"]');
        return c ? { content: Ea(c), formControl: null } : { content: '', formControl: null };
      })
    : Array.from(Xm(t)).map((a) => {
        const c = Ea(a),
          u = Array.from(
            a.querySelectorAll('button, input, meter, output, progress, select, textarea'),
          ).filter((p) => p.matches(n))[0];
        return { content: c, formControl: u };
      });
}
o(Qm, 'getLabels');
function Zm(e) {
  if (e == null)
    throw new Error(
      'It looks like ' +
        e +
        ' was passed instead of a matcher. Did you do something like getByText(' +
        e +
        ')?',
    );
}
o(Zm, 'assertNotNullOrUndefined');
function Mn(e, t, r, n) {
  if (typeof e != 'string') return !1;
  Zm(r);
  const i = n(e);
  return typeof r == 'string' || typeof r == 'number'
    ? i.toLowerCase().includes(r.toString().toLowerCase())
    : typeof r == 'function'
      ? r(i, t)
      : ey(r, i);
}
o(Mn, 'fuzzyMatches');
function nr(e, t, r, n) {
  if (typeof e != 'string') return !1;
  Zm(r);
  const i = n(e);
  return r instanceof Function ? r(i, t) : r instanceof RegExp ? ey(r, i) : i === String(r);
}
o(nr, 'matches');
function Ul(e) {
  let { trim: t = !0, collapseWhitespace: r = !0 } = e === void 0 ? {} : e;
  return (n) => {
    let i = n;
    return ((i = t ? i.trim() : i), (i = r ? i.replace(/\s+/g, ' ') : i), i);
  };
}
o(Ul, 'getDefaultNormalizer');
function Kr(e) {
  let { trim: t, collapseWhitespace: r, normalizer: n } = e;
  if (!n) return Ul({ trim: t, collapseWhitespace: r });
  if (typeof t < 'u' || typeof r < 'u')
    throw new Error(
      'trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer',
    );
  return n;
}
o(Kr, 'makeNormalizer');
function ey(e, t) {
  const r = e.test(t);
  return (
    e.global &&
      e.lastIndex !== 0 &&
      (console.warn(
        'To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.',
      ),
      (e.lastIndex = 0)),
    r
  );
}
o(ey, 'matchRegExp');
function Oo(e) {
  return e.matches('input[type=submit], input[type=button], input[type=reset]')
    ? e.value
    : Array.from(e.childNodes)
        .filter((t) => t.nodeType === _R && !!t.textContent)
        .map((t) => t.textContent)
        .join('');
}
o(Oo, 'getNodeText');
var WB = CR(Mt.elementRoles);
function ty(e) {
  return (
    e.hidden === !0 ||
    e.getAttribute('aria-hidden') === 'true' ||
    e.ownerDocument.defaultView.getComputedStyle(e).display === 'none'
  );
}
o(ty, 'isSubtreeInaccessible');
function hs(e, t) {
  t === void 0 && (t = {});
  const { isSubtreeInaccessible: r = ty } = t;
  if (e.ownerDocument.defaultView.getComputedStyle(e).visibility === 'hidden') return !0;
  let i = e;
  for (; i; ) {
    if (r(i)) return !0;
    i = i.parentElement;
  }
  return !1;
}
o(hs, 'isInaccessible');
function Vl(e) {
  for (const { match: t, roles: r } of WB) if (t(e)) return [...r];
  return [];
}
o(Vl, 'getImplicitAriaRoles');
function CR(e) {
  function t(a) {
    let { name: c, attributes: d } = a;
    return (
      '' +
      c +
      d
        .map((u) => {
          let { name: p, value: f, constraints: y = [] } = u;
          const h = y.indexOf('undefined') !== -1,
            g = y.indexOf('set') !== -1;
          return typeof f < 'u'
            ? '[' + p + '="' + f + '"]'
            : h
              ? ':not([' + p + '])'
              : g
                ? '[' + p + ']:not([' + p + '=""])'
                : '[' + p + ']';
        })
        .join('')
    );
  }
  o(t, 'makeElementSelector');
  function r(a) {
    let { attributes: c = [] } = a;
    return c.length;
  }
  o(r, 'getSelectorSpecificity');
  function n(a, c) {
    let { specificity: d } = a,
      { specificity: u } = c;
    return u - d;
  }
  o(n, 'bySelectorSpecificity');
  function i(a) {
    let { attributes: c = [] } = a;
    const d = c.findIndex((p) => p.value && p.name === 'type' && p.value === 'text');
    d >= 0 && (c = [...c.slice(0, d), ...c.slice(d + 1)]);
    const u = t({ ...a, attributes: c });
    return (p) => (d >= 0 && p.type !== 'text' ? !1 : p.matches(u));
  }
  o(i, 'match');
  let s = [];
  for (const [a, c] of e.entries())
    s = [...s, { match: i(a), roles: Array.from(c), specificity: r(a) }];
  return s.sort(n);
}
o(CR, 'buildElementRoleList');
function ry(e, t) {
  let { hidden: r = !1 } = t === void 0 ? {} : t;
  function n(i) {
    return [i, ...Array.from(i.children).reduce((s, a) => [...s, ...n(a)], [])];
  }
  return (
    o(n, 'flattenDOM'),
    n(e)
      .filter((i) => (r === !1 ? hs(i) === !1 : !0))
      .reduce((i, s) => {
        let a = [];
        return (
          s.hasAttribute('role')
            ? (a = s.getAttribute('role').split(' ').slice(0, 1))
            : (a = Vl(s)),
          a.reduce(
            (c, d) => (Array.isArray(c[d]) ? { ...c, [d]: [...c[d], s] } : { ...c, [d]: [s] }),
            i,
          )
        );
      }, {})
  );
}
o(ry, 'getRoles');
function ny(e, t) {
  let { hidden: r, includeDescription: n } = t;
  const i = ry(e, { hidden: r });
  return Object.entries(i)
    .filter((s) => {
      let [a] = s;
      return a !== 'generic';
    })
    .map((s) => {
      let [a, c] = s;
      const d = '-'.repeat(50),
        u = c.map((p) => {
          const f =
              'Name "' +
              Jl(p, {
                computedStyleSupportsPseudoElements: Te().computedStyleSupportsPseudoElements,
              }) +
              `":
`,
            y = po(p.cloneNode(!1));
          if (n) {
            const h =
              'Description "' +
              Hm(p, {
                computedStyleSupportsPseudoElements: Te().computedStyleSupportsPseudoElements,
              }) +
              `":
`;
            return '' + f + h + y;
          }
          return '' + f + y;
        }).join(`

`);
      return (
        a +
        `:

` +
        u +
        `

` +
        d
      );
    }).join(`
`);
}
o(ny, 'prettyRoles');
var KB = o(function (e, t) {
  let { hidden: r = !1 } = t === void 0 ? {} : t;
  return console.log(ny(e, { hidden: r }));
}, 'logRoles');
function xR(e) {
  return e.tagName === 'OPTION' ? e.selected : Co(e, 'aria-selected');
}
o(xR, 'computeAriaSelected');
function NR(e) {
  return e.getAttribute('aria-busy') === 'true';
}
o(NR, 'computeAriaBusy');
function IR(e) {
  if (!('indeterminate' in e && e.indeterminate))
    return 'checked' in e ? e.checked : Co(e, 'aria-checked');
}
o(IR, 'computeAriaChecked');
function MR(e) {
  return Co(e, 'aria-pressed');
}
o(MR, 'computeAriaPressed');
function qR(e) {
  var t, r;
  return (t = (r = Co(e, 'aria-current')) != null ? r : e.getAttribute('aria-current')) != null
    ? t
    : !1;
}
o(qR, 'computeAriaCurrent');
function jR(e) {
  return Co(e, 'aria-expanded');
}
o(jR, 'computeAriaExpanded');
function Co(e, t) {
  const r = e.getAttribute(t);
  if (r === 'true') return !0;
  if (r === 'false') return !1;
}
o(Co, 'checkBooleanAttribute');
function kR(e) {
  const t = { H1: 1, H2: 2, H3: 3, H4: 4, H5: 5, H6: 6 };
  return (e.getAttribute('aria-level') && Number(e.getAttribute('aria-level'))) || t[e.tagName];
}
o(kR, 'computeHeadingLevel');
function DR(e) {
  const t = e.getAttribute('aria-valuenow');
  return t === null ? void 0 : +t;
}
o(DR, 'computeAriaValueNow');
function LR(e) {
  const t = e.getAttribute('aria-valuemax');
  return t === null ? void 0 : +t;
}
o(LR, 'computeAriaValueMax');
function FR(e) {
  const t = e.getAttribute('aria-valuemin');
  return t === null ? void 0 : +t;
}
o(FR, 'computeAriaValueMin');
function BR(e) {
  const t = e.getAttribute('aria-valuetext');
  return t === null ? void 0 : t;
}
o(BR, 'computeAriaValueText');
var dg = Ul();
function JR(e) {
  return e.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
}
o(JR, 'escapeRegExp');
function rd(e) {
  return new RegExp(JR(e.toLowerCase()), 'i');
}
o(rd, 'getRegExpMatcher');
function mr(e, t, r, n) {
  let { variant: i, name: s } = n,
    a = '';
  const c = {},
    d = [['Role', 'TestId'].includes(e) ? r : rd(r)];
  (s && (c.name = rd(s)),
    e === 'Role' &&
      hs(t) &&
      ((c.hidden = !0),
      (a = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `)),
    Object.keys(c).length > 0 && d.push(c));
  const u = i + 'By' + e;
  return {
    queryName: e,
    queryMethod: u,
    queryArgs: d,
    variant: i,
    warning: a,
    toString() {
      a && console.warn(a);
      let [p, f] = d;
      return (
        (p = typeof p == 'string' ? "'" + p + "'" : p),
        (f = f
          ? ', { ' +
            Object.entries(f)
              .map((y) => {
                let [h, g] = y;
                return h + ': ' + g;
              })
              .join(', ') +
            ' }'
          : ''),
        u + '(' + p + f + ')'
      );
    },
  };
}
o(mr, 'makeSuggestion');
function yr(e, t, r) {
  return r && (!t || t.toLowerCase() === e.toLowerCase());
}
o(yr, 'canSuggest');
function Hi(e, t, r) {
  var n, i;
  if ((t === void 0 && (t = 'get'), e.matches(Te().defaultIgnore))) return;
  const s = (n = e.getAttribute('role')) != null ? n : (i = Vl(e)) == null ? void 0 : i[0];
  if (s !== 'generic' && yr('Role', r, s))
    return mr('Role', e, s, {
      variant: t,
      name: Jl(e, {
        computedStyleSupportsPseudoElements: Te().computedStyleSupportsPseudoElements,
      }),
    });
  const a = Qm(document, e)
    .map((y) => y.content)
    .join(' ');
  if (yr('LabelText', r, a)) return mr('LabelText', e, a, { variant: t });
  const c = e.getAttribute('placeholder');
  if (yr('PlaceholderText', r, c)) return mr('PlaceholderText', e, c, { variant: t });
  const d = dg(Oo(e));
  if (yr('Text', r, d)) return mr('Text', e, d, { variant: t });
  if (yr('DisplayValue', r, e.value)) return mr('DisplayValue', e, dg(e.value), { variant: t });
  const u = e.getAttribute('alt');
  if (yr('AltText', r, u)) return mr('AltText', e, u, { variant: t });
  const p = e.getAttribute('title');
  if (yr('Title', r, p)) return mr('Title', e, p, { variant: t });
  const f = e.getAttribute(Te().testIdAttribute);
  if (yr('TestId', r, f)) return mr('TestId', e, f, { variant: t });
}
o(Hi, 'getSuggestedQuery');
function ui(e, t) {
  e.stack = t.stack.replace(t.message, e.message);
}
o(ui, 'copyStackTrace');
function $R(e, t) {
  let {
    container: r = $l(),
    timeout: n = Te().asyncUtilTimeout,
    showOriginalStackTrace: i = Te().showOriginalStackTrace,
    stackTraceError: s,
    interval: a = 50,
    onTimeout: c = o(
      (u) => (
        Object.defineProperty(u, 'message', { value: Te().getElementError(u.message, r).message }),
        u
      ),
      'onTimeout',
    ),
    mutationObserverOptions: d = { subtree: !0, childList: !0, attributes: !0, characterData: !0 },
  } = t;
  if (typeof e != 'function') throw new TypeError('Received `callback` arg must be a function');
  return new Promise(async (u, p) => {
    let f,
      y,
      h,
      g = !1,
      T = 'idle';
    const E = setTimeout(j, n),
      v = js();
    if (v) {
      const { unstable_advanceTimersWrapper: C } = Te();
      for (N(); !g; ) {
        if (!js()) {
          const R = new Error(
            "Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830",
          );
          (i || ui(R, s), p(R));
          return;
        }
        if (
          (await C(async () => {
            jest.advanceTimersByTime(a);
          }),
          g)
        )
          break;
        N();
      }
    } else {
      try {
        sr(r);
      } catch (R) {
        p(R);
        return;
      }
      y = setInterval(A, a);
      const { MutationObserver: C } = Km(r);
      ((h = new C(A)), h.observe(r, d), N());
    }
    function S(C, R) {
      ((g = !0), clearTimeout(E), v || (clearInterval(y), h.disconnect()), C ? p(C) : u(R));
    }
    o(S, 'onDone');
    function A() {
      if (js()) {
        const C = new Error(
          "Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830",
        );
        return (i || ui(C, s), p(C));
      } else return N();
    }
    o(A, 'checkRealTimersCallback');
    function N() {
      if (T !== 'pending')
        try {
          const C = PR(e);
          typeof C?.then == 'function'
            ? ((T = 'pending'),
              C.then(
                (R) => {
                  ((T = 'resolved'), S(null, R));
                },
                (R) => {
                  ((T = 'rejected'), (f = R));
                },
              ))
            : S(null, C);
        } catch (C) {
          f = C;
        }
    }
    o(N, 'checkCallback');
    function j() {
      let C;
      (f
        ? ((C = f), !i && C.name === 'TestingLibraryElementError' && ui(C, s))
        : ((C = new Error('Timed out in waitFor.')), i || ui(C, s)),
        S(c(C), null));
    }
    o(j, 'handleTimeout');
  });
}
o($R, 'waitFor');
function Hl(e, t) {
  const r = new Error('STACK_TRACE_MESSAGE');
  return Te().asyncWrapper(() => $R(e, { stackTraceError: r, ...t }));
}
o(Hl, 'waitForWrapper');
function gs(e, t) {
  return Te().getElementError(e, t);
}
o(gs, 'getElementError');
function bs(e, t) {
  return gs(
    e +
      '\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).',
    t,
  );
}
o(bs, 'getMultipleElementsFoundError');
function Yr(e, t, r, n) {
  let { exact: i = !0, collapseWhitespace: s, trim: a, normalizer: c } = n === void 0 ? {} : n;
  const d = i ? nr : Mn,
    u = Kr({ collapseWhitespace: s, trim: a, normalizer: c });
  return Array.from(t.querySelectorAll('[' + e + ']')).filter((p) => d(p.getAttribute(e), p, r, u));
}
o(Yr, 'queryAllByAttribute');
function oy(e, t, r, n) {
  const i = Yr(e, t, r, n);
  if (i.length > 1) throw bs('Found multiple elements by [' + e + '=' + r + ']', t);
  return i[0] || null;
}
o(oy, 'queryByAttribute');
function vn(e, t) {
  return function (r) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      i[s - 1] = arguments[s];
    const a = e(r, ...i);
    if (a.length > 1) {
      const c = a.map((d) => gs(null, d).message).join(`

`);
      throw bs(
        t(r, ...i) +
          `

Here are the matching elements:

` +
          c,
        r,
      );
    }
    return a[0] || null;
  };
}
o(vn, 'makeSingleQuery');
function iy(e, t) {
  return Te().getElementError(
    `A better query is available, try this:
` +
      e.toString() +
      `
`,
    t,
  );
}
o(iy, 'getSuggestionError');
function Gl(e, t) {
  return function (r) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      i[s - 1] = arguments[s];
    const a = e(r, ...i);
    if (!a.length) throw Te().getElementError(t(r, ...i), r);
    return a;
  };
}
o(Gl, 'makeGetAllQuery');
function En(e) {
  return (t, r, n, i) => Hl(() => e(t, r, n), { container: t, ...i });
}
o(En, 'makeFindQuery');
var Fr = o(
    (e, t, r) =>
      function (n) {
        for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
          s[a - 1] = arguments[a];
        const c = e(n, ...s),
          [{ suggest: d = Te().throwSuggestions } = {}] = s.slice(-1);
        if (c && d) {
          const u = Hi(c, r);
          if (u && !t.endsWith(u.queryName)) throw iy(u.toString(), n);
        }
        return c;
      },
    'wrapSingleQueryWithSuggestion',
  ),
  vt = o(
    (e, t, r) =>
      function (n) {
        for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
          s[a - 1] = arguments[a];
        const c = e(n, ...s),
          [{ suggest: d = Te().throwSuggestions } = {}] = s.slice(-1);
        if (c.length && d) {
          const u = [
            ...new Set(
              c.map((p) => {
                var f;
                return (f = Hi(p, r)) == null ? void 0 : f.toString();
              }),
            ),
          ];
          if (u.length === 1 && !t.endsWith(Hi(c[0], r).queryName)) throw iy(u[0], n);
        }
        return c;
      },
    'wrapAllByQueryWithSuggestion',
  );
function ar(e, t, r) {
  const n = Fr(vn(e, t), e.name, 'query'),
    i = Gl(e, r),
    s = vn(i, t),
    a = Fr(s, e.name, 'get'),
    c = vt(i, e.name.replace('query', 'get'), 'getAll'),
    d = En(vt(i, e.name, 'findAll')),
    u = En(Fr(s, e.name, 'find'));
  return [n, c, a, d, u];
}
o(ar, 'buildQueries');
var YB = Object.freeze({
  __proto__: null,
  getElementError: gs,
  wrapAllByQueryWithSuggestion: vt,
  wrapSingleQueryWithSuggestion: Fr,
  getMultipleElementsFoundError: bs,
  queryAllByAttribute: Yr,
  queryByAttribute: oy,
  makeSingleQuery: vn,
  makeGetAllQuery: Gl,
  makeFindQuery: En,
  buildQueries: ar,
});
function UR(e) {
  return Array.from(e.querySelectorAll('label,input'))
    .map((t) => ({ node: t, textToMatch: Ea(t) }))
    .filter((t) => {
      let { textToMatch: r } = t;
      return r !== null;
    });
}
o(UR, 'queryAllLabels');
var XB = o(function (e, t, r) {
    let { exact: n = !0, trim: i, collapseWhitespace: s, normalizer: a } = r === void 0 ? {} : r;
    const c = n ? nr : Mn,
      d = Kr({ collapseWhitespace: s, trim: i, normalizer: a });
    return UR(e)
      .filter((p) => {
        let { node: f, textToMatch: y } = p;
        return c(y, f, t, d);
      })
      .map((p) => {
        let { node: f } = p;
        return f;
      });
  }, 'queryAllLabelsByText'),
  Gi = o(function (e, t, r) {
    let {
      selector: n = '*',
      exact: i = !0,
      collapseWhitespace: s,
      trim: a,
      normalizer: c,
    } = r === void 0 ? {} : r;
    sr(e);
    const d = i ? nr : Mn,
      u = Kr({ collapseWhitespace: s, trim: a, normalizer: c }),
      p = Array.from(e.querySelectorAll('*'))
        .filter((f) => Xm(f).length || f.hasAttribute('aria-labelledby'))
        .reduce((f, y) => {
          const h = Qm(e, y, { selector: n });
          h.filter((T) => !!T.formControl).forEach((T) => {
            d(T.content, T.formControl, t, u) && T.formControl && f.push(T.formControl);
          });
          const g = h.filter((T) => !!T.content).map((T) => T.content);
          return (
            d(g.join(' '), y, t, u) && f.push(y),
            g.length > 1 &&
              g.forEach((T, E) => {
                d(T, y, t, u) && f.push(y);
                const v = [...g];
                (v.splice(E, 1), v.length > 1 && d(v.join(' '), y, t, u) && f.push(y));
              }),
            f
          );
        }, [])
        .concat(Yr('aria-label', e, t, { exact: i, normalizer: u }));
    return Array.from(new Set(p)).filter((f) => f.matches(n));
  }, 'queryAllByLabelText'),
  Tn = o(function (e, t) {
    for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++)
      n[i - 2] = arguments[i];
    const s = Gi(e, t, ...n);
    if (!s.length) {
      const a = XB(e, t, ...n);
      if (a.length) {
        const c = a.map((d) => VR(e, d)).filter((d) => !!d);
        throw c.length
          ? Te().getElementError(
              c.map(
                (d) =>
                  'Found a label with the text of: ' +
                  t +
                  ', however the element associated with this label (<' +
                  d +
                  ' />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <' +
                  d +
                  ' />, you can use aria-label or aria-labelledby instead.',
              ).join(`

`),
              e,
            )
          : Te().getElementError(
              'Found a label with the text of: ' +
                t +
                `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`,
              e,
            );
      } else throw Te().getElementError('Unable to find a label with the text of: ' + t, e);
    }
    return s;
  }, 'getAllByLabelText');
function VR(e, t) {
  const r = t.getAttribute('for');
  if (!r) return null;
  const n = e.querySelector('[id="' + r + '"]');
  return n ? n.tagName.toLowerCase() : null;
}
o(VR, 'getTagNameOfElementAssociatedWithLabelViaFor');
var HR = o((e, t) => 'Found multiple elements with the text of: ' + t, 'getMultipleError$7'),
  GR = Fr(vn(Gi, HR), Gi.name, 'query'),
  zR = vn(Tn, HR),
  WR = En(vt(Tn, Tn.name, 'findAll')),
  KR = En(Fr(zR, Tn.name, 'find')),
  YR = vt(Tn, Tn.name, 'getAll'),
  XR = Fr(zR, Tn.name, 'get'),
  QR = vt(Gi, Gi.name, 'queryAll'),
  nd = o(function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    return (sr(t[0]), Yr('placeholder', ...t));
  }, 'queryAllByPlaceholderText'),
  QB = o(
    (e, t) => 'Found multiple elements with the placeholder text of: ' + t,
    'getMultipleError$6',
  ),
  ZB = o(
    (e, t) => 'Unable to find an element with the placeholder text of: ' + t,
    'getMissingError$6',
  ),
  ZR = vt(nd, nd.name, 'queryAll'),
  [eP, tP, rP, nP, oP] = ar(nd, QB, ZB),
  od = o(function (e, t, r) {
    let {
      selector: n = '*',
      exact: i = !0,
      collapseWhitespace: s,
      trim: a,
      ignore: c = Te().defaultIgnore,
      normalizer: d,
    } = r === void 0 ? {} : r;
    sr(e);
    const u = i ? nr : Mn,
      p = Kr({ collapseWhitespace: s, trim: a, normalizer: d });
    let f = [];
    return (
      typeof e.matches == 'function' && e.matches(n) && (f = [e]),
      [...f, ...Array.from(e.querySelectorAll(n))]
        .filter((y) => !c || !y.matches(c))
        .filter((y) => u(Oo(y), y, t, p))
    );
  }, 'queryAllByText'),
  eJ = o((e, t) => 'Found multiple elements with the text: ' + t, 'getMultipleError$5'),
  tJ = o(function (e, t, r) {
    r === void 0 && (r = {});
    const { collapseWhitespace: n, trim: i, normalizer: s, selector: a } = r,
      d = Kr({ collapseWhitespace: n, trim: i, normalizer: s })(t.toString()),
      u = d !== t.toString(),
      p = (a ?? '*') !== '*';
    return (
      'Unable to find an element with the text: ' +
      (u ? d + " (normalized from '" + t + "')" : t) +
      (p ? ", which matches selector '" + a + "'" : '') +
      '. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.'
    );
  }, 'getMissingError$5'),
  iP = vt(od, od.name, 'queryAll'),
  [sP, aP, lP, cP, uP] = ar(od, eJ, tJ),
  id = o(function (e, t, r) {
    let { exact: n = !0, collapseWhitespace: i, trim: s, normalizer: a } = r === void 0 ? {} : r;
    sr(e);
    const c = n ? nr : Mn,
      d = Kr({ collapseWhitespace: i, trim: s, normalizer: a });
    return Array.from(e.querySelectorAll('input,textarea,select')).filter((u) =>
      u.tagName === 'SELECT'
        ? Array.from(u.options)
            .filter((f) => f.selected)
            .some((f) => c(Oo(f), f, t, d))
        : c(u.value, u, t, d),
    );
  }, 'queryAllByDisplayValue'),
  rJ = o(
    (e, t) => 'Found multiple elements with the display value: ' + t + '.',
    'getMultipleError$4',
  ),
  nJ = o(
    (e, t) => 'Unable to find an element with the display value: ' + t + '.',
    'getMissingError$4',
  ),
  dP = vt(id, id.name, 'queryAll'),
  [pP, fP, mP, yP, hP] = ar(id, rJ, nJ),
  oJ = /^(img|input|area|.+-.+)$/i,
  sd = o(function (e, t, r) {
    return (r === void 0 && (r = {}), sr(e), Yr('alt', e, t, r).filter((n) => oJ.test(n.tagName)));
  }, 'queryAllByAltText'),
  iJ = o((e, t) => 'Found multiple elements with the alt text: ' + t, 'getMultipleError$3'),
  sJ = o((e, t) => 'Unable to find an element with the alt text: ' + t, 'getMissingError$3'),
  gP = vt(sd, sd.name, 'queryAll'),
  [bP, vP, EP, TP, wP] = ar(sd, iJ, sJ),
  aJ = o((e) => {
    var t;
    return (
      e.tagName.toLowerCase() === 'title' &&
      ((t = e.parentElement) == null ? void 0 : t.tagName.toLowerCase()) === 'svg'
    );
  }, 'isSvgTitle'),
  ad = o(function (e, t, r) {
    let { exact: n = !0, collapseWhitespace: i, trim: s, normalizer: a } = r === void 0 ? {} : r;
    sr(e);
    const c = n ? nr : Mn,
      d = Kr({ collapseWhitespace: i, trim: s, normalizer: a });
    return Array.from(e.querySelectorAll('[title], svg > title')).filter(
      (u) => c(u.getAttribute('title'), u, t, d) || (aJ(u) && c(Oo(u), u, t, d)),
    );
  }, 'queryAllByTitle'),
  lJ = o((e, t) => 'Found multiple elements with the title: ' + t + '.', 'getMultipleError$2'),
  cJ = o((e, t) => 'Unable to find an element with the title: ' + t + '.', 'getMissingError$2'),
  SP = vt(ad, ad.name, 'queryAll'),
  [_P, RP, PP, AP, OP] = ar(ad, lJ, cJ),
  ld = o(function (e, t, r) {
    let {
      hidden: n = Te().defaultHidden,
      name: i,
      description: s,
      queryFallbacks: a = !1,
      selected: c,
      busy: d,
      checked: u,
      pressed: p,
      current: f,
      level: y,
      expanded: h,
      value: { now: g, min: T, max: E, text: v } = {},
    } = r === void 0 ? {} : r;
    if ((sr(e), c !== void 0)) {
      var S;
      if (((S = Mt.roles.get(t)) == null ? void 0 : S.props['aria-selected']) === void 0)
        throw new Error('"aria-selected" is not supported on role "' + t + '".');
    }
    if (d !== void 0) {
      var A;
      if (((A = Mt.roles.get(t)) == null ? void 0 : A.props['aria-busy']) === void 0)
        throw new Error('"aria-busy" is not supported on role "' + t + '".');
    }
    if (u !== void 0) {
      var N;
      if (((N = Mt.roles.get(t)) == null ? void 0 : N.props['aria-checked']) === void 0)
        throw new Error('"aria-checked" is not supported on role "' + t + '".');
    }
    if (p !== void 0) {
      var j;
      if (((j = Mt.roles.get(t)) == null ? void 0 : j.props['aria-pressed']) === void 0)
        throw new Error('"aria-pressed" is not supported on role "' + t + '".');
    }
    if (f !== void 0) {
      var C;
      if (((C = Mt.roles.get(t)) == null ? void 0 : C.props['aria-current']) === void 0)
        throw new Error('"aria-current" is not supported on role "' + t + '".');
    }
    if (y !== void 0 && t !== 'heading')
      throw new Error('Role "' + t + '" cannot have "level" property.');
    if (g !== void 0) {
      var R;
      if (((R = Mt.roles.get(t)) == null ? void 0 : R.props['aria-valuenow']) === void 0)
        throw new Error('"aria-valuenow" is not supported on role "' + t + '".');
    }
    if (E !== void 0) {
      var w;
      if (((w = Mt.roles.get(t)) == null ? void 0 : w.props['aria-valuemax']) === void 0)
        throw new Error('"aria-valuemax" is not supported on role "' + t + '".');
    }
    if (T !== void 0) {
      var _;
      if (((_ = Mt.roles.get(t)) == null ? void 0 : _.props['aria-valuemin']) === void 0)
        throw new Error('"aria-valuemin" is not supported on role "' + t + '".');
    }
    if (v !== void 0) {
      var k;
      if (((k = Mt.roles.get(t)) == null ? void 0 : k.props['aria-valuetext']) === void 0)
        throw new Error('"aria-valuetext" is not supported on role "' + t + '".');
    }
    if (h !== void 0) {
      var I;
      if (((I = Mt.roles.get(t)) == null ? void 0 : I.props['aria-expanded']) === void 0)
        throw new Error('"aria-expanded" is not supported on role "' + t + '".');
    }
    const V = new WeakMap();
    function H(P) {
      return (V.has(P) || V.set(P, ty(P)), V.get(P));
    }
    return (
      o(H, 'cachedIsSubtreeInaccessible'),
      Array.from(e.querySelectorAll(CP(t)))
        .filter((P) => {
          if (P.hasAttribute('role')) {
            const D = P.getAttribute('role');
            if (a)
              return D.split(' ')
                .filter(Boolean)
                .some((X) => X === t);
            const [K] = D.split(' ');
            return K === t;
          }
          return Vl(P).some((D) => D === t);
        })
        .filter((P) => {
          if (c !== void 0) return c === xR(P);
          if (d !== void 0) return d === NR(P);
          if (u !== void 0) return u === IR(P);
          if (p !== void 0) return p === MR(P);
          if (f !== void 0) return f === qR(P);
          if (h !== void 0) return h === jR(P);
          if (y !== void 0) return y === kR(P);
          if (g !== void 0 || E !== void 0 || T !== void 0 || v !== void 0) {
            let B = !0;
            if (
              (g !== void 0 && B && (B = g === DR(P)),
              E !== void 0 && B && (B = E === LR(P)),
              T !== void 0 && B && (B = T === FR(P)),
              v !== void 0)
            ) {
              var L;
              B && (B = nr((L = BR(P)) != null ? L : null, P, v, (D) => D));
            }
            return B;
          }
          return !0;
        })
        .filter((P) =>
          i === void 0
            ? !0
            : nr(
                Jl(P, {
                  computedStyleSupportsPseudoElements: Te().computedStyleSupportsPseudoElements,
                }),
                P,
                i,
                (L) => L,
              ),
        )
        .filter((P) =>
          s === void 0
            ? !0
            : nr(
                Hm(P, {
                  computedStyleSupportsPseudoElements: Te().computedStyleSupportsPseudoElements,
                }),
                P,
                s,
                (L) => L,
              ),
        )
        .filter((P) => (n === !1 ? hs(P, { isSubtreeInaccessible: H }) === !1 : !0))
    );
  }, 'queryAllByRole');
function CP(e) {
  var t;
  const r = '*[role~="' + e + '"]',
    n = (t = Mt.roleElements.get(e)) != null ? t : new Set(),
    i = new Set(
      Array.from(n).map((s) => {
        let { name: a } = s;
        return a;
      }),
    );
  return [r].concat(Array.from(i)).join(',');
}
o(CP, 'makeRoleSelector');
var xP = o((e) => {
    let t = '';
    return (
      e === void 0
        ? (t = '')
        : typeof e == 'string'
          ? (t = ' and name "' + e + '"')
          : (t = ' and name `' + e + '`'),
      t
    );
  }, 'getNameHint'),
  uJ = o(function (e, t, r) {
    let { name: n } = r === void 0 ? {} : r;
    return 'Found multiple elements with the role "' + t + '"' + xP(n);
  }, 'getMultipleError$1'),
  dJ = o(function (e, t, r) {
    let { hidden: n = Te().defaultHidden, name: i, description: s } = r === void 0 ? {} : r;
    if (Te()._disableExpensiveErrorDiagnostics) return 'Unable to find role="' + t + '"' + xP(i);
    let a = '';
    Array.from(e.children).forEach((p) => {
      a += ny(p, { hidden: n, includeDescription: s !== void 0 });
    });
    let c;
    a.length === 0
      ? n === !1
        ? (c =
            'There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole')
        : (c = 'There are no available roles.')
      : (c = (
          `
Here are the ` +
          (n === !1 ? 'accessible' : 'available') +
          ` roles:

  ` +
          a
            .replace(
              /\n/g,
              `
  `,
            )
            .replace(
              /\n\s\s\n/g,
              `

`,
            ) +
          `
`
        ).trim());
    let d = '';
    i === void 0
      ? (d = '')
      : typeof i == 'string'
        ? (d = ' and name "' + i + '"')
        : (d = ' and name `' + i + '`');
    let u = '';
    return (
      s === void 0
        ? (u = '')
        : typeof s == 'string'
          ? (u = ' and description "' + s + '"')
          : (u = ' and description `' + s + '`'),
      (
        `
Unable to find an ` +
        (n === !1 ? 'accessible ' : '') +
        'element with the role "' +
        t +
        '"' +
        d +
        u +
        `

` +
        c
      ).trim()
    );
  }, 'getMissingError$1'),
  NP = vt(ld, ld.name, 'queryAll'),
  [IP, MP, qP, jP, kP] = ar(ld, uJ, dJ),
  sy = o(() => Te().testIdAttribute, 'getTestIdAttribute'),
  cd = o(function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    return (sr(t[0]), Yr(sy(), ...t));
  }, 'queryAllByTestId'),
  pJ = o((e, t) => 'Found multiple elements by: [' + sy() + '="' + t + '"]', 'getMultipleError'),
  fJ = o((e, t) => 'Unable to find an element by: [' + sy() + '="' + t + '"]', 'getMissingError'),
  DP = vt(cd, cd.name, 'queryAll'),
  [LP, FP, BP, JP, $P] = ar(cd, pJ, fJ),
  Ta = Object.freeze({
    __proto__: null,
    queryAllByLabelText: QR,
    queryByLabelText: GR,
    getAllByLabelText: YR,
    getByLabelText: XR,
    findAllByLabelText: WR,
    findByLabelText: KR,
    queryByPlaceholderText: eP,
    queryAllByPlaceholderText: ZR,
    getByPlaceholderText: rP,
    getAllByPlaceholderText: tP,
    findAllByPlaceholderText: nP,
    findByPlaceholderText: oP,
    queryByText: sP,
    queryAllByText: iP,
    getByText: lP,
    getAllByText: aP,
    findAllByText: cP,
    findByText: uP,
    queryByDisplayValue: pP,
    queryAllByDisplayValue: dP,
    getByDisplayValue: mP,
    getAllByDisplayValue: fP,
    findAllByDisplayValue: yP,
    findByDisplayValue: hP,
    queryByAltText: bP,
    queryAllByAltText: gP,
    getByAltText: EP,
    getAllByAltText: vP,
    findAllByAltText: TP,
    findByAltText: wP,
    queryByTitle: _P,
    queryAllByTitle: SP,
    getByTitle: PP,
    getAllByTitle: RP,
    findAllByTitle: AP,
    findByTitle: OP,
    queryByRole: IP,
    queryAllByRole: NP,
    getAllByRole: MP,
    getByRole: qP,
    findAllByRole: jP,
    findByRole: kP,
    queryByTestId: LP,
    queryAllByTestId: DP,
    getByTestId: BP,
    getAllByTestId: FP,
    findAllByTestId: JP,
    findByTestId: $P,
  });
function wa(e, t, r) {
  return (
    t === void 0 && (t = Ta),
    r === void 0 && (r = {}),
    Object.keys(t).reduce((n, i) => {
      const s = t[i];
      return ((n[i] = s.bind(null, e)), n);
    }, r)
  );
}
o(wa, 'getQueriesForElement');
var UP = o((e) => !e || (Array.isArray(e) && !e.length), 'isRemoved');
function ud(e) {
  if (UP(e))
    throw new Error(
      'The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.',
    );
}
o(ud, 'initialCheck');
async function VP(e, t) {
  const r = new Error('Timed out in waitForElementToBeRemoved.');
  if (typeof e != 'function') {
    ud(e);
    const i = (Array.isArray(e) ? e : [e]).map((s) => {
      let a = s.parentElement;
      if (a === null) return () => null;
      for (; a.parentElement; ) a = a.parentElement;
      return () => (a.contains(s) ? s : null);
    });
    e = o(() => i.map((s) => s()).filter(Boolean), 'callback');
  }
  return (
    ud(e()),
    Hl(() => {
      let n;
      try {
        n = e();
      } catch (i) {
        if (i.name === 'TestingLibraryElementError') return;
        throw i;
      }
      if (!UP(n)) throw r;
    }, t)
  );
}
o(VP, 'waitForElementToBeRemoved');
var pg = {
    copy: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    cut: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    paste: {
      EventType: 'ClipboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionEnd: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionStart: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    compositionUpdate: {
      EventType: 'CompositionEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    keyDown: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    keyPress: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    keyUp: {
      EventType: 'KeyboardEvent',
      defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 },
    },
    focus: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
    blur: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
    focusIn: {
      EventType: 'FocusEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    focusOut: {
      EventType: 'FocusEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    change: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
    input: { EventType: 'InputEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
    invalid: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !0 } },
    submit: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
    reset: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
    click: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, button: 0, composed: !0 },
    },
    contextMenu: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dblClick: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    drag: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    dragEnd: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
    dragEnter: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dragExit: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    dragLeave: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    dragOver: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    dragStart: {
      EventType: 'DragEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    drop: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    mouseDown: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseEnter: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
    },
    mouseLeave: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
    },
    mouseMove: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseOut: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseOver: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    mouseUp: {
      EventType: 'MouseEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    select: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
    touchCancel: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    touchEnd: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    touchMove: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    touchStart: {
      EventType: 'TouchEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    resize: { EventType: 'UIEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    scroll: { EventType: 'UIEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    wheel: { EventType: 'WheelEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
    abort: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    canPlay: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    canPlayThrough: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    durationChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    emptied: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    encrypted: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    ended: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadedData: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadedMetadata: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    loadStart: { EventType: 'ProgressEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    pause: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    play: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    playing: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    progress: { EventType: 'ProgressEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    rateChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    seeked: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    seeking: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    stalled: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    suspend: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    timeUpdate: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    volumeChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    waiting: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    load: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    error: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    animationStart: { EventType: 'AnimationEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    animationEnd: { EventType: 'AnimationEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    animationIteration: {
      EventType: 'AnimationEvent',
      defaultInit: { bubbles: !0, cancelable: !1 },
    },
    transitionCancel: {
      EventType: 'TransitionEvent',
      defaultInit: { bubbles: !0, cancelable: !1 },
    },
    transitionEnd: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
    transitionRun: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    transitionStart: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    pointerOver: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerEnter: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    pointerDown: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerMove: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerUp: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerCancel: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    pointerOut: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
    },
    pointerLeave: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
    gotPointerCapture: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    lostPointerCapture: {
      EventType: 'PointerEvent',
      defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
    },
    popState: { EventType: 'PopStateEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
    offline: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    online: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
    pageHide: { EventType: 'PageTransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
    pageShow: { EventType: 'PageTransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
  },
  fg = { doubleClick: 'dblClick' };
function fo(e, t) {
  return Te().eventWrapper(() => {
    if (!t) throw new Error('Unable to fire an event - please provide an event object.');
    if (!e)
      throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
    return e.dispatchEvent(t);
  });
}
o(fo, 'fireEvent');
function _i(e, t, r, n) {
  let { EventType: i = 'Event', defaultInit: s = {} } = n === void 0 ? {} : n;
  if (!t) throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
  const a = { ...s, ...r },
    { target: { value: c, files: d, ...u } = {} } = a;
  (c !== void 0 && HP(t, c),
    d !== void 0 &&
      Object.defineProperty(t, 'files', {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: d,
      }),
    Object.assign(t, u));
  const p = Km(t),
    f = p[i] || p.Event;
  let y;
  if (typeof f == 'function') y = new f(e, a);
  else {
    y = p.document.createEvent(i);
    const { bubbles: g, cancelable: T, detail: E, ...v } = a;
    (y.initEvent(e, g, T, E),
      Object.keys(v).forEach((S) => {
        y[S] = v[S];
      }));
  }
  return (
    ['dataTransfer', 'clipboardData'].forEach((g) => {
      const T = a[g];
      typeof T == 'object' &&
        (typeof p.DataTransfer == 'function'
          ? Object.defineProperty(y, g, {
              value: Object.getOwnPropertyNames(T).reduce(
                (E, v) => (Object.defineProperty(E, v, { value: T[v] }), E),
                new p.DataTransfer(),
              ),
            })
          : Object.defineProperty(y, g, { value: T }));
    }),
    y
  );
}
o(_i, 'createEvent');
Object.keys(pg).forEach((e) => {
  const { EventType: t, defaultInit: r } = pg[e],
    n = e.toLowerCase();
  ((_i[e] = (i, s) => _i(n, i, s, { EventType: t, defaultInit: r })),
    (fo[e] = (i, s) => fo(i, _i[e](i, s))));
});
function HP(e, t) {
  const { set: r } = Object.getOwnPropertyDescriptor(e, 'value') || {},
    n = Object.getPrototypeOf(e),
    { set: i } = Object.getOwnPropertyDescriptor(n, 'value') || {};
  if (i && r !== i) i.call(e, t);
  else if (r) r.call(e, t);
  else throw new Error('The given element does not have a value setter');
}
o(HP, 'setNativeValue');
Object.keys(fg).forEach((e) => {
  const t = fg[e];
  fo[e] = function () {
    return fo[t](...arguments);
  };
});
function GP(e) {
  return e.replace(
    /[ \t]*[\n][ \t]*/g,
    `
`,
  );
}
o(GP, 'unindent');
function zP(e) {
  return MB.default.compressToEncodedURIComponent(GP(e));
}
o(zP, 'encode');
function WP(e) {
  return 'https://testing-playground.com/#markup=' + zP(e);
}
o(WP, 'getPlaygroundUrl');
var mJ = o((e, t, r) => (Array.isArray(e) ? e.forEach((n) => td(n, t, r)) : td(e, t, r)), 'debug'),
  yJ = o(function (e) {
    if ((e === void 0 && (e = $l().body), !e || !('innerHTML' in e))) {
      console.log("The element you're providing isn't a valid DOM element.");
      return;
    }
    if (!e.innerHTML) {
      console.log("The provided element doesn't have any children.");
      return;
    }
    const t = WP(e.innerHTML);
    return (
      console.log(
        `Open this URL in your browser

` + t,
      ),
      t
    );
  }, 'logTestingPlaygroundURL'),
  mg = { debug: mJ, logTestingPlaygroundURL: yJ },
  hJ =
    typeof document < 'u' && document.body
      ? wa(document.body, Ta, mg)
      : Object.keys(Ta).reduce(
          (e, t) => (
            (e[t] = () => {
              throw new TypeError(
                'For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error',
              );
            }),
            e
          ),
          mg,
        );
function he(e, t, r) {
  return (e.namespaceURI && e.namespaceURI !== 'http://www.w3.org/1999/xhtml') ||
    ((t = Array.isArray(t) ? t : [t]), !t.includes(e.tagName.toLowerCase()))
    ? !1
    : r
      ? Object.entries(r).every(([n, i]) => e[n] === i)
      : !0;
}
o(he, 'isElementType');
function xt(e) {
  var t;
  if (KP(e) && e.defaultView) return e.defaultView;
  if (!((t = e.ownerDocument) === null || t === void 0) && t.defaultView)
    return e.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${YP(e)}`);
}
o(xt, 'getWindow');
function KP(e) {
  return e.nodeType === 9;
}
o(KP, 'isDocument');
function YP(e) {
  return typeof e == 'function' ? `function ${e.name}` : e === null ? 'null' : String(e);
}
o(YP, 'describe');
function ay(e, t) {
  return new Promise((r, n) => {
    const i = new t();
    ((i.onerror = n),
      (i.onabort = n),
      (i.onload = () => {
        r(String(i.result));
      }),
      i.readAsText(e));
  });
}
o(ay, 'readBlobText');
function zl(e, t) {
  const r = {
    ...t,
    length: t.length,
    item: o((n) => r[n], 'item'),
    [Symbol.iterator]: o(function* () {
      for (let i = 0; i < r.length; i++) yield r[i];
    }, 'nextFile'),
  };
  return (
    (r.constructor = e.FileList),
    e.FileList && Object.setPrototypeOf(r, e.FileList.prototype),
    Object.freeze(r),
    r
  );
}
o(zl, 'createFileList');
function Er(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(Er, '_define_property');
var XP = class {
  getAsFile() {
    return this.file;
  }
  getAsString(t) {
    typeof this.data == 'string' && t(this.data);
  }
  webkitGetAsEntry() {
    throw new Error('not implemented');
  }
  constructor(t, r) {
    (Er(this, 'kind', void 0),
      Er(this, 'type', void 0),
      Er(this, 'file', null),
      Er(this, 'data', void 0),
      typeof t == 'string'
        ? ((this.kind = 'string'), (this.type = String(r)), (this.data = t))
        : ((this.kind = 'file'), (this.type = t.type), (this.file = t)));
  }
};
o(XP, 'DataTransferItemStub');
var QP = XP,
  ZP = class extends Array {
    add(...t) {
      const r = new QP(t[0], t[1]);
      return (this.push(r), r);
    }
    clear() {
      this.splice(0, this.length);
    }
    remove(t) {
      this.splice(t, 1);
    }
  };
o(ZP, 'DataTransferItemListStub');
var gJ = ZP;
function di(e, t) {
  const [r, n] = e.split('/'),
    i = !n || n === '*';
  return (s) => (t ? s.type === (i ? r : e) : i ? s.type.startsWith(`${r}/`) : s.type === r);
}
o(di, 'getTypeMatcher');
function eA(e) {
  var t;
  return new ((t = class {
    getData(r) {
      var n;
      const i =
        (n = this.items.find(di(r, !0))) !== null && n !== void 0 ? n : this.items.find(di(r, !1));
      let s = '';
      return (
        i?.getAsString((a) => {
          s = a;
        }),
        s
      );
    }
    setData(r, n) {
      const i = this.items.findIndex(di(r, !0)),
        s = new QP(n, r);
      i >= 0 ? this.items.splice(i, 1, s) : this.items.push(s);
    }
    clearData(r) {
      if (r) {
        const n = this.items.findIndex(di(r, !0));
        n >= 0 && this.items.remove(n);
      } else this.items.clear();
    }
    get types() {
      const r = [];
      return (
        this.files.length && r.push('Files'),
        this.items.forEach((n) => r.push(n.type)),
        Object.freeze(r),
        r
      );
    }
    setDragImage() {}
    constructor() {
      (Er(this, 'dropEffect', 'none'),
        Er(this, 'effectAllowed', 'uninitialized'),
        Er(this, 'items', new gJ()),
        Er(this, 'files', zl(e, [])));
    }
  }),
  o(t, 'DataTransferStub'),
  t)();
}
o(eA, 'createDataTransferStub');
function Wl(e, t = []) {
  const r = typeof e.DataTransfer > 'u' ? eA(e) : new e.DataTransfer();
  return (Object.defineProperty(r, 'files', { get: o(() => zl(e, t), 'get') }), r);
}
o(Wl, 'createDataTransfer');
async function tA(e, t) {
  return t.kind === 'file'
    ? t.getAsFile()
    : new e.Blob([await new Promise((r) => t.getAsString(r))], { type: t.type });
}
o(tA, 'getBlobFromDataTransferItem');
function ly(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(ly, '_define_property');
function cy(e, ...t) {
  var r;
  const n = Object.fromEntries(
    t.map((i) => [typeof i == 'string' ? 'text/plain' : i.type, Promise.resolve(i)]),
  );
  return typeof e.ClipboardItem < 'u'
    ? new e.ClipboardItem(n)
    : new ((r = class {
        get types() {
          return Array.from(Object.keys(this.data));
        }
        async getType(i) {
          const s = await this.data[i];
          if (!s) throw new Error(`${i} is not one of the available MIME types on this item.`);
          return s instanceof e.Blob ? s : new e.Blob([s], { type: i });
        }
        constructor(i) {
          (ly(this, 'data', void 0), (this.data = i));
        }
      }),
      o(r, 'ClipboardItem'),
      r)(n);
}
o(cy, 'createClipboardItem');
var mo = Symbol('Manage ClipboardSub');
function dd(e, t) {
  var r;
  return Object.assign(
    new ((r = class extends e.EventTarget {
      async read() {
        return Array.from(this.items);
      }
      async readText() {
        let n = '';
        for (const i of this.items) {
          const s = i.types.includes('text/plain')
            ? 'text/plain'
            : i.types.find((a) => a.startsWith('text/'));
          s && (n += await i.getType(s).then((a) => ay(a, e.FileReader)));
        }
        return n;
      }
      async write(n) {
        this.items = n;
      }
      async writeText(n) {
        this.items = [cy(e, n)];
      }
      constructor(...n) {
        (super(...n), ly(this, 'items', []));
      }
    }),
    o(r, 'Clipboard'),
    r)(),
    { [mo]: t },
  );
}
o(dd, 'createClipboardStub');
function Kl(e) {
  return !!e?.[mo];
}
o(Kl, 'isClipboardStub');
function rA(e) {
  if (Kl(e.navigator.clipboard)) return e.navigator.clipboard[mo];
  const t = Object.getOwnPropertyDescriptor(e.navigator, 'clipboard');
  let r;
  const n = {
    resetClipboardStub: o(() => {
      r = dd(e, n);
    }, 'resetClipboardStub'),
    detachClipboardStub: o(() => {
      t
        ? Object.defineProperty(e.navigator, 'clipboard', t)
        : Object.defineProperty(e.navigator, 'clipboard', { value: void 0, configurable: !0 });
    }, 'detachClipboardStub'),
  };
  return (
    (r = dd(e, n)),
    Object.defineProperty(e.navigator, 'clipboard', { get: o(() => r, 'get'), configurable: !0 }),
    r[mo]
  );
}
o(rA, 'attachClipboardStubToView');
function nA(e) {
  Kl(e.navigator.clipboard) && e.navigator.clipboard[mo].resetClipboardStub();
}
o(nA, 'resetClipboardStubOnView');
function oA(e) {
  Kl(e.navigator.clipboard) && e.navigator.clipboard[mo].detachClipboardStub();
}
o(oA, 'detachClipboardStubFromView');
async function iA(e) {
  const t = e.defaultView,
    r = t?.navigator.clipboard,
    n = r && (await r.read());
  if (!n) throw new Error('The Clipboard API is unavailable.');
  const i = Wl(t);
  for (const s of n)
    for (const a of s.types) i.setData(a, await s.getType(a).then((c) => ay(c, t.FileReader)));
  return i;
}
o(iA, 'readDataTransferFromClipboard');
async function uy(e, t) {
  const r = xt(e),
    n = r.navigator.clipboard,
    i = [];
  for (let a = 0; a < t.items.length; a++) {
    const c = t.items[a],
      d = await tA(r, c);
    i.push(cy(r, d));
  }
  if (
    !(
      n &&
      (await n.write(i).then(
        () => !0,
        () => !1,
      ))
    )
  )
    throw new Error('The Clipboard API is unavailable.');
}
o(uy, 'writeDataTransferToClipboard');
var Sa = globalThis;
typeof Sa.afterEach == 'function' &&
  Sa.afterEach(() => {
    typeof globalThis.window < 'u' && nA(globalThis.window);
  });
typeof Sa.afterAll == 'function' &&
  Sa.afterAll(() => {
    typeof globalThis.window < 'u' && oA(globalThis.window);
  });
var sA = [
  'input:not([type=hidden]):not([disabled])',
  'button:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  '[contenteditable=""]',
  '[contenteditable="true"]',
  'a[href]',
  '[tabindex]:not([disabled])',
].join(', ');
function Yl(e) {
  return e.matches(sA);
}
o(Yl, 'isFocusable');
function aA(e) {
  return new e.constructor(e.type, e);
}
o(aA, 'cloneEvent');
function or(e) {
  for (let r = e; r; r = r.parentElement)
    if (he(r, ['button', 'input', 'select', 'textarea', 'optgroup', 'option'])) {
      if (r.hasAttribute('disabled')) return !0;
    } else if (he(r, 'fieldset')) {
      var t;
      if (
        r.hasAttribute('disabled') &&
        !(!((t = r.querySelector(':scope > legend')) === null || t === void 0) && t.contains(e))
      )
        return !0;
    } else if (
      r.tagName.includes('-') &&
      r.constructor.formAssociated &&
      r.hasAttribute('disabled')
    )
      return !0;
  return !1;
}
o(or, 'isDisabled');
function xo(e) {
  const t = e.activeElement;
  return t?.shadowRoot
    ? xo(t.shadowRoot)
    : or(t)
      ? e.ownerDocument
        ? e.ownerDocument.body
        : e.body
      : t;
}
o(xo, 'getActiveElement');
function ks(e) {
  var t;
  return (t = xo(e)) !== null && t !== void 0 ? t : e.body;
}
o(ks, 'getActiveElementOrBody');
function lA(e, t) {
  let r = e;
  do {
    if (t(r)) return r;
    r = r.parentElement;
  } while (r && r !== e.ownerDocument.body);
}
o(lA, 'findClosest');
function Vr(e) {
  return (
    e.hasAttribute('contenteditable') &&
    (e.getAttribute('contenteditable') == 'true' || e.getAttribute('contenteditable') == '')
  );
}
o(Vr, 'isContentEditable');
function yo(e) {
  const t = cA(e);
  return t && (t.closest('[contenteditable=""]') || t.closest('[contenteditable="true"]'));
}
o(yo, 'getContentEditable');
function cA(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
o(cA, 'getElement');
var uA = (function (e) {
  return (
    (e.button = 'button'),
    (e.color = 'color'),
    (e.file = 'file'),
    (e.image = 'image'),
    (e.reset = 'reset'),
    (e.submit = 'submit'),
    (e.checkbox = 'checkbox'),
    (e.radio = 'radio'),
    e
  );
})(uA || {});
function dy(e) {
  return he(e, 'button') || (he(e, 'input') && e.type in uA);
}
o(dy, 'isClickableInput');
function wn(e) {
  return (py(e) && !e.readOnly) || Vr(e);
}
o(wn, 'isEditable');
var dA = (function (e) {
  return (
    (e.text = 'text'),
    (e.date = 'date'),
    (e['datetime-local'] = 'datetime-local'),
    (e.email = 'email'),
    (e.month = 'month'),
    (e.number = 'number'),
    (e.password = 'password'),
    (e.search = 'search'),
    (e.tel = 'tel'),
    (e.time = 'time'),
    (e.url = 'url'),
    (e.week = 'week'),
    e
  );
})(dA || {});
function py(e) {
  return he(e, 'textarea') || (he(e, 'input') && e.type in dA);
}
o(py, 'isEditableInputOrTextArea');
function zt(e) {
  return fy(e) && py(e);
}
o(zt, 'hasOwnSelection');
function pA(e) {
  return fy(e) && dy(e);
}
o(pA, 'hasNoSelection');
function fy(e) {
  return e.nodeType === 1;
}
o(fy, 'isElement');
function fA(e) {
  const t = e.ownerDocument.getSelection();
  if (t?.focusNode && zt(e)) {
    const n = yo(t.focusNode);
    if (n) {
      if (!t.isCollapsed) {
        var r;
        const i =
          ((r = n.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === 3
            ? n.firstChild
            : n;
        t.setBaseAndExtent(i, 0, i, 0);
      }
    } else t.setBaseAndExtent(e, 0, e, 0);
  }
}
o(fA, 'updateSelectionOnFocus');
function Sn(e, t) {
  return Te().eventWrapper(e);
}
o(Sn, 'wrapEvent');
function Rr(e) {
  const t = lA(e, Yl),
    r = xo(e.ownerDocument);
  (t ?? e.ownerDocument.body) !== r &&
    (Sn(t ? () => t.focus() : () => r?.blur()), fA(t ?? e.ownerDocument.body));
}
o(Rr, 'focusElement');
function mA(e) {
  !Yl(e) || !(xo(e.ownerDocument) === e) || Sn(() => e.blur());
}
o(mA, 'blurElement');
var Hr = {};
Hr.click = (e, t, r) => {
  const n = t.closest('button,input,label,select,textarea'),
    i = n && he(n, 'label') && n.control;
  if (i && i !== t)
    return () => {
      Yl(i) && (Rr(i), r.dispatchEvent(i, aA(e)));
    };
  if (he(t, 'input', { type: 'file' }))
    return () => {
      (mA(t), t.dispatchEvent(new (xt(t).Event)('fileDialog')), Rr(t));
    };
};
var ho = Symbol('Displayed value in UI'),
  Tr = Symbol('Displayed selection in UI'),
  _a = Symbol('Initial value to compare on blur');
function yA(e) {
  return typeof e == 'object' && ho in e;
}
o(yA, 'isUIValue');
function hA(e) {
  return !!e && typeof e == 'object' && Tr in e;
}
o(hA, 'isUISelectionStart');
function gA(e, t) {
  (e[_a] === void 0 && (e[_a] = e.value),
    (e[ho] = t),
    (e.value = Object.assign(new String(t), { [ho]: !0 })));
}
o(gA, 'setUIValue');
function Wt(e) {
  return e[ho] === void 0 ? e.value : String(e[ho]);
}
o(Wt, 'getUIValue');
function Xl(e) {
  e[ho] = void 0;
}
o(Xl, 'setUIValueClean');
function my(e) {
  e[_a] = void 0;
}
o(my, 'clearInitialValue');
function bA(e) {
  return e[_a];
}
o(bA, 'getInitialValue');
function vA(e, t) {
  e[Tr] = t;
}
o(vA, 'setUISelectionRaw');
function qn(e, { focusOffset: t, anchorOffset: r = t }, n = 'replace') {
  const i = Wt(e).length,
    s = o((f) => Math.max(0, Math.min(i, f)), 'sanitizeOffset'),
    a = n === 'replace' || e[Tr] === void 0 ? s(r) : e[Tr].anchorOffset,
    c = s(t),
    d = Math.min(a, c),
    u = Math.max(a, c);
  if (
    ((e[Tr] = { anchorOffset: a, focusOffset: c }), e.selectionStart === d && e.selectionEnd === u)
  )
    return;
  const p = Object.assign(new Number(d), { [Tr]: !0 });
  try {
    e.setSelectionRange(p, u);
  } catch {}
}
o(qn, 'setUISelection');
function go(e) {
  var t, r, n;
  const i =
    (n = e[Tr]) !== null && n !== void 0
      ? n
      : {
          anchorOffset: (t = e.selectionStart) !== null && t !== void 0 ? t : 0,
          focusOffset: (r = e.selectionEnd) !== null && r !== void 0 ? r : 0,
        };
  return {
    ...i,
    startOffset: Math.min(i.anchorOffset, i.focusOffset),
    endOffset: Math.max(i.anchorOffset, i.focusOffset),
  };
}
o(go, 'getUISelection');
function EA(e) {
  return !!e[Tr];
}
o(EA, 'hasUISelection');
function Ri(e) {
  e[Tr] = void 0;
}
o(Ri, 'setUISelectionClean');
var Ra = globalThis.parseInt;
function TA(e) {
  const t = e.replace(/\D/g, '');
  if (t.length < 2) return e;
  const r = Ra(t[0], 10),
    n = Ra(t[1], 10);
  if (r >= 3 || (r === 2 && n >= 4)) {
    let i;
    return (r >= 3 ? (i = 1) : (i = 2), pd(t, i));
  }
  return e.length === 2 ? e : pd(t, 2);
}
o(TA, 'buildTimeValue');
function pd(e, t) {
  const r = e.slice(0, t),
    n = Math.min(Ra(r, 10), 23),
    i = e.slice(t),
    s = Ra(i, 10),
    a = Math.min(s, 59);
  return `${n.toString().padStart(2, '0')}:${a.toString().padStart(2, '0')}`;
}
o(pd, 'build');
function yy(e, t) {
  const r = e.cloneNode();
  return ((r.value = t), r.value === t);
}
o(yy, 'isValidDateOrTimeValue');
var wA = (function (e) {
  return (
    (e.email = 'email'),
    (e.password = 'password'),
    (e.search = 'search'),
    (e.telephone = 'telephone'),
    (e.text = 'text'),
    (e.url = 'url'),
    e
  );
})(wA || {});
function SA(e) {
  var t;
  const r = (t = e.getAttribute('maxlength')) !== null && t !== void 0 ? t : '';
  return /^\d+$/.test(r) && Number(r) >= 0 ? Number(r) : void 0;
}
o(SA, 'getMaxLength');
function _A(e) {
  return he(e, 'textarea') || (he(e, 'input') && e.type in wA);
}
o(_A, 'supportsMaxLength');
function hy(e, t, r, n) {
  if (Pi(e) && t + r >= 0 && t + r <= e.nodeValue.length) return { node: e, offset: t + r };
  const i = fd(e, t, r);
  if (i) {
    if (Pi(i))
      return {
        node: i,
        offset: r > 0 ? Math.min(1, i.nodeValue.length) : Math.max(i.nodeValue.length - 1, 0),
      };
    if (he(i, 'br')) {
      const s = fd(i, void 0, r);
      return s
        ? Pi(s)
          ? { node: s, offset: r > 0 ? 0 : s.nodeValue.length }
          : r < 0 && he(s, 'br')
            ? { node: i.parentNode, offset: pi(i) }
            : { node: s.parentNode, offset: pi(s) + (r > 0 ? 0 : 1) }
        : r < 0 && n === 'deleteContentBackward'
          ? { node: i.parentNode, offset: pi(i) }
          : void 0;
    } else return { node: i.parentNode, offset: pi(i) + (r > 0 ? 1 : 0) };
  }
}
o(hy, 'getNextCursorPosition');
function fd(e, t, r) {
  const n = Number(t) + (r < 0 ? -1 : 0);
  return (
    t !== void 0 && Ql(e) && n >= 0 && n < e.children.length && (e = e.children[n]),
    PA(e, r === 1 ? 'next' : 'previous', RA)
  );
}
o(fd, 'getNextCharacterContentNode');
function RA(e) {
  if (Pi(e)) return !0;
  if (Ql(e)) {
    if (he(e, ['input', 'textarea'])) return e.type !== 'hidden';
    if (he(e, 'br')) return !0;
  }
  return !1;
}
o(RA, 'isTreatedAsCharacterContent');
function pi(e) {
  let t = 0;
  for (; e.previousSibling; ) (t++, (e = e.previousSibling));
  return t;
}
o(pi, 'getOffset');
function Ql(e) {
  return e.nodeType === 1;
}
o(Ql, 'isElement');
function Pi(e) {
  return e.nodeType === 3;
}
o(Pi, 'isTextNode');
function PA(e, t, r) {
  for (;;) {
    var n;
    const i = e[`${t}Sibling`];
    if (i) {
      if (((e = AA(i, t === 'next' ? 'first' : 'last')), r(e))) return e;
    } else if (
      e.parentNode &&
      (!Ql(e.parentNode) ||
        (!Vr(e.parentNode) &&
          e.parentNode !== ((n = e.ownerDocument) === null || n === void 0 ? void 0 : n.body)))
    )
      e = e.parentNode;
    else break;
  }
}
o(PA, 'walkNodes');
function AA(e, t) {
  for (; e.hasChildNodes(); ) e = e[`${t}Child`];
  return e;
}
o(AA, 'getDescendant');
var zi = Symbol('Track programmatic changes for React workaround');
function OA(e) {
  return (
    Object.getOwnPropertyNames(e).some((t) => t.startsWith('__react')) && xt(e).REACT_VERSION === 17
  );
}
o(OA, 'isReact17Element');
function CA(e) {
  OA(e) && (e[zi] = { previousValue: String(e.value), tracked: [] });
}
o(CA, 'startTrackValue');
function xA(e, t) {
  var r, n;
  ((n = e[zi]) === null || n === void 0 || (r = n.tracked) === null || r === void 0 || r.push(t),
    e[zi] || (Xl(e), qn(e, { focusOffset: t.length })));
}
o(xA, 'trackOrSetValue');
function NA(e, t) {
  var r;
  const n = e[zi];
  if (((e[zi] = void 0), !(!(n == null || (r = n.tracked) === null || r === void 0) && r.length)))
    return;
  const i = n.tracked.length === 2 && n.tracked[0] === n.previousValue && n.tracked[1] === e.value;
  (i || Xl(e), EA(e) && qn(e, { focusOffset: i ? t : e.value.length }));
}
o(NA, 'commitValueAfterInput');
function gy(e) {
  const t = IA(e);
  if (t && zt(t)) return { type: 'input', selection: go(t) };
  const r = t?.ownerDocument.getSelection();
  return {
    type: yo(e) && r?.anchorNode && yo(r.anchorNode) ? 'contenteditable' : 'default',
    selection: r,
  };
}
o(gy, 'getTargetTypeAndSelection');
function IA(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
o(IA, 'getElement');
function MA(e) {
  const t = gy(e);
  if (t.type === 'input') return t.selection;
  if (t.type === 'contenteditable') {
    var r;
    return (r = t.selection) === null || r === void 0 ? void 0 : r.getRangeAt(0);
  }
}
o(MA, 'getInputRange');
function Gr({ focusNode: e, focusOffset: t, anchorNode: r = e, anchorOffset: n = t }) {
  var i, s;
  if (gy(e).type === 'input') return qn(e, { anchorOffset: n, focusOffset: t });
  (s = r.ownerDocument) === null ||
    s === void 0 ||
    (i = s.getSelection()) === null ||
    i === void 0 ||
    i.setBaseAndExtent(r, n, e, t);
}
o(Gr, 'setSelection');
function by(e) {
  return he(e, 'input') && ['date', 'time'].includes(e.type);
}
o(by, 'isDateOrTime');
function _n(e, t, r, n = 'insertText') {
  const i = MA(t);
  i &&
    ((!by(t) && !e.dispatchUIEvent(t, 'beforeinput', { inputType: n, data: r })) ||
      ('startContainer' in i ? qA(e, t, i, r, n) : jA(e, t, i, r, n)));
}
o(_n, 'input');
function qA(e, t, r, n, i) {
  let s = !1;
  if (!r.collapsed) ((s = !0), r.deleteContents());
  else if (['deleteContentBackward', 'deleteContentForward'].includes(i)) {
    const a = hy(r.startContainer, r.startOffset, i === 'deleteContentBackward' ? -1 : 1, i);
    if (a) {
      s = !0;
      const c = r.cloneRange();
      (c.comparePoint(a.node, a.offset) < 0
        ? c.setStart(a.node, a.offset)
        : c.setEnd(a.node, a.offset),
        c.deleteContents());
    }
  }
  if (n)
    if (r.endContainer.nodeType === 3) {
      const a = r.endOffset;
      (r.endContainer.insertData(a, n),
        r.setStart(r.endContainer, a + n.length),
        r.setEnd(r.endContainer, a + n.length));
    } else {
      const a = t.ownerDocument.createTextNode(n);
      (r.insertNode(a), r.setStart(a, n.length), r.setEnd(a, n.length));
    }
  (s || n) && e.dispatchUIEvent(t, 'input', { inputType: i });
}
o(qA, 'editContenteditable');
function jA(e, t, r, n, i) {
  let s = n;
  if (_A(t)) {
    const u = SA(t);
    if (u !== void 0 && n.length > 0) {
      const p = u - t.value.length;
      if (p > 0) s = n.substring(0, p);
      else return;
    }
  }
  const { newValue: a, newOffset: c, oldValue: d } = kA(s, t, r, i);
  (a === d && c === r.startOffset && c === r.endOffset) ||
    (he(t, 'input', { type: 'number' }) && !DA(a)) ||
    (gA(t, a),
    Gr({ focusNode: t, anchorOffset: c, focusOffset: c }),
    by(t)
      ? yy(t, a) && (md(e, t, c, {}), e.dispatchUIEvent(t, 'change'), my(t))
      : md(e, t, c, { data: n, inputType: i }));
}
o(jA, 'editInputElement');
function kA(e, t, { startOffset: r, endOffset: n }, i) {
  const s = Wt(t),
    a = Math.max(0, r === n && i === 'deleteContentBackward' ? r - 1 : r),
    c = s.substring(0, a),
    d = Math.min(s.length, r === n && i === 'deleteContentForward' ? r + 1 : n),
    u = s.substring(d, s.length);
  let p = `${c}${e}${u}`,
    f = a + e.length;
  if (he(t, 'input', { type: 'time' })) {
    const y = TA(p);
    y !== '' && yy(t, y) && ((p = y), (f = y.length));
  }
  return { oldValue: s, newValue: p, newOffset: f };
}
o(kA, 'calculateNewValue');
function md(e, t, r, n) {
  (e.dispatchUIEvent(t, 'input', n), NA(t, r));
}
o(md, 'commitInput');
function DA(e) {
  var t, r;
  const n = e.split('e', 2);
  return !(
    /[^\d.\-e]/.test(e) ||
    Number((t = e.match(/-/g)) === null || t === void 0 ? void 0 : t.length) > 2 ||
    Number((r = e.match(/\./g)) === null || r === void 0 ? void 0 : r.length) > 1 ||
    (n[1] && !/^-?\d*$/.test(n[1]))
  );
}
o(DA, 'isValidNumberInput');
Hr.cut = (e, t, r) => () => {
  wn(t) && _n(r, t, '', 'deleteByCut');
};
function LA(e) {
  return e ? (Vr(e) ? e.textContent : Wt(e)) : null;
}
o(LA, 'getValueOrTextContent');
function FA(e) {
  const t = xt(e);
  for (let r = e; r?.ownerDocument; r = r.parentElement) {
    const { display: n, visibility: i } = t.getComputedStyle(r);
    if (n === 'none' || i === 'hidden') return !1;
  }
  return !0;
}
o(FA, 'isVisible');
function BA(e, t) {
  const r = e.ownerDocument,
    n = r.querySelectorAll(sA),
    i = Array.from(n).filter((d) => d === e || !(Number(d.getAttribute('tabindex')) < 0 || or(d)));
  Number(e.getAttribute('tabindex')) >= 0 &&
    i.sort((d, u) => {
      const p = Number(d.getAttribute('tabindex')),
        f = Number(u.getAttribute('tabindex'));
      return p === f ? 0 : p === 0 ? 1 : f === 0 ? -1 : p - f;
    });
  const s = {};
  let a = [r.body];
  const c = he(e, 'input', { type: 'radio' }) ? e.name : void 0;
  i.forEach((d) => {
    const u = d;
    if (he(u, 'input', { type: 'radio' }) && u.name) {
      if (u === e) {
        a.push(u);
        return;
      } else if (u.name === c) return;
      if (u.checked) {
        ((a = a.filter((p) => !he(p, 'input', { type: 'radio', name: u.name }))),
          a.push(u),
          (s[u.name] = u));
        return;
      }
      if (typeof s[u.name] < 'u') return;
    }
    a.push(u);
  });
  for (let d = a.findIndex((u) => u === e); ; )
    if (
      ((d += t ? -1 : 1),
      d === a.length ? (d = 0) : d === -1 && (d = a.length - 1),
      a[d] === e || a[d] === r.body || FA(a[d]))
    )
      return a[d];
}
o(BA, 'getTabDestination');
function yd(e, t) {
  if (zt(e)) {
    const r = go(e);
    Gr({
      focusNode: e,
      focusOffset:
        r.startOffset === r.endOffset ? r.focusOffset + t : t < 0 ? r.startOffset : r.endOffset,
    });
  } else {
    const r = e.ownerDocument.getSelection();
    if (!r?.focusNode) return;
    if (r.isCollapsed) {
      const n = hy(r.focusNode, r.focusOffset, t);
      n && Gr({ focusNode: n.node, focusOffset: n.offset });
    } else r[t < 0 ? 'collapseToStart' : 'collapseToEnd']();
  }
}
o(yd, 'moveSelection');
function vy(e) {
  if (zt(e)) return Gr({ focusNode: e, anchorOffset: 0, focusOffset: Wt(e).length });
  var t;
  const r = (t = yo(e)) !== null && t !== void 0 ? t : e.ownerDocument.body;
  Gr({ focusNode: r, anchorOffset: 0, focusOffset: r.childNodes.length });
}
o(vy, 'selectAll');
function JA(e) {
  if (zt(e)) return go(e).startOffset === 0 && go(e).endOffset === Wt(e).length;
  var t;
  const r = (t = yo(e)) !== null && t !== void 0 ? t : e.ownerDocument.body,
    n = e.ownerDocument.getSelection();
  return (
    n?.anchorNode === r &&
    n.focusNode === r &&
    n.anchorOffset === 0 &&
    n.focusOffset === r.childNodes.length
  );
}
o(JA, 'isAllSelected');
function Un(e, t, r) {
  var n;
  if (zt(e)) return Gr({ focusNode: e, anchorOffset: t, focusOffset: r });
  if (Vr(e) && ((n = e.firstChild) === null || n === void 0 ? void 0 : n.nodeType) === 3)
    return Gr({ focusNode: e.firstChild, anchorOffset: t, focusOffset: r });
  throw new Error('Not implemented. The result of this interaction is unreliable.');
}
o(Un, 'setSelectionRange');
function fi(e, t, r) {
  const n = xt(t),
    i = Array.from(
      t.ownerDocument.querySelectorAll(
        t.name
          ? `input[type="radio"][name="${n.CSS.escape(t.name)}"]`
          : 'input[type="radio"][name=""], input[type="radio"]:not([name])',
      ),
    );
  for (let s = i.findIndex((a) => a === t) + r; ; s += r) {
    if ((i[s] || (s = r > 0 ? 0 : i.length - 1), i[s] === t)) return;
    if (!or(i[s])) {
      (Rr(i[s]), e.dispatchUIEvent(i[s], 'click'));
      return;
    }
  }
}
o(fi, 'walkRadio');
Hr.keydown = (e, t, r) => {
  var n, i;
  return (i = (n = yg[e.key]) === null || n === void 0 ? void 0 : n.call(yg, e, t, r)) !== null &&
    i !== void 0
    ? i
    : bJ(e, t, r);
};
var yg = {
    ArrowDown: o((e, t, r) => {
      if (he(t, 'input', { type: 'radio' })) return () => fi(r, t, 1);
    }, 'ArrowDown'),
    ArrowLeft: o(
      (e, t, r) => (he(t, 'input', { type: 'radio' }) ? () => fi(r, t, -1) : () => yd(t, -1)),
      'ArrowLeft',
    ),
    ArrowRight: o(
      (e, t, r) => (he(t, 'input', { type: 'radio' }) ? () => fi(r, t, 1) : () => yd(t, 1)),
      'ArrowRight',
    ),
    ArrowUp: o((e, t, r) => {
      if (he(t, 'input', { type: 'radio' })) return () => fi(r, t, -1);
    }, 'ArrowUp'),
    Backspace: o((e, t, r) => {
      if (wn(t))
        return () => {
          _n(r, t, '', 'deleteContentBackward');
        };
    }, 'Backspace'),
    Delete: o((e, t, r) => {
      if (wn(t))
        return () => {
          _n(r, t, '', 'deleteContentForward');
        };
    }, 'Delete'),
    End: o((e, t) => {
      if (he(t, ['input', 'textarea']) || Vr(t))
        return () => {
          var r, n;
          const i =
            (n = (r = LA(t)) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0
              ? n
              : 0;
          Un(t, i, i);
        };
    }, 'End'),
    Home: o((e, t) => {
      if (he(t, ['input', 'textarea']) || Vr(t))
        return () => {
          Un(t, 0, 0);
        };
    }, 'Home'),
    PageDown: o((e, t) => {
      if (he(t, ['input']))
        return () => {
          const r = Wt(t).length;
          Un(t, r, r);
        };
    }, 'PageDown'),
    PageUp: o((e, t) => {
      if (he(t, ['input']))
        return () => {
          Un(t, 0, 0);
        };
    }, 'PageUp'),
    Tab: o(
      (e, t, r) => () => {
        const n = BA(t, r.system.keyboard.modifiers.Shift);
        (Rr(n), zt(n) && qn(n, { anchorOffset: 0, focusOffset: n.value.length }));
      },
      'Tab',
    ),
  },
  bJ = o((e, t, r) => {
    if (e.code === 'KeyA' && r.system.keyboard.modifiers.Control) return () => vy(t);
  }, 'combinationBehavior');
Hr.keypress = (e, t, r) => {
  if (e.key === 'Enter') {
    if (he(t, 'button') || (he(t, 'input') && vJ.includes(t.type)) || (he(t, 'a') && t.href))
      return () => {
        r.dispatchUIEvent(t, 'click');
      };
    if (he(t, 'input')) {
      const n = t.form,
        i = n?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return i
        ? () => r.dispatchUIEvent(i, 'click')
        : n && EJ.includes(t.type) && n.querySelectorAll('input').length === 1
          ? () => r.dispatchUIEvent(n, 'submit')
          : void 0;
    }
  }
  if (wn(t)) {
    const n =
        e.key === 'Enter'
          ? Vr(t) && !r.system.keyboard.modifiers.Shift
            ? 'insertParagraph'
            : 'insertLineBreak'
          : 'insertText',
      i =
        e.key === 'Enter'
          ? `
`
          : e.key;
    return () => _n(r, t, i, n);
  }
};
var vJ = ['button', 'color', 'file', 'image', 'reset', 'submit'],
  EJ = ['email', 'month', 'password', 'search', 'tel', 'text', 'url', 'week'];
Hr.keyup = (e, t, r) => {
  var n;
  return (n = hg[e.key]) === null || n === void 0 ? void 0 : n.call(hg, e, t, r);
};
var hg = {
  ' ': o((e, t, r) => {
    if (dy(t)) return () => r.dispatchUIEvent(t, 'click');
  }, ' '),
};
Hr.paste = (e, t, r) => {
  if (wn(t))
    return () => {
      var n;
      const i = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.getData('text');
      i && _n(r, t, i, 'insertFromPaste');
    };
};
var $A = {
  auxclick: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  beforeinput: {
    EventType: 'InputEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  blur: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
  click: { EventType: 'PointerEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  contextmenu: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  copy: { EventType: 'ClipboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  change: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
  cut: { EventType: 'ClipboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  dblclick: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  focus: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
  focusin: { EventType: 'FocusEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  focusout: { EventType: 'FocusEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  keydown: {
    EventType: 'KeyboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  keypress: {
    EventType: 'KeyboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  keyup: { EventType: 'KeyboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  paste: {
    EventType: 'ClipboardEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  input: { EventType: 'InputEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
  mousedown: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseenter: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
  },
  mouseleave: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !1, cancelable: !1, composed: !0 },
  },
  mousemove: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseout: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  mouseover: {
    EventType: 'MouseEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  mouseup: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
  pointerover: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerenter: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
  pointerdown: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointermove: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerup: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointercancel: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !1, composed: !0 },
  },
  pointerout: {
    EventType: 'PointerEvent',
    defaultInit: { bubbles: !0, cancelable: !0, composed: !0 },
  },
  pointerleave: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
  submit: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
};
function Ey(e) {
  return $A[e].EventType;
}
o(Ey, 'getEventClass');
var TJ = ['MouseEvent', 'PointerEvent'];
function UA(e) {
  return TJ.includes(Ey(e));
}
o(UA, 'isMouseEvent');
function VA(e) {
  return Ey(e) === 'KeyboardEvent';
}
o(VA, 'isKeyboardEvent');
var wJ = {
  ClipboardEvent: [GA],
  Event: [],
  FocusEvent: [Fn, zA],
  InputEvent: [Fn, WA],
  MouseEvent: [Fn, Ds, hd],
  PointerEvent: [Fn, Ds, hd, YA],
  KeyboardEvent: [Fn, Ds, KA],
};
function Ty(e, t, r) {
  const n = xt(t),
    { EventType: i, defaultInit: s } = $A[e],
    a = new (HA(n)[i])(e, s);
  return (wJ[i].forEach((c) => c(a, r ?? {})), a);
}
o(Ty, 'createEvent');
function HA(e) {
  var t, r, n, i, s, a, c, d, u, p, f, y, h, g, T, E;
  const v = (E = e.Event) !== null && E !== void 0 ? E : ((t = class {}), o(t, 'Event'), t);
  var S;
  const A =
    (S = e.AnimationEvent) !== null && S !== void 0
      ? S
      : ((r = class extends v {}), o(r, 'AnimationEvent'), r);
  var N;
  const j =
    (N = e.ClipboardEvent) !== null && N !== void 0
      ? N
      : ((n = class extends v {}), o(n, 'ClipboardEvent'), n);
  var C;
  const R =
    (C = e.PopStateEvent) !== null && C !== void 0
      ? C
      : ((i = class extends v {}), o(i, 'PopStateEvent'), i);
  var w;
  const _ =
    (w = e.ProgressEvent) !== null && w !== void 0
      ? w
      : ((s = class extends v {}), o(s, 'ProgressEvent'), s);
  var k;
  const I =
    (k = e.TransitionEvent) !== null && k !== void 0
      ? k
      : ((a = class extends v {}), o(a, 'TransitionEvent'), a);
  var V;
  const H =
    (V = e.UIEvent) !== null && V !== void 0 ? V : ((c = class extends v {}), o(c, 'UIEvent'), c);
  var P;
  const L =
    (P = e.CompositionEvent) !== null && P !== void 0
      ? P
      : ((d = class extends H {}), o(d, 'CompositionEvent'), d);
  var B;
  const D =
    (B = e.FocusEvent) !== null && B !== void 0
      ? B
      : ((u = class extends H {}), o(u, 'FocusEvent'), u);
  var K;
  const X =
    (K = e.InputEvent) !== null && K !== void 0
      ? K
      : ((p = class extends H {}), o(p, 'InputEvent'), p);
  var ie;
  const se =
    (ie = e.KeyboardEvent) !== null && ie !== void 0
      ? ie
      : ((f = class extends H {}), o(f, 'KeyboardEvent'), f);
  var W;
  const ae =
    (W = e.MouseEvent) !== null && W !== void 0
      ? W
      : ((y = class extends H {}), o(y, 'MouseEvent'), y);
  var be;
  const ue =
    (be = e.DragEvent) !== null && be !== void 0
      ? be
      : ((h = class extends ae {}), o(h, 'DragEvent'), h);
  var ee;
  const Ae =
    (ee = e.PointerEvent) !== null && ee !== void 0
      ? ee
      : ((g = class extends ae {}), o(g, 'PointerEvent'), g);
  var Oe;
  const He =
    (Oe = e.TouchEvent) !== null && Oe !== void 0
      ? Oe
      : ((T = class extends H {}), o(T, 'TouchEvent'), T);
  return {
    Event: v,
    AnimationEvent: A,
    ClipboardEvent: j,
    PopStateEvent: R,
    ProgressEvent: _,
    TransitionEvent: I,
    UIEvent: H,
    CompositionEvent: L,
    FocusEvent: D,
    InputEvent: X,
    KeyboardEvent: se,
    MouseEvent: ae,
    DragEvent: ue,
    PointerEvent: Ae,
    TouchEvent: He,
  };
}
o(HA, 'getEventConstructors');
function Or(e, t) {
  for (const [r, n] of Object.entries(t))
    Object.defineProperty(e, r, { get: o(() => n ?? null, 'get') });
}
o(Or, 'assignProps');
function Fe(e) {
  return Number(e ?? 0);
}
o(Fe, 'sanitizeNumber');
function GA(e, { clipboardData: t }) {
  Or(e, { clipboardData: t });
}
o(GA, 'initClipboardEvent');
function zA(e, { relatedTarget: t }) {
  Or(e, { relatedTarget: t });
}
o(zA, 'initFocusEvent');
function WA(e, { data: t, inputType: r, isComposing: n }) {
  Or(e, { data: t, isComposing: !!n, inputType: String(r) });
}
o(WA, 'initInputEvent');
function Fn(e, { view: t, detail: r }) {
  Or(e, { view: t, detail: Fe(r ?? 0) });
}
o(Fn, 'initUIEvent');
function Ds(
  e,
  {
    altKey: t,
    ctrlKey: r,
    metaKey: n,
    shiftKey: i,
    modifierAltGraph: s,
    modifierCapsLock: a,
    modifierFn: c,
    modifierFnLock: d,
    modifierNumLock: u,
    modifierScrollLock: p,
    modifierSymbol: f,
    modifierSymbolLock: y,
  },
) {
  Or(e, {
    altKey: !!t,
    ctrlKey: !!r,
    metaKey: !!n,
    shiftKey: !!i,
    getModifierState(h) {
      return !!{
        Alt: t,
        AltGraph: s,
        CapsLock: a,
        Control: r,
        Fn: c,
        FnLock: d,
        Meta: n,
        NumLock: u,
        ScrollLock: p,
        Shift: i,
        Symbol: f,
        SymbolLock: y,
      }[h];
    },
  });
}
o(Ds, 'initUIEventModifiers');
function KA(e, { key: t, code: r, location: n, repeat: i, isComposing: s, charCode: a }) {
  Or(e, {
    key: String(t),
    code: String(r),
    location: Fe(n),
    repeat: !!i,
    isComposing: !!s,
    charCode: a,
  });
}
o(KA, 'initKeyboardEvent');
function hd(
  e,
  {
    x: t,
    y: r,
    screenX: n,
    screenY: i,
    clientX: s = t,
    clientY: a = r,
    button: c,
    buttons: d,
    relatedTarget: u,
    offsetX: p,
    offsetY: f,
    pageX: y,
    pageY: h,
  },
) {
  Or(e, {
    screenX: Fe(n),
    screenY: Fe(i),
    clientX: Fe(s),
    x: Fe(s),
    clientY: Fe(a),
    y: Fe(a),
    button: Fe(c),
    buttons: Fe(d),
    relatedTarget: u,
    offsetX: Fe(p),
    offsetY: Fe(f),
    pageX: Fe(y),
    pageY: Fe(h),
  });
}
o(hd, 'initMouseEvent');
function YA(
  e,
  {
    pointerId: t,
    width: r,
    height: n,
    pressure: i,
    tangentialPressure: s,
    tiltX: a,
    tiltY: c,
    twist: d,
    pointerType: u,
    isPrimary: p,
  },
) {
  Or(e, {
    pointerId: Fe(t),
    width: Fe(r ?? 1),
    height: Fe(n ?? 1),
    pressure: Fe(i),
    tangentialPressure: Fe(s),
    tiltX: Fe(a),
    tiltY: Fe(c),
    twist: Fe(d),
    pointerType: String(u),
    isPrimary: !!p,
  });
}
o(YA, 'initPointerEvent');
function XA(e, t, r, n = !1) {
  (UA(t) || VA(t)) && (r = { ...r, ...this.system.getUIEventModifiers() });
  const i = Ty(t, e, r);
  return wy.call(this, e, i, n);
}
o(XA, 'dispatchUIEvent');
function wy(e, t, r = !1) {
  var n;
  const i = t.type,
    s = r ? () => {} : (n = Hr[i]) === null || n === void 0 ? void 0 : n.call(Hr, t, e, this);
  if (s) {
    t.preventDefault();
    let a = !1;
    return (
      Object.defineProperty(t, 'defaultPrevented', { get: o(() => a, 'get') }),
      Object.defineProperty(t, 'preventDefault', {
        value: o(() => {
          a = t.cancelable;
        }, 'value'),
      }),
      Sn(() => e.dispatchEvent(t)),
      a || s(),
      !a
    );
  }
  return Sn(() => e.dispatchEvent(t));
}
o(wy, 'dispatchEvent');
function Mr(e, t, r) {
  const n = Ty(t, e, r);
  Sn(() => e.dispatchEvent(n));
}
o(Mr, 'dispatchDOMEvent');
var gg = Symbol('patched focus/blur methods');
function Sy(e) {
  if (e.prototype[gg]) return;
  const { focus: t, blur: r } = e.prototype;
  Object.defineProperties(e.prototype, {
    focus: { configurable: !0, get: o(() => i, 'get') },
    blur: { configurable: !0, get: o(() => s, 'get') },
    [gg]: { configurable: !0, get: o(() => ({ focus: t, blur: r }), 'get') },
  });
  let n;
  function i(a) {
    if (this.ownerDocument.visibilityState !== 'hidden') return t.call(this, a);
    const c = gd(this.ownerDocument);
    if (c === this) return;
    const d = Symbol('focus call');
    ((n = d),
      c &&
        (r.call(c),
        Mr(c, 'blur', { relatedTarget: this }),
        Mr(c, 'focusout', { relatedTarget: n === d ? this : null })),
      n === d && (t.call(this, a), Mr(this, 'focus', { relatedTarget: c })),
      n === d && Mr(this, 'focusin', { relatedTarget: c }));
  }
  o(i, 'patchedFocus');
  function s() {
    if (this.ownerDocument.visibilityState !== 'hidden') return r.call(this);
    const a = gd(this.ownerDocument);
    if (a !== this) return;
    ((n = Symbol('blur call')),
      r.call(this),
      Mr(a, 'blur', { relatedTarget: null }),
      Mr(a, 'focusout', { relatedTarget: null }));
  }
  o(s, 'patchedBlur');
}
o(Sy, 'patchFocus');
function gd(e) {
  const t = xo(e);
  return t?.tagName === 'BODY' ? null : t;
}
o(gd, 'getActiveTarget');
var qc = Symbol('Interceptor for programmatical calls');
function cn(e, t, r) {
  const n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    i = Object.getOwnPropertyDescriptor(e, t),
    s = n?.set ? 'set' : 'value';
  if (typeof n?.[s] != 'function' || n[s][qc])
    throw new Error(`Element ${e.tagName} does not implement "${String(t)}".`);
  function a(...c) {
    const { applyNative: d = !1, realArgs: u, then: p } = r.call(this, ...c),
      f = ((!d && i) || n)[s];
    (s === 'set' ? f.call(this, u) : f.call(this, ...u), p?.());
  }
  (o(a, 'intercept'), (a[qc] = qc), Object.defineProperty(e, t, { ...(i ?? n), [s]: a }));
}
o(cn, 'prepareInterceptor');
function QA(e) {
  cn(
    e,
    'value',
    o(function (r) {
      const n = yA(r);
      return (
        n && CA(this),
        { applyNative: !!n, realArgs: ZA(this, r), then: n ? void 0 : () => xA(this, String(r)) }
      );
    }, 'interceptorImpl'),
  );
}
o(QA, 'prepareValueInterceptor');
function ZA(e, t) {
  return he(e, 'input', { type: 'number' }) && String(t) !== '' && !Number.isNaN(Number(t))
    ? String(Number(t))
    : String(t);
}
o(ZA, 'sanitizeValue');
function eO(e) {
  (cn(
    e,
    'setSelectionRange',
    o(function (r, ...n) {
      const i = hA(r);
      return {
        applyNative: !!i,
        realArgs: [Number(r), ...n],
        then: o(() => (i ? void 0 : Ri(e)), 'then'),
      };
    }, 'interceptorImpl'),
  ),
    cn(
      e,
      'selectionStart',
      o(function (r) {
        return { realArgs: r, then: o(() => Ri(e), 'then') };
      }, 'interceptorImpl'),
    ),
    cn(
      e,
      'selectionEnd',
      o(function (r) {
        return { realArgs: r, then: o(() => Ri(e), 'then') };
      }, 'interceptorImpl'),
    ),
    cn(
      e,
      'select',
      o(function () {
        return {
          realArgs: [],
          then: o(() => vA(e, { anchorOffset: 0, focusOffset: Wt(e).length }), 'then'),
        };
      }, 'interceptorImpl'),
    ));
}
o(eO, 'prepareSelectionInterceptor');
function tO(e) {
  cn(
    e,
    'setRangeText',
    o(function (...r) {
      return {
        realArgs: r,
        then: o(() => {
          (Xl(e), Ri(e));
        }, 'then'),
      };
    }, 'interceptorImpl'),
  );
}
o(tO, 'prepareRangeTextInterceptor');
var Yn = Symbol('Node prepared with document state workarounds');
function _y(e) {
  e[Yn] ||
    (e.addEventListener(
      'focus',
      (t) => {
        const r = t.target;
        bd(r);
      },
      { capture: !0, passive: !0 },
    ),
    e.activeElement && bd(e.activeElement),
    e.addEventListener(
      'blur',
      (t) => {
        const r = t.target,
          n = bA(r);
        n !== void 0 && (r.value !== n && Mr(r, 'change'), my(r));
      },
      { capture: !0, passive: !0 },
    ),
    (e[Yn] = Yn));
}
o(_y, 'prepareDocument');
function bd(e) {
  e[Yn] || (he(e, ['input', 'textarea']) && (QA(e), eO(e), tO(e)), (e[Yn] = Yn));
}
o(bd, 'prepareElement');
function rO(e) {
  return nO(e) ? e : e.ownerDocument;
}
o(rO, 'getDocumentFromNode');
function nO(e) {
  return e.nodeType === 9;
}
o(nO, 'isDocument');
var Pt = (function (e) {
  return ((e[(e.Trigger = 2)] = 'Trigger'), (e[(e.Call = 1)] = 'Call'), e);
})({});
function Vn(e, t) {
  e.levelRefs[t] = {};
}
o(Vn, 'setLevelRef');
function mi(e, t) {
  return e.levelRefs[t];
}
o(mi, 'getLevelRef');
function Rn(e) {
  const t = e.delay;
  if (typeof t == 'number')
    return Promise.all([
      new Promise((r) => globalThis.setTimeout(() => r(), t)),
      e.advanceTimers(t),
    ]);
}
o(Rn, 'wait');
var Ls = (function (e) {
  return (
    (e[(e.EachTrigger = 4)] = 'EachTrigger'),
    (e[(e.EachApiCall = 2)] = 'EachApiCall'),
    (e[(e.EachTarget = 1)] = 'EachTarget'),
    (e[(e.Never = 0)] = 'Never'),
    e
  );
})({});
function xr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(xr, '_define_property');
var Kt = (function (e) {
    return (
      (e[(e.STANDARD = 0)] = 'STANDARD'),
      (e[(e.LEFT = 1)] = 'LEFT'),
      (e[(e.RIGHT = 2)] = 'RIGHT'),
      (e[(e.NUMPAD = 3)] = 'NUMPAD'),
      e
    );
  })({}),
  SJ = ['Alt', 'AltGraph', 'Control', 'Fn', 'Meta', 'Shift', 'Symbol'];
function vd(e) {
  return SJ.includes(e);
}
o(vd, 'isModifierKey');
var _J = ['CapsLock', 'FnLock', 'NumLock', 'ScrollLock', 'SymbolLock'];
function Ed(e) {
  return _J.includes(e);
}
o(Ed, 'isModifierLock');
var oO = class {
  isKeyPressed(t) {
    return this.pressed.has(String(t.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((t) => t.keyDef);
  }
  async keydown(t, r) {
    const n = String(r.key),
      i = String(r.code),
      s = ks(t.config.document);
    (this.setKeydownTarget(s), this.pressed.add(i, r), vd(n) && (this.modifiers[n] = !0));
    const a = t.dispatchUIEvent(s, 'keydown', { key: n, code: i });
    (Ed(n) && !this.modifiers[n] && ((this.modifiers[n] = !0), (this.modifierLockStart[n] = !0)),
      a && this.pressed.setUnprevented(i),
      a &&
        this.hasKeyPress(n) &&
        t.dispatchUIEvent(ks(t.config.document), 'keypress', {
          key: n,
          code: i,
          charCode: r.key === 'Enter' ? 13 : String(r.key).charCodeAt(0),
        }));
  }
  async keyup(t, r) {
    const n = String(r.key),
      i = String(r.code),
      s = this.pressed.isUnprevented(i);
    (this.pressed.delete(i),
      vd(n) && !this.pressed.values().find((a) => a.keyDef.key === n) && (this.modifiers[n] = !1),
      t.dispatchUIEvent(ks(t.config.document), 'keyup', { key: n, code: i }, !s),
      Ed(n) &&
        this.modifiers[n] &&
        (this.modifierLockStart[n] ? (this.modifierLockStart[n] = !1) : (this.modifiers[n] = !1)));
  }
  setKeydownTarget(t) {
    (t !== this.lastKeydownTarget && (this.carryChar = ''), (this.lastKeydownTarget = t));
  }
  hasKeyPress(t) {
    return (t.length === 1 || t === 'Enter') && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(t) {
    (xr(this, 'system', void 0),
      xr(this, 'modifiers', {
        Alt: !1,
        AltGraph: !1,
        CapsLock: !1,
        Control: !1,
        Fn: !1,
        FnLock: !1,
        Meta: !1,
        NumLock: !1,
        ScrollLock: !1,
        Shift: !1,
        Symbol: !1,
        SymbolLock: !1,
      }),
      xr(
        this,
        'pressed',
        new (class {
          add(r, n) {
            var i, s, a;
            ((a = (i = this.registry)[(s = r)]) !== null && a !== void 0) ||
              (i[s] = { keyDef: n, unpreventedDefault: !1 });
          }
          has(r) {
            return !!this.registry[r];
          }
          setUnprevented(r) {
            const n = this.registry[r];
            n && (n.unpreventedDefault = !0);
          }
          isUnprevented(r) {
            var n;
            return !!(!((n = this.registry[r]) === null || n === void 0) && n.unpreventedDefault);
          }
          delete(r) {
            delete this.registry[r];
          }
          values() {
            return Object.values(this.registry);
          }
          constructor() {
            xr(this, 'registry', {});
          }
        })(),
      ),
      xr(this, 'carryChar', ''),
      xr(this, 'lastKeydownTarget', void 0),
      xr(this, 'modifierLockStart', {}),
      (this.system = t));
  }
};
o(oO, 'KeyboardHost');
var RJ = oO,
  PJ = [
    ...'0123456789'.split('').map((e) => ({ code: `Digit${e}`, key: e })),
    ...')!@#$%^&*('.split('').map((e, t) => ({ code: `Digit${t}`, key: e, shiftKey: !0 })),
    ...'abcdefghijklmnopqrstuvwxyz'
      .split('')
      .map((e) => ({ code: `Key${e.toUpperCase()}`, key: e })),
    ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      .split('')
      .map((e) => ({ code: `Key${e}`, key: e, shiftKey: !0 })),
    { code: 'BracketLeft', key: '[' },
    { code: 'BracketLeft', key: '{', shiftKey: !0 },
    { code: 'BracketRight', key: ']' },
    { code: 'BracketRight', key: '}', shiftKey: !0 },
    { code: 'Space', key: ' ' },
    { code: 'AltLeft', key: 'Alt', location: Kt.LEFT },
    { code: 'AltRight', key: 'Alt', location: Kt.RIGHT },
    { code: 'ShiftLeft', key: 'Shift', location: Kt.LEFT },
    { code: 'ShiftRight', key: 'Shift', location: Kt.RIGHT },
    { code: 'ControlLeft', key: 'Control', location: Kt.LEFT },
    { code: 'ControlRight', key: 'Control', location: Kt.RIGHT },
    { code: 'MetaLeft', key: 'Meta', location: Kt.LEFT },
    { code: 'MetaRight', key: 'Meta', location: Kt.RIGHT },
    { code: 'OSLeft', key: 'OS', location: Kt.LEFT },
    { code: 'OSRight', key: 'OS', location: Kt.RIGHT },
    { code: 'ContextMenu', key: 'ContextMenu' },
    { code: 'Tab', key: 'Tab' },
    { code: 'CapsLock', key: 'CapsLock' },
    { code: 'Backspace', key: 'Backspace' },
    { code: 'Enter', key: 'Enter' },
    { code: 'Escape', key: 'Escape' },
    { code: 'ArrowUp', key: 'ArrowUp' },
    { code: 'ArrowDown', key: 'ArrowDown' },
    { code: 'ArrowLeft', key: 'ArrowLeft' },
    { code: 'ArrowRight', key: 'ArrowRight' },
    { code: 'Home', key: 'Home' },
    { code: 'End', key: 'End' },
    { code: 'Delete', key: 'Delete' },
    { code: 'PageUp', key: 'PageUp' },
    { code: 'PageDown', key: 'PageDown' },
    { code: 'Fn', key: 'Fn' },
    { code: 'Symbol', key: 'Symbol' },
    { code: 'AltRight', key: 'AltGraph' },
  ],
  AJ = [
    { name: 'MouseLeft', pointerType: 'mouse', button: 'primary' },
    { name: 'MouseRight', pointerType: 'mouse', button: 'secondary' },
    { name: 'MouseMiddle', pointerType: 'mouse', button: 'auxiliary' },
    { name: 'TouchA', pointerType: 'touch' },
    { name: 'TouchB', pointerType: 'touch' },
    { name: 'TouchC', pointerType: 'touch' },
  ];
function iO(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(iO, '_define_property');
var sO = class {
  getButtons() {
    let t = 0;
    for (const r of Object.keys(this.pressed)) t |= 2 ** Number(r);
    return t;
  }
  down(t) {
    const r = Pa(t.button);
    if (r in this.pressed) {
      this.pressed[r].push(t);
      return;
    }
    return ((this.pressed[r] = [t]), r);
  }
  up(t) {
    const r = Pa(t.button);
    if (
      r in this.pressed &&
      ((this.pressed[r] = this.pressed[r].filter((n) => n.name !== t.name)),
      this.pressed[r].length === 0)
    )
      return (delete this.pressed[r], r);
  }
  constructor() {
    iO(this, 'pressed', {});
  }
};
o(sO, 'Buttons');
var aO = sO,
  bg = { primary: 0, secondary: 1, auxiliary: 2, back: 3, X1: 3, forward: 4, X2: 4 };
function Pa(e = 0) {
  return e in bg ? bg[e] : Number(e);
}
o(Pa, 'getMouseButtonId');
var vg = { 1: 2, 2: 1 };
function Aa(e) {
  return ((e = Pa(e)), e in vg ? vg[e] : e);
}
o(Aa, 'getMouseEventButton');
function lO(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(lO, '_define_property');
var cO = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(t) {
    return this.pressedKeys.has(t.name);
  }
  addPressed(t) {
    return this.pressedKeys.add(t.name);
  }
  removePressed(t) {
    return this.pressedKeys.delete(t.name);
  }
  constructor() {
    lO(this, 'pressedKeys', new Set());
  }
};
o(cO, 'Device');
var OJ = cO;
function Xn(e, t) {
  const r = [];
  for (let s = e; s; s = s.parentElement) r.push(s);
  const n = [];
  for (let s = t; s; s = s.parentElement) n.push(s);
  let i = 0;
  for (; !(i >= r.length || i >= n.length || r[r.length - 1 - i] !== n[n.length - 1 - i]); i++);
  return [r.slice(0, r.length - i), n.slice(0, n.length - i), n.slice(n.length - i)];
}
o(Xn, 'getTreeDiff');
function Oa({ target: e, node: t, offset: r }) {
  return zt(e)
    ? { node: e, offset: r ?? Wt(e).length }
    : t
      ? { node: t, offset: r ?? (t.nodeType === 3 ? t.nodeValue.length : t.childNodes.length) }
      : Ry(e, r);
}
o(Oa, 'resolveCaretPosition');
function Ry(e, t, r = !0) {
  let n = t === void 0 ? e.childNodes.length - 1 : 0;
  const i = t === void 0 ? -1 : 1;
  for (
    ;
    t === void 0 ? n >= (r ? Math.max(e.childNodes.length - 1, 0) : 0) : n <= e.childNodes.length;

  ) {
    if (t && n === e.childNodes.length) throw new Error('The given offset is out of bounds.');
    const s = e.childNodes.item(n),
      a = String(s.textContent);
    if (a.length)
      if (t !== void 0 && a.length < t) t -= a.length;
      else {
        if (s.nodeType === 1) return Ry(s, t, !1);
        if (s.nodeType === 3) return { node: s, offset: t ?? s.nodeValue.length };
      }
    n += i;
  }
  return { node: e, offset: e.childNodes.length };
}
o(Ry, 'findNodeAtTextOffset');
function uO({ document: e, target: t, clickCount: r, node: n, offset: i }) {
  if (pA(t)) return;
  const s = zt(t),
    a = String(s ? Wt(t) : t.textContent),
    [c, d] = n ? [i, i] : dO(a, i, r);
  if (s)
    return (
      qn(t, { anchorOffset: c ?? a.length, focusOffset: d ?? a.length }),
      { node: t, start: c ?? 0, end: d ?? a.length }
    );
  {
    const { node: u, offset: p } = Oa({ target: t, node: n, offset: c }),
      { node: f, offset: y } = Oa({ target: t, node: n, offset: d }),
      h = t.ownerDocument.createRange();
    try {
      (h.setStart(u, p), h.setEnd(f, y));
    } catch {
      throw new Error('The given offset is out of bounds.');
    }
    const g = e.getSelection();
    return (g?.removeAllRanges(), g?.addRange(h.cloneRange()), h);
  }
}
o(uO, 'setSelectionPerMouseDown');
function dO(e, t, r) {
  if (r % 3 === 1 || e.length === 0) return [t, t];
  const n = t ?? e.length;
  return r % 3 === 2
    ? [
        n - e.substr(0, t).match(/(\w+|\s+|\W)?$/)[0].length,
        t === void 0 ? t : t + e.substr(t).match(/^(\w+|\s+|\W)?/)[0].length,
      ]
    : [
        n - e.substr(0, t).match(/[^\r\n]*$/)[0].length,
        t === void 0 ? t : t + e.substr(t).match(/^[^\r\n]*/)[0].length,
      ];
}
o(dO, 'getTextRange');
function pO(e, { document: t, target: r, node: n, offset: i }) {
  const s = Oa({ target: r, node: n, offset: i });
  if ('node' in e) {
    if (s.node === e.node) {
      const a = s.offset < e.start ? e.end : e.start,
        c = s.offset > e.end || s.offset < e.start ? s.offset : e.end;
      qn(e.node, { anchorOffset: a, focusOffset: c });
    }
  } else {
    const a = e.cloneRange(),
      c = a.comparePoint(s.node, s.offset);
    c < 0 ? a.setStart(s.node, s.offset) : c > 0 && a.setEnd(s.node, s.offset);
    const d = t.getSelection();
    (d?.removeAllRanges(), d?.addRange(a.cloneRange()));
  }
}
o(pO, 'modifySelectionPerMouseMove');
function Py(e, t) {
  var r, n, i, s, a, c, d, u, p, f, y, h, g, T, E, v, S, A, N, j, C, R, w, _;
  return (
    e.target !== t.target ||
    ((r = e.coords) === null || r === void 0 ? void 0 : r.x) !==
      ((n = t.coords) === null || n === void 0 ? void 0 : n.x) ||
    ((i = e.coords) === null || i === void 0 ? void 0 : i.y) !==
      ((s = t.coords) === null || s === void 0 ? void 0 : s.y) ||
    ((a = e.coords) === null || a === void 0 ? void 0 : a.clientX) !==
      ((c = t.coords) === null || c === void 0 ? void 0 : c.clientX) ||
    ((d = e.coords) === null || d === void 0 ? void 0 : d.clientY) !==
      ((u = t.coords) === null || u === void 0 ? void 0 : u.clientY) ||
    ((p = e.coords) === null || p === void 0 ? void 0 : p.offsetX) !==
      ((f = t.coords) === null || f === void 0 ? void 0 : f.offsetX) ||
    ((y = e.coords) === null || y === void 0 ? void 0 : y.offsetY) !==
      ((h = t.coords) === null || h === void 0 ? void 0 : h.offsetY) ||
    ((g = e.coords) === null || g === void 0 ? void 0 : g.pageX) !==
      ((T = t.coords) === null || T === void 0 ? void 0 : T.pageX) ||
    ((E = e.coords) === null || E === void 0 ? void 0 : E.pageY) !==
      ((v = t.coords) === null || v === void 0 ? void 0 : v.pageY) ||
    ((S = e.coords) === null || S === void 0 ? void 0 : S.screenX) !==
      ((A = t.coords) === null || A === void 0 ? void 0 : A.screenX) ||
    ((N = e.coords) === null || N === void 0 ? void 0 : N.screenY) !==
      ((j = t.coords) === null || j === void 0 ? void 0 : j.screenY) ||
    ((C = e.caret) === null || C === void 0 ? void 0 : C.node) !==
      ((R = t.caret) === null || R === void 0 ? void 0 : R.node) ||
    ((w = e.caret) === null || w === void 0 ? void 0 : w.offset) !==
      ((_ = t.caret) === null || _ === void 0 ? void 0 : _.offset)
  );
}
o(Py, 'isDifferentPointerPosition');
function Nr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(Nr, '_define_property');
var fO = class {
  move(t, r, n) {
    const i = this.position,
      s = this.getTarget(t);
    if (((this.position = r), !Py(i, r))) return;
    const a = this.getTarget(t),
      c = this.getEventInit('mousemove'),
      [d, u] = Xn(s, a);
    return {
      leave: o(() => {
        s !== a &&
          (t.dispatchUIEvent(s, 'mouseout', c),
          d.forEach((p) => t.dispatchUIEvent(p, 'mouseleave', c)));
      }, 'leave'),
      enter: o(() => {
        s !== a &&
          (t.dispatchUIEvent(a, 'mouseover', c),
          u.forEach((p) => t.dispatchUIEvent(p, 'mouseenter', c)));
      }, 'enter'),
      move: o(() => {
        n || (t.dispatchUIEvent(a, 'mousemove', c), this.modifySelecting(t));
      }, 'move'),
    };
  }
  down(t, r, n) {
    const i = this.buttons.down(r);
    if (i === void 0) return;
    const s = this.getTarget(t);
    this.buttonDownTarget[i] = s;
    const a = this.getEventInit('mousedown', r.button),
      c = or(s);
    (!n && (c || t.dispatchUIEvent(s, 'mousedown', a)) && (this.startSelecting(t, a.detail), Rr(s)),
      !c &&
        Aa(r.button) === 2 &&
        t.dispatchUIEvent(s, 'contextmenu', this.getEventInit('contextmenu', r.button)));
  }
  up(t, r, n) {
    const i = this.buttons.up(r);
    if (i === void 0) return;
    const s = this.getTarget(t);
    if (!or(s)) {
      if (!n) {
        const c = this.getEventInit('mouseup', r.button);
        (t.dispatchUIEvent(s, 'mouseup', c), this.endSelecting());
      }
      const a = Xn(this.buttonDownTarget[i], s)[2][0];
      if (a) {
        const c = this.getEventInit('click', r.button);
        c.detail &&
          (t.dispatchUIEvent(a, c.button === 0 ? 'click' : 'auxclick', c),
          c.button === 0 &&
            c.detail === 2 &&
            t.dispatchUIEvent(a, 'dblclick', {
              ...this.getEventInit('dblclick', r.button),
              detail: c.detail,
            }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(t, r) {
    const n = { ...this.position.coords };
    return (
      (n.button = Aa(r)),
      (n.buttons = this.buttons.getButtons()),
      t === 'mousedown'
        ? (n.detail = this.clickCount.getOnDown(n.button))
        : t === 'mouseup'
          ? (n.detail = this.clickCount.getOnUp(n.button))
          : (t === 'click' || t === 'auxclick') &&
            (n.detail = this.clickCount.incOnClick(n.button)),
      n
    );
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  startSelecting(t, r) {
    var n, i;
    this.selecting = uO({
      document: t.config.document,
      target: this.getTarget(t),
      node: (n = this.position.caret) === null || n === void 0 ? void 0 : n.node,
      offset: (i = this.position.caret) === null || i === void 0 ? void 0 : i.offset,
      clickCount: r,
    });
  }
  modifySelecting(t) {
    var r, n;
    this.selecting &&
      pO(this.selecting, {
        document: t.config.document,
        target: this.getTarget(t),
        node: (r = this.position.caret) === null || r === void 0 ? void 0 : r.node,
        offset: (n = this.position.caret) === null || n === void 0 ? void 0 : n.offset,
      });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    (Nr(this, 'position', {}),
      Nr(this, 'buttons', new aO()),
      Nr(this, 'selecting', void 0),
      Nr(this, 'buttonDownTarget', {}),
      Nr(
        this,
        'clickCount',
        new (class {
          incOnClick(t) {
            const r = this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
            return (
              (this.count = this.count[t] === void 0 ? {} : { [t]: Number(this.count[t]) + 1 }),
              r
            );
          }
          getOnDown(t) {
            var r;
            this.down = { [t]: (r = this.count[t]) !== null && r !== void 0 ? r : 0 };
            var n;
            return (
              (this.count = { [t]: (n = this.count[t]) !== null && n !== void 0 ? n : 0 }),
              Number(this.count[t]) + 1
            );
          }
          getOnUp(t) {
            return this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
          }
          reset() {
            this.count = {};
          }
          constructor() {
            (Nr(this, 'down', {}), Nr(this, 'count', {}));
          }
        })(),
      ));
  }
};
o(fO, 'Mouse');
var CJ = fO;
function Wi(e, t) {
  var r;
  return ((r = Ay(e, t)) === null || r === void 0 ? void 0 : r.pointerEvents) !== 'none';
}
o(Wi, 'hasPointerEvents');
function mO(e) {
  const t = xt(e);
  for (let r = e, n = []; r?.ownerDocument; r = r.parentElement) {
    n.push(r);
    const i = t.getComputedStyle(r).pointerEvents;
    if (i && !['inherit', 'unset'].includes(i)) return { pointerEvents: i, tree: n };
  }
}
o(mO, 'closestPointerEventsDeclaration');
var Eg = Symbol('Last check for pointer-events');
function Ay(e, t) {
  const r = t[Eg];
  if (
    !(
      e.config.pointerEventsCheck !== Ls.Never &&
      (!r ||
        (Td(e.config.pointerEventsCheck, Ls.EachApiCall) && r[Pt.Call] !== mi(e, Pt.Call)) ||
        (Td(e.config.pointerEventsCheck, Ls.EachTrigger) && r[Pt.Trigger] !== mi(e, Pt.Trigger)))
    )
  )
    return r?.result;
  const i = mO(t);
  return ((t[Eg] = { [Pt.Call]: mi(e, Pt.Call), [Pt.Trigger]: mi(e, Pt.Trigger), result: i }), i);
}
o(Ay, 'checkPointerEvents');
function Hn(e, t) {
  const r = Ay(e, t);
  if (r?.pointerEvents === 'none')
    throw new Error(
      [
        `Unable to perform pointer interaction as the element ${r.tree.length > 1 ? 'inherits' : 'has'} \`pointer-events: none\`:`,
        '',
        yO(r.tree),
      ].join(`
`),
    );
}
o(Hn, 'assertPointerEvents');
function yO(e) {
  return e
    .reverse()
    .map((t, r) =>
      [
        ''.padEnd(r),
        t.tagName,
        t.id && `#${t.id}`,
        t.hasAttribute('data-testid') && `(testId=${t.getAttribute('data-testid')})`,
        hO(t),
        e.length > 1 && r === 0 && '  <-- This element declared `pointer-events: none`',
        e.length > 1 && r === e.length - 1 && '  <-- Asserted pointer events here',
      ]
        .filter(Boolean)
        .join(''),
    ).join(`
`);
}
o(yO, 'printTree');
function hO(e) {
  var t;
  let r;
  if (e.hasAttribute('aria-label')) r = e.getAttribute('aria-label');
  else if (e.hasAttribute('aria-labelledby')) {
    var n, i;
    r =
      (i = e.ownerDocument.getElementById(e.getAttribute('aria-labelledby'))) === null ||
      i === void 0 ||
      (n = i.textContent) === null ||
      n === void 0
        ? void 0
        : n.trim();
  } else if (
    he(e, ['button', 'input', 'meter', 'output', 'progress', 'select', 'textarea']) &&
    !((t = e.labels) === null || t === void 0) &&
    t.length
  )
    r = Array.from(e.labels)
      .map((a) => {
        var c;
        return (c = a.textContent) === null || c === void 0 ? void 0 : c.trim();
      })
      .join('|');
  else if (he(e, 'button')) {
    var s;
    r = (s = e.textContent) === null || s === void 0 ? void 0 : s.trim();
  }
  return (
    (r = r?.replace(/\n/g, '  ')),
    Number(r?.length) > 30 && (r = `${r?.substring(0, 29)}`),
    r ? `(label=${r})` : ''
  );
}
o(hO, 'getLabelDescr');
function Td(e, t) {
  return (e & t) > 0;
}
o(Td, 'hasBitFlag');
function Qt(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(Qt, '_define_property');
var gO = class {
  init(t) {
    const r = this.getTarget(t),
      [, n] = Xn(null, r),
      i = this.getEventInit();
    return (
      Hn(t, r),
      t.dispatchUIEvent(r, 'pointerover', i),
      n.forEach((s) => t.dispatchUIEvent(s, 'pointerenter', i)),
      this
    );
  }
  move(t, r) {
    const n = this.position,
      i = this.getTarget(t);
    if (((this.position = r), !Py(n, r))) return;
    const s = this.getTarget(t),
      a = this.getEventInit(-1),
      [c, d] = Xn(i, s);
    return {
      leave: o(() => {
        Wi(t, i) &&
          i !== s &&
          (t.dispatchUIEvent(i, 'pointerout', a),
          c.forEach((u) => t.dispatchUIEvent(u, 'pointerleave', a)));
      }, 'leave'),
      enter: o(() => {
        (Hn(t, s),
          i !== s &&
            (t.dispatchUIEvent(s, 'pointerover', a),
            d.forEach((u) => t.dispatchUIEvent(u, 'pointerenter', a))));
      }, 'enter'),
      move: o(() => {
        t.dispatchUIEvent(s, 'pointermove', a);
      }, 'move'),
    };
  }
  down(t, r = 0) {
    if (this.isDown) return;
    const n = this.getTarget(t);
    (Hn(t, n),
      (this.isDown = !0),
      (this.isPrevented = !t.dispatchUIEvent(n, 'pointerdown', this.getEventInit(r))));
  }
  up(t, r = 0) {
    if (!this.isDown) return;
    const n = this.getTarget(t);
    (Hn(t, n),
      (this.isPrevented = !1),
      (this.isDown = !1),
      t.dispatchUIEvent(n, 'pointerup', this.getEventInit(r)));
  }
  release(t) {
    const r = this.getTarget(t),
      [n] = Xn(r, null),
      i = this.getEventInit();
    (Wi(t, r) &&
      (t.dispatchUIEvent(r, 'pointerout', i),
      n.forEach((s) => t.dispatchUIEvent(s, 'pointerleave', i))),
      (this.isCancelled = !0));
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  getEventInit(t) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: Aa(t),
      buttons: this.buttons.getButtons(),
    };
  }
  constructor({ pointerId: t, pointerType: r, isPrimary: n }, i) {
    (Qt(this, 'pointerId', void 0),
      Qt(this, 'pointerType', void 0),
      Qt(this, 'isPrimary', void 0),
      Qt(this, 'buttons', void 0),
      Qt(this, 'isMultitouch', !1),
      Qt(this, 'isCancelled', !1),
      Qt(this, 'isDown', !1),
      Qt(this, 'isPrevented', !1),
      Qt(this, 'position', {}),
      (this.pointerId = t),
      (this.pointerType = r),
      (this.isPrimary = n),
      (this.isMultitouch = !n),
      (this.buttons = i));
  }
};
o(gO, 'Pointer');
var xJ = gO;
function hr(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(hr, '_define_property');
var bO = class {
  isKeyPressed(t) {
    return this.devices.get(t.pointerType).isPressed(t);
  }
  async press(t, r, n) {
    (this.devices.get(r.pointerType).addPressed(r), this.buttons.down(r));
    const i = this.getPointerName(r),
      s =
        r.pointerType === 'touch'
          ? this.pointers.new(i, r.pointerType, this.buttons)
          : this.pointers.get(i);
    ((s.position = n),
      s.pointerType !== 'touch' && (this.mouse.position = n),
      s.pointerType === 'touch' && s.init(t),
      s.down(t, r.button),
      s.pointerType !== 'touch' && this.mouse.down(t, r, s.isPrevented));
  }
  async move(t, r, n) {
    const i = this.pointers.get(r),
      s = i.move(t, n),
      a = i.pointerType === 'touch' ? void 0 : this.mouse.move(t, n, i.isPrevented);
    (s?.leave(), a?.leave(), s?.enter(), a?.enter(), s?.move(), a?.move());
  }
  async release(t, r, n) {
    const i = this.devices.get(r.pointerType);
    (i.removePressed(r), this.buttons.up(r));
    const s = this.pointers.get(this.getPointerName(r)),
      a = s.isPrevented;
    if (
      ((s.position = n),
      s.pointerType !== 'touch' && (this.mouse.position = n),
      i.countPressed === 0 && s.up(t, r.button),
      s.pointerType === 'touch' && s.release(t),
      s.pointerType === 'touch' && !s.isMultitouch)
    ) {
      const c = this.mouse.move(t, n, a);
      (c?.leave(), c?.enter(), c?.move(), this.mouse.down(t, r, a));
    }
    if (!s.isMultitouch) {
      const c = this.mouse.move(t, n, a);
      (c?.leave(), c?.enter(), c?.move(), this.mouse.up(t, r, a));
    }
  }
  getPointerName(t) {
    return t.pointerType === 'touch' ? t.name : t.pointerType;
  }
  getPreviousPosition(t) {
    return this.pointers.has(t) ? this.pointers.get(t).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(t) {
    var r;
    return (r = this.mouse.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  setMousePosition(t) {
    ((this.mouse.position = t), (this.pointers.get('mouse').position = t));
  }
  constructor(t) {
    (hr(this, 'system', void 0),
      hr(this, 'mouse', void 0),
      hr(this, 'buttons', void 0),
      hr(
        this,
        'devices',
        new (class {
          get(r) {
            var n, i, s;
            return (s = (n = this.registry)[(i = r)]) !== null && s !== void 0
              ? s
              : (n[i] = new OJ());
          }
          constructor() {
            hr(this, 'registry', {});
          }
        })(),
      ),
      hr(
        this,
        'pointers',
        new (class {
          new(r, n, i) {
            const s =
              n !== 'touch' ||
              !Object.values(this.registry).some(
                (a) => a.pointerType === 'touch' && !a.isCancelled,
              );
            return (
              s ||
                Object.values(this.registry).forEach((a) => {
                  a.pointerType === n && !a.isCancelled && (a.isMultitouch = !0);
                }),
              (this.registry[r] = new xJ(
                { pointerId: this.nextId++, pointerType: n, isPrimary: s },
                i,
              )),
              this.registry[r]
            );
          }
          get(r) {
            if (!this.has(r))
              throw new Error(`Trying to access pointer "${r}" which does not exist.`);
            return this.registry[r];
          }
          has(r) {
            return r in this.registry;
          }
          constructor() {
            (hr(this, 'registry', {}), hr(this, 'nextId', 1));
          }
        })(),
      ),
      (this.system = t),
      (this.buttons = new aO()),
      (this.mouse = new CJ()),
      this.pointers.new('mouse', 'mouse', this.buttons));
  }
};
o(bO, 'PointerHost');
var NJ = bO;
function wd(e, t, r) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = r),
    e
  );
}
o(wd, '_define_property');
var vO = class {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock,
    };
  }
  constructor() {
    (wd(this, 'keyboard', new RJ(this)), wd(this, 'pointer', new NJ(this)));
  }
};
o(vO, 'System');
var EO = vO;
async function TO(e) {
  const t = [];
  return (
    this.config.skipHover || t.push({ target: e }),
    t.push({ keys: '[MouseLeft]', target: e }),
    this.pointer(t)
  );
}
o(TO, 'click');
async function wO(e) {
  return this.pointer([{ target: e }, '[MouseLeft][MouseLeft]']);
}
o(wO, 'dblClick');
async function SO(e) {
  return this.pointer([{ target: e }, '[MouseLeft][MouseLeft][MouseLeft]']);
}
o(SO, 'tripleClick');
async function _O(e) {
  return this.pointer({ target: e });
}
o(_O, 'hover');
async function RO(e) {
  return (
    Hn(this, this.system.pointer.getMouseTarget(this)),
    this.pointer({ target: e.ownerDocument.body })
  );
}
o(RO, 'unhover');
async function PO({ shift: e } = {}) {
  return this.keyboard(
    e === !0 ? '{Shift>}{Tab}{/Shift}' : e === !1 ? '[/ShiftLeft][/ShiftRight]{Tab}' : '{Tab}',
  );
}
o(PO, 'tab');
var Oy = (function (e) {
  return ((e['{'] = '}'), (e['['] = ']'), e);
})(Oy || {});
function Cy(e, t) {
  let r = 0;
  const n = e[r] in Oy ? e[r] : '';
  r += n.length;
  const s = new RegExp(`^\\${n}{2}`).test(e) ? '' : n;
  return { type: s, ...(s === '' ? AO(e, r, t) : OO(e, r, s, t)) };
}
o(Cy, 'readNextDescriptor');
function AO(e, t, r) {
  const n = e[t];
  return (
    xy(n, e, t, r),
    (t += n.length),
    { consumedLength: t, descriptor: n, releasePrevious: !1, releaseSelf: !0, repeat: 1 }
  );
}
o(AO, 'readPrintableChar');
function OO(e, t, r, n) {
  var i, s;
  const a = e[t] === '/' ? '/' : '';
  t += a.length;
  const c = r === '{' && e[t] === '\\';
  t += Number(c);
  const d = c
    ? e[t]
    : (i = e.slice(t).match(r === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || i === void 0
      ? void 0
      : i[0];
  (xy(d, e, t, n), (t += d.length));
  var u;
  const p =
    (u = (s = e.slice(t).match(/^>\d+/)) === null || s === void 0 ? void 0 : s[0]) !== null &&
    u !== void 0
      ? u
      : '';
  t += p.length;
  const f = e[t] === '/' || (!p && e[t] === '>') ? e[t] : '';
  t += f.length;
  const y = Oy[r],
    h = e[t] === y ? y : '';
  if (!h)
    throw new Error(
      Ny(
        [!p && 'repeat modifier', !f && 'release modifier', `"${y}"`].filter(Boolean).join(' or '),
        e[t],
        e,
        n,
      ),
    );
  return (
    (t += h.length),
    {
      consumedLength: t,
      descriptor: d,
      releasePrevious: !!a,
      repeat: p ? Math.max(Number(p.substr(1)), 1) : 1,
      releaseSelf: CO(f, p),
    }
  );
}
o(OO, 'readTag');
function xy(e, t, r, n) {
  if (!e) throw new Error(Ny('key descriptor', t[r], t, n));
}
o(xy, 'assertDescriptor');
function CO(e, t) {
  if (e) return e === '/';
  if (t) return !1;
}
o(CO, 'hasReleaseSelf');
function Ny(e, t, r, n) {
  return `Expected ${e} but found "${t ?? ''}" in "${r}"
    See ${n === 'pointer' ? 'https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen' : 'https://testing-library.com/docs/user-event/keyboard'}
    for more information about how userEvent parses your input.`;
}
o(Ny, 'getErrorMessage');
function xO(e, t) {
  const r = [];
  do {
    const {
      type: i,
      descriptor: s,
      consumedLength: a,
      releasePrevious: c,
      releaseSelf: d = !0,
      repeat: u,
    } = Cy(t, 'keyboard');
    var n;
    const p =
      (n = e.find((f) => {
        if (i === '[') {
          var y;
          return (
            ((y = f.code) === null || y === void 0 ? void 0 : y.toLowerCase()) === s.toLowerCase()
          );
        } else if (i === '{') {
          var h;
          return (
            ((h = f.key) === null || h === void 0 ? void 0 : h.toLowerCase()) === s.toLowerCase()
          );
        }
        return f.key === s;
      })) !== null && n !== void 0
        ? n
        : { key: 'Unknown', code: 'Unknown', [i === '[' ? 'code' : 'key']: s };
    (r.push({ keyDef: p, releasePrevious: c, releaseSelf: d, repeat: u }), (t = t.slice(a)));
  } while (t);
  return r;
}
o(xO, 'parseKeyDef');
async function NO(e) {
  const t = xO(this.config.keyboardMap, e);
  for (let r = 0; r < t.length; r++) (await Rn(this.config), await IO(this, t[r]));
}
o(NO, 'keyboard');
async function IO(e, { keyDef: t, releasePrevious: r, releaseSelf: n, repeat: i }) {
  const { system: s } = e;
  if ((s.keyboard.isKeyPressed(t) && (await s.keyboard.keyup(e, t)), !r)) {
    for (let a = 1; a <= i; a++) (await s.keyboard.keydown(e, t), a < i && (await Rn(e.config)));
    n && (await s.keyboard.keyup(e, t));
  }
}
o(IO, 'keyboardAction');
async function MO(e) {
  for (const t of e.system.keyboard.getPressedKeys()) await e.system.keyboard.keyup(e, t);
}
o(MO, 'releaseAllKeys');
function Iy(e) {
  const t = zt(e)
      ? { 'text/plain': qO(e) }
      : { 'text/plain': String(e.ownerDocument.getSelection()) },
    r = Wl(xt(e));
  for (const n in t) t[n] && r.setData(n, t[n]);
  return r;
}
o(Iy, 'copySelection');
function qO(e) {
  const t = go(e);
  return Wt(e).substring(t.startOffset, t.endOffset);
}
o(qO, 'readSelectedValueFromInput');
async function jO() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : e.body,
    n = Iy(r);
  if (n.items.length !== 0)
    return (
      this.dispatchUIEvent(r, 'copy', { clipboardData: n }) &&
        this.config.writeToClipboard &&
        (await uy(e, n)),
      n
    );
}
o(jO, 'copy');
async function kO() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : e.body,
    n = Iy(r);
  if (n.items.length !== 0)
    return (
      this.dispatchUIEvent(r, 'cut', { clipboardData: n }) &&
        this.config.writeToClipboard &&
        (await uy(r.ownerDocument, n)),
      n
    );
}
o(kO, 'cut');
async function DO(e) {
  const t = this.config.document;
  var r;
  const n = (r = t.activeElement) !== null && r !== void 0 ? r : t.body;
  var i;
  const s =
    (i = typeof e == 'string' ? LO(t, e) : e) !== null && i !== void 0
      ? i
      : await iA(t).catch(() => {
          throw new Error(
            '`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.',
          );
        });
  this.dispatchUIEvent(n, 'paste', { clipboardData: s });
}
o(DO, 'paste');
function LO(e, t) {
  const r = Wl(xt(e));
  return (r.setData('text', t), r);
}
o(LO, 'getClipboardDataFromString');
function Sd(e, t) {
  const r = [];
  do {
    const {
        descriptor: n,
        consumedLength: i,
        releasePrevious: s,
        releaseSelf: a = !0,
      } = Cy(t, 'pointer'),
      c = e.find((d) => d.name === n);
    (c && r.push({ keyDef: c, releasePrevious: s, releaseSelf: a }), (t = t.slice(i)));
  } while (t);
  return r;
}
o(Sd, 'parseKeyDef');
async function FO(e) {
  const { pointerMap: t } = this.config,
    r = [];
  (Array.isArray(e) ? e : [e]).forEach((n) => {
    typeof n == 'string'
      ? r.push(...Sd(t, n))
      : 'keys' in n
        ? r.push(...Sd(t, n.keys).map((i) => ({ ...n, ...i })))
        : r.push(n);
  });
  for (let n = 0; n < r.length; n++) (await Rn(this.config), await BO(this, r[n]));
  this.system.pointer.resetClickCount();
}
o(FO, 'pointer');
async function BO(e, t) {
  var r, n;
  const i =
      'pointerName' in t && t.pointerName
        ? t.pointerName
        : 'keyDef' in t
          ? e.system.pointer.getPointerName(t.keyDef)
          : 'mouse',
    s = e.system.pointer.getPreviousPosition(i);
  var a, c, d, u;
  const p = {
    target: (a = t.target) !== null && a !== void 0 ? a : JO(e, s),
    coords: (c = t.coords) !== null && c !== void 0 ? c : s?.coords,
    caret: {
      node:
        (d = t.node) !== null && d !== void 0
          ? d
          : _d(t) || s == null || (r = s.caret) === null || r === void 0
            ? void 0
            : r.node,
      offset:
        (u = t.offset) !== null && u !== void 0
          ? u
          : _d(t) || s == null || (n = s.caret) === null || n === void 0
            ? void 0
            : n.offset,
    },
  };
  'keyDef' in t
    ? (e.system.pointer.isKeyPressed(t.keyDef) &&
        (Vn(e, Pt.Trigger), await e.system.pointer.release(e, t.keyDef, p)),
      t.releasePrevious ||
        (Vn(e, Pt.Trigger),
        await e.system.pointer.press(e, t.keyDef, p),
        t.releaseSelf && (Vn(e, Pt.Trigger), await e.system.pointer.release(e, t.keyDef, p))))
    : (Vn(e, Pt.Trigger), await e.system.pointer.move(e, i, p));
}
o(BO, 'pointerAction');
function _d(e) {
  var t, r;
  return !!((r = (t = e.target) !== null && t !== void 0 ? t : e.node) !== null && r !== void 0
    ? r
    : e.offset !== void 0);
}
o(_d, 'hasCaretPosition');
function JO(e, t) {
  if (!t) throw new Error('This pointer has no previous position. Provide a target property!');
  var r;
  return (r = t.target) !== null && r !== void 0 ? r : e.config.document.body;
}
o(JO, 'getPrevTarget');
async function $O(e) {
  if (!wn(e) || or(e)) throw new Error('clear()` is only supported on editable elements.');
  if ((Rr(e), e.ownerDocument.activeElement !== e))
    throw new Error('The element to be cleared could not be focused.');
  if ((vy(e), !JA(e))) throw new Error('The element content to be cleared could not be selected.');
  _n(this, e, '', 'deleteContentBackward');
}
o($O, 'clear');
async function UO(e, t) {
  return My.call(this, !0, e, t);
}
o(UO, 'selectOptions');
async function VO(e, t) {
  return My.call(this, !1, e, t);
}
o(VO, 'deselectOptions');
async function My(e, t, r) {
  if (!e && !t.multiple)
    throw Te().getElementError(
      'Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.',
      t,
    );
  const n = Array.isArray(r) ? r : [r],
    i = Array.from(t.querySelectorAll('option, [role="option"]')),
    s = n
      .map((c) => {
        if (typeof c != 'string' && i.includes(c)) return c;
        {
          const d = i.find((u) => u.value === c || u.innerHTML === c);
          if (d) return d;
          throw Te().getElementError(`Value "${String(c)}" not found in options`, t);
        }
      })
      .filter((c) => !or(c));
  if (or(t) || !s.length) return;
  const a = o((c) => {
    ((c.selected = e),
      this.dispatchUIEvent(t, 'input', { bubbles: !0, cancelable: !1, composed: !0 }),
      this.dispatchUIEvent(t, 'change'));
  }, 'selectOption');
  if (he(t, 'select'))
    if (t.multiple)
      for (const c of s) {
        const d = this.config.pointerEventsCheck === 0 ? !0 : Wi(this, c);
        (d &&
          (this.dispatchUIEvent(c, 'pointerover'),
          this.dispatchUIEvent(t, 'pointerenter'),
          this.dispatchUIEvent(c, 'mouseover'),
          this.dispatchUIEvent(t, 'mouseenter'),
          this.dispatchUIEvent(c, 'pointermove'),
          this.dispatchUIEvent(c, 'mousemove'),
          this.dispatchUIEvent(c, 'pointerdown'),
          this.dispatchUIEvent(c, 'mousedown')),
          Rr(t),
          d && (this.dispatchUIEvent(c, 'pointerup'), this.dispatchUIEvent(c, 'mouseup')),
          a(c),
          d && this.dispatchUIEvent(c, 'click'),
          await Rn(this.config));
      }
    else if (s.length === 1) {
      const c = this.config.pointerEventsCheck === 0 ? !0 : Wi(this, t);
      (c ? await this.click(t) : Rr(t),
        a(s[0]),
        c &&
          (this.dispatchUIEvent(t, 'pointerover'),
          this.dispatchUIEvent(t, 'pointerenter'),
          this.dispatchUIEvent(t, 'mouseover'),
          this.dispatchUIEvent(t, 'mouseenter'),
          this.dispatchUIEvent(t, 'pointerup'),
          this.dispatchUIEvent(t, 'mouseup'),
          this.dispatchUIEvent(t, 'click')),
        await Rn(this.config));
    } else throw Te().getElementError('Cannot select multiple options on a non-multiple select', t);
  else if (t.getAttribute('role') === 'listbox')
    for (const c of s) (await this.click(c), await this.unhover(c));
  else
    throw Te().getElementError(
      'Cannot select options on elements that are neither select nor listbox elements',
      t,
    );
}
o(My, 'selectOptionsBase');
async function HO(
  e,
  t,
  {
    skipClick: r = this.config.skipClick,
    skipAutoClose: n = this.config.skipAutoClose,
    initialSelectionStart: i,
    initialSelectionEnd: s,
  } = {},
) {
  e.disabled ||
    (r || (await this.click(e)),
    i !== void 0 && Un(e, i, s ?? i),
    await this.keyboard(t),
    n || (await MO(this)));
}
o(HO, 'type');
var Tg = Symbol('files and value properties are mocked');
function Fs(e, t, r) {
  r ? Object.defineProperty(e, t, r) : delete e[t];
}
o(Fs, 'restoreProperty');
function GO(e, t) {
  var r;
  (r = e[Tg]) === null || r === void 0 || r.restore();
  const n = Object.getOwnPropertyDescriptor(e, 'type'),
    i = Object.getOwnPropertyDescriptor(e, 'value'),
    s = Object.getOwnPropertyDescriptor(e, 'files');
  function a() {
    (Fs(e, 'type', n), Fs(e, 'value', i), Fs(e, 'files', s));
  }
  (o(a, 'restore'),
    (e[Tg] = { restore: a }),
    Object.defineProperties(e, {
      files: { configurable: !0, get: o(() => t, 'get') },
      value: {
        configurable: !0,
        get: o(() => (t.length ? `C:\\fakepath\\${t[0].name}` : ''), 'get'),
        set(c) {
          if (c === '') a();
          else {
            var d;
            i == null || (d = i.set) === null || d === void 0 || d.call(e, c);
          }
        },
      },
      type: {
        configurable: !0,
        get: o(() => 'file', 'get'),
        set(c) {
          c !== 'file' && (a(), (e.type = c));
        },
      },
    }));
}
o(GO, 'setFiles');
async function zO(e, t) {
  const r = he(e, 'label') ? e.control : e;
  if (!r || !he(r, 'input', { type: 'file' }))
    throw new TypeError(
      `The ${r === e ? 'given' : 'associated'} ${r?.tagName} element does not accept file uploads`,
    );
  if (or(e)) return;
  const n = (Array.isArray(t) ? t : [t])
      .filter((s) => !this.config.applyAccept || WO(s, r.accept))
      .slice(0, r.multiple ? void 0 : 1),
    i = o(() => {
      var s;
      (n.length === ((s = r.files) === null || s === void 0 ? void 0 : s.length) &&
        n.every((a, c) => {
          var d;
          return a === ((d = r.files) === null || d === void 0 ? void 0 : d.item(c));
        })) ||
        (GO(r, zl(xt(e), n)), this.dispatchUIEvent(r, 'input'), this.dispatchUIEvent(r, 'change'));
    }, 'fileDialog');
  (r.addEventListener('fileDialog', i),
    await this.click(e),
    r.removeEventListener('fileDialog', i));
}
o(zO, 'upload');
function yi(e) {
  return e.toLowerCase().replace(/(\.|\/)jpg\b/g, '$1jpeg');
}
o(yi, 'normalize');
function WO(e, t) {
  if (!t) return !0;
  const r = ['audio/*', 'image/*', 'video/*'];
  return yi(t)
    .trim()
    .split(/\s*,\s*/)
    .some((n) =>
      n.startsWith('.')
        ? yi(e.name).endsWith(n)
        : r.includes(n)
          ? yi(e.type).startsWith(n.replace('*', ''))
          : yi(e.type) === n,
    );
}
o(WO, 'isAcceptableFile');
var wg = {
  click: TO,
  dblClick: wO,
  tripleClick: SO,
  hover: _O,
  unhover: RO,
  tab: PO,
  keyboard: NO,
  copy: jO,
  cut: kO,
  paste: DO,
  pointer: FO,
  clear: $O,
  deselectOptions: VO,
  selectOptions: UO,
  type: HO,
  upload: zO,
};
function KO(e) {
  return Te().asyncWrapper(e);
}
o(KO, 'wrapAsync');
var YO = {
    applyAccept: !0,
    autoModify: !0,
    delay: 0,
    document: globalThis.document,
    keyboardMap: PJ,
    pointerMap: AJ,
    pointerEventsCheck: Ls.EachApiCall,
    skipAutoClose: !1,
    skipClick: !1,
    skipHover: !1,
    writeToClipboard: !1,
    advanceTimers: o(() => Promise.resolve(), 'advanceTimers'),
  },
  IJ = { ...YO, writeToClipboard: !0 };
function qy(e = {}, t = IJ, r) {
  const n = eC(e, r, t);
  return { ...t, ...e, document: n };
}
o(qy, 'createConfig');
function XO(e = {}) {
  const t = qy(e);
  (_y(t.document), Sy(xt(t.document).HTMLElement));
  var r;
  const n = (r = t.document.defaultView) !== null && r !== void 0 ? r : globalThis.window;
  return (rA(n), Zl(t).api);
}
o(XO, 'setupMain');
function ut({ keyboardState: e, pointerState: t, ...r } = {}, n) {
  const i = qy(r, YO, n);
  (_y(i.document), Sy(xt(i.document).HTMLElement));
  var s;
  const a = (s = t ?? e) !== null && s !== void 0 ? s : new EO();
  return { api: Zl(i, a).api, system: a };
}
o(ut, 'setupDirect');
function QO(e) {
  return Zl({ ...this.config, ...e }, this.system).api;
}
o(QO, 'setupSub');
function ZO(e, t) {
  function r(...n) {
    return (Vn(e, Pt.Call), KO(() => t.apply(e, n).then(async (i) => (await Rn(e.config), i))));
  }
  return (o(r, 'method'), Object.defineProperty(r, 'name', { get: o(() => t.name, 'get') }), r);
}
o(ZO, 'wrapAndBindImpl');
function Zl(e, t = new EO()) {
  const r = {};
  return (
    Object.assign(r, {
      config: e,
      dispatchEvent: wy.bind(r),
      dispatchUIEvent: XA.bind(r),
      system: t,
      levelRefs: {},
      ...wg,
    }),
    {
      instance: r,
      api: {
        ...Object.fromEntries(Object.entries(wg).map(([n, i]) => [n, ZO(r, i)])),
        setup: QO.bind(r),
      },
    }
  );
}
o(Zl, 'createInstance');
function eC(e, t, r) {
  var n, i;
  return (i = (n = e.document) !== null && n !== void 0 ? n : t && rO(t)) !== null && i !== void 0
    ? i
    : r.document;
}
o(eC, 'getDocument');
var tC = {};
Et(tC, {
  clear: () => rC,
  click: () => nC,
  copy: () => oC,
  cut: () => iC,
  dblClick: () => sC,
  deselectOptions: () => aC,
  hover: () => lC,
  keyboard: () => cC,
  paste: () => dC,
  pointer: () => uC,
  selectOptions: () => pC,
  tab: () => gC,
  tripleClick: () => fC,
  type: () => mC,
  unhover: () => yC,
  upload: () => hC,
});
function rC(e) {
  return ut().api.clear(e);
}
o(rC, 'clear');
function nC(e, t = {}) {
  return ut(t, e).api.click(e);
}
o(nC, 'click');
function oC(e = {}) {
  return ut(e).api.copy();
}
o(oC, 'copy');
function iC(e = {}) {
  return ut(e).api.cut();
}
o(iC, 'cut');
function sC(e, t = {}) {
  return ut(t).api.dblClick(e);
}
o(sC, 'dblClick');
function aC(e, t, r = {}) {
  return ut(r).api.deselectOptions(e, t);
}
o(aC, 'deselectOptions');
function lC(e, t = {}) {
  return ut(t).api.hover(e);
}
o(lC, 'hover');
async function cC(e, t = {}) {
  const { api: r, system: n } = ut(t);
  return r.keyboard(e).then(() => n);
}
o(cC, 'keyboard');
async function uC(e, t = {}) {
  const { api: r, system: n } = ut(t);
  return r.pointer(e).then(() => n);
}
o(uC, 'pointer');
function dC(e, t) {
  return ut(t).api.paste(e);
}
o(dC, 'paste');
function pC(e, t, r = {}) {
  return ut(r).api.selectOptions(e, t);
}
o(pC, 'selectOptions');
function fC(e, t = {}) {
  return ut(t).api.tripleClick(e);
}
o(fC, 'tripleClick');
function mC(e, t, r = {}) {
  return ut(r, e).api.type(e, t, r);
}
o(mC, 'type');
function yC(e, t = {}) {
  const { api: r, system: n } = ut(t);
  return (n.pointer.setMousePosition({ target: e }), r.unhover(e));
}
o(yC, 'unhover');
function hC(e, t, r = {}) {
  return ut(r).api.upload(e, t);
}
o(hC, 'upload');
function gC(e = {}) {
  return ut().api.tab(e);
}
o(gC, 'tab');
var bC = { ...tC, setup: XO },
  Rd = To(
    { ...C0 },
    {
      getKeys: o((e) => Object.keys(e).filter((t) => t !== 'eventWrapper'), 'getKeys'),
      intercept: o(
        (e, t) => t[0] === 'fireEvent' || e.startsWith('find') || e.startsWith('waitFor'),
        'intercept',
      ),
    },
  );
Rd.screen = new Proxy(Rd.screen, {
  get(e, t, r) {
    return (
      typeof window < 'u' &&
        globalThis.location?.href?.includes('viewMode=docs') &&
        Ve.warn(ve`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `),
      Reflect.get(e, t, r)
    );
  },
});
var {
    buildQueries: MJ,
    configure: qJ,
    createEvent: jJ,
    fireEvent: kJ,
    findAllByAltText: DJ,
    findAllByDisplayValue: LJ,
    findAllByLabelText: FJ,
    findAllByPlaceholderText: BJ,
    findAllByRole: JJ,
    findAllByTestId: $J,
    findAllByText: UJ,
    findAllByTitle: VJ,
    findByAltText: HJ,
    findByDisplayValue: GJ,
    findByLabelText: zJ,
    findByPlaceholderText: WJ,
    findByRole: KJ,
    findByTestId: YJ,
    findByText: XJ,
    findByTitle: QJ,
    getAllByAltText: ZJ,
    getAllByDisplayValue: e$,
    getAllByLabelText: t$,
    getAllByPlaceholderText: r$,
    getAllByRole: n$,
    getAllByTestId: o$,
    getAllByText: i$,
    getAllByTitle: s$,
    getByAltText: a$,
    getByDisplayValue: l$,
    getByLabelText: c$,
    getByPlaceholderText: u$,
    getByRole: d$,
    getByTestId: p$,
    getByText: f$,
    getByTitle: m$,
    getConfig: y$,
    getDefaultNormalizer: h$,
    getElementError: g$,
    getNodeText: b$,
    getQueriesForElement: v$,
    getRoles: E$,
    getSuggestedQuery: T$,
    isInaccessible: w$,
    logDOM: S$,
    logRoles: _$,
    prettyDOM: R$,
    queries: P$,
    queryAllByAltText: A$,
    queryAllByAttribute: O$,
    queryAllByDisplayValue: C$,
    queryAllByLabelText: x$,
    queryAllByPlaceholderText: N$,
    queryAllByRole: I$,
    queryAllByTestId: M$,
    queryAllByText: q$,
    queryAllByTitle: j$,
    queryByAltText: k$,
    queryByAttribute: D$,
    queryByDisplayValue: L$,
    queryByLabelText: F$,
    queryByPlaceholderText: B$,
    queryByRole: J$,
    queryByTestId: $$,
    queryByText: U$,
    queryByTitle: V$,
    queryHelpers: H$,
    screen: G$,
    waitFor: z$,
    waitForElementToBeRemoved: W$,
    within: vC,
    prettyFormat: K$,
  } = Rd,
  EC = bC,
  { userEvent: Y$ } = To(
    { userEvent: bC },
    {
      intercept: !0,
      getKeys: o((e) => Object.keys(e).filter((t) => t !== 'eventWrapper'), 'getKeys'),
    },
  ),
  { expect: X$ } = To(
    { expect: P0 },
    {
      getKeys: o((e, t) => {
        if ('constructor' in e && e.constructor === q) {
          const r = ['assert', '__methods', '__flags', '_obj'],
            n = Object.keys(Object.getPrototypeOf(e)).filter((i) => !r.includes(i));
          return t > 2 ? n : [...n, 'not'];
        }
        return 'any' in e ? Object.keys(e).filter((r) => r !== 'any') : Object.keys(e);
      }, 'getKeys'),
      mutate: !0,
      intercept: o((e) => e !== 'expect', 'intercept'),
    },
  ),
  Q$ = { mock: o(() => {}, 'mock') },
  Sg = !1,
  Z$ = o((e) => {
    const { parameters: t } = e;
    t?.actions?.disable ||
      Sg ||
      (Nm((r, n) => {
        const i = r.getMockName();
        i !== 'spy' &&
          i !== 'vi.fn()' &&
          (!/^next\/.*::/.test(i) ||
            [
              'next/router::useRouter()',
              'next/navigation::useRouter()',
              'next/navigation::redirect',
              'next/cache::',
              'next/headers::cookies().set',
              'next/headers::cookies().delete',
              'next/headers::headers().set',
              'next/headers::headers().delete',
            ].some((s) => i.startsWith(s))) &&
          No(i)(n);
      }),
      (Sg = !0));
  }, 'logActionsWhenMockCalled'),
  eU = [Z$],
  _g = o(() => ({ ...iT, ...aT }), 'default'),
  Ca = 'backgrounds',
  tU = { light: { name: 'light', value: '#F8F8F8' }, dark: { name: 'dark', value: '#333' } },
  { document: Vt } = globalThis,
  rU = o(
    () =>
      globalThis?.matchMedia
        ? !!globalThis.matchMedia('(prefers-reduced-motion: reduce)')?.matches
        : !1,
    'isReduceMotionEnabled',
  ),
  Rg = o((e) => {
    (Array.isArray(e) ? e : [e]).forEach(nU);
  }, 'clearStyles'),
  nU = o((e) => {
    if (!Vt) return;
    const t = Vt.getElementById(e);
    t && t.parentElement && t.parentElement.removeChild(t);
  }, 'clearStyle'),
  oU = o((e, t) => {
    if (!Vt) return;
    const r = Vt.getElementById(e);
    if (r) r.innerHTML !== t && (r.innerHTML = t);
    else {
      const n = Vt.createElement('style');
      (n.setAttribute('id', e), (n.innerHTML = t), Vt.head.appendChild(n));
    }
  }, 'addGridStyle'),
  iU = o((e, t, r) => {
    if (!Vt) return;
    const n = Vt.getElementById(e);
    if (n) n.innerHTML !== t && (n.innerHTML = t);
    else {
      const i = Vt.createElement('style');
      (i.setAttribute('id', e), (i.innerHTML = t));
      const s = `addon-backgrounds-grid${r ? `-docs-${r}` : ''}`,
        a = Vt.getElementById(s);
      a ? a.parentElement?.insertBefore(i, a) : Vt.head.appendChild(i);
    }
  }, 'addBackgroundStyle'),
  sU = { cellSize: 100, cellAmount: 10, opacity: 0.8 },
  Pg = 'addon-backgrounds',
  Ag = 'addon-backgrounds-grid',
  aU = rU() ? '' : 'transition: background-color 0.3s;',
  lU = o((e, t) => {
    const { globals: r = {}, parameters: n = {}, viewMode: i, id: s } = t,
      { options: a = tU, disable: c, grid: d = sU } = n[Ca] || {},
      u = r[Ca] || {},
      p = typeof u == 'string' ? u : u?.value,
      f = p ? a[p] : void 0,
      y = typeof f == 'string' ? f : f?.value || 'transparent',
      h = typeof u == 'string' ? !1 : u.grid || !1,
      g = !!f && !c,
      T = i === 'docs' ? `#anchor--${s} .docs-story` : '.sb-show-main',
      E = i === 'docs' ? `#anchor--${s} .docs-story` : '.sb-show-main',
      v = n.layout === void 0 || n.layout === 'padded',
      S = i === 'docs' ? 20 : v ? 16 : 0,
      { cellAmount: A, cellSize: N, opacity: j, offsetX: C = S, offsetY: R = S } = d,
      w = i === 'docs' ? `${Pg}-docs-${s}` : `${Pg}-color`,
      _ = i === 'docs' ? s : null;
    $r(() => {
      const I = `
    ${T} {
      background: ${y} !important;
      ${aU}
      }`;
      if (!g) {
        Rg(w);
        return;
      }
      iU(w, I, _);
    }, [T, w, _, g, y]);
    const k = i === 'docs' ? `${Ag}-docs-${s}` : `${Ag}`;
    return (
      $r(() => {
        if (!h) {
          Rg(k);
          return;
        }
        const I = [
            `${N * A}px ${N * A}px`,
            `${N * A}px ${N * A}px`,
            `${N}px ${N}px`,
            `${N}px ${N}px`,
          ].join(', '),
          V = `
        ${E} {
          background-size: ${I} !important;
          background-position: ${C}px ${R}px, ${C}px ${R}px, ${C}px ${R}px, ${C}px ${R}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${j}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${j}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${j / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${j / 2}) 1px, transparent 1px) !important;
        }
      `;
        oU(k, V);
      }, [A, N, E, k, h, C, R, j]),
      e()
    );
  }, 'withBackgroundAndGrid'),
  cU = globalThis.FEATURES?.backgrounds ? [lU] : [],
  uU = { [Ca]: { grid: { cellSize: 20, opacity: 0.5, cellAmount: 5 }, disable: !1 } },
  dU = { [Ca]: { value: void 0, grid: !1 } },
  Og = o(() => ({ decorators: cU, parameters: uU, initialGlobals: dU }), 'default'),
  { step: pU } = To({ step: o(async (e, t, r) => t(r), 'step') }, { intercept: !0 }),
  Cg = o(() => ({ parameters: { throwPlayFunctionExceptions: !1 }, runStep: pU }), 'default'),
  ec = 'storybook/highlight',
  fU = `${ec}/add`,
  mU = `${ec}/remove`,
  yU = `${ec}/reset`,
  hU = `${ec}/scroll-into-view`,
  xg = 2147483647,
  qr = 28,
  Ng = {
    chevronLeft: [
      'M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z',
    ],
    chevronRight: [
      'M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z',
    ],
    info: [
      'M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z',
      'M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z',
    ],
    shareAlt: [
      'M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z',
      'M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z',
    ],
  },
  gU = 'svg,path,rect,circle,line,polyline,polygon,ellipse,text'.split(','),
  et = o((e, t = {}, r) => {
    const n = gU.includes(e)
      ? document.createElementNS('http://www.w3.org/2000/svg', e)
      : document.createElement(e);
    return (
      Object.entries(t).forEach(([i, s]) => {
        /[A-Z]/.test(i)
          ? (i === 'onClick' &&
              (n.addEventListener('click', s),
              n.addEventListener('keydown', (a) => {
                (a.key === 'Enter' || a.key === ' ') && (a.preventDefault(), s());
              })),
            i === 'onMouseEnter' && n.addEventListener('mouseenter', s),
            i === 'onMouseLeave' && n.addEventListener('mouseleave', s))
          : n.setAttribute(i, s);
      }),
      r?.forEach((i) => {
        if (!(i == null || i === !1))
          try {
            n.appendChild(i);
          } catch {
            n.appendChild(document.createTextNode(String(i)));
          }
      }),
      n
    );
  }, 'createElement'),
  ws = o(
    (e) =>
      Ng[e] &&
      et(
        'svg',
        { width: '14', height: '14', viewBox: '0 0 14 14', xmlns: 'http://www.w3.org/2000/svg' },
        Ng[e].map((t) =>
          et('path', {
            fill: 'currentColor',
            'fill-rule': 'evenodd',
            'clip-rule': 'evenodd',
            d: t,
          }),
        ),
      ),
    'createIcon',
  ),
  bU = o((e) => {
    if ('elements' in e) {
      const { elements: n, color: i, style: s } = e;
      return {
        id: void 0,
        priority: 0,
        selectors: n,
        styles: {
          outline: `2px ${s} ${i}`,
          outlineOffset: '2px',
          boxShadow: '0 0 0 6px rgba(255,255,255,0.6)',
        },
        menu: void 0,
      };
    }
    const { menu: t, ...r } = e;
    return {
      id: void 0,
      priority: 0,
      styles: { outline: '2px dashed #029cfd' },
      ...r,
      menu: Array.isArray(t) ? (t.every(Array.isArray) ? t : [t]) : void 0,
    };
  }, 'normalizeOptions'),
  vU = o((e) => e instanceof Function, 'isFunction'),
  ai = new Map(),
  nn = new Map(),
  Ss = new Map(),
  fr = o((e) => {
    const t = Symbol();
    return (
      nn.set(t, []),
      ai.set(t, e),
      {
        get: o(() => ai.get(t), 'get'),
        set: o((a) => {
          const c = ai.get(t),
            d = vU(a) ? a(c) : a;
          d !== c &&
            (ai.set(t, d),
            nn.get(t)?.forEach((u) => {
              (Ss.get(u)?.(), Ss.set(u, u(d)));
            }));
        }, 'set'),
        subscribe: o(
          (a) => (
            nn.get(t)?.push(a),
            () => {
              const c = nn.get(t);
              c &&
                nn.set(
                  t,
                  c.filter((d) => d !== a),
                );
            }
          ),
          'subscribe',
        ),
        teardown: o(() => {
          (nn.get(t)?.forEach((a) => {
            (Ss.get(a)?.(), Ss.delete(a));
          }),
            nn.delete(t),
            ai.delete(t));
        }, 'teardown'),
      }
    );
  }, 'useStore'),
  Ig = o((e) => {
    const t = document.getElementById('storybook-root'),
      r = new Map();
    for (const n of e) {
      const { priority: i = 0 } = n;
      for (const s of n.selectors) {
        const a = [
          ...document.querySelectorAll(
            `:is(${s}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`,
          ),
          ...(t?.querySelectorAll(s) || []),
        ];
        for (const c of a) {
          const d = r.get(c);
          (!d || d.priority <= i) &&
            r.set(c, {
              ...n,
              priority: i,
              selectors: Array.from(new Set((d?.selectors || []).concat(s))),
            });
        }
      }
    }
    return r;
  }, 'mapElements'),
  EU = o(
    (e) =>
      Array.from(e.entries())
        .map(([t, { selectors: r, styles: n, hoverStyles: i, focusStyles: s, menu: a }]) => {
          const { top: c, left: d, width: u, height: p } = t.getBoundingClientRect(),
            { position: f } = getComputedStyle(t);
          return {
            element: t,
            selectors: r,
            styles: n,
            hoverStyles: i,
            focusStyles: s,
            menu: a,
            top: f === 'fixed' ? c : c + window.scrollY,
            left: f === 'fixed' ? d : d + window.scrollX,
            width: u,
            height: p,
          };
        })
        .sort((t, r) => r.width * r.height - t.width * t.height),
    'mapBoxes',
  ),
  Mg = o((e, t) => {
    const r = e.getBoundingClientRect(),
      { x: n, y: i } = t;
    return (
      r?.top &&
      r?.left &&
      n >= r.left &&
      n <= r.left + r.width &&
      i >= r.top &&
      i <= r.top + r.height
    );
  }, 'isOverMenu'),
  qg = o((e, t, r) => {
    if (!t || !r) return !1;
    let { left: n, top: i, width: s, height: a } = e;
    (a < qr && ((i = i - Math.round((qr - a) / 2)), (a = qr)),
      s < qr && ((n = n - Math.round((qr - s) / 2)), (s = qr)),
      t.style.position === 'fixed' && ((n += window.scrollX), (i += window.scrollY)));
    const { x: c, y: d } = r;
    return c >= n && c <= n + s && d >= i && d <= i + a;
  }, 'isTargeted'),
  TU = o((e, t, r = {}) => {
    const { x: n, y: i } = t,
      { margin: s = 5, topOffset: a = 0, centered: c = !1 } = r,
      { scrollX: d, scrollY: u, innerHeight: p, innerWidth: f } = window,
      y = Math.min(e.style.position === 'fixed' ? i - u : i, p - e.clientHeight - s - a + u),
      h = c ? e.clientWidth / 2 : 0,
      g =
        e.style.position === 'fixed'
          ? Math.max(Math.min(n - d, f - h - s), h + s)
          : Math.max(Math.min(n, f - h - s + d), h + s + d);
    Object.assign(e.style, {
      ...(g !== n && { left: `${g}px` }),
      ...(y !== i && { top: `${y}px` }),
    });
  }, 'keepInViewport'),
  jg = o((e) => {
    window.HTMLElement.prototype.hasOwnProperty('showPopover') && e.showPopover();
  }, 'showPopover'),
  wU = o((e) => {
    window.HTMLElement.prototype.hasOwnProperty('showPopover') && e.hidePopover();
  }, 'hidePopover'),
  SU = o(
    (e) => ({
      top: e.top,
      left: e.left,
      width: e.width,
      height: e.height,
      selectors: e.selectors,
      element: {
        attributes: Object.fromEntries(
          Array.from(e.element.attributes).map((t) => [t.name, t.value]),
        ),
        localName: e.element.localName,
        tagName: e.element.tagName,
        outerHTML: e.element.outerHTML,
      },
    }),
    'getEventDetails',
  ),
  qe = 'storybook-highlights-menu',
  kg = 'storybook-highlights-root',
  _U = 'storybook-root',
  RU = o((e) => {
    if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED) return;
    globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
    const { document: t } = globalThis,
      r = fr([]),
      n = fr(new Map()),
      i = fr([]),
      s = fr(),
      a = fr(),
      c = fr([]),
      d = fr([]),
      u = fr(),
      p = fr();
    let f = t.getElementById(kg);
    (r.subscribe(() => {
      f || ((f = et('div', { id: kg })), t.body.appendChild(f));
    }),
      r.subscribe((R) => {
        const w = t.getElementById(_U);
        if (!w) return;
        n.set(Ig(R));
        const _ = new MutationObserver(() => n.set(Ig(R)));
        return (
          _.observe(w, { subtree: !0, childList: !0 }),
          () => {
            _.disconnect();
          }
        );
      }),
      n.subscribe((R) => {
        const w = o(() => requestAnimationFrame(() => i.set(EU(R))), 'updateBoxes'),
          _ = new ResizeObserver(w);
        (_.observe(t.body), Array.from(R.keys()).forEach((I) => _.observe(I)));
        const k = Array.from(t.body.querySelectorAll('*')).filter((I) => {
          const { overflow: V, overflowX: H, overflowY: P } = window.getComputedStyle(I);
          return ['auto', 'scroll'].some((L) => [V, H, P].includes(L));
        });
        return (
          k.forEach((I) => I.addEventListener('scroll', w)),
          () => {
            (_.disconnect(), k.forEach((I) => I.removeEventListener('scroll', w)));
          }
        );
      }),
      n.subscribe((R) => {
        const w = Array.from(R.keys()).filter(({ style: k }) => k.position === 'sticky'),
          _ = o(
            () =>
              requestAnimationFrame(() => {
                i.set((k) =>
                  k.map((I) => {
                    if (w.includes(I.element)) {
                      const { top: V, left: H } = I.element.getBoundingClientRect();
                      return { ...I, top: V + window.scrollY, left: H + window.scrollX };
                    }
                    return I;
                  }),
                );
              }),
            'updateBoxes',
          );
        return (t.addEventListener('scroll', _), () => t.removeEventListener('scroll', _));
      }),
      n.subscribe((R) => {
        c.set((w) => w.filter(({ element: _ }) => R.has(_)));
      }),
      c.subscribe((R) => {
        R.length
          ? (p.set((w) => (R.some((_) => _.element === w?.element) ? w : void 0)),
            u.set((w) => (R.some((_) => _.element === w?.element) ? w : void 0)))
          : (p.set(void 0), u.set(void 0), s.set(void 0));
      }));
    const y = new Map(new Map());
    r.subscribe((R) => {
      (R.forEach(({ keyframes: w }) => {
        if (w) {
          let _ = y.get(w);
          (_ ||
            ((_ = t.createElement('style')),
            _.setAttribute('data-highlight', 'keyframes'),
            y.set(w, _),
            t.head.appendChild(_)),
            (_.innerHTML = w));
        }
      }),
        y.forEach((w, _) => {
          R.some((k) => k.keyframes === _) || (w.remove(), y.delete(_));
        }));
    });
    const h = new Map(new Map());
    (i.subscribe((R) => {
      (R.forEach((w) => {
        let _ = h.get(w.element);
        if (f && !_) {
          const k = {
            popover: 'manual',
            'data-highlight-dimensions': `w${w.width.toFixed(0)}h${w.height.toFixed(0)}`,
            'data-highlight-coordinates': `x${w.left.toFixed(0)}y${w.top.toFixed(0)}`,
          };
          ((_ = f.appendChild(et('div', k, [et('div')]))), h.set(w.element, _));
        }
      }),
        h.forEach((w, _) => {
          R.some(({ element: k }) => k === _) || (w.remove(), h.delete(_));
        }));
    }),
      i.subscribe((R) => {
        const w = R.filter((k) => k.menu);
        if (!w.length) return;
        const _ = o((k) => {
          requestAnimationFrame(() => {
            const I = t.getElementById(qe),
              V = { x: k.pageX, y: k.pageY };
            if (I && !Mg(I, V)) {
              const H = w.filter((P) => {
                const L = h.get(P.element);
                return qg(P, L, V);
              });
              (s.set(H.length ? V : void 0), c.set(H));
            }
          });
        }, 'onClick');
        return (t.addEventListener('click', _), () => t.removeEventListener('click', _));
      }));
    const g = o(() => {
      const R = t.getElementById(qe),
        w = a.get();
      !w ||
        (R && Mg(R, w)) ||
        d.set((_) => {
          const k = i.get().filter((P) => {
              const L = h.get(P.element);
              return qg(P, L, w);
            }),
            I = _.filter((P) => k.includes(P)),
            V = k.filter((P) => !_.includes(P)),
            H = _.length - I.length;
          return V.length || H ? [...I, ...V] : _;
        });
    }, 'updateHovered');
    (a.subscribe(g), i.subscribe(g));
    const T = o(() => {
      const R = p.get(),
        w = R ? [R] : c.get(),
        _ = w.length === 1 ? w[0] : u.get(),
        k = s.get() !== void 0;
      i.get().forEach((I) => {
        const V = h.get(I.element);
        if (V) {
          const H = _ === I,
            P = k ? (_ ? H : w.includes(I)) : d.get()?.includes(I);
          (Object.assign(V.style, {
            animation: 'none',
            background: 'transparent',
            border: 'none',
            boxSizing: 'border-box',
            outline: 'none',
            outlineOffset: '0px',
            ...I.styles,
            ...(P ? I.hoverStyles : {}),
            ...(H ? I.focusStyles : {}),
            position: getComputedStyle(I.element).position === 'fixed' ? 'fixed' : 'absolute',
            zIndex: xg - 10,
            top: `${I.top}px`,
            left: `${I.left}px`,
            width: `${I.width}px`,
            height: `${I.height}px`,
            margin: 0,
            padding: 0,
            cursor: I.menu && P ? 'pointer' : 'default',
            pointerEvents: I.menu ? 'auto' : 'none',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            overflow: 'visible',
          }),
            Object.assign(V.children[0].style, {
              width: '100%',
              height: '100%',
              minHeight: `${qr}px`,
              minWidth: `${qr}px`,
              boxSizing: 'content-box',
              padding: V.style.outlineWidth || '0px',
            }),
            jg(V));
        }
      });
    }, 'updateBoxStyles');
    (i.subscribe(T), c.subscribe(T), d.subscribe(T), u.subscribe(T), p.subscribe(T));
    const E = o(() => {
      if (!f) return;
      let R = t.getElementById(qe);
      if (R) R.innerHTML = '';
      else {
        const I = { id: qe, popover: 'manual' };
        ((R = f.appendChild(et('div', I))),
          f.appendChild(
            et('style', {}, [
              `
            #${qe} {
              position: absolute;
              z-index: ${xg};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${qe} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${qe} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${qe} li {
              padding: 0 4px;
              margin: 0;
            }
            #${qe} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${qe} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${qe} button:focus-visible {
              outline-color: #029CFD;
            }
            #${qe} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${qe} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${qe} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${qe} li > button:hover svg, #${qe} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${qe} .element-list li svg {
              display: none;
            }
            #${qe} li.selectable svg, #${qe} li.selected svg {
              display: block;
            }
            #${qe} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${qe} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${qe} .menu-items, #${qe} .menu-items li {
              padding: 0;
            }
            #${qe} .menu-item {
              display: flex;
            }
            #${qe} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `,
            ]),
          ));
      }
      const w = p.get(),
        _ = w ? [w] : c.get();
      if (
        (_.length &&
          ((R.style.position =
            getComputedStyle(_[0].element).position === 'fixed' ? 'fixed' : 'absolute'),
          R.appendChild(
            et(
              'ul',
              { class: 'element-list' },
              _.map((I) => {
                const V =
                    _.length > 1 &&
                    !!I.menu?.some((L) =>
                      L.some(
                        (B) => !B.selectors || B.selectors.some((D) => I.selectors.includes(D)),
                      ),
                    ),
                  H = V
                    ? {
                        class: 'selectable',
                        onClick: o(() => p.set(I), 'onClick'),
                        onMouseEnter: o(() => u.set(I), 'onMouseEnter'),
                        onMouseLeave: o(() => u.set(void 0), 'onMouseLeave'),
                      }
                    : w
                      ? { class: 'selected', onClick: o(() => p.set(void 0), 'onClick') }
                      : {},
                  P = V || w;
                return et('li', H, [
                  et(P ? 'button' : 'div', P ? { type: 'button' } : {}, [
                    w ? ws('chevronLeft') : null,
                    et('code', {}, [I.element.outerHTML]),
                    V ? ws('chevronRight') : null,
                  ]),
                ]);
              }),
            ),
          )),
        p.get() || c.get().length === 1)
      ) {
        const I = p.get() || c.get()[0],
          V = I.menu?.filter((H) =>
            H.some((P) => !P.selectors || P.selectors.some((L) => I.selectors.includes(L))),
          );
        V?.length &&
          R.appendChild(
            et(
              'ul',
              { class: 'menu-list' },
              V.map((H) =>
                et('li', {}, [
                  et(
                    'ul',
                    { class: 'menu-items' },
                    H.map(
                      ({
                        id: P,
                        title: L,
                        description: B,
                        iconLeft: D,
                        iconRight: K,
                        clickEvent: X,
                      }) => {
                        const ie = X && (() => e.emit(X, P, SU(I)));
                        return et('li', {}, [
                          et(
                            ie ? 'button' : 'div',
                            ie
                              ? { class: 'menu-item', type: 'button', onClick: ie }
                              : { class: 'menu-item' },
                            [
                              D ? ws(D) : null,
                              et('div', { class: 'menu-item-content' }, [
                                et(B ? 'strong' : 'span', {}, [L]),
                                B && et('span', {}, [B]),
                              ]),
                              K ? ws(K) : null,
                            ],
                          ),
                        ]);
                      },
                    ),
                  ),
                ]),
              ),
            ),
          );
      }
      const k = s.get();
      k
        ? (Object.assign(R.style, {
            display: 'block',
            left: `${R.style.position === 'fixed' ? k.x - window.scrollX : k.x}px`,
            top: `${R.style.position === 'fixed' ? k.y - window.scrollY : k.y}px`,
          }),
          jg(R),
          requestAnimationFrame(() => TU(R, k, { topOffset: 15, centered: !0 })))
        : (wU(R), Object.assign(R.style, { display: 'none' }));
    }, 'renderMenu');
    (c.subscribe(E), p.subscribe(E));
    const v = o((R) => {
        const w = bU(R);
        r.set((_) => {
          const k = w.id ? _.filter((I) => I.id !== w.id) : _;
          return w.selectors?.length ? [...k, w] : k;
        });
      }, 'addHighlight'),
      S = o((R) => {
        R && r.set((w) => w.filter((_) => _.id !== R));
      }, 'removeHighlight'),
      A = o(() => {
        (r.set([]),
          n.set(new Map()),
          i.set([]),
          s.set(void 0),
          a.set(void 0),
          c.set([]),
          d.set([]),
          u.set(void 0),
          p.set(void 0));
      }, 'resetState');
    let N;
    const j = o((R, w) => {
        const _ = 'scrollIntoView-highlight';
        (clearTimeout(N), S(_));
        const k = t.querySelector(R);
        if (!k) {
          console.warn(`Cannot scroll into view: ${R} not found`);
          return;
        }
        k.scrollIntoView({ behavior: 'smooth', block: 'center', ...w });
        const I = `kf-${Math.random().toString(36).substring(2, 15)}`;
        (r.set((V) => [
          ...V,
          {
            id: _,
            priority: 1e3,
            selectors: [R],
            styles: {
              outline: '2px solid #1EA7FD',
              outlineOffset: '-1px',
              animation: `${I} 3s linear forwards`,
            },
            keyframes: `@keyframes ${I} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`,
          },
        ]),
          (N = setTimeout(() => S(_), 3500)));
      }, 'scrollIntoView'),
      C = o((R) => {
        requestAnimationFrame(() => a.set({ x: R.pageX, y: R.pageY }));
      }, 'onMouseMove');
    (t.body.addEventListener('mousemove', C),
      e.on(fU, v),
      e.on(mU, S),
      e.on(yU, A),
      e.on(hU, j),
      e.on(gn, ({ newPhase: R }) => {
        R === 'loading' && A();
      }));
  }, 'useHighlights');
globalThis?.FEATURES?.highlight && Dt?.ready && Dt.ready().then(RU);
var Dg = o(() => ({}), 'default'),
  PU = 'measureEnabled';
function jy() {
  const e = te.document.documentElement,
    t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
o(jy, 'getDocumentWidthAndHeight');
function TC() {
  const e = te.document.createElement('canvas');
  e.id = 'storybook-addon-measure';
  const t = e.getContext('2d');
  rr(t != null);
  const { width: r, height: n } = jy();
  return (
    xa(e, t, { width: r, height: n }),
    (e.style.position = 'absolute'),
    (e.style.left = '0'),
    (e.style.top = '0'),
    (e.style.zIndex = '2147483647'),
    (e.style.pointerEvents = 'none'),
    te.document.body.appendChild(e),
    { canvas: e, context: t, width: r, height: n }
  );
}
o(TC, 'createCanvas');
function xa(e, t, { width: r, height: n }) {
  ((e.style.width = `${r}px`), (e.style.height = `${n}px`));
  const i = te.window.devicePixelRatio;
  ((e.width = Math.floor(r * i)), (e.height = Math.floor(n * i)), t.scale(i, i));
}
o(xa, 'setCanvasWidthAndHeight');
var tt = {};
function wC() {
  tt.canvas || (tt = TC());
}
o(wC, 'init');
function ky() {
  tt.context && tt.context.clearRect(0, 0, tt.width ?? 0, tt.height ?? 0);
}
o(ky, 'clear');
function SC(e) {
  (ky(), e(tt.context));
}
o(SC, 'draw');
function _C() {
  (rr(tt.canvas), rr(tt.context), xa(tt.canvas, tt.context, { width: 0, height: 0 }));
  const { width: e, height: t } = jy();
  (xa(tt.canvas, tt.context, { width: e, height: t }), (tt.width = e), (tt.height = t));
}
o(_C, 'rescale');
function RC() {
  tt.canvas && (ky(), tt.canvas.parentNode?.removeChild(tt.canvas), (tt = {}));
}
o(RC, 'destroy');
var Dn = {
    margin: '#f6b26b',
    border: '#ffe599',
    padding: '#93c47d',
    content: '#6fa8dc',
    text: '#232020',
  },
  wr = 6;
function Pd(e, { x: t, y: r, w: n, h: i, r: s }) {
  ((t = t - n / 2),
    (r = r - i / 2),
    n < 2 * s && (s = n / 2),
    i < 2 * s && (s = i / 2),
    e.beginPath(),
    e.moveTo(t + s, r),
    e.arcTo(t + n, r, t + n, r + i, s),
    e.arcTo(t + n, r + i, t, r + i, s),
    e.arcTo(t, r + i, t, r, s),
    e.arcTo(t, r, t + n, r, s),
    e.closePath());
}
o(Pd, 'roundedRect');
function PC(e, { padding: t, border: r, width: n, height: i, top: s, left: a }) {
  const c = n - r.left - r.right - t.left - t.right,
    d = i - t.top - t.bottom - r.top - r.bottom;
  let u = a + r.left + t.left,
    p = s + r.top + t.top;
  return (
    e === 'top'
      ? (u += c / 2)
      : e === 'right'
        ? ((u += c), (p += d / 2))
        : e === 'bottom'
          ? ((u += c / 2), (p += d))
          : e === 'left'
            ? (p += d / 2)
            : e === 'center' && ((u += c / 2), (p += d / 2)),
    { x: u, y: p }
  );
}
o(PC, 'positionCoordinate');
function AC(e, t, { margin: r, border: n, padding: i }, s, a) {
  let c = o((y) => 0, 'shift'),
    d = 0,
    u = 0;
  const p = a ? 1 : 0.5,
    f = a ? s * 2 : 0;
  return (
    e === 'padding'
      ? (c = o((y) => i[y] * p + f, 'shift'))
      : e === 'border'
        ? (c = o((y) => i[y] + n[y] * p + f, 'shift'))
        : e === 'margin' && (c = o((y) => i[y] + n[y] + r[y] * p + f, 'shift')),
    t === 'top'
      ? (u = -c('top'))
      : t === 'right'
        ? (d = c('right'))
        : t === 'bottom'
          ? (u = c('bottom'))
          : t === 'left' && (d = -c('left')),
    { offsetX: d, offsetY: u }
  );
}
o(AC, 'offset');
function OC(e, t) {
  return (
    Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2
  );
}
o(OC, 'collide');
function CC(e, t, r) {
  return (
    e === 'top'
      ? (t.y = r.y - r.h - wr)
      : e === 'right'
        ? (t.x = r.x + r.w / 2 + wr + t.w / 2)
        : e === 'bottom'
          ? (t.y = r.y + r.h + wr)
          : e === 'left' && (t.x = r.x - r.w / 2 - wr - t.w / 2),
    { x: t.x, y: t.y }
  );
}
o(CC, 'overlapAdjustment');
function Dy(e, t, { x: r, y: n, w: i, h: s }, a) {
  return (
    Pd(e, { x: r, y: n, w: i, h: s, r: 3 }),
    (e.fillStyle = `${Dn[t]}dd`),
    e.fill(),
    (e.strokeStyle = Dn[t]),
    e.stroke(),
    (e.fillStyle = Dn.text),
    e.fillText(a, r, n),
    Pd(e, { x: r, y: n, w: i, h: s, r: 3 }),
    (e.fillStyle = `${Dn[t]}dd`),
    e.fill(),
    (e.strokeStyle = Dn[t]),
    e.stroke(),
    (e.fillStyle = Dn.text),
    e.fillText(a, r, n),
    { x: r, y: n, w: i, h: s }
  );
}
o(Dy, 'textWithRect');
function Ly(e, t) {
  ((e.font = '600 12px monospace'), (e.textBaseline = 'middle'), (e.textAlign = 'center'));
  const r = e.measureText(t),
    n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent,
    i = r.width + wr * 2,
    s = n + wr * 2;
  return { w: i, h: s };
}
o(Ly, 'configureText');
function xC(e, t, { type: r, position: n = 'center', text: i }, s, a = !1) {
  let { x: c, y: d } = PC(n, t);
  const { offsetX: u, offsetY: p } = AC(r, n, t, wr + 1, a);
  ((c += u), (d += p));
  const { w: f, h: y } = Ly(e, i);
  if (s && OC({ x: c, y: d, w: f, h: y }, s)) {
    const h = CC(n, { x: c, y: d, w: f }, s);
    ((c = h.x), (d = h.y));
  }
  return Dy(e, r, { x: c, y: d, w: f, h: y }, i);
}
o(xC, 'drawLabel');
function NC(e, { w: t, h: r }) {
  const n = t * 0.5 + wr,
    i = r * 0.5 + wr;
  return { offsetX: (e.x === 'left' ? -1 : 1) * n, offsetY: (e.y === 'top' ? -1 : 1) * i };
}
o(NC, 'floatingOffset');
function IC(e, t, { type: r, text: n }) {
  const { floatingAlignment: i, extremities: s } = t;
  let a = s[i.x],
    c = s[i.y];
  const { w: d, h: u } = Ly(e, n),
    { offsetX: p, offsetY: f } = NC(i, { w: d, h: u });
  return ((a += p), (c += f), Dy(e, r, { x: a, y: c, w: d, h: u }, n));
}
o(IC, 'drawFloatingLabel');
function Bn(e, t, r, n) {
  const i = [];
  r.forEach((s, a) => {
    const c = n && s.position === 'center' ? IC(e, t, s) : xC(e, t, s, i[a - 1], n);
    i[a] = c;
  });
}
o(Bn, 'drawStack');
function MC(e, t, r, n) {
  const i = r.reduce(
    (s, a) => (
      Object.prototype.hasOwnProperty.call(s, a.position) || (s[a.position] = []),
      s[a.position]?.push(a),
      s
    ),
    {},
  );
  (i.top && Bn(e, t, i.top, n),
    i.right && Bn(e, t, i.right, n),
    i.bottom && Bn(e, t, i.bottom, n),
    i.left && Bn(e, t, i.left, n),
    i.center && Bn(e, t, i.center, n));
}
o(MC, 'labelStacks');
var tc = { margin: '#f6b26ba8', border: '#ffe599a8', padding: '#93c47d8c', content: '#6fa8dca8' },
  Lg = 30;
function St(e) {
  return parseInt(e.replace('px', ''), 10);
}
o(St, 'pxToNumber');
function un(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
o(un, 'round');
function rc(e) {
  return e.filter((t) => t.text !== 0 && t.text !== '0');
}
o(rc, 'filterZeroValues');
function qC(e) {
  const t = {
      top: te.window.scrollY,
      bottom: te.window.scrollY + te.window.innerHeight,
      left: te.window.scrollX,
      right: te.window.scrollX + te.window.innerWidth,
    },
    r = {
      top: Math.abs(t.top - e.top),
      bottom: Math.abs(t.bottom - e.bottom),
      left: Math.abs(t.left - e.left),
      right: Math.abs(t.right - e.right),
    };
  return { x: r.left > r.right ? 'left' : 'right', y: r.top > r.bottom ? 'top' : 'bottom' };
}
o(qC, 'floatingAlignment');
function jC(e) {
  const t = te.getComputedStyle(e);
  let { top: r, left: n, right: i, bottom: s, width: a, height: c } = e.getBoundingClientRect();
  const {
    marginTop: d,
    marginBottom: u,
    marginLeft: p,
    marginRight: f,
    paddingTop: y,
    paddingBottom: h,
    paddingLeft: g,
    paddingRight: T,
    borderBottomWidth: E,
    borderTopWidth: v,
    borderLeftWidth: S,
    borderRightWidth: A,
  } = t;
  ((r = r + te.window.scrollY),
    (n = n + te.window.scrollX),
    (s = s + te.window.scrollY),
    (i = i + te.window.scrollX));
  const N = { top: St(d), bottom: St(u), left: St(p), right: St(f) },
    j = { top: St(y), bottom: St(h), left: St(g), right: St(T) },
    C = { top: St(v), bottom: St(E), left: St(S), right: St(A) },
    R = { top: r - N.top, bottom: s + N.bottom, left: n - N.left, right: i + N.right };
  return {
    margin: N,
    padding: j,
    border: C,
    top: r,
    left: n,
    bottom: s,
    right: i,
    width: a,
    height: c,
    extremities: R,
    floatingAlignment: qC(R),
  };
}
o(jC, 'measureElement');
function kC(e, { margin: t, width: r, height: n, top: i, left: s, bottom: a, right: c }) {
  const d = n + t.bottom + t.top;
  ((e.fillStyle = tc.margin),
    e.fillRect(s, i - t.top, r, t.top),
    e.fillRect(c, i - t.top, t.right, d),
    e.fillRect(s, a, r, t.bottom),
    e.fillRect(s - t.left, i - t.top, t.left, d));
  const u = [
    { type: 'margin', text: un(t.top), position: 'top' },
    { type: 'margin', text: un(t.right), position: 'right' },
    { type: 'margin', text: un(t.bottom), position: 'bottom' },
    { type: 'margin', text: un(t.left), position: 'left' },
  ];
  return rc(u);
}
o(kC, 'drawMargin');
function DC(
  e,
  { padding: t, border: r, width: n, height: i, top: s, left: a, bottom: c, right: d },
) {
  const u = n - r.left - r.right,
    p = i - t.top - t.bottom - r.top - r.bottom;
  ((e.fillStyle = tc.padding),
    e.fillRect(a + r.left, s + r.top, u, t.top),
    e.fillRect(d - t.right - r.right, s + t.top + r.top, t.right, p),
    e.fillRect(a + r.left, c - t.bottom - r.bottom, u, t.bottom),
    e.fillRect(a + r.left, s + t.top + r.top, t.left, p));
  const f = [
    { type: 'padding', text: t.top, position: 'top' },
    { type: 'padding', text: t.right, position: 'right' },
    { type: 'padding', text: t.bottom, position: 'bottom' },
    { type: 'padding', text: t.left, position: 'left' },
  ];
  return rc(f);
}
o(DC, 'drawPadding');
function LC(e, { border: t, width: r, height: n, top: i, left: s, bottom: a, right: c }) {
  const d = n - t.top - t.bottom;
  ((e.fillStyle = tc.border),
    e.fillRect(s, i, r, t.top),
    e.fillRect(s, a - t.bottom, r, t.bottom),
    e.fillRect(s, i + t.top, t.left, d),
    e.fillRect(c - t.right, i + t.top, t.right, d));
  const u = [
    { type: 'border', text: t.top, position: 'top' },
    { type: 'border', text: t.right, position: 'right' },
    { type: 'border', text: t.bottom, position: 'bottom' },
    { type: 'border', text: t.left, position: 'left' },
  ];
  return rc(u);
}
o(LC, 'drawBorder');
function FC(e, { padding: t, border: r, width: n, height: i, top: s, left: a }) {
  const c = n - r.left - r.right - t.left - t.right,
    d = i - t.top - t.bottom - r.top - r.bottom;
  return (
    (e.fillStyle = tc.content),
    e.fillRect(a + r.left + t.left, s + r.top + t.top, c, d),
    [{ type: 'content', position: 'center', text: `${un(c)} x ${un(d)}` }]
  );
}
o(FC, 'drawContent');
function BC(e) {
  return (t) => {
    if (e && t) {
      const r = jC(e),
        n = kC(t, r),
        i = DC(t, r),
        s = LC(t, r),
        a = FC(t, r),
        c = r.width <= Lg * 3 || r.height <= Lg;
      MC(t, r, [...a, ...i, ...s, ...n], c);
    }
  };
}
o(BC, 'drawBoxModel');
function JC(e) {
  SC(BC(e));
}
o(JC, 'drawSelectedElement');
var AU = o((e, t) => {
    const r = te.document.elementFromPoint(e, t),
      n = o((s) => {
        if (s && s.shadowRoot) {
          const a = s.shadowRoot.elementFromPoint(e, t);
          return s.isEqualNode(a) ? s : a.shadowRoot ? n(a) : a;
        }
        return s;
      }, 'crawlShadows');
    return n(r) || r;
  }, 'deepElementFromPoint'),
  Fg,
  _s = { x: 0, y: 0 };
function Ad(e, t) {
  ((Fg = AU(e, t)), JC(Fg));
}
o(Ad, 'findAndDrawElement');
var OU = o((e, t) => {
    const { measureEnabled: r } = t.globals || {};
    return (
      $r(() => {
        if (typeof globalThis.document > 'u') return;
        const n = o((i) => {
          window.requestAnimationFrame(() => {
            (i.stopPropagation(), (_s.x = i.clientX), (_s.y = i.clientY));
          });
        }, 'onPointerMove');
        return (
          globalThis.document.addEventListener('pointermove', n),
          () => {
            globalThis.document.removeEventListener('pointermove', n);
          }
        );
      }, []),
      $r(() => {
        const n = o((s) => {
            window.requestAnimationFrame(() => {
              (s.stopPropagation(), Ad(s.clientX, s.clientY));
            });
          }, 'onPointerOver'),
          i = o(() => {
            window.requestAnimationFrame(() => {
              _C();
            });
          }, 'onResize');
        return (
          t.viewMode === 'story' &&
            r &&
            (globalThis.document.addEventListener('pointerover', n),
            wC(),
            globalThis.window.addEventListener('resize', i),
            Ad(_s.x, _s.y)),
          () => {
            (globalThis.window.removeEventListener('resize', i), RC());
          }
        );
      }, [r, t.viewMode]),
      e()
    );
  }, 'withMeasure'),
  CU = globalThis.FEATURES?.measure ? [OU] : [],
  xU = { [PU]: !1 },
  Bg = o(() => ({ decorators: CU, initialGlobals: xU }), 'default'),
  $C = 'outline',
  Jg = o((e) => {
    (Array.isArray(e) ? e : [e]).forEach(NU);
  }, 'clearStyles'),
  NU = o((e) => {
    const t = typeof e == 'string' ? e : e.join(''),
      r = te.document.getElementById(t);
    r && r.parentElement && r.parentElement.removeChild(r);
  }, 'clearStyle'),
  IU = o((e, t) => {
    const r = te.document.getElementById(e);
    if (r) r.innerHTML !== t && (r.innerHTML = t);
    else {
      const n = te.document.createElement('style');
      (n.setAttribute('id', e), (n.innerHTML = t), te.document.head.appendChild(n));
    }
  }, 'addOutlineStyles');
function UC(e) {
  return ve`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
o(UC, 'outlineCSS');
var MU = o((e, t) => {
    const r = t.globals || {},
      n = [!0, 'true'].includes(r[$C]),
      i = t.viewMode === 'docs',
      s = bp(() => UC(i ? '[data-story-block="true"]' : '.sb-show-main'), [t]);
    return (
      $r(() => {
        const a = i ? `addon-outline-docs-${t.id}` : 'addon-outline';
        return (
          n ? IU(a, s) : Jg(a),
          () => {
            Jg(a);
          }
        );
      }, [n, s, t]),
      e()
    );
  }, 'withOutline'),
  qU = globalThis.FEATURES?.outline ? [MU] : [],
  jU = { [$C]: !1 },
  $g = o(() => ({ decorators: qU, initialGlobals: jU }), 'default'),
  kU = o(({ parameters: e }) => {
    e?.test?.mockReset === !0
      ? jm()
      : e?.test?.clearMocks === !0
        ? qm()
        : e?.test?.restoreMocks !== !1 && km();
  }, 'resetAllMocksLoader'),
  Od = o((e, t = 0, r) => {
    if (t > 5 || e == null) return e;
    if (fn(e)) return (r && e.mockName(r), e);
    if (
      typeof e == 'function' &&
      'isAction' in e &&
      e.isAction &&
      !('implicit' in e && e.implicit)
    ) {
      const n = Im(e);
      return (r && n.mockName(r), n);
    }
    if (Array.isArray(e)) {
      t++;
      for (let n = 0; n < e.length; n++)
        Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = Od(e[n], t));
      return e;
    }
    if (typeof e == 'object' && e.constructor === Object) {
      t++;
      for (const [n, i] of Object.entries(e))
        Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = Od(i, t, n));
      return e;
    }
    return e;
  }, 'traverseArgs'),
  DU = o(({ initialArgs: e }) => {
    Od(e);
  }, 'nameSpiesAndWrapActionsInSpies'),
  Ug = !1,
  LU = o(async (e) => {
    globalThis.HTMLElement &&
      e.canvasElement instanceof globalThis.HTMLElement &&
      (e.canvas = vC(e.canvasElement));
    const t = globalThis.window?.navigator?.clipboard;
    if (
      t &&
      ((e.userEvent = To(
        { userEvent: EC.setup() },
        {
          intercept: !0,
          getKeys: o((r) => Object.keys(r).filter((n) => n !== 'eventWrapper'), 'getKeys'),
        },
      ).userEvent),
      Object.defineProperty(globalThis.window.navigator, 'clipboard', {
        get: o(() => t, 'get'),
        configurable: !0,
      }),
      !Ug)
    ) {
      const r = HTMLElement.prototype.focus;
      let n = HTMLElement.prototype.focus;
      const i = new Set();
      (Object.defineProperties(HTMLElement.prototype, {
        focus: {
          configurable: !0,
          set: o((s) => {
            n = s;
          }, 'set'),
          get() {
            return i.has(this) ? r : (i.add(this), setTimeout(() => i.delete(this), 0), n);
          },
        },
      }),
        (Ug = !0));
    }
  }, 'enhanceContext'),
  Vg = o(() => ({ loaders: [kU, DU, LU] }), 'default'),
  FU = 'viewport',
  BU = { [FU]: { value: void 0, isRotated: !1 } },
  Hg = o(() => ({ initialGlobals: BU }), 'default');
function Fy() {
  return [
    (Bg.default ?? Bg)(),
    (Og.default ?? Og)(),
    (Dg.default ?? Dg)(),
    ($g.default ?? $g)(),
    (Hg.default ?? Hg)(),
    (_g.default ?? _g)(),
    (Cg.default ?? Cg)(),
    (Vg.default ?? Vg)(),
  ];
}
o(Fy, 'getCoreAnnotations');
function JU(e) {
  return e;
}
o(JU, 'definePreviewAddon');
function VC(e) {
  return e != null && typeof e == 'object' && '_tag' in e && e?._tag === 'Meta';
}
o(VC, 'isMeta');
function nc(e) {
  return e != null && typeof e == 'object' && '_tag' in e && e?._tag === 'Story';
}
o(nc, 'isStory');
function HC(e) {
  return '__children' in e ? e.__children : [];
}
o(HC, 'getStoryChildren');
var GC = o(
    (e) =>
      e
        .toLowerCase()
        .replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '-')
        .replace(/-+/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, ''),
    'sanitize',
  ),
  Cd = o((e, t) => {
    const r = GC(e);
    if (r === '') throw new Error(`Invalid ${t} '${e}', must include alphanumeric characters`);
    return r;
  }, 'sanitizeSafe'),
  $U = o((e, t) => `${Cd(e, 'kind')}${t ? `--${Cd(t, 'name')}` : ''}`, 'toId'),
  UU = o((e, t) => `${e}:${Cd(t, 'test')}`, 'toTestId'),
  VU = o((e) => tT(e), 'storyNameFromExport');
function xd(e, t) {
  return Array.isArray(t) ? t.includes(e) : e.match(t);
}
o(xd, 'matches');
function Na(e, { includeStories: t, excludeStories: r }) {
  return e !== '__esModule' && (!t || xd(e, t)) && (!r || !xd(e, r));
}
o(Na, 'isExportStory');
var HU = o((...e) => {
  const t = e.reduce((r, n) => (n.startsWith('!') ? r.delete(n.slice(1)) : r.add(n), r), new Set());
  return Array.from(t);
}, 'combineTags');
function Nd(e) {
  return Object.getOwnPropertySymbols(e).filter((t) =>
    Object.prototype.propertyIsEnumerable.call(e, t),
  );
}
o(Nd, 'getSymbols');
function Id(e) {
  return e == null
    ? e === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(e);
}
o(Id, 'getTag');
var GU = '[object RegExp]',
  zU = '[object String]',
  WU = '[object Number]',
  KU = '[object Boolean]',
  Gg = '[object Arguments]',
  YU = '[object Symbol]',
  XU = '[object Date]',
  QU = '[object Map]',
  ZU = '[object Set]',
  eV = '[object Array]',
  tV = '[object Function]',
  rV = '[object ArrayBuffer]',
  jc = '[object Object]',
  nV = '[object Error]',
  oV = '[object DataView]',
  iV = '[object Uint8Array]',
  sV = '[object Uint8ClampedArray]',
  aV = '[object Uint16Array]',
  lV = '[object Uint32Array]',
  cV = '[object BigUint64Array]',
  uV = '[object Int8Array]',
  dV = '[object Int16Array]',
  pV = '[object Int32Array]',
  fV = '[object BigInt64Array]',
  mV = '[object Float32Array]',
  yV = '[object Float64Array]';
function Gt(e) {
  if (!e || typeof e != 'object') return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null
    ? Object.prototype.toString.call(e) === '[object Object]'
    : !1;
}
o(Gt, 'isPlainObject');
function bo(e, t) {
  const r = {},
    n = Object.keys(e);
  for (let i = 0; i < n.length; i++) {
    const s = n[i],
      a = e[s];
    r[s] = t(a, s, e);
  }
  return r;
}
o(bo, 'mapValues');
function zC(e, t) {
  const r = {},
    n = Object.keys(e);
  for (let i = 0; i < n.length; i++) {
    const s = n[i],
      a = e[s];
    t(a, s) && (r[s] = a);
  }
  return r;
}
o(zC, 'pickBy');
var kc = ze(cb(), 1);
function WC(e, t) {
  return e === t || (Number.isNaN(e) && Number.isNaN(t));
}
o(WC, 'eq');
function KC(e, t, r) {
  return Gn(e, t, void 0, void 0, void 0, void 0, r);
}
o(KC, 'isEqualWith');
function Gn(e, t, r, n, i, s, a) {
  const c = a(e, t, r, n, i, s);
  if (c !== void 0) return c;
  if (typeof e == typeof t)
    switch (typeof e) {
      case 'bigint':
      case 'string':
      case 'boolean':
      case 'symbol':
      case 'undefined':
        return e === t;
      case 'number':
        return e === t || Object.is(e, t);
      case 'function':
        return e === t;
      case 'object':
        return Qn(e, t, s, a);
    }
  return Qn(e, t, s, a);
}
o(Gn, 'isEqualWithImpl');
function Qn(e, t, r, n) {
  if (Object.is(e, t)) return !0;
  let i = Id(e),
    s = Id(t);
  if ((i === Gg && (i = jc), s === Gg && (s = jc), i !== s)) return !1;
  switch (i) {
    case zU:
      return e.toString() === t.toString();
    case WU: {
      const d = e.valueOf(),
        u = t.valueOf();
      return WC(d, u);
    }
    case KU:
    case XU:
    case YU:
      return Object.is(e.valueOf(), t.valueOf());
    case GU:
      return e.source === t.source && e.flags === t.flags;
    case tV:
      return e === t;
  }
  r = r ?? new Map();
  const a = r.get(e),
    c = r.get(t);
  if (a != null && c != null) return a === t;
  (r.set(e, t), r.set(t, e));
  try {
    switch (i) {
      case QU: {
        if (e.size !== t.size) return !1;
        for (const [d, u] of e.entries())
          if (!t.has(d) || !Gn(u, t.get(d), d, e, t, r, n)) return !1;
        return !0;
      }
      case ZU: {
        if (e.size !== t.size) return !1;
        const d = Array.from(e.values()),
          u = Array.from(t.values());
        for (let p = 0; p < d.length; p++) {
          const f = d[p],
            y = u.findIndex((h) => Gn(f, h, void 0, e, t, r, n));
          if (y === -1) return !1;
          u.splice(y, 1);
        }
        return !0;
      }
      case eV:
      case iV:
      case sV:
      case aV:
      case lV:
      case cV:
      case uV:
      case dV:
      case pV:
      case fV:
      case mV:
      case yV: {
        if (
          (typeof Buffer < 'u' && Buffer.isBuffer(e) !== Buffer.isBuffer(t)) ||
          e.length !== t.length
        )
          return !1;
        for (let d = 0; d < e.length; d++) if (!Gn(e[d], t[d], d, e, t, r, n)) return !1;
        return !0;
      }
      case rV:
        return e.byteLength !== t.byteLength ? !1 : Qn(new Uint8Array(e), new Uint8Array(t), r, n);
      case oV:
        return e.byteLength !== t.byteLength || e.byteOffset !== t.byteOffset
          ? !1
          : Qn(new Uint8Array(e), new Uint8Array(t), r, n);
      case nV:
        return e.name === t.name && e.message === t.message;
      case jc: {
        if (!(Qn(e.constructor, t.constructor, r, n) || (Gt(e) && Gt(t)))) return !1;
        const u = [...Object.keys(e), ...Nd(e)],
          p = [...Object.keys(t), ...Nd(t)];
        if (u.length !== p.length) return !1;
        for (let f = 0; f < u.length; f++) {
          const y = u[f],
            h = e[y];
          if (!Object.hasOwn(t, y)) return !1;
          const g = t[y];
          if (!Gn(h, g, y, e, t, r, n)) return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    (r.delete(e), r.delete(t));
  }
}
o(Qn, 'areObjectsEqual');
function YC() {}
o(YC, 'noop');
function XC(e, t) {
  return KC(e, t, YC);
}
o(XC, 'isEqual');
var sn = Symbol('incompatible'),
  Md = o((e, t) => {
    const r = t.type;
    if (e == null || !r || t.mapping) return e;
    switch (r.name) {
      case 'string':
        return String(e);
      case 'enum':
        return e;
      case 'number':
        return Number(e);
      case 'boolean':
        return String(e) === 'true';
      case 'array':
        return !r.value || !Array.isArray(e)
          ? sn
          : e.reduce((n, i, s) => {
              const a = Md(i, { type: r.value });
              return (a !== sn && (n[s] = a), n);
            }, new Array(e.length));
      case 'object':
        return typeof e == 'string' || typeof e == 'number'
          ? e
          : !r.value || typeof e != 'object'
            ? sn
            : Object.entries(e).reduce((n, [i, s]) => {
                const a = Md(s, { type: r.value[i] });
                return a === sn ? n : Object.assign(n, { [i]: a });
              }, {});
      case 'other': {
        const n = typeof e == 'string' || typeof e == 'number' || typeof e == 'boolean';
        return r.value === 'ReactNode' && n ? e : sn;
      }
      default:
        return sn;
    }
  }, 'map'),
  hV = o(
    (e, t) =>
      Object.entries(e).reduce((r, [n, i]) => {
        if (!t[n]) return r;
        const s = Md(i, t[n]);
        return s === sn ? r : Object.assign(r, { [n]: s });
      }, {}),
    'mapArgsToTypes',
  ),
  Ia = o(
    (e, t) =>
      Array.isArray(e) && Array.isArray(t)
        ? t.reduce((r, n, i) => ((r[i] = Ia(e[i], t[i])), r), [...e]).filter((r) => r !== void 0)
        : !Gt(e) || !Gt(t)
          ? t
          : Object.keys({ ...e, ...t }).reduce((r, n) => {
              if (n in t) {
                const i = Ia(e[n], t[n]);
                i !== void 0 && (r[n] = i);
              } else r[n] = e[n];
              return r;
            }, {}),
    'combineArgs',
  ),
  gV = o(
    (e, t) =>
      Object.entries(t).reduce((r, [n, { options: i }]) => {
        function s() {
          return (n in e && (r[n] = e[n]), r);
        }
        if ((o(s, 'allowArg'), !i)) return s();
        if (!Array.isArray(i))
          return (
            Ve.error(ve`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `),
            s()
          );
        if (i.some((f) => f && ['object', 'function'].includes(typeof f)))
          return (
            Ve.error(ve`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `),
            s()
          );
        const a = Array.isArray(e[n]),
          c = a && e[n].findIndex((f) => !i.includes(f)),
          d = a && c === -1;
        if (e[n] === void 0 || i.includes(e[n]) || d) return s();
        const u = a ? `${n}[${c}]` : n,
          p = i.map((f) => (typeof f == 'string' ? `'${f}'` : String(f))).join(', ');
        return (Ve.warn(`Received illegal value for '${u}'. Supported options: ${p}`), r);
      }, {}),
    'validateOptions',
  ),
  Ai = Symbol('Deeply equal'),
  Ma = o((e, t) => {
    if (typeof e != typeof t) return t;
    if (XC(e, t)) return Ai;
    if (Array.isArray(e) && Array.isArray(t)) {
      const r = t.reduce((n, i, s) => {
        const a = Ma(e[s], i);
        return (a !== Ai && (n[s] = a), n);
      }, new Array(t.length));
      return t.length >= e.length ? r : r.concat(new Array(e.length - t.length).fill(void 0));
    }
    return Gt(e) && Gt(t)
      ? Object.keys({ ...e, ...t }).reduce((r, n) => {
          const i = Ma(e?.[n], t?.[n]);
          return i === Ai ? r : Object.assign(r, { [n]: i });
        }, {})
      : t;
  }, 'deepDiff'),
  QC = 'UNTARGETED';
function ZC({ args: e, argTypes: t }) {
  const r = {};
  return (
    Object.entries(e).forEach(([n, i]) => {
      const { target: s = QC } = t[n] || {};
      ((r[s] = r[s] || {}), (r[s][n] = i));
    }),
    r
  );
}
o(ZC, 'groupArgsByTarget');
function ex(e) {
  return (Object.keys(e).forEach((t) => e[t] === void 0 && delete e[t]), e);
}
o(ex, 'deleteUndefined');
var tx = class {
  constructor() {
    ((this.initialArgsByStoryId = {}), (this.argsByStoryId = {}));
  }
  get(t) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    return this.argsByStoryId[t];
  }
  setInitial(t) {
    if (!this.initialArgsByStoryId[t.id])
      ((this.initialArgsByStoryId[t.id] = t.initialArgs),
        (this.argsByStoryId[t.id] = t.initialArgs));
    else if (this.initialArgsByStoryId[t.id] !== t.initialArgs) {
      const r = Ma(this.initialArgsByStoryId[t.id], this.argsByStoryId[t.id]);
      ((this.initialArgsByStoryId[t.id] = t.initialArgs),
        (this.argsByStoryId[t.id] = t.initialArgs),
        r !== Ai && this.updateFromDelta(t, r));
    }
  }
  updateFromDelta(t, r) {
    const n = gV(r, t.argTypes);
    this.argsByStoryId[t.id] = Ia(this.argsByStoryId[t.id], n);
  }
  updateFromPersisted(t, r) {
    const n = hV(r, t.argTypes);
    return this.updateFromDelta(t, n);
  }
  update(t, r) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    this.argsByStoryId[t] = ex({ ...this.argsByStoryId[t], ...r });
  }
};
o(tx, 'ArgsStore');
var bV = tx,
  rx = o(
    (e = {}) =>
      Object.entries(e).reduce(
        (t, [r, { defaultValue: n }]) => (typeof n < 'u' && (t[r] = n), t),
        {},
      ),
    'getValuesFromArgTypes',
  ),
  nx = class {
    constructor({ globals: t = {}, globalTypes: r = {} }) {
      this.set({ globals: t, globalTypes: r });
    }
    set({ globals: t = {}, globalTypes: r = {} }) {
      const n = this.initialGlobals && Ma(this.initialGlobals, this.globals);
      this.allowedGlobalNames = new Set([...Object.keys(t), ...Object.keys(r)]);
      const i = rx(r);
      ((this.initialGlobals = { ...i, ...t }),
        (this.globals = this.initialGlobals),
        n && n !== Ai && this.updateFromPersisted(n));
    }
    filterAllowedGlobals(t) {
      return Object.entries(t).reduce(
        (r, [n, i]) => (
          this.allowedGlobalNames.has(n)
            ? (r[n] = i)
            : De.warn(
                `Attempted to set a global (${n}) that is not defined in initial globals or globalTypes`,
              ),
          r
        ),
        {},
      );
    }
    updateFromPersisted(t) {
      const r = this.filterAllowedGlobals(t);
      this.globals = { ...this.globals, ...r };
    }
    get() {
      return this.globals;
    }
    update(t) {
      this.globals = { ...this.globals, ...this.filterAllowedGlobals(t) };
      for (const r in t) t[r] === void 0 && (this.globals[r] = this.initialGlobals[r]);
    }
  };
o(nx, 'GlobalsStore');
var vV = nx,
  EV = ze(cb(), 1),
  TV = (0, EV.default)(1)((e) =>
    Object.values(e).reduce((t, r) => ((t[r.importPath] = t[r.importPath] || r), t), {}),
  ),
  ox = class {
    constructor({ entries: t } = { v: 5, entries: {} }) {
      this.entries = t;
    }
    entryFromSpecifier(t) {
      const r = Object.values(this.entries);
      if (t === '*') return r[0];
      if (typeof t == 'string')
        return this.entries[t] ? this.entries[t] : r.find((s) => s.id.startsWith(t));
      const { name: n, title: i } = t;
      return r.find((s) => s.name === n && s.title === i);
    }
    storyIdToEntry(t) {
      const r = this.entries[t];
      if (!r) throw new aE({ storyId: t });
      return r;
    }
    importPathToEntry(t) {
      return TV(this.entries)[t];
    }
  };
o(ox, 'StoryIndexStore');
var wV = ox,
  SV = o((e) => (typeof e == 'string' ? { name: e } : e), 'normalizeType'),
  _V = o((e) => (typeof e == 'string' ? { type: e } : e), 'normalizeControl'),
  RV = o((e, t) => {
    const { type: r, control: n, ...i } = e,
      s = { name: t, ...i };
    return (
      r && (s.type = SV(r)),
      n ? (s.control = _V(n)) : n === !1 && (s.control = { disable: !0 }),
      s
    );
  }, 'normalizeInputType'),
  qa = o((e) => bo(e, RV), 'normalizeInputTypes'),
  Ie = o((e) => (Array.isArray(e) ? e : e ? [e] : []), 'normalizeArrays'),
  PV = ve`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function Zn(e, t, r) {
  const n = t,
    i = typeof t == 'function' ? t : null,
    { story: s } = n;
  s && (De.debug('deprecated story', s), ep(PV));
  const a = VU(e),
    c = (typeof n != 'function' && n.name) || n.storyName || s?.name || a,
    d = [...Ie(n.decorators), ...Ie(s?.decorators)],
    u = { ...s?.parameters, ...n.parameters },
    p = { ...s?.args, ...n.args },
    f = { ...s?.argTypes, ...n.argTypes },
    y = [...Ie(n.loaders), ...Ie(s?.loaders)],
    h = [...Ie(n.beforeEach), ...Ie(s?.beforeEach)],
    g = [...Ie(n.afterEach), ...Ie(s?.afterEach)],
    { render: T, play: E, tags: v = [], globals: S = {} } = n,
    A = u.__id || $U(r.id, a);
  return {
    moduleExport: t,
    id: A,
    name: c,
    tags: v,
    decorators: d,
    parameters: u,
    args: p,
    argTypes: qa(f),
    loaders: y,
    beforeEach: h,
    afterEach: g,
    globals: S,
    ...(T && { render: T }),
    ...(i && { userStoryFn: i }),
    ...(E && { play: E }),
  };
}
o(Zn, 'normalizeStory');
function ja(e, t = e.title, r) {
  const { id: n, argTypes: i } = e;
  return {
    id: GC(n || t),
    ...e,
    title: t,
    ...(i && { argTypes: qa(i) }),
    parameters: { fileName: r, ...e.parameters },
  };
}
o(ja, 'normalizeComponentAnnotations');
var AV = o((e) => {
    const { globals: t, globalTypes: r } = e;
    (t || r) &&
      De.error(
        'Global args/argTypes can only be set globally',
        JSON.stringify({ globals: t, globalTypes: r }),
      );
  }, 'checkGlobals'),
  OV = o((e) => {
    const { options: t } = e;
    t?.storySort && De.error('The storySort option parameter can only be set globally');
  }, 'checkStorySort'),
  Rs = o((e) => {
    e && (AV(e), OV(e));
  }, 'checkDisallowedParameters');
function ix(e, t, r) {
  const { default: n, __namedExportsOrder: i, ...s } = e,
    a = Object.values(s)[0];
  if (nc(a)) {
    const u = ja(a.meta.input, r, t);
    Rs(u.parameters);
    const p = { meta: u, stories: {}, moduleExports: e };
    return (
      Object.keys(s).forEach((f) => {
        if (Na(f, u)) {
          const y = s[f],
            h = Zn(f, y.input, u);
          (Rs(h.parameters),
            (p.stories[h.id] = h),
            HC(y).forEach((g) => {
              var v;
              const T = g.input.name,
                E = UU(h.id, T);
              ((v = g.input).parameters ?? (v.parameters = {}),
                (g.input.parameters.__id = E),
                (p.stories[E] = Zn(T, g.input, u)));
            }));
        }
      }),
      (p.projectAnnotations = a.meta.preview.composed),
      p
    );
  }
  const c = ja(n, r, t);
  Rs(c.parameters);
  const d = { meta: c, stories: {}, moduleExports: e };
  return (
    Object.keys(s).forEach((u) => {
      if (Na(u, c)) {
        const p = Zn(u, s[u], c);
        (Rs(p.parameters), (d.stories[p.id] = p));
      }
    }),
    d
  );
}
o(ix, 'processCSFFile');
function By(e, t, r) {
  const n = r(e);
  return (i) => t(n, i);
}
o(By, 'decorateStory');
function Jy({
  componentId: e,
  title: t,
  kind: r,
  id: n,
  name: i,
  story: s,
  parameters: a,
  initialArgs: c,
  argTypes: d,
  ...u
} = {}) {
  return u;
}
o(Jy, 'sanitizeStoryContextUpdate');
function $y(e, t) {
  const r = {},
    n = o(
      (s) => (a) => {
        if (!r.value) throw new Error('Decorated function called without init');
        return ((r.value = { ...r.value, ...Jy(a) }), s(r.value));
      },
      'bindWithContext',
    ),
    i = t.reduce((s, a) => By(s, a, n), e);
  return (s) => ((r.value = s), i(s));
}
o($y, 'defaultDecorateStory');
var Pn = o((...e) => {
  const t = {},
    r = e.filter(Boolean),
    n = r.reduce(
      (i, s) => (
        Object.entries(s).forEach(([a, c]) => {
          const d = i[a];
          Array.isArray(c) || typeof d > 'u'
            ? (i[a] = c)
            : Gt(c) && Gt(d)
              ? (t[a] = !0)
              : typeof c < 'u' && (i[a] = c);
        }),
        i
      ),
      {},
    );
  return (
    Object.keys(t).forEach((i) => {
      const s = r
        .filter(Boolean)
        .map((a) => a[i])
        .filter((a) => typeof a < 'u');
      s.every((a) => Gt(a)) ? (n[i] = Pn(...s)) : (n[i] = s[s.length - 1]);
    }),
    n
  );
}, 'combineParameters');
function oc(e, t, r) {
  const { moduleExport: n, id: i, name: s } = e || {},
    a = Vy(e, t, r),
    c = o(async (C) => {
      const R = {};
      for (const w of [Ie(r.loaders), Ie(t.loaders), Ie(e.loaders)]) {
        if (C.abortSignal.aborted) return R;
        const _ = await Promise.all(w.map((k) => k(C)));
        Object.assign(R, ..._);
      }
      return R;
    }, 'applyLoaders'),
    d = o(async (C) => {
      const R = new Array();
      for (const w of [...Ie(r.beforeEach), ...Ie(t.beforeEach), ...Ie(e.beforeEach)]) {
        if (C.abortSignal.aborted) return R;
        const _ = await w(C);
        _ && R.push(_);
      }
      return R;
    }, 'applyBeforeEach'),
    u = o(async (C) => {
      const R = [...Ie(r.afterEach), ...Ie(t.afterEach), ...Ie(e.afterEach)].reverse();
      for (const w of R) {
        if (C.abortSignal.aborted) return;
        await w(C);
      }
    }, 'applyAfterEach'),
    p = o((C) => C.originalStoryFn(C.args, C), 'undecoratedStoryFn'),
    { applyDecorators: f = $y, runStep: y } = r,
    h = [...Ie(e?.decorators), ...Ie(t?.decorators), ...Ie(r?.decorators)],
    g = e?.userStoryFn || e?.render || t.render || r.render,
    T = HE(f)(p, h),
    E = o((C) => T(C), 'unboundStoryFn'),
    v = e?.play ?? t?.play,
    S = nT(v);
  if (!g && !S) throw new CE({ id: i });
  const A = o((C) => async () => (await C.renderToCanvas(), C.canvas), 'defaultMount'),
    N = e.mount ?? t.mount ?? r.mount ?? A,
    j = r.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a,
    moduleExport: n,
    id: i,
    name: s,
    story: s,
    originalStoryFn: g,
    undecoratedStoryFn: p,
    unboundStoryFn: E,
    applyLoaders: c,
    applyBeforeEach: d,
    applyAfterEach: u,
    playFunction: v,
    runStep: y,
    mount: N,
    testingLibraryRender: j,
    renderToCanvas: r.renderToCanvas,
    usesMount: S,
  };
}
o(oc, 'prepareStory');
function Uy(e, t, r) {
  return { ...Vy(void 0, e, t), moduleExport: r };
}
o(Uy, 'prepareMeta');
function Vy(e, t, r) {
  const n = ['dev', 'test'],
    i = te.DOCS_OPTIONS?.autodocs === !0 ? ['autodocs'] : [],
    s = e?.tags?.includes('test-fn') ? ['!autodocs'] : [],
    a = HU(...n, ...i, ...(r.tags ?? []), ...(t.tags ?? []), ...s, ...(e?.tags ?? [])),
    c = Pn(r.parameters, t.parameters, e?.parameters),
    { argTypesEnhancers: d = [], argsEnhancers: u = [] } = r,
    p = Pn(r.argTypes, t.argTypes, e?.argTypes);
  if (e) {
    const S = e?.userStoryFn || e?.render || t.render || r.render;
    c.__isArgsStory = S && S.length > 0;
  }
  const f = { ...r.args, ...t.args, ...e?.args },
    y = { ...t.globals, ...e?.globals },
    h = {
      componentId: t.id,
      title: t.title,
      kind: t.title,
      id: e?.id || t.id,
      name: e?.name || '__meta',
      story: e?.name || '__meta',
      component: t.component,
      subcomponents: t.subcomponents,
      tags: a,
      parameters: c,
      initialArgs: f,
      argTypes: p,
      storyGlobals: y,
    };
  h.argTypes = d.reduce((S, A) => A({ ...h, argTypes: S }), h.argTypes);
  const g = { ...f };
  h.initialArgs = [...u].reduce((S, A) => ({ ...S, ...A({ ...h, initialArgs: S }) }), g);
  const { name: T, story: E, ...v } = h;
  return v;
}
o(Vy, 'preparePartialAnnotations');
function Hy(e) {
  const { args: t } = e;
  let r = { ...e, allArgs: void 0, argsByTarget: void 0 };
  if (te.FEATURES?.argTypeTargetsV7) {
    const s = ZC(e);
    r = { ...e, allArgs: e.args, argsByTarget: s, args: s[QC] || {} };
  }
  const n = Object.entries(r.args).reduce((s, [a, c]) => {
      if (!r.argTypes[a]?.mapping) return ((s[a] = c), s);
      const d = o((u) => {
        const p = r.argTypes[a].mapping;
        return p && u in p ? p[u] : u;
      }, 'mappingFn');
      return ((s[a] = Array.isArray(c) ? c.map(d) : d(c)), s);
    }, {}),
    i = Object.entries(n).reduce((s, [a, c]) => {
      const d = r.argTypes[a] || {};
      return (DL(d, n, r.globals) && (s[a] = c), s);
    }, {});
  return { ...r, unmappedArgs: t, args: i };
}
o(Hy, 'prepareContext');
var qd = o((e, t, r) => {
    const n = typeof e;
    switch (n) {
      case 'boolean':
      case 'string':
      case 'number':
      case 'function':
      case 'symbol':
        return { name: n };
    }
    return e
      ? r.has(e)
        ? (De.warn(ve`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `),
          { name: 'other', value: 'cyclic object' })
        : (r.add(e),
          Array.isArray(e)
            ? {
                name: 'array',
                value: e.length > 0 ? qd(e[0], t, new Set(r)) : { name: 'other', value: 'unknown' },
              }
            : { name: 'object', value: bo(e, (s) => qd(s, t, new Set(r))) })
      : { name: 'object', value: {} };
  }, 'inferType'),
  sx = o((e) => {
    const { id: t, argTypes: r = {}, initialArgs: n = {} } = e,
      i = bo(n, (a, c) => ({ name: c, type: qd(a, `${t}.${c}`, new Set()) })),
      s = bo(r, (a, c) => ({ name: c }));
    return Pn(i, s, r);
  }, 'inferArgTypes');
sx.secondPass = !0;
var zg = o((e, t) => (Array.isArray(t) ? t.includes(e) : e.match(t)), 'matches'),
  ax = o(
    (e, t, r) =>
      !t && !r
        ? e
        : e &&
          zC(e, (n, i) => {
            const s = n.name || i.toString();
            return !!(!t || zg(s, t)) && (!r || !zg(s, r));
          }),
    'filterArgTypes',
  ),
  CV = o((e, t, r) => {
    const { type: n, options: i } = e;
    if (n) {
      if (r.color && r.color.test(t)) {
        const s = n.name;
        if (s === 'string') return { control: { type: 'color' } };
        s !== 'enum' &&
          De.warn(
            `Addon controls: Control of type color only supports string, received "${s}" instead`,
          );
      }
      if (r.date && r.date.test(t)) return { control: { type: 'date' } };
      switch (n.name) {
        case 'array':
          return { control: { type: 'object' } };
        case 'boolean':
          return { control: { type: 'boolean' } };
        case 'string':
          return { control: { type: 'text' } };
        case 'number':
          return { control: { type: 'number' } };
        case 'enum': {
          const { value: s } = n;
          return { control: { type: s?.length <= 5 ? 'radio' : 'select' }, options: s };
        }
        case 'function':
        case 'symbol':
          return null;
        default:
          return { control: { type: i ? 'select' : 'object' } };
      }
    }
  }, 'inferControl'),
  Gy = o((e) => {
    const {
      argTypes: t,
      parameters: {
        __isArgsStory: r,
        controls: { include: n = null, exclude: i = null, matchers: s = {} } = {},
      },
    } = e;
    if (!r) return t;
    const a = ax(t, n, i),
      c = bo(a, (d, u) => d?.type && CV(d, u.toString(), s));
    return Pn(c, a);
  }, 'inferControls');
Gy.secondPass = !0;
function Ki({
  argTypes: e,
  globalTypes: t,
  argTypesEnhancers: r,
  decorators: n,
  loaders: i,
  beforeEach: s,
  afterEach: a,
  initialGlobals: c,
  ...d
}) {
  return {
    ...(e && { argTypes: qa(e) }),
    ...(t && { globalTypes: qa(t) }),
    decorators: Ie(n),
    loaders: Ie(i),
    beforeEach: Ie(s),
    afterEach: Ie(a),
    argTypesEnhancers: [...(r || []), sx, Gy],
    initialGlobals: c,
    ...d,
  };
}
o(Ki, 'normalizeProjectAnnotations');
var xV = o(
  (e) => async () => {
    const t = [];
    for (const r of e) {
      const n = await r();
      n && t.unshift(n);
    }
    return async () => {
      for (const r of t) await r();
    };
  },
  'composeBeforeAllHooks',
);
function zy(e) {
  return async (t, r, n) => {
    await e.reduceRight(
      (s, a) => async () => a(t, s, n),
      async () => r(n),
    )();
  };
}
o(zy, 'composeStepRunners');
function vo(e, t) {
  return e.map((r) => r.default?.[t] ?? r[t]).filter(Boolean);
}
o(vo, 'getField');
function gr(e, t, r = {}) {
  return vo(e, t).reduce((n, i) => {
    const s = Ie(i);
    return r.reverseFileOrder ? [...s, ...n] : [...n, ...s];
  }, []);
}
o(gr, 'getArrayField');
function hi(e, t) {
  return Object.assign({}, ...vo(e, t));
}
o(hi, 'getObjectField');
function Jn(e, t) {
  return vo(e, t).pop();
}
o(Jn, 'getSingletonField');
function An(e) {
  const t = gr(e, 'argTypesEnhancers'),
    r = vo(e, 'runStep'),
    n = gr(e, 'beforeAll');
  return {
    parameters: Pn(...vo(e, 'parameters')),
    decorators: gr(e, 'decorators', {
      reverseFileOrder: !(te.FEATURES?.legacyDecoratorFileOrder ?? !1),
    }),
    args: hi(e, 'args'),
    argsEnhancers: gr(e, 'argsEnhancers'),
    argTypes: hi(e, 'argTypes'),
    argTypesEnhancers: [...t.filter((i) => !i.secondPass), ...t.filter((i) => i.secondPass)],
    initialGlobals: hi(e, 'initialGlobals'),
    globalTypes: hi(e, 'globalTypes'),
    loaders: gr(e, 'loaders'),
    beforeAll: xV(n),
    beforeEach: gr(e, 'beforeEach'),
    afterEach: gr(e, 'afterEach'),
    render: Jn(e, 'render'),
    renderToCanvas: Jn(e, 'renderToCanvas'),
    applyDecorators: Jn(e, 'applyDecorators'),
    runStep: zy(r),
    tags: gr(e, 'tags'),
    mount: Jn(e, 'mount'),
    testingLibraryRender: Jn(e, 'testingLibraryRender'),
  };
}
o(An, 'composeConfigs');
var NV = 5e3;
function Wy() {
  try {
    return (
      !!globalThis.__vitest_browser__ ||
      !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return !1;
  }
}
o(Wy, 'isTestEnvironment');
function ic(e = !0) {
  if (!('document' in globalThis && 'createElement' in globalThis.document)) return () => {};
  const t = document.createElement('style');
  ((t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`),
    document.head.appendChild(t));
  const r = document.createElement('style');
  return (
    (r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? 'reverse' : 'normal'} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`),
    document.head.appendChild(r),
    document.body.clientHeight,
    document.head.removeChild(t),
    () => {
      r.parentNode?.removeChild(r);
    }
  );
}
o(ic, 'pauseAnimations');
async function sc(e) {
  if (
    !(
      'document' in globalThis &&
      'getAnimations' in globalThis.document &&
      'querySelectorAll' in globalThis.document
    )
  )
    return;
  let t = !1;
  await Promise.race([
    new Promise((r) => {
      setTimeout(() => {
        const n = [globalThis.document, ...Ky(globalThis.document)],
          i = o(async () => {
            if (t || e?.aborted) return;
            const s = n
              .flatMap((a) => a?.getAnimations?.() || [])
              .filter((a) => a.playState === 'running' && !lx(a));
            s.length > 0 && (await Promise.all(s.map((a) => a.finished)), await i());
          }, 'checkAnimationsFinished');
        i().then(r);
      }, 100);
    }),
    new Promise((r) =>
      setTimeout(() => {
        ((t = !0), r(void 0));
      }, NV),
    ),
  ]);
}
o(sc, 'waitForAnimations');
function Ky(e) {
  return [e, ...e.querySelectorAll('*')].reduce(
    (t, r) => ('shadowRoot' in r && r.shadowRoot && t.push(r.shadowRoot, ...Ky(r.shadowRoot)), t),
    [],
  );
}
o(Ky, 'getShadowRoots');
function lx(e) {
  if (e instanceof CSSAnimation && e.effect instanceof KeyframeEffect && e.effect.target) {
    const t = getComputedStyle(e.effect.target, e.effect.pseudoElement),
      r = t.animationName?.split(', ').indexOf(e.animationName);
    return t.animationIterationCount.split(', ')[r] === 'infinite';
  }
  return !1;
}
o(lx, 'isInfiniteAnimation');
var cx = class {
  constructor() {
    this.reports = [];
  }
  async addReport(t) {
    this.reports.push(t);
  }
};
o(cx, 'ReporterAPI');
var Yy = cx;
function Xy(e, t, r) {
  return nc(e)
    ? { story: e.input, meta: e.meta.input, preview: e.meta.preview.composed }
    : { story: e, meta: VC(t) ? t.input : t, preview: r };
}
o(Xy, 'getCsfFactoryAnnotations');
function ux(e) {
  globalThis.defaultProjectAnnotations = e;
}
o(ux, 'setDefaultProjectAnnotations');
var IV = 'ComposedStory',
  MV = 'Unnamed Story';
function dx(e) {
  return e ? An([e]) : {};
}
o(dx, 'extractAnnotation');
function px(e) {
  const t = Array.isArray(e) ? e : [e];
  return (
    (globalThis.globalProjectAnnotations = An([
      ...Fy(),
      globalThis.defaultProjectAnnotations ?? {},
      An(t.map(dx)),
    ])),
    globalThis.globalProjectAnnotations ?? {}
  );
}
o(px, 'setProjectAnnotations');
var jr = [];
function Qy(e, t, r, n, i) {
  if (e === void 0) throw new Error('Expected a story but received undefined.');
  t.title = t.title ?? IV;
  const s = ja(t),
    a = i || e.storyName || e.story?.name || e.name || MV,
    c = Zn(a, e, s),
    d = Ki(An([n ?? globalThis.globalProjectAnnotations ?? {}, r ?? {}])),
    u = oc(c, s, d),
    f = { ...rx(d.globalTypes), ...d.initialGlobals, ...u.storyGlobals },
    y = new Yy(),
    h = o(() => {
      const A = Hy({
        hooks: new yp(),
        globals: f,
        args: { ...u.initialArgs },
        viewMode: 'story',
        reporting: y,
        loaded: {},
        abortSignal: new AbortController().signal,
        step: o((N, j) => u.runStep(N, j, A), 'step'),
        canvasElement: null,
        canvas: {},
        userEvent: {},
        globalTypes: d.globalTypes,
        ...u,
        context: null,
        mount: null,
      });
      return (
        (A.parameters.__isPortableStory = !0),
        (A.context = A),
        u.renderToCanvas &&
          (A.renderToCanvas = async () => {
            const N = await u.renderToCanvas?.(
              {
                componentId: u.componentId,
                title: u.title,
                id: u.id,
                name: u.name,
                tags: u.tags,
                showMain: o(() => {}, 'showMain'),
                showError: o((j) => {
                  throw new Error(`${j.title}
${j.description}`);
                }, 'showError'),
                showException: o((j) => {
                  throw j;
                }, 'showException'),
                forceRemount: !0,
                storyContext: A,
                storyFn: o(() => u.unboundStoryFn(A), 'storyFn'),
                unboundStoryFn: u.unboundStoryFn,
              },
              A.canvasElement,
            );
            N && jr.push(N);
          }),
        (A.mount = u.mount(A)),
        A
      );
    }, 'initializeContext');
  let g;
  const T = o(async (A) => {
      const N = h();
      return (
        N.canvasElement ?? (N.canvasElement = globalThis?.document?.body),
        g && (N.loaded = g.loaded),
        Object.assign(N, A),
        u.playFunction(N)
      );
    }, 'play'),
    E = o((A) => {
      const N = h();
      return (Object.assign(N, A), yx(u, N));
    }, 'run'),
    v = u.playFunction ? T : void 0;
  return Object.assign(
    o(function (N) {
      const j = h();
      return (
        g && (j.loaded = g.loaded),
        (j.args = { ...j.initialArgs, ...N }),
        u.unboundStoryFn(j)
      );
    }, 'storyFn'),
    {
      id: u.id,
      storyName: a,
      load: o(async () => {
        for (const N of [...jr].reverse()) await N();
        jr.length = 0;
        const A = h();
        ((A.loaded = await u.applyLoaders(A)),
          jr.push(...(await u.applyBeforeEach(A)).filter(Boolean)),
          (g = A));
      }, 'load'),
      globals: f,
      args: u.initialArgs,
      parameters: u.parameters,
      argTypes: u.argTypes,
      play: v,
      run: E,
      reporting: y,
      tags: u.tags,
    },
  );
}
o(Qy, 'composeStory');
var qV = o((e, t, r, n) => Qy(e, t, r, {}, n), 'defaultComposeStory');
function fx(e, t, r = qV) {
  const { default: n, __esModule: i, __namedExportsOrder: s, ...a } = e;
  let c = n;
  return Object.entries(a).reduce((u, [p, f]) => {
    const { story: y, meta: h } = Xy(f);
    return (!c && h && (c = h), Na(p, c) ? Object.assign(u, { [p]: r(y, c, t, p) }) : u);
  }, {});
}
o(fx, 'composeStories');
function mx(e) {
  return e.extend({
    mount: o(async ({ mount: t, page: r }, n) => {
      await n(async (i, ...s) => {
        if (!('__pw_type' in i) || ('__pw_type' in i && i.__pw_type !== 'jsx'))
          throw new Error(ve`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        const { props: a, ...c } = i;
        await r.evaluate(async (u) => {
          const p = await globalThis.__pwUnwrapObject?.(u);
          return ('__pw_type' in p ? p.type : p)?.load?.();
        }, c);
        const d = await t(i, ...s);
        return (
          await r.evaluate(async (u) => {
            const p = await globalThis.__pwUnwrapObject?.(u),
              f = '__pw_type' in p ? p.type : p,
              y = document.querySelector('#root');
            return f?.play?.({ canvasElement: y });
          }, c),
          d
        );
      });
    }, 'mount'),
  });
}
o(mx, 'createPlaywrightTest');
async function yx(e, t) {
  for (const s of [...jr].reverse()) await s();
  if (((jr.length = 0), !t.canvasElement)) {
    const s = document.createElement('div');
    (globalThis?.document?.body?.appendChild(s),
      (t.canvasElement = s),
      jr.push(() => {
        globalThis?.document?.body?.contains(s) && globalThis?.document?.body?.removeChild(s);
      }));
  }
  if (((t.loaded = await e.applyLoaders(t)), t.abortSignal.aborted)) return;
  jr.push(...(await e.applyBeforeEach(t)).filter(Boolean));
  const r = e.playFunction,
    n = e.usesMount;
  if ((n || (await t.mount()), t.abortSignal.aborted)) return;
  r &&
    (n ||
      (t.mount = async () => {
        throw new fp({ playFunction: r.toString() });
      }),
    await r(t));
  let i;
  (Wy() ? (i = ic()) : await sc(t.abortSignal), await e.applyAfterEach(t), await i?.());
}
o(yx, 'runStory');
var Wg = 1e3,
  jV = 1e4,
  hx = class {
    constructor(t, r, n) {
      ((this.importFn = r),
        (this.storyIndex = new wV(t)),
        (this.projectAnnotations = Ki(An([...Fy(), n]))));
      const { initialGlobals: i, globalTypes: s } = this.projectAnnotations;
      ((this.args = new bV()),
        (this.userGlobals = new vV({ globals: i, globalTypes: s })),
        (this.hooks = {}),
        (this.cleanupCallbacks = {}),
        (this.processCSFFileWithCache = (0, kc.default)(Wg)(ix)),
        (this.prepareMetaWithCache = (0, kc.default)(Wg)(Uy)),
        (this.prepareStoryWithCache = (0, kc.default)(jV)(oc)));
    }
    setProjectAnnotations(t) {
      this.projectAnnotations = Ki(t);
      const { initialGlobals: r, globalTypes: n } = t;
      this.userGlobals.set({ globals: r, globalTypes: n });
    }
    async onStoriesChanged({ importFn: t, storyIndex: r }) {
      (t && (this.importFn = t),
        r && (this.storyIndex.entries = r.entries),
        this.cachedCSFFiles && (await this.cacheAllCSFFiles()));
    }
    async storyIdToEntry(t) {
      return this.storyIndex.storyIdToEntry(t);
    }
    async loadCSFFileByStoryId(t) {
      const { importPath: r, title: n } = this.storyIndex.storyIdToEntry(t),
        i = await this.importFn(r);
      return this.processCSFFileWithCache(i, r, n);
    }
    async loadAllCSFFiles() {
      const t = {};
      return (
        Object.entries(this.storyIndex.entries).forEach(([n, { importPath: i }]) => {
          t[i] = n;
        }),
        (
          await Promise.all(
            Object.entries(t).map(async ([n, i]) => ({
              importPath: n,
              csfFile: await this.loadCSFFileByStoryId(i),
            })),
          )
        ).reduce((n, { importPath: i, csfFile: s }) => ((n[i] = s), n), {})
      );
    }
    async cacheAllCSFFiles() {
      this.cachedCSFFiles = await this.loadAllCSFFiles();
    }
    preparedMetaFromCSFFile({ csfFile: t }) {
      const r = t.meta;
      return this.prepareMetaWithCache(r, this.projectAnnotations, t.moduleExports.default);
    }
    async loadStory({ storyId: t }) {
      const r = await this.loadCSFFileByStoryId(t);
      return this.storyFromCSFFile({ storyId: t, csfFile: r });
    }
    storyFromCSFFile({ storyId: t, csfFile: r }) {
      const n = r.stories[t];
      if (!n) throw new _E({ storyId: t });
      const i = r.meta,
        s = this.prepareStoryWithCache(n, i, r.projectAnnotations ?? this.projectAnnotations);
      return (this.args.setInitial(s), (this.hooks[s.id] = this.hooks[s.id] || new yp()), s);
    }
    componentStoriesFromCSFFile({ csfFile: t }) {
      return Object.keys(this.storyIndex.entries)
        .filter((r) => !!t.stories[r])
        .map((r) => this.storyFromCSFFile({ storyId: r, csfFile: t }));
    }
    async loadEntry(t) {
      const r = await this.storyIdToEntry(t),
        n = r.type === 'docs' ? r.storiesImports : [],
        [i, ...s] = await Promise.all([
          this.importFn(r.importPath),
          ...n.map((a) => {
            const c = this.storyIndex.importPathToEntry(a);
            return this.loadCSFFileByStoryId(c.id);
          }),
        ]);
      return { entryExports: i, csfFiles: s };
    }
    getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
      const n = this.userGlobals.get(),
        { initialGlobals: i } = this.userGlobals,
        s = new Yy();
      return Hy({
        ...t,
        args: r ? t.initialArgs : this.args.get(t.id),
        initialGlobals: i,
        globalTypes: this.projectAnnotations.globalTypes,
        userGlobals: n,
        reporting: s,
        globals: { ...n, ...t.storyGlobals },
        hooks: this.hooks[t.id],
      });
    }
    addCleanupCallbacks(t, ...r) {
      this.cleanupCallbacks[t.id] = (this.cleanupCallbacks[t.id] || []).concat(r);
    }
    async cleanupStory(t) {
      this.hooks[t.id].clean();
      const r = this.cleanupCallbacks[t.id];
      if (r) for (const n of [...r].reverse()) await n();
      delete this.cleanupCallbacks[t.id];
    }
    extract(t = { includeDocsOnly: !1 }) {
      const { cachedCSFFiles: r } = this;
      if ((console.log('extract: extracting stories', r), !r)) throw new dE();
      const n = Object.entries(this.storyIndex.entries).reduce((i, [s, a]) => {
        if (a.type === 'docs') return i;
        const c = r[a.importPath],
          d = this.storyFromCSFFile({ storyId: s, csfFile: c });
        return (
          (!t.includeDocsOnly && d.parameters.docsOnly) ||
            (i[s] = Object.entries(d).reduce(
              (u, [p, f]) =>
                p === 'story' && a.subtype === 'test'
                  ? { ...u, story: a.parentName }
                  : p === 'moduleExport' || typeof f == 'function'
                    ? u
                    : Array.isArray(f)
                      ? Object.assign(u, { [p]: f.slice().sort() })
                      : Object.assign(u, { [p]: f }),
              {
                args: d.initialArgs,
                globals: {
                  ...this.userGlobals.initialGlobals,
                  ...this.userGlobals.globals,
                  ...d.storyGlobals,
                },
                storyId: a.parent ? a.parent : s,
              },
            )),
          i
        );
      }, {});
      return (console.log('extract: stories', n), n);
    }
  };
o(hx, 'StoryStore');
var gx = hx;
function bx(e) {
  return e.startsWith('\\\\?\\') ? e : e.replace(/\\/g, '/');
}
o(bx, 'slash');
var kV = o((e) => {
  if (e.length === 0) return e;
  const t = e[e.length - 1],
    r = t?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, '');
  if (e.length === 1) return [r];
  const n = e[e.length - 2];
  return r && n && r.toLowerCase() === n.toLowerCase()
    ? [...e.slice(0, -2), r]
    : r && (/^(story|stories)([.][^.]+)$/i.test(t) || /^index$/i.test(r))
      ? e.slice(0, -1)
      : [...e.slice(0, -1), r];
}, 'sanitize');
function jd(e) {
  return e
    .flatMap((t) => t.split('/'))
    .filter(Boolean)
    .join('/');
}
o(jd, 'pathJoin');
var vx = o((e, t, r) => {
    const { directory: n, importPathMatcher: i, titlePrefix: s = '' } = t || {};
    typeof e == 'number' &&
      Ve.warn(ve`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
    const a = bx(String(e));
    if (i.exec(a)) {
      if (!r) {
        const c = a.replace(n, '');
        let d = jd([s, c]).split('/');
        return ((d = kV(d)), d.join('/'));
      }
      return s ? jd([s, r]) : r;
    }
  }, 'userOrAutoTitleFromSpecifier'),
  DV = o((e, t, r) => {
    for (let n = 0; n < t.length; n += 1) {
      const i = vx(e, t[n], r);
      if (i) return i;
    }
    return r || void 0;
  }, 'userOrAutoTitle'),
  Kg = /\s*\/\s*/,
  LV = o(
    (e = {}) =>
      (t, r) => {
        if (t.title === r.title && !e.includeNames) return 0;
        const n = e.method || 'configure';
        let i = e.order || [];
        const s = t.title.trim().split(Kg),
          a = r.title.trim().split(Kg);
        e.includeNames && (s.push(t.name), a.push(r.name));
        let c = 0;
        for (; s[c] || a[c]; ) {
          if (!s[c]) return -1;
          if (!a[c]) return 1;
          const d = s[c],
            u = a[c];
          if (d !== u) {
            let f = i.indexOf(d),
              y = i.indexOf(u);
            const h = i.indexOf('*');
            return f !== -1 || y !== -1
              ? (f === -1 && (h !== -1 ? (f = h) : (f = i.length)),
                y === -1 && (h !== -1 ? (y = h) : (y = i.length)),
                f - y)
              : n === 'configure'
                ? 0
                : d.localeCompare(u, e.locales ? e.locales : void 0, {
                    numeric: !0,
                    sensitivity: 'accent',
                  });
          }
          let p = i.indexOf(d);
          (p === -1 && (p = i.indexOf('*')),
            (i = p !== -1 && Array.isArray(i[p + 1]) ? i[p + 1] : []),
            (c += 1));
        }
        return 0;
      },
    'storySort',
  ),
  FV = o((e, t, r) => {
    if (t) {
      let n;
      (typeof t == 'function' ? (n = t) : (n = LV(t)), e.sort(n));
    } else e.sort((n, i) => r.indexOf(n.importPath) - r.indexOf(i.importPath));
    return e;
  }, 'sortStoriesCommon'),
  BV = o((e, t, r) => {
    try {
      return FV(e, t, r);
    } catch (n) {
      throw new Error(ve`
    Error sorting stories with sort parameter ${t}:

    > ${n.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
    }
  }, 'sortStoriesV7'),
  ac = new Error('prepareAborted'),
  { AbortController: Yg } = globalThis;
function kd(e) {
  try {
    const { name: t = 'Error', message: r = String(e), stack: n } = e;
    return { name: t, message: r, stack: n };
  } catch {
    return { name: 'Error', message: String(e) };
  }
}
o(kd, 'serializeError');
var Ex = class {
  constructor(t, r, n, i, s, a, c = { autoplay: !0, forceInitialArgs: !1 }, d) {
    ((this.channel = t),
      (this.store = r),
      (this.renderToScreen = n),
      (this.callbacks = i),
      (this.id = s),
      (this.viewMode = a),
      (this.renderOptions = c),
      (this.type = 'story'),
      (this.notYetRendered = !0),
      (this.rerenderEnqueued = !1),
      (this.disableKeyListeners = !1),
      (this.teardownRender = o(() => {}, 'teardownRender')),
      (this.torndown = !1),
      (this.abortController = new Yg()),
      (this.renderId = Date.now()),
      d && ((this.story = d), (this.phase = 'preparing')));
  }
  async runPhase(t, r, n) {
    ((this.phase = r),
      this.channel.emit(gn, { newPhase: this.phase, renderId: this.renderId, storyId: this.id }),
      n && (await n(), this.checkIfAborted(t)));
  }
  checkIfAborted(t) {
    return (
      t.aborted &&
        !['finished', 'aborted', 'errored'].includes(this.phase) &&
        ((this.phase = 'aborted'),
        this.channel.emit(gn, { newPhase: this.phase, renderId: this.renderId, storyId: this.id })),
      t.aborted
    );
  }
  async prepare() {
    if (
      (await this.runPhase(this.abortController.signal, 'preparing', async () => {
        this.story = await this.store.loadStory({ storyId: this.id });
      }),
      this.abortController.signal.aborted)
    )
      throw (await this.store.cleanupStory(this.story), ac);
  }
  isEqual(t) {
    return !!(this.id === t.id && this.story && this.story === t.story);
  }
  isPreparing() {
    return ['preparing'].includes(this.phase);
  }
  isPending() {
    return ['loading', 'beforeEach', 'rendering', 'playing', 'afterEach'].includes(this.phase);
  }
  async renderToElement(t) {
    return ((this.canvasElement = t), this.render({ initial: !0, forceRemount: !0 }));
  }
  storyContext() {
    if (!this.story) throw new Error('Cannot call storyContext before preparing');
    const { forceInitialArgs: t } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: t });
  }
  async render({ initial: t = !1, forceRemount: r = !1 } = {}) {
    const { canvasElement: n } = this;
    if (!this.story) throw new Error('cannot render when not prepared');
    const i = this.story;
    if (!n) throw new Error('cannot render when canvasElement is unset');
    const {
      id: s,
      componentId: a,
      title: c,
      name: d,
      tags: u,
      applyLoaders: p,
      applyBeforeEach: f,
      applyAfterEach: y,
      unboundStoryFn: h,
      playFunction: g,
      runStep: T,
    } = i;
    r && !t && (this.cancelRender(), (this.abortController = new Yg()));
    const E = this.abortController.signal;
    let v = !1;
    const S = i.usesMount;
    try {
      const A = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: E,
        canvasElement: n,
        loaded: {},
        step: o((H, P) => T(H, P, A), 'step'),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: o(async () => {
          const H = await this.renderToScreen(N, n);
          ((this.teardownRender = H || (() => {})), (v = !0));
        }, 'renderToCanvas'),
        mount: o(async (...H) => {
          this.callbacks.showStoryDuringRender?.();
          let P = null;
          return (
            await this.runPhase(E, 'rendering', async () => {
              P = await i.mount(A)(...H);
            }),
            S && (await this.runPhase(E, 'playing')),
            P
          );
        }, 'mount'),
      };
      A.context = A;
      const N = {
        componentId: a,
        title: c,
        kind: c,
        id: s,
        name: d,
        story: d,
        tags: u,
        ...this.callbacks,
        showError: o((H) => ((this.phase = 'errored'), this.callbacks.showError(H)), 'showError'),
        showException: o(
          (H) => ((this.phase = 'errored'), this.callbacks.showException(H)),
          'showException',
        ),
        forceRemount: r || this.notYetRendered,
        storyContext: A,
        storyFn: o(() => h(A), 'storyFn'),
        unboundStoryFn: h,
      };
      if (
        (await this.runPhase(E, 'loading', async () => {
          A.loaded = await p(A);
        }),
        E.aborted)
      )
        return;
      const j = await f(A);
      if (
        (this.store.addCleanupCallbacks(i, ...j),
        this.checkIfAborted(E) ||
          (!v && !S && (await A.mount()), (this.notYetRendered = !1), E.aborted))
      )
        return;
      const C = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0,
        R = new Set(),
        w = o((H) => {
          H.error && R.add(H.error);
        }, 'onError'),
        _ = o((H) => {
          H.reason && R.add(H.reason);
        }, 'onUnhandledRejection');
      if (this.renderOptions.autoplay && r && g && this.phase !== 'errored') {
        (window?.addEventListener?.('error', w),
          window?.addEventListener?.('unhandledrejection', _),
          (this.disableKeyListeners = !0));
        try {
          if (
            (S
              ? await g(A)
              : ((A.mount = async () => {
                  throw new fp({ playFunction: g.toString() });
                }),
                await this.runPhase(E, 'playing', async () => g(A))),
            !v)
          )
            throw new NE();
          (this.checkIfAborted(E),
            !C && R.size > 0
              ? await this.runPhase(E, 'errored')
              : await this.runPhase(E, 'played'));
        } catch (H) {
          if (
            (this.callbacks.showStoryDuringRender?.(),
            await this.runPhase(E, 'errored', async () => {
              this.channel.emit(Eb, kd(H));
            }),
            this.story.parameters.throwPlayFunctionExceptions !== !1)
          )
            throw H;
          console.error(H);
        }
        if (
          (!C && R.size > 0 && this.channel.emit(Tb, Array.from(R).map(kd)),
          (this.disableKeyListeners = !1),
          window?.removeEventListener?.('unhandledrejection', _),
          window?.removeEventListener?.('error', w),
          E.aborted)
        )
          return;
      }
      (await this.runPhase(E, 'completing', async () => {
        Wy() ? this.store.addCleanupCallbacks(i, ic()) : await sc(E);
      }),
        await this.runPhase(E, 'completed', async () => {
          this.channel.emit(Vs, s);
        }),
        this.phase !== 'errored' &&
          (await this.runPhase(E, 'afterEach', async () => {
            await y(A);
          })));
      const k = !C && R.size > 0,
        I = A.reporting.reports.some((H) => H.status === 'failed'),
        V = k || I;
      await this.runPhase(E, 'finished', async () =>
        this.channel.emit(Hc, {
          storyId: s,
          status: V ? 'error' : 'success',
          reporters: A.reporting.reports,
        }),
      );
    } catch (A) {
      ((this.phase = 'errored'),
        this.callbacks.showException(A),
        await this.runPhase(E, 'finished', async () =>
          this.channel.emit(Hc, { storyId: s, status: 'error', reporters: [] }),
        ));
    }
    this.rerenderEnqueued && ((this.rerenderEnqueued = !1), this.render());
  }
  async rerender() {
    if (this.isPending() && this.phase !== 'playing') this.rerenderEnqueued = !0;
    else return this.render();
  }
  async remount() {
    return (await this.teardown(), this.render({ forceRemount: !0 }));
  }
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === 'playing' &&
      (this.abortController.abort(), this.runPhase(this.abortController.signal, 'aborted'));
  }
  async teardown() {
    ((this.torndown = !0),
      this.cancelRender(),
      this.story && (await this.store.cleanupStory(this.story)));
    for (let t = 0; t < 3; t += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((r) => setTimeout(r, 0));
    }
    (window?.location?.reload?.(), await new Promise(() => {}));
  }
};
o(Ex, 'StoryRender');
var Dd = Ex,
  { fetch: JV } = te,
  $V = './index.json',
  Tx = class {
    constructor(t, r, n = Dt.getChannel(), i = !0) {
      ((this.importFn = t),
        (this.getProjectAnnotations = r),
        (this.channel = n),
        (this.storyRenders = []),
        (this.storeInitializationPromise = new Promise((s, a) => {
          ((this.resolveStoreInitializationPromise = s),
            (this.rejectStoreInitializationPromise = a));
        })),
        i && this.initialize());
    }
    get storyStore() {
      return new Proxy(
        {},
        {
          get: o((t, r) => {
            if (this.storyStoreValue)
              return (
                ep('Accessing the Story Store is deprecated and will be removed in 9.0'),
                this.storyStoreValue[r]
              );
            throw new PE();
          }, 'get'),
        },
      );
    }
    async initialize() {
      this.setupListeners();
      try {
        const t = await this.getProjectAnnotationsOrRenderError();
        (await this.runBeforeAllHook(t), await this.initializeWithProjectAnnotations(t));
        const r = globalThis?.navigator?.userAgent;
        await this.channel.emit(Sb, { userAgent: r });
      } catch (t) {
        this.rejectStoreInitializationPromise(t);
      }
    }
    ready() {
      return this.storeInitializationPromise;
    }
    setupListeners() {
      (this.channel.on(Cb, this.onStoryIndexChanged.bind(this)),
        this.channel.on(Qd, this.onUpdateGlobals.bind(this)),
        this.channel.on(Zd, this.onUpdateArgs.bind(this)),
        this.channel.on(Db, this.onRequestArgTypesInfo.bind(this)),
        this.channel.on(Yd, this.onResetArgs.bind(this)),
        this.channel.on(Kd, this.onForceReRender.bind(this)),
        this.channel.on(Us, this.onForceRemount.bind(this)),
        this.channel.on(qb, this.onStoryHotUpdated.bind(this)));
    }
    async getProjectAnnotationsOrRenderError() {
      try {
        const t = await this.getProjectAnnotations();
        if (((this.renderToCanvas = t.renderToCanvas), !this.renderToCanvas)) throw new fE();
        return t;
      } catch (t) {
        throw (this.renderPreviewEntryError('Error reading preview.js:', t), t);
      }
    }
    async initializeWithProjectAnnotations(t) {
      this.projectAnnotationsBeforeInitialization = t;
      try {
        const r = await this.getStoryIndexFromServer();
        return this.initializeWithStoryIndex(r);
      } catch (r) {
        throw (this.renderPreviewEntryError('Error loading story index:', r), r);
      }
    }
    async runBeforeAllHook(t) {
      try {
        (await this.beforeAllCleanup?.(), (this.beforeAllCleanup = await t.beforeAll?.()));
      } catch (r) {
        throw (this.renderPreviewEntryError('Error in beforeAll hook:', r), r);
      }
    }
    async getStoryIndexFromServer() {
      const t = await JV($V);
      if (t.status === 200) return t.json();
      throw new hE({ text: await t.text() });
    }
    initializeWithStoryIndex(t) {
      if (!this.projectAnnotationsBeforeInitialization)
        throw new Error('Cannot call initializeWithStoryIndex until project annotations resolve');
      ((this.storyStoreValue = new gx(
        t,
        this.importFn,
        this.projectAnnotationsBeforeInitialization,
      )),
        delete this.projectAnnotationsBeforeInitialization,
        this.setInitialGlobals(),
        this.resolveStoreInitializationPromise());
    }
    async setInitialGlobals() {
      this.emitGlobals();
    }
    emitGlobals() {
      if (!this.storyStoreValue) throw new Rt({ methodName: 'emitGlobals' });
      const t = {
        globals: this.storyStoreValue.userGlobals.get() || {},
        globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {},
      };
      this.channel.emit(Rb, t);
    }
    async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
      (delete this.previewEntryError, (this.getProjectAnnotations = t));
      const r = await this.getProjectAnnotationsOrRenderError();
      if ((await this.runBeforeAllHook(r), !this.storyStoreValue)) {
        await this.initializeWithProjectAnnotations(r);
        return;
      }
      (this.storyStoreValue.setProjectAnnotations(r), this.emitGlobals());
    }
    async onStoryIndexChanged() {
      if (
        (delete this.previewEntryError,
        !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      )
        try {
          const t = await this.getStoryIndexFromServer();
          if (this.projectAnnotationsBeforeInitialization) {
            this.initializeWithStoryIndex(t);
            return;
          }
          await this.onStoriesChanged({ storyIndex: t });
        } catch (t) {
          throw (this.renderPreviewEntryError('Error loading story index:', t), t);
        }
    }
    async onStoriesChanged({ importFn: t, storyIndex: r }) {
      if (!this.storyStoreValue) throw new Rt({ methodName: 'onStoriesChanged' });
      await this.storyStoreValue.onStoriesChanged({ importFn: t, storyIndex: r });
    }
    async onUpdateGlobals({ globals: t, currentStory: r }) {
      if ((this.storyStoreValue || (await this.storeInitializationPromise), !this.storyStoreValue))
        throw new Rt({ methodName: 'onUpdateGlobals' });
      if ((this.storyStoreValue.userGlobals.update(t), r)) {
        const {
          initialGlobals: n,
          storyGlobals: i,
          userGlobals: s,
          globals: a,
        } = this.storyStoreValue.getStoryContext(r);
        this.channel.emit(Ci, { initialGlobals: n, userGlobals: s, storyGlobals: i, globals: a });
      } else {
        const { initialGlobals: n, globals: i } = this.storyStoreValue.userGlobals;
        this.channel.emit(Ci, { initialGlobals: n, userGlobals: i, storyGlobals: {}, globals: i });
      }
      await Promise.all(this.storyRenders.map((n) => n.rerender()));
    }
    async onUpdateArgs({ storyId: t, updatedArgs: r }) {
      if (!this.storyStoreValue) throw new Rt({ methodName: 'onUpdateArgs' });
      (this.storyStoreValue.args.update(t, r),
        await Promise.all(
          this.storyRenders
            .filter((n) => n.id === t && !n.renderOptions.forceInitialArgs)
            .map((n) => (n.story && n.story.usesMount ? n.remount() : n.rerender())),
        ),
        this.channel.emit(Pb, { storyId: t, args: this.storyStoreValue.args.get(t) }));
    }
    async onRequestArgTypesInfo({ id: t, payload: r }) {
      try {
        await this.storeInitializationPromise;
        const n = await this.storyStoreValue?.loadStory(r);
        this.channel.emit(Gc, {
          id: t,
          success: !0,
          payload: { argTypes: n?.argTypes || {} },
          error: null,
        });
      } catch (n) {
        this.channel.emit(Gc, { id: t, success: !1, error: n?.message });
      }
    }
    async onResetArgs({ storyId: t, argNames: r }) {
      if (!this.storyStoreValue) throw new Rt({ methodName: 'onResetArgs' });
      const i =
          this.storyRenders.find((c) => c.id === t)?.story ||
          (await this.storyStoreValue.loadStory({ storyId: t })),
        a = (
          r || [
            ...new Set([
              ...Object.keys(i.initialArgs),
              ...Object.keys(this.storyStoreValue.args.get(t)),
            ]),
          ]
        ).reduce((c, d) => ((c[d] = i.initialArgs[d]), c), {});
      await this.onUpdateArgs({ storyId: t, updatedArgs: a });
    }
    async onForceReRender() {
      await Promise.all(this.storyRenders.map((t) => t.rerender()));
    }
    async onForceRemount({ storyId: t }) {
      await Promise.all(this.storyRenders.filter((r) => r.id === t).map((r) => r.remount()));
    }
    async onStoryHotUpdated() {
      await Promise.all(this.storyRenders.map((t) => t.cancelPlayFunction()));
    }
    renderStoryToElement(t, r, n, i) {
      if (!this.renderToCanvas || !this.storyStoreValue)
        throw new Rt({ methodName: 'renderStoryToElement' });
      const s = new Dd(
        this.channel,
        this.storyStoreValue,
        this.renderToCanvas,
        n,
        t.id,
        'docs',
        i,
        t,
      );
      return (
        s.renderToElement(r),
        this.storyRenders.push(s),
        async () => {
          await this.teardownRender(s);
        }
      );
    }
    async teardownRender(t, { viewModeChanged: r } = {}) {
      ((this.storyRenders = this.storyRenders.filter((n) => n !== t)),
        await t?.teardown?.({ viewModeChanged: r }));
    }
    async loadStory({ storyId: t }) {
      if (!this.storyStoreValue) throw new Rt({ methodName: 'loadStory' });
      return this.storyStoreValue.loadStory({ storyId: t });
    }
    getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
      if (!this.storyStoreValue) throw new Rt({ methodName: 'getStoryContext' });
      return this.storyStoreValue.getStoryContext(t, { forceInitialArgs: r });
    }
    async extract(t) {
      if (!this.storyStoreValue) throw new Rt({ methodName: 'extract' });
      if (this.previewEntryError) throw this.previewEntryError;
      return (await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(t));
    }
    renderPreviewEntryError(t, r) {
      ((this.previewEntryError = r), De.error(t), De.error(r), this.channel.emit(bb, r));
    }
  };
o(Tx, 'Preview');
var wx = Tx,
  Sx = class {
    constructor(t, r, n, i) {
      ((this.channel = t),
        (this.store = r),
        (this.renderStoryToElement = n),
        (this.storyIdByName = o((s) => {
          const a = this.nameToStoryId.get(s);
          if (a) return a;
          throw new Error(`No story found with that name: ${s}`);
        }, 'storyIdByName')),
        (this.componentStories = o(() => this.componentStoriesValue, 'componentStories')),
        (this.componentStoriesFromCSFFile = o(
          (s) => this.store.componentStoriesFromCSFFile({ csfFile: s }),
          'componentStoriesFromCSFFile',
        )),
        (this.storyById = o((s) => {
          if (!s) {
            if (!this.primaryStory)
              throw new Error(
                'No primary story defined for docs entry. Did you forget to use `<Meta>`?',
              );
            return this.primaryStory;
          }
          const a = this.storyIdToCSFFile.get(s);
          if (!a) throw new Error(`Called \`storyById\` for story that was never loaded: ${s}`);
          return this.store.storyFromCSFFile({ storyId: s, csfFile: a });
        }, 'storyById')),
        (this.getStoryContext = o(
          (s) => ({ ...this.store.getStoryContext(s), loaded: {}, viewMode: 'docs' }),
          'getStoryContext',
        )),
        (this.loadStory = o((s) => this.store.loadStory({ storyId: s }), 'loadStory')),
        (this.componentStoriesValue = []),
        (this.storyIdToCSFFile = new Map()),
        (this.exportToStory = new Map()),
        (this.exportsToCSFFile = new Map()),
        (this.nameToStoryId = new Map()),
        (this.attachedCSFFiles = new Set()),
        i.forEach((s, a) => {
          this.referenceCSFFile(s);
        }));
    }
    referenceCSFFile(t) {
      (this.exportsToCSFFile.set(t.moduleExports, t),
        this.exportsToCSFFile.set(t.moduleExports.default, t),
        this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
          const i = t.stories[n.id];
          (this.storyIdToCSFFile.set(i.id, t), this.exportToStory.set(i.moduleExport, n));
        }));
    }
    attachCSFFile(t) {
      if (!this.exportsToCSFFile.has(t.moduleExports))
        throw new Error('Cannot attach a CSF file that has not been referenced');
      if (this.attachedCSFFiles.has(t)) return;
      (this.attachedCSFFiles.add(t),
        this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
          (this.nameToStoryId.set(n.name, n.id),
            this.componentStoriesValue.push(n),
            this.primaryStory || (this.primaryStory = n));
        }));
    }
    referenceMeta(t, r) {
      const n = this.resolveModuleExport(t);
      if (n.type !== 'meta')
        throw new Error(
          '<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?',
        );
      r && this.attachCSFFile(n.csfFile);
    }
    get projectAnnotations() {
      const { projectAnnotations: t } = this.store;
      if (!t)
        throw new Error(
          "Can't get projectAnnotations from DocsContext before they are initialized",
        );
      return t;
    }
    resolveAttachedModuleExportType(t) {
      if (t === 'story') {
        if (!this.primaryStory)
          throw new Error(
            'No primary story attached to this docs file, did you forget to use <Meta of={} />?',
          );
        return { type: 'story', story: this.primaryStory };
      }
      if (this.attachedCSFFiles.size === 0)
        throw new Error(
          'No CSF file attached to this docs file, did you forget to use <Meta of={} />?',
        );
      const r = Array.from(this.attachedCSFFiles)[0];
      if (t === 'meta') return { type: 'meta', csfFile: r };
      const { component: n } = r.meta;
      if (!n)
        throw new Error(
          'Attached CSF file does not defined a component, did you forget to export one?',
        );
      return { type: 'component', component: n };
    }
    resolveModuleExport(t) {
      const r = this.exportsToCSFFile.get(t);
      if (r) return { type: 'meta', csfFile: r };
      const n = this.exportToStory.get(nc(t) ? t.input : t);
      return n ? { type: 'story', story: n } : { type: 'component', component: t };
    }
    resolveOf(t, r = []) {
      let n;
      if (['component', 'meta', 'story'].includes(t)) {
        const i = t;
        n = this.resolveAttachedModuleExportType(i);
      } else n = this.resolveModuleExport(t);
      if (r.length && !r.includes(n.type)) {
        const i = n.type === 'component' ? 'component or unknown' : n.type;
        throw new Error(ve`Invalid value passed to the 'of' prop. The value was resolved to a '${i}' type but the only types for this block are: ${r.join(', ')}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
      }
      switch (n.type) {
        case 'component':
          return { ...n, projectAnnotations: this.projectAnnotations };
        case 'meta':
          return { ...n, preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: n.csfFile }) };
        case 'story':
        default:
          return n;
      }
    }
  };
o(Sx, 'DocsContext');
var Zy = Sx,
  _x = class {
    constructor(t, r, n, i) {
      ((this.channel = t),
        (this.store = r),
        (this.entry = n),
        (this.callbacks = i),
        (this.type = 'docs'),
        (this.subtype = 'csf'),
        (this.torndown = !1),
        (this.disableKeyListeners = !1),
        (this.preparing = !1),
        (this.id = n.id),
        (this.renderId = Date.now()));
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
      if (this.torndown) throw ac;
      const { importPath: n, title: i } = this.entry,
        s = this.store.processCSFFileWithCache(t, n, i),
        a = Object.keys(s.stories)[0];
      ((this.story = this.store.storyFromCSFFile({ storyId: a, csfFile: s })),
        (this.csfFiles = [s, ...r]),
        (this.preparing = !1));
    }
    isEqual(t) {
      return !!(this.id === t.id && this.story && this.story === t.story);
    }
    docsContext(t) {
      if (!this.csfFiles) throw new Error('Cannot render docs before preparing');
      const r = new Zy(this.channel, this.store, t, this.csfFiles);
      return (this.csfFiles.forEach((n) => r.attachCSFFile(n)), r);
    }
    async renderToElement(t, r) {
      if (!this.story || !this.csfFiles) throw new Error('Cannot render docs before preparing');
      const n = this.docsContext(r),
        { docs: i } = this.story.parameters || {};
      if (!i)
        throw new Error(
          'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed',
        );
      const s = await i.renderer(),
        { render: a } = s,
        c = o(async () => {
          try {
            (await a(n, i, t), this.channel.emit(Wd, this.id));
          } catch (d) {
            this.callbacks.showException(d);
          }
        }, 'renderDocs');
      return (
        (this.rerender = async () => c()),
        (this.teardownRender = async ({ viewModeChanged: d }) => {
          !d || !t || s.unmount(t);
        }),
        c()
      );
    }
    async teardown({ viewModeChanged: t } = {}) {
      (this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0));
    }
  };
o(_x, 'CsfDocsRender');
var Xg = _x,
  Rx = class {
    constructor(t, r, n, i) {
      ((this.channel = t),
        (this.store = r),
        (this.entry = n),
        (this.callbacks = i),
        (this.type = 'docs'),
        (this.subtype = 'mdx'),
        (this.torndown = !1),
        (this.disableKeyListeners = !1),
        (this.preparing = !1),
        (this.id = n.id),
        (this.renderId = Date.now()));
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
      if (this.torndown) throw ac;
      ((this.csfFiles = r), (this.exports = t), (this.preparing = !1));
    }
    isEqual(t) {
      return !!(this.id === t.id && this.exports && this.exports === t.exports);
    }
    docsContext(t) {
      if (!this.csfFiles) throw new Error('Cannot render docs before preparing');
      return new Zy(this.channel, this.store, t, this.csfFiles);
    }
    async renderToElement(t, r) {
      if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
        throw new Error('Cannot render docs before preparing');
      const n = this.docsContext(r),
        { docs: i } = this.store.projectAnnotations.parameters ?? {};
      if (!i)
        throw new Error(
          'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed',
        );
      const s = { ...i, page: this.exports.default },
        a = await i.renderer(),
        { render: c } = a,
        d = o(async () => {
          try {
            (await c(n, s, t), this.channel.emit(Wd, this.id));
          } catch (u) {
            this.callbacks.showException(u);
          }
        }, 'renderDocs');
      return (
        (this.rerender = async () => d()),
        (this.teardownRender = async ({ viewModeChanged: u } = {}) => {
          !u || !t || (a.unmount(t), (this.torndown = !0));
        }),
        d()
      );
    }
    async teardown({ viewModeChanged: t } = {}) {
      (this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0));
    }
  };
o(Rx, 'MdxDocsRender');
var Qg = Rx,
  UV = globalThis;
function Px(e) {
  const t = (e.composedPath && e.composedPath()[0]) || e.target;
  return /input|textarea/i.test(t.tagName) || t.getAttribute('contenteditable') !== null;
}
o(Px, 'focusInInput');
var Ax = 'attached-mdx',
  VV = 'unattached-mdx';
function Ox({ tags: e }) {
  return e?.includes(VV) || e?.includes(Ax);
}
o(Ox, 'isMdxEntry');
function Bs(e) {
  return e.type === 'story';
}
o(Bs, 'isStoryRender');
function Cx(e) {
  return e.type === 'docs';
}
o(Cx, 'isDocsRender');
function xx(e) {
  return Cx(e) && e.subtype === 'csf';
}
o(xx, 'isCsfDocsRender');
var Nx = class extends wx {
  constructor(t, r, n, i) {
    (super(t, r, void 0, !1),
      (this.importFn = t),
      (this.getProjectAnnotations = r),
      (this.selectionStore = n),
      (this.view = i),
      this.initialize());
  }
  setupListeners() {
    (super.setupListeners(),
      (UV.onkeydown = this.onKeydown.bind(this)),
      this.channel.on(Xd, this.onSetCurrentStory.bind(this)),
      this.channel.on(jb, this.onUpdateQueryParams.bind(this)),
      this.channel.on(wb, this.onPreloadStories.bind(this)));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue) throw new Rt({ methodName: 'setInitialGlobals' });
    const { globals: t } = this.selectionStore.selectionSpecifier || {};
    (t && this.storyStoreValue.userGlobals.updateFromPersisted(t), this.emitGlobals());
  }
  async initializeWithStoryIndex(t) {
    return (await super.initializeWithStoryIndex(t), this.selectSpecifiedStory());
  }
  async selectSpecifiedStory() {
    if (!this.storyStoreValue) throw new Rt({ methodName: 'selectSpecifiedStory' });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    const { storySpecifier: t, args: r } = this.selectionStore.selectionSpecifier,
      n = this.storyStoreValue.storyIndex.entryFromSpecifier(t);
    if (!n) {
      t === '*'
        ? this.renderStoryLoadingException(t, new EE())
        : this.renderStoryLoadingException(t, new wE({ storySpecifier: t.toString() }));
      return;
    }
    const { id: i, type: s } = n;
    (this.selectionStore.setSelection({ storyId: i, viewMode: s }),
      this.channel.emit(Nb, this.selectionStore.selection),
      this.channel.emit(Uc, this.selectionStore.selection),
      await this.renderSelection({ persistedArgs: r }));
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
    (await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: t }),
      this.selectionStore.selection && this.renderSelection());
  }
  async onStoriesChanged({ importFn: t, storyIndex: r }) {
    (await super.onStoriesChanged({ importFn: t, storyIndex: r }),
      this.selectionStore.selection
        ? await this.renderSelection()
        : await this.selectSpecifiedStory());
  }
  onKeydown(t) {
    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !Px(t)) {
      const { altKey: r, ctrlKey: n, metaKey: i, shiftKey: s, key: a, code: c, keyCode: d } = t;
      this.channel.emit(_b, {
        event: { altKey: r, ctrlKey: n, metaKey: i, shiftKey: s, key: a, code: c, keyCode: d },
      });
    }
  }
  async onSetCurrentStory(t) {
    (this.selectionStore.setSelection({ viewMode: 'story', ...t }),
      await this.storeInitializationPromise,
      this.channel.emit(Uc, this.selectionStore.selection),
      this.renderSelection());
  }
  onUpdateQueryParams(t) {
    this.selectionStore.setQueryParams(t);
  }
  async onUpdateGlobals({ globals: t }) {
    const r = (this.currentRender instanceof Dd && this.currentRender.story) || void 0;
    (super.onUpdateGlobals({ globals: t, currentStory: r }),
      (this.currentRender instanceof Qg || this.currentRender instanceof Xg) &&
        (await this.currentRender.rerender?.()));
  }
  async onUpdateArgs({ storyId: t, updatedArgs: r }) {
    super.onUpdateArgs({ storyId: t, updatedArgs: r });
  }
  async onPreloadStories({ ids: t }) {
    (await this.storeInitializationPromise,
      this.storyStoreValue &&
        (await Promise.allSettled(t.map((r) => this.storyStoreValue?.loadEntry(r)))));
  }
  async renderSelection({ persistedArgs: t } = {}) {
    const { renderToCanvas: r } = this;
    if (!this.storyStoreValue || !r) throw new Rt({ methodName: 'renderSelection' });
    const { selection: n } = this.selectionStore;
    if (!n) throw new Error('Cannot call renderSelection as no selection was made');
    const { storyId: i } = n;
    let s;
    try {
      s = await this.storyStoreValue.storyIdToEntry(i);
    } catch (y) {
      (this.currentRender && (await this.teardownRender(this.currentRender)),
        this.renderStoryLoadingException(i, y));
      return;
    }
    const a = this.currentSelection?.storyId !== i,
      c = this.currentRender?.type !== s.type;
    (s.type === 'story'
      ? this.view.showPreparingStory({ immediate: c })
      : this.view.showPreparingDocs({ immediate: c }),
      this.currentRender?.isPreparing() && (await this.teardownRender(this.currentRender)));
    let d;
    s.type === 'story'
      ? (d = new Dd(this.channel, this.storyStoreValue, r, this.mainStoryCallbacks(i), i, 'story'))
      : Ox(s)
        ? (d = new Qg(this.channel, this.storyStoreValue, s, this.mainStoryCallbacks(i)))
        : (d = new Xg(this.channel, this.storyStoreValue, s, this.mainStoryCallbacks(i)));
    const u = this.currentSelection;
    this.currentSelection = n;
    const p = this.currentRender;
    this.currentRender = d;
    try {
      await d.prepare();
    } catch (y) {
      (p && (await this.teardownRender(p)), y !== ac && this.renderStoryLoadingException(i, y));
      return;
    }
    const f = !a && p && !d.isEqual(p);
    if (
      (t && Bs(d) && (rr(!!d.story), this.storyStoreValue.args.updateFromPersisted(d.story, t)),
      p && !p.torndown && !a && !f && !c)
    ) {
      ((this.currentRender = p), this.channel.emit(Mb, i), this.view.showMain());
      return;
    }
    if (
      (p && (await this.teardownRender(p, { viewModeChanged: c })),
      u && (a || c) && this.channel.emit(Ab, i),
      Bs(d))
    ) {
      rr(!!d.story);
      const {
        parameters: y,
        initialArgs: h,
        argTypes: g,
        unmappedArgs: T,
        initialGlobals: E,
        userGlobals: v,
        storyGlobals: S,
        globals: A,
      } = this.storyStoreValue.getStoryContext(d.story);
      (this.channel.emit(xb, { id: i, parameters: y, initialArgs: h, argTypes: g, args: T }),
        this.channel.emit(Ci, { userGlobals: v, storyGlobals: S, globals: A, initialGlobals: E }));
    } else {
      let { parameters: y } = this.storyStoreValue.projectAnnotations;
      const { initialGlobals: h, globals: g } = this.storyStoreValue.userGlobals;
      if (
        (this.channel.emit(Ci, { globals: g, initialGlobals: h, storyGlobals: {}, userGlobals: g }),
        xx(d) || d.entry.tags?.includes(Ax))
      ) {
        if (!d.csfFiles) throw new bE({ storyId: i });
        ({ parameters: y } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: d.csfFiles[0],
        }));
      }
      this.channel.emit(vb, { id: i, parameters: y });
    }
    Bs(d)
      ? (rr(!!d.story),
        this.storyRenders.push(d),
        this.currentRender.renderToElement(this.view.prepareForStory(d.story)))
      : this.currentRender.renderToElement(
          this.view.prepareForDocs(),
          this.renderStoryToElement.bind(this),
        );
  }
  async teardownRender(t, { viewModeChanged: r = !1 } = {}) {
    ((this.storyRenders = this.storyRenders.filter((n) => n !== t)),
      await t?.teardown?.({ viewModeChanged: r }));
  }
  mainStoryCallbacks(t) {
    return {
      showStoryDuringRender: o(() => this.view.showStoryDuringRender(), 'showStoryDuringRender'),
      showMain: o(() => this.view.showMain(), 'showMain'),
      showError: o((r) => this.renderError(t, r), 'showError'),
      showException: o((r) => this.renderException(t, r), 'showException'),
    };
  }
  renderPreviewEntryError(t, r) {
    (super.renderPreviewEntryError(t, r), this.view.showErrorDisplay(r));
  }
  renderMissingStory() {
    (this.view.showNoPreview(), this.channel.emit(Vc));
  }
  renderStoryLoadingException(t, r) {
    (De.error(r), this.view.showErrorDisplay(r), this.channel.emit(Vc, t));
  }
  renderException(t, r) {
    const { name: n = 'Error', message: i = String(r), stack: s } = r,
      a = this.currentRender?.renderId;
    (this.channel.emit(Ib, { name: n, message: i, stack: s }),
      this.channel.emit(gn, { newPhase: 'errored', renderId: a, storyId: t }),
      this.view.showErrorDisplay(r),
      De.error(`Error rendering story '${t}':`),
      De.error(r));
  }
  renderError(t, { title: r, description: n }) {
    const i = this.currentRender?.renderId;
    (this.channel.emit(Ob, { title: r, description: n }),
      this.channel.emit(gn, { newPhase: 'errored', renderId: i, storyId: t }),
      this.view.showErrorDisplay({ message: r, stack: n }),
      De.error(`Error rendering story ${r}: ${n}`));
  }
};
o(Nx, 'PreviewWithSelection');
var Ix = Nx,
  Ld = ze(Hd(), 1),
  HV = ze(Hd(), 1),
  Zg = /^[a-zA-Z0-9 _-]*$/,
  Mx = /^-?[0-9]+(\.[0-9]+)?$/,
  GV = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i,
  qx =
    /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i,
  Fd = o(
    (e = '', t) =>
      e === null || e === '' || !Zg.test(e)
        ? !1
        : t == null || t instanceof Date || typeof t == 'number' || typeof t == 'boolean'
          ? !0
          : typeof t == 'string'
            ? Zg.test(t) || Mx.test(t) || GV.test(t) || qx.test(t)
            : Array.isArray(t)
              ? t.every((r) => Fd(e, r))
              : Gt(t)
                ? Object.entries(t).every(([r, n]) => Fd(r, n))
                : !1,
    'validateArgs',
  ),
  zV = {
    delimiter: ';',
    nesting: !0,
    arrayRepeat: !0,
    arrayRepeatSyntax: 'bracket',
    nestingSyntax: 'js',
    valueDeserializer(e) {
      if (e.startsWith('!')) {
        if (e === '!undefined') return;
        if (e === '!null') return null;
        if (e === '!true') return !0;
        if (e === '!false') return !1;
        if (e.startsWith('!date(') && e.endsWith(')'))
          return new Date(e.replaceAll(' ', '+').slice(6, -1));
        if (e.startsWith('!hex(') && e.endsWith(')')) return `#${e.slice(5, -1)}`;
        const t = e.slice(1).match(qx);
        if (t)
          return e.startsWith('!rgba') || e.startsWith('!RGBA')
            ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})`
            : e.startsWith('!hsla') || e.startsWith('!HSLA')
              ? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})`
              : e.startsWith('!rgb') || e.startsWith('!RGB')
                ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})`
                : `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`;
      }
      return Mx.test(e) ? Number(e) : e;
    },
  },
  eb = o((e) => {
    const t = e.split(';').map((r) => r.replace('=', '~').replace(':', '='));
    return Object.entries((0, HV.parse)(t.join(';'), zV)).reduce(
      (r, [n, i]) =>
        Fd(n, i)
          ? Object.assign(r, { [n]: i })
          : (Ve.warn(ve`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `),
            r),
      {},
    );
  }, 'parseArgsParam'),
  { history: jx, document: Br } = te;
function kx(e) {
  const t = (e || '').match(/^\/story\/(.+)/);
  if (!t) throw new Error(`Invalid path '${e}',  must start with '/story/'`);
  return t[1];
}
o(kx, 'pathToId');
var Dx = o(({ selection: e, extraParams: t }) => {
    const r = Br?.location.search.slice(1),
      { path: n, selectedKind: i, selectedStory: s, ...a } = (0, Ld.parse)(r);
    return `?${(0, Ld.stringify)({ ...a, ...t, ...(e && { id: e.storyId, viewMode: e.viewMode }) })}`;
  }, 'getQueryString'),
  WV = o((e) => {
    if (!e) return;
    const t = Dx({ selection: e }),
      { hash: r = '' } = Br.location;
    ((Br.title = e.storyId), jx.replaceState({}, '', `${Br.location.pathname}${t}${r}`));
  }, 'setPath'),
  KV = o((e) => e != null && typeof e == 'object' && Array.isArray(e) === !1, 'isObject'),
  Oi = o((e) => {
    if (e !== void 0) {
      if (typeof e == 'string') return e;
      if (Array.isArray(e)) return Oi(e[0]);
      if (KV(e)) return Oi(Object.values(e).filter(Boolean));
    }
  }, 'getFirstString'),
  YV = o(() => {
    if (typeof Br < 'u') {
      const e = Br.location.search.slice(1),
        t = (0, Ld.parse)(e),
        r = typeof t.args == 'string' ? eb(t.args) : void 0,
        n = typeof t.globals == 'string' ? eb(t.globals) : void 0;
      let i = Oi(t.viewMode);
      (typeof i != 'string' || !i.match(/docs|story/)) && (i = 'story');
      const s = Oi(t.path),
        a = s ? kx(s) : Oi(t.id);
      if (a) return { storySpecifier: a, args: r, globals: n, viewMode: i };
    }
    return null;
  }, 'getSelectionSpecifierFromPath'),
  Lx = class {
    constructor() {
      this.selectionSpecifier = YV();
    }
    setSelection(t) {
      ((this.selection = t), WV(this.selection));
    }
    setQueryParams(t) {
      const r = Dx({ extraParams: t }),
        { hash: n = '' } = Br.location;
      jx.replaceState({}, '', `${Br.location.pathname}${r}${n}`);
    }
  };
o(Lx, 'UrlStore');
var Fx = Lx,
  XV = ze(Tj(), 1),
  QV = ze(Hd(), 1),
  { document: yt } = te,
  tb = 100,
  Bx = ((e) => (
    (e.MAIN = 'MAIN'),
    (e.NOPREVIEW = 'NOPREVIEW'),
    (e.PREPARING_STORY = 'PREPARING_STORY'),
    (e.PREPARING_DOCS = 'PREPARING_DOCS'),
    (e.ERROR = 'ERROR'),
    e
  ))(Bx || {}),
  Dc = {
    PREPARING_STORY: 'sb-show-preparing-story',
    PREPARING_DOCS: 'sb-show-preparing-docs',
    MAIN: 'sb-show-main',
    NOPREVIEW: 'sb-show-nopreview',
    ERROR: 'sb-show-errordisplay',
  },
  Lc = { centered: 'sb-main-centered', fullscreen: 'sb-main-fullscreen', padded: 'sb-main-padded' },
  rb = new XV.default({ escapeXML: !0 }),
  Jx = class {
    constructor() {
      if (((this.testing = !1), typeof yt < 'u')) {
        const { __SPECIAL_TEST_PARAMETER__: t } = (0, QV.parse)(yt.location.search.slice(1));
        switch (t) {
          case 'preparing-story': {
            (this.showPreparingStory(), (this.testing = !0));
            break;
          }
          case 'preparing-docs': {
            (this.showPreparingDocs(), (this.testing = !0));
            break;
          }
        }
      }
    }
    prepareForStory(t) {
      return (
        this.showStory(),
        this.applyLayout(t.parameters.layout),
        (yt.documentElement.scrollTop = 0),
        (yt.documentElement.scrollLeft = 0),
        this.storyRoot()
      );
    }
    storyRoot() {
      return yt.getElementById('storybook-root');
    }
    prepareForDocs() {
      return (
        this.showMain(),
        this.showDocs(),
        this.applyLayout('fullscreen'),
        (yt.documentElement.scrollTop = 0),
        (yt.documentElement.scrollLeft = 0),
        this.docsRoot()
      );
    }
    docsRoot() {
      return yt.getElementById('storybook-docs');
    }
    applyLayout(t = 'padded') {
      if (t === 'none') {
        (yt.body.classList.remove(this.currentLayoutClass), (this.currentLayoutClass = null));
        return;
      }
      this.checkIfLayoutExists(t);
      const r = Lc[t];
      (yt.body.classList.remove(this.currentLayoutClass),
        yt.body.classList.add(r),
        (this.currentLayoutClass = r));
    }
    checkIfLayoutExists(t) {
      Lc[t] ||
        De.warn(ve`
          The desired layout: ${t} is not a valid option.
          The possible options are: ${Object.keys(Lc).join(', ')}, none.
        `);
    }
    showMode(t) {
      (clearTimeout(this.preparingTimeout),
        Object.keys(Bx).forEach((r) => {
          r === t ? yt.body.classList.add(Dc[r]) : yt.body.classList.remove(Dc[r]);
        }));
    }
    showErrorDisplay({ message: t = '', stack: r = '' }) {
      let n = t,
        i = r;
      const s = t.split(`
`);
      (s.length > 1 &&
        (([n] = s),
        (i = s
          .slice(1)
          .join(
            `
`,
          )
          .replace(/^\n/, ''))),
        (yt.getElementById('error-message').innerHTML = rb.toHtml(n)),
        (yt.getElementById('error-stack').innerHTML = rb.toHtml(i)),
        this.showMode('ERROR'));
    }
    showNoPreview() {
      this.testing ||
        (this.showMode('NOPREVIEW'),
        this.storyRoot()?.setAttribute('hidden', 'true'),
        this.docsRoot()?.setAttribute('hidden', 'true'));
    }
    showPreparingStory({ immediate: t = !1 } = {}) {
      (clearTimeout(this.preparingTimeout),
        t
          ? this.showMode('PREPARING_STORY')
          : (this.preparingTimeout = setTimeout(() => this.showMode('PREPARING_STORY'), tb)));
    }
    showPreparingDocs({ immediate: t = !1 } = {}) {
      (clearTimeout(this.preparingTimeout),
        t
          ? this.showMode('PREPARING_DOCS')
          : (this.preparingTimeout = setTimeout(() => this.showMode('PREPARING_DOCS'), tb)));
    }
    showMain() {
      this.showMode('MAIN');
    }
    showDocs() {
      (this.storyRoot().setAttribute('hidden', 'true'), this.docsRoot().removeAttribute('hidden'));
    }
    showStory() {
      (this.docsRoot().setAttribute('hidden', 'true'), this.storyRoot().removeAttribute('hidden'));
    }
    showStoryDuringRender() {
      yt.body.classList.add(Dc.MAIN);
    }
  };
o(Jx, 'WebView');
var $x = Jx,
  Ux = class extends Ix {
    constructor(t, r) {
      (super(t, r, new Fx(), new $x()),
        (this.importFn = t),
        (this.getProjectAnnotations = r),
        (te.__STORYBOOK_PREVIEW__ = this));
    }
  };
o(Ux, 'PreviewWeb');
var ZV = Ux,
  { document: yn } = te,
  eH = [
    'application/javascript',
    'application/ecmascript',
    'application/x-ecmascript',
    'application/x-javascript',
    'text/ecmascript',
    'text/javascript',
    'text/javascript1.0',
    'text/javascript1.1',
    'text/javascript1.2',
    'text/javascript1.3',
    'text/javascript1.4',
    'text/javascript1.5',
    'text/jscript',
    'text/livescript',
    'text/x-ecmascript',
    'text/x-javascript',
    'module',
  ],
  tH = 'script',
  nb = 'scripts-root';
function ka() {
  const e = yn.createEvent('Event');
  (e.initEvent('DOMContentLoaded', !0, !0), yn.dispatchEvent(e));
}
o(ka, 'simulateDOMContentLoaded');
function Vx(e, t, r) {
  const n = yn.createElement('script');
  ((n.type = e.type === 'module' ? 'module' : 'text/javascript'),
    e.src ? ((n.onload = t), (n.onerror = t), (n.src = e.src)) : (n.textContent = e.innerText),
    r ? r.appendChild(n) : yn.head.appendChild(n),
    e.parentNode.removeChild(e),
    e.src || t());
}
o(Vx, 'insertScript');
function eh(e, t, r = 0) {
  e[r](() => {
    (r++, r === e.length ? t() : eh(e, t, r));
  });
}
o(eh, 'insertScriptsSequentially');
function Hx(e) {
  let t = yn.getElementById(nb);
  t ? (t.innerHTML = '') : ((t = yn.createElement('div')), (t.id = nb), yn.body.appendChild(t));
  const r = Array.from(e.querySelectorAll(tH));
  if (r.length) {
    const n = [];
    (r.forEach((i) => {
      const s = i.getAttribute('type');
      (!s || eH.includes(s)) && n.push((a) => Vx(i, a, t));
    }),
      n.length && eh(n, ka, void 0));
  } else ka();
}
o(Hx, 'simulatePageLoad');
var Fc;
(function (e) {
  ((e.start = '/**'), (e.nostart = '/***'), (e.delim = '*'), (e.end = '*/'));
})((Fc = Fc || (Fc = {})));
function Gx(e) {
  return (
    e.start +
    e.delimiter +
    e.postDelimiter +
    e.tag +
    e.postTag +
    e.type +
    e.postType +
    e.name +
    e.postName +
    e.description +
    e.end +
    e.lineEnd
  );
}
o(Gx, 'join');
function rH() {
  return (e) =>
    e.source.map(({ tokens: t }) => Gx(t)).join(`
`);
}
o(rH, 'getStringifier');
var nH = ze(wj(), 1),
  jn = (0, nH.stringifyRules)(),
  oH = jn.JsdocTypeObject;
jn.JsdocTypeAny = () => 'any';
jn.JsdocTypeObject = (e, t) => `(${oH(e, t)})`;
jn.JsdocTypeOptional = (e, t) => t(e.element);
jn.JsdocTypeNullable = (e, t) => t(e.element);
jn.JsdocTypeNotNullable = (e, t) => t(e.element);
jn.JsdocTypeUnion = (e, t) => e.elements.map(t).join('|');
var iH = 'storybook/docs',
  sH = `${iH}/snippet-rendered`;
async function zx(e, t) {
  const r = t.parameters?.docs?.source?.transform,
    { id: n, unmappedArgs: i } = t,
    s = r && e ? r?.(e, t) : e,
    a = s ? await s : void 0;
  Dt.getChannel().emit(sH, { id: n, source: a, args: i });
}
o(zx, 'emitTransformCode');
var Yi = { depth: 10, clearOnStoryChange: !0, limit: 50 },
  aH = o((e = {}) => {
    Object.assign(Yi, e);
  }, 'configureActions'),
  Wx = o((e, t) => {
    const r = Object.getPrototypeOf(e);
    return !r || t(r) ? r : Wx(r, t);
  }, 'findProto'),
  lH = o(
    (e) =>
      !!(
        typeof e == 'object' &&
        e &&
        Wx(e, (t) => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) &&
        typeof e.persist == 'function'
      ),
    'isReactSyntheticEvent',
  ),
  cH = o((e) => {
    if (lH(e)) {
      const t = Object.create(e.constructor.prototype, Object.getOwnPropertyDescriptors(e));
      t.persist();
      const r = Object.getOwnPropertyDescriptor(t, 'view'),
        n = r?.value;
      return (
        typeof n == 'object' &&
          n?.constructor.name === 'Window' &&
          Object.defineProperty(t, 'view', { ...r, value: Object.create(n.constructor.prototype) }),
        t
      );
    }
    return e;
  }, 'serializeArg');
function No(e, t = {}) {
  const r = { ...Yi, ...t },
    n = o(function (...s) {
      if (t.implicit) {
        const h = (
          '__STORYBOOK_PREVIEW__' in te ? te.__STORYBOOK_PREVIEW__ : void 0
        )?.storyRenders.find((g) => g.phase === 'playing' || g.phase === 'rendering');
        if (h) {
          const g = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8,
            T = new cE({ phase: h.phase, name: e, deprecated: g });
          if (g) console.warn(T);
          else throw T;
        }
      }
      const a = Dt.getChannel(),
        c = Date.now().toString(36) + Math.random().toString(36).substring(2),
        d = 5,
        u = s.map(cH),
        p = s.length > 1 ? u : u[0],
        f = {
          id: c,
          count: 0,
          data: { name: e, args: p },
          options: { ...r, maxDepth: d + (r.depth || 3) },
        };
      a.emit(JE, f);
    }, 'actionHandler');
  return ((n.isAction = !0), (n.implicit = t.implicit), n);
}
o(No, 'action');
var uH = o((...e) => {
    let t = Yi,
      r = e;
    (r.length === 1 && Array.isArray(r[0]) && ([r] = r),
      r.length !== 1 && typeof r[r.length - 1] != 'string' && (t = { ...Yi, ...r.pop() }));
    let n = r[0];
    (r.length !== 1 || typeof n == 'string') &&
      ((n = {}),
      r.forEach((s) => {
        n[s] = s;
      }));
    const i = {};
    return (
      Object.keys(n).forEach((s) => {
        i[s] = No(n[s], t);
      }),
      i
    );
  }, 'actions'),
  dH = {
    '@storybook/global': Lb,
    'storybook/test': lT,
    'storybook/actions': BE,
    'storybook/preview-api': Yc,
    'storybook/internal/channels': Bb,
    'storybook/internal/client-logger': $b,
    'storybook/internal/core-events': Gd,
    'storybook/internal/types': LE,
    'storybook/internal/preview-errors': rE,
    'storybook/internal/preview-api': Yc,
  };
async function Kx() {
  const e = new URL(window.location.href);
  if (e.searchParams.get('navigator') !== 'true' || globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__)
    return;
  globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__ = !0;
  const t = await (await fetch('/index.json')).json(),
    r = e.searchParams.get('id');
  if (!r) {
    const n = Object.values(t.entries)[0];
    n &&
      (e.searchParams.set('id', n.id),
      e.searchParams.set('viewMode', n.type),
      (window.location.href = e.toString()));
    return;
  }
  pH(t, r);
}
o(Kx, 'maybeSetupPreviewNavigator');
var pH = o(async (e, t) => {
    const r = { entries: {} };
    for (const c of Object.values(e.entries)) {
      const d = c.title.split('/');
      let u = r;
      for (const p of d)
        (u.entries || (u.entries = {}),
          u.entries[p]
            ? t === c.id && (u.entries[p].isActive = !0)
            : (u.entries[p] = { title: p, isActive: t === c.id, entries: {} }),
          (u = u.entries[p]));
      (u.entries || (u.entries = {}),
        (u.entries[c.name] = {
          id: c.id,
          name: c.name,
          href: `?id=${c.id}&viewMode=${c.type}&navigator=true`,
          isActive: t === c.id,
        }));
    }
    const n = o((c) => {
        if ('entries' in c && 'title' in c) {
          const u = c;
          return `
      <li class="sb-navigator-branch">
        <details${u.isActive ? ' open' : ''}>
          <summary class="sb-navigator-title">
            ${u.title}
          </summary>
          <ul class="sb-navigator-entries" aria-label="${u.title}">
            ${Object.values(u.entries).map(n).join('')}
          </ul>
        </details>
      </li>
      `;
        }
        const d = c;
        return `
      <li class="sb-navigator-story-item">
        <a href="${d.href}" 
           class="sb-navigator-story-link${d.isActive ? ' active' : ''}" 
           aria-current="${d.isActive ? 'location' : 'false'}">${d.name}</a>
      </li>
    `;
      }, 'createHtmlForNode'),
      i = Object.values(r.entries).map(n).join(''),
      s = document.createElement('nav');
    ((s.id = 'sb-navigator-container'),
      s.setAttribute('role', 'navigation'),
      s.setAttribute('aria-label', 'Story navigation'),
      (s.innerHTML = `
    <ul class="sb-navigator-list">${i}</ul>
  `),
      document.body.insertBefore(s, document.body.firstChild));
    const a = document.createElement('style');
    ((a.id = 'sb-navigator-style'),
      (a.textContent = `
    body {
      display: grid !important;
      grid-template-columns: 300px 1fr;
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      margin: 0;

      --text-color: rgb(46, 52, 56);
      --bg-color: rgb(246, 249, 252);

      @media (prefers-color-scheme: dark) {
        --text-color: rgb(201, 205, 207);
        --bg-color: rgb(34, 36, 37);
      }
    }
    #storybook-root, #storybook-docs {
      overflow-y: auto;
      max-height: 100vh;
      max-width: 100%;
    }
    #sb-navigator-container, #sb-navigator-container * {
      box-sizing: border-box;
    }
    #sb-navigator-container {
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid #eee;
        padding: 1rem;
        font-size: 14px;
        color: var(--text-color);
        background-color: var(--bg-color);
        align-self: start;
        z-index: 1000;
    }
    .sb-main-padded #sb-navigator-container {
      margin: -1rem 1rem -1rem -1rem;
    }
    .sb-navigator-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    .sb-navigator-branch {
      list-style-type: none;
    }
    .sb-navigator-item {
      margin-bottom: 15px;
    }
    .sb-navigator-title {
      color: var(--text-color);
      text-decoration: none;
      padding-block: 5px;
      cursor: pointer;
    }
    .sb-navigator-entries {
      padding-left: 15px;
    }
    .sb-navigator-story-item {
      margin-bottom: 8px;
      margin-left: 8px;
    }
    .sb-navigator-story-link {
      color: var(--text-color);
    }
    .sb-navigator-story-link.active {
      font-weight: bold;
      color: rgb(2, 156, 253);
    }
  `),
      document.head.appendChild(a),
      s
        .querySelector('.sb-navigator-story-link.active')
        ?.closest('details')
        ?.scrollIntoView({ block: 'center' }));
  }, 'setupPreviewNavigator'),
  fH = ze(Sj(), 1),
  Bc;
function Yx() {
  return (Bc || (Bc = new fH.default(te.navigator?.userAgent).getBrowserInfo()), Bc);
}
o(Yx, 'getBrowserInfo');
function Xx(e) {
  return ((e.browserInfo = Yx()), e);
}
o(Xx, 'prepareForTelemetry');
function Qx(e) {
  const t = e.error || e;
  t.fromStorybook && te.sendTelemetryError(t);
}
o(Qx, 'errorListener');
function Zx({ reason: e }) {
  e.fromStorybook && te.sendTelemetryError(e);
}
o(Zx, 'unhandledRejectionListener');
function eN() {
  (Yj.forEach((e) => {
    te[Fb[e]] = dH[e];
  }),
    (te.sendTelemetryError = (e) => {
      te.__STORYBOOK_ADDONS_CHANNEL__.emit(kb, Xx(e));
    }),
    te.addEventListener('error', Qx),
    te.addEventListener('unhandledrejection', Zx),
    Kx());
}
o(eN, 'setup');
eN();
var mH = Object.create,
  th = Object.defineProperty,
  yH = Object.getOwnPropertyDescriptor,
  tN = Object.getOwnPropertyNames,
  hH = Object.getPrototypeOf,
  gH = Object.prototype.hasOwnProperty,
  O = (e, t) => th(e, 'name', { value: t, configurable: !0 }),
  bH = (e, t) =>
    function () {
      return (t || (0, e[tN(e)[0]])((t = { exports: {} }).exports, t), t.exports);
    },
  vH = (e, t, r, n) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let i of tN(t))
        !gH.call(e, i) &&
          i !== r &&
          th(e, i, { get: () => t[i], enumerable: !(n = yH(t, i)) || n.enumerable });
    return e;
  },
  EH = (e, t, r) => (
    (r = e != null ? mH(hH(e)) : {}),
    vH(th(r, 'default', { value: e, enumerable: !0 }), e)
  );
function Js(e) {
  if (!e || typeof e != 'object') return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null
    ? Object.prototype.toString.call(e) === '[object Object]'
    : !1;
}
O(Js, 'isPlainObject');
function TH(e) {
  return e == null || (typeof e != 'object' && typeof e != 'function');
}
O(TH, 'isPrimitive');
function wH(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
O(wH, 'isTypedArray');
function SH(e) {
  return Object.getOwnPropertySymbols(e).filter((t) =>
    Object.prototype.propertyIsEnumerable.call(e, t),
  );
}
O(SH, 'getSymbols');
function _H(e) {
  return e == null
    ? e === void 0
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(e);
}
O(_H, 'getTag');
var RH = bH({
  '../node_modules/jsdoc-type-pratt-parser/dist/index.js'(e, t) {
    (function (r, n) {
      typeof e == 'object' && typeof t < 'u'
        ? n(e)
        : typeof define == 'function' && define.amd
          ? define(['exports'], n)
          : ((r = typeof globalThis < 'u' ? globalThis : r || self), n((r.jtpp = {})));
    })(e, function (r) {
      function n(l) {
        return l.text !== void 0 && l.text !== ''
          ? `'${l.type}' with value '${l.text}'`
          : `'${l.type}'`;
      }
      O(n, 'tokenToString');
      const i = class rN extends Error {
        constructor(m) {
          (super(`No parslet found for token: ${n(m)}`),
            (this.token = m),
            Object.setPrototypeOf(this, rN.prototype));
        }
        getToken() {
          return this.token;
        }
      };
      O(i, 'NoParsletFoundError');
      let s = i;
      const a = class nN extends Error {
        constructor(m) {
          (super(`The parsing ended early. The next token was: ${n(m)}`),
            (this.token = m),
            Object.setPrototypeOf(this, nN.prototype));
        }
        getToken() {
          return this.token;
        }
      };
      O(a, 'EarlyEndOfParseError');
      let c = a;
      const d = class oN extends Error {
        constructor(m, b) {
          let x = `Unexpected type: '${m.type}'.`;
          (b !== void 0 && (x += ` Message: ${b}`),
            super(x),
            Object.setPrototypeOf(this, oN.prototype));
        }
      };
      O(d, 'UnexpectedTypeError');
      let u = d;
      function p(l) {
        return (m) => (m.startsWith(l) ? { type: l, text: l } : null);
      }
      O(p, 'makePunctuationRule');
      function f(l) {
        let m = 0,
          b;
        const x = l[0];
        let F = !1;
        if (x !== "'" && x !== '"') return null;
        for (; m < l.length; ) {
          if ((m++, (b = l[m]), !F && b === x)) {
            m++;
            break;
          }
          F = !F && b === '\\';
        }
        if (b !== x) throw new Error('Unterminated String');
        return l.slice(0, m);
      }
      O(f, 'getQuoted');
      const y = new RegExp(
          '[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
          'u',
        ),
        h = new RegExp(
          '[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
          'u',
        );
      function g(l) {
        let m = l[0];
        if (!y.test(m)) return null;
        let b = 1;
        do {
          if (((m = l[b]), !h.test(m))) break;
          b++;
        } while (b < l.length);
        return l.slice(0, b);
      }
      O(g, 'getIdentifier');
      const T = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function E(l) {
        var m, b;
        return (b = (m = T.exec(l)) === null || m === void 0 ? void 0 : m[0]) !== null &&
          b !== void 0
          ? b
          : null;
      }
      O(E, 'getNumber');
      const v = O((l) => {
        const m = g(l);
        return m == null ? null : { type: 'Identifier', text: m };
      }, 'identifierRule');
      function S(l) {
        return (m) => {
          if (!m.startsWith(l)) return null;
          const b = m[l.length];
          return b !== void 0 && h.test(b) ? null : { type: l, text: l };
        };
      }
      O(S, 'makeKeyWordRule');
      const A = O((l) => {
          const m = f(l);
          return m == null ? null : { type: 'StringValue', text: m };
        }, 'stringValueRule'),
        N = O((l) => (l.length > 0 ? null : { type: 'EOF', text: '' }), 'eofRule'),
        j = O((l) => {
          const m = E(l);
          return m === null ? null : { type: 'Number', text: m };
        }, 'numberRule'),
        C = [
          N,
          p('=>'),
          p('('),
          p(')'),
          p('{'),
          p('}'),
          p('['),
          p(']'),
          p('|'),
          p('&'),
          p('<'),
          p('>'),
          p(','),
          p(';'),
          p('*'),
          p('?'),
          p('!'),
          p('='),
          p(':'),
          p('...'),
          p('.'),
          p('#'),
          p('~'),
          p('/'),
          p('@'),
          S('undefined'),
          S('null'),
          S('function'),
          S('this'),
          S('new'),
          S('module'),
          S('event'),
          S('extends'),
          S('external'),
          S('infer'),
          S('typeof'),
          S('keyof'),
          S('readonly'),
          S('import'),
          S('is'),
          S('in'),
          S('asserts'),
          j,
          v,
          A,
        ],
        R = /^\s*\n\s*/,
        w = class $s {
          static create(m) {
            const b = this.read(m);
            m = b.text;
            const x = this.read(m);
            return ((m = x.text), new $s(m, void 0, b.token, x.token));
          }
          constructor(m, b, x, F) {
            ((this.text = ''),
              (this.text = m),
              (this.previous = b),
              (this.current = x),
              (this.next = F));
          }
          static read(m, b = !1) {
            ((b = b || R.test(m)), (m = m.trim()));
            for (const x of C) {
              const F = x(m);
              if (F !== null) {
                const z = Object.assign(Object.assign({}, F), { startOfLine: b });
                return ((m = m.slice(z.text.length)), { text: m, token: z });
              }
            }
            throw new Error('Unexpected Token ' + m);
          }
          advance() {
            const m = $s.read(this.text);
            return new $s(m.text, this.current, this.next, m.token);
          }
        };
      O(w, 'Lexer');
      let _ = w;
      function k(l) {
        if (l === void 0) throw new Error('Unexpected undefined');
        if (
          l.type === 'JsdocTypeKeyValue' ||
          l.type === 'JsdocTypeParameterList' ||
          l.type === 'JsdocTypeProperty' ||
          l.type === 'JsdocTypeReadonlyProperty' ||
          l.type === 'JsdocTypeObjectField' ||
          l.type === 'JsdocTypeJsdocObjectField' ||
          l.type === 'JsdocTypeIndexSignature' ||
          l.type === 'JsdocTypeMappedType' ||
          l.type === 'JsdocTypeTypeParameter'
        )
          throw new u(l);
        return l;
      }
      O(k, 'assertRootResult');
      function I(l) {
        return l.type === 'JsdocTypeKeyValue' ? H(l) : k(l);
      }
      O(I, 'assertPlainKeyValueOrRootResult');
      function V(l) {
        return l.type === 'JsdocTypeName' ? l : H(l);
      }
      O(V, 'assertPlainKeyValueOrNameResult');
      function H(l) {
        if (l.type !== 'JsdocTypeKeyValue') throw new u(l);
        return l;
      }
      O(H, 'assertPlainKeyValueResult');
      function P(l) {
        var m;
        if (l.type === 'JsdocTypeVariadic') {
          if (((m = l.element) === null || m === void 0 ? void 0 : m.type) === 'JsdocTypeName')
            return l;
          throw new u(l);
        }
        if (l.type !== 'JsdocTypeNumber' && l.type !== 'JsdocTypeName') throw new u(l);
        return l;
      }
      O(P, 'assertNumberOrVariadicNameResult');
      function L(l) {
        if (
          l.type === 'JsdocTypeTuple' ||
          (l.type === 'JsdocTypeGeneric' && l.meta.brackets === 'square')
        )
          return l;
        throw new u(l);
      }
      O(L, 'assertArrayOrTupleResult');
      function B(l) {
        return l.type === 'JsdocTypeIndexSignature' || l.type === 'JsdocTypeMappedType';
      }
      O(B, 'isSquaredProperty');
      var D;
      (function (l) {
        ((l[(l.ALL = 0)] = 'ALL'),
          (l[(l.PARAMETER_LIST = 1)] = 'PARAMETER_LIST'),
          (l[(l.OBJECT = 2)] = 'OBJECT'),
          (l[(l.KEY_VALUE = 3)] = 'KEY_VALUE'),
          (l[(l.INDEX_BRACKETS = 4)] = 'INDEX_BRACKETS'),
          (l[(l.UNION = 5)] = 'UNION'),
          (l[(l.INTERSECTION = 6)] = 'INTERSECTION'),
          (l[(l.PREFIX = 7)] = 'PREFIX'),
          (l[(l.INFIX = 8)] = 'INFIX'),
          (l[(l.TUPLE = 9)] = 'TUPLE'),
          (l[(l.SYMBOL = 10)] = 'SYMBOL'),
          (l[(l.OPTIONAL = 11)] = 'OPTIONAL'),
          (l[(l.NULLABLE = 12)] = 'NULLABLE'),
          (l[(l.KEY_OF_TYPE_OF = 13)] = 'KEY_OF_TYPE_OF'),
          (l[(l.FUNCTION = 14)] = 'FUNCTION'),
          (l[(l.ARROW = 15)] = 'ARROW'),
          (l[(l.ARRAY_BRACKETS = 16)] = 'ARRAY_BRACKETS'),
          (l[(l.GENERIC = 17)] = 'GENERIC'),
          (l[(l.NAME_PATH = 18)] = 'NAME_PATH'),
          (l[(l.PARENTHESIS = 19)] = 'PARENTHESIS'),
          (l[(l.SPECIAL_TYPES = 20)] = 'SPECIAL_TYPES'));
      })(D || (D = {}));
      const K = class {
        constructor(m, b, x) {
          ((this.grammar = m),
            typeof b == 'string' ? (this._lexer = _.create(b)) : (this._lexer = b),
            (this.baseParser = x));
        }
        get lexer() {
          return this._lexer;
        }
        parse() {
          const m = this.parseType(D.ALL);
          if (this.lexer.current.type !== 'EOF') throw new c(this.lexer.current);
          return m;
        }
        parseType(m) {
          return k(this.parseIntermediateType(m));
        }
        parseIntermediateType(m) {
          const b = this.tryParslets(null, m);
          if (b === null) throw new s(this.lexer.current);
          return this.parseInfixIntermediateType(b, m);
        }
        parseInfixIntermediateType(m, b) {
          let x = this.tryParslets(m, b);
          for (; x !== null; ) ((m = x), (x = this.tryParslets(m, b)));
          return m;
        }
        tryParslets(m, b) {
          for (const x of this.grammar) {
            const F = x(this, b, m);
            if (F !== null) return F;
          }
          return null;
        }
        consume(m) {
          return (
            Array.isArray(m) || (m = [m]),
            m.includes(this.lexer.current.type) ? ((this._lexer = this.lexer.advance()), !0) : !1
          );
        }
        acceptLexerState(m) {
          this._lexer = m.lexer;
        }
      };
      O(K, 'Parser');
      let X = K;
      function ie(l) {
        return l === '}' || l === 'EOF' || l === '|' || l === ',' || l === ')' || l === '>';
      }
      O(ie, 'isQuestionMarkUnknownType');
      const se = O((l, m, b) => {
        const x = l.lexer.current.type,
          F = l.lexer.next.type;
        return (b == null && x === '?' && !ie(F)) || (b != null && x === '?')
          ? (l.consume('?'),
            b == null
              ? {
                  type: 'JsdocTypeNullable',
                  element: l.parseType(D.NULLABLE),
                  meta: { position: 'prefix' },
                }
              : { type: 'JsdocTypeNullable', element: k(b), meta: { position: 'suffix' } })
          : null;
      }, 'nullableParslet');
      function W(l) {
        const m = O((b, x, F) => {
          const z = b.lexer.current.type,
            Z = b.lexer.next.type;
          if (F === null) {
            if ('parsePrefix' in l && l.accept(z, Z)) return l.parsePrefix(b);
          } else if ('parseInfix' in l && l.precedence > x && l.accept(z, Z))
            return l.parseInfix(b, F);
          return null;
        }, 'parslet');
        return (Object.defineProperty(m, 'name', { value: l.name }), m);
      }
      O(W, 'composeParslet');
      const ae = W({
          name: 'optionalParslet',
          accept: O((l) => l === '=', 'accept'),
          precedence: D.OPTIONAL,
          parsePrefix: O(
            (l) => (
              l.consume('='),
              {
                type: 'JsdocTypeOptional',
                element: l.parseType(D.OPTIONAL),
                meta: { position: 'prefix' },
              }
            ),
            'parsePrefix',
          ),
          parseInfix: O(
            (l, m) => (
              l.consume('='),
              { type: 'JsdocTypeOptional', element: k(m), meta: { position: 'suffix' } }
            ),
            'parseInfix',
          ),
        }),
        be = W({
          name: 'numberParslet',
          accept: O((l) => l === 'Number', 'accept'),
          parsePrefix: O((l) => {
            const m = parseFloat(l.lexer.current.text);
            return (l.consume('Number'), { type: 'JsdocTypeNumber', value: m });
          }, 'parsePrefix'),
        }),
        ue = W({
          name: 'parenthesisParslet',
          accept: O((l) => l === '(', 'accept'),
          parsePrefix: O((l) => {
            if ((l.consume('('), l.consume(')')))
              return { type: 'JsdocTypeParameterList', elements: [] };
            const m = l.parseIntermediateType(D.ALL);
            if (!l.consume(')')) throw new Error('Unterminated parenthesis');
            return m.type === 'JsdocTypeParameterList'
              ? m
              : m.type === 'JsdocTypeKeyValue'
                ? { type: 'JsdocTypeParameterList', elements: [m] }
                : { type: 'JsdocTypeParenthesis', element: k(m) };
          }, 'parsePrefix'),
        }),
        ee = W({
          name: 'specialTypesParslet',
          accept: O(
            (l, m) => (l === '?' && ie(m)) || l === 'null' || l === 'undefined' || l === '*',
            'accept',
          ),
          parsePrefix: O((l) => {
            if (l.consume('null')) return { type: 'JsdocTypeNull' };
            if (l.consume('undefined')) return { type: 'JsdocTypeUndefined' };
            if (l.consume('*')) return { type: 'JsdocTypeAny' };
            if (l.consume('?')) return { type: 'JsdocTypeUnknown' };
            throw new Error('Unacceptable token: ' + l.lexer.current.text);
          }, 'parsePrefix'),
        }),
        Ae = W({
          name: 'notNullableParslet',
          accept: O((l) => l === '!', 'accept'),
          precedence: D.NULLABLE,
          parsePrefix: O(
            (l) => (
              l.consume('!'),
              {
                type: 'JsdocTypeNotNullable',
                element: l.parseType(D.NULLABLE),
                meta: { position: 'prefix' },
              }
            ),
            'parsePrefix',
          ),
          parseInfix: O(
            (l, m) => (
              l.consume('!'),
              { type: 'JsdocTypeNotNullable', element: k(m), meta: { position: 'suffix' } }
            ),
            'parseInfix',
          ),
        });
      function Oe({ allowTrailingComma: l }) {
        return W({
          name: 'parameterListParslet',
          accept: O((m) => m === ',', 'accept'),
          precedence: D.PARAMETER_LIST,
          parseInfix: O((m, b) => {
            const x = [I(b)];
            m.consume(',');
            do
              try {
                const F = m.parseIntermediateType(D.PARAMETER_LIST);
                x.push(I(F));
              } catch (F) {
                if (F instanceof s) break;
                throw F;
              }
            while (m.consume(','));
            if (x.length > 0 && x.slice(0, -1).some((F) => F.type === 'JsdocTypeVariadic'))
              throw new Error('Only the last parameter may be a rest parameter');
            return { type: 'JsdocTypeParameterList', elements: x };
          }, 'parseInfix'),
        });
      }
      O(Oe, 'createParameterListParslet');
      const He = W({
          name: 'genericParslet',
          accept: O((l, m) => l === '<' || (l === '.' && m === '<'), 'accept'),
          precedence: D.GENERIC,
          parseInfix: O((l, m) => {
            const b = l.consume('.');
            l.consume('<');
            const x = [];
            let F = !1;
            if (l.consume('infer')) {
              F = !0;
              const z = l.parseIntermediateType(D.SYMBOL);
              if (z.type !== 'JsdocTypeName')
                throw new u(z, 'A typescript asserts always has to have a name on the left side.');
              x.push(z);
            } else
              do x.push(l.parseType(D.PARAMETER_LIST));
              while (l.consume(','));
            if (!l.consume('>')) throw new Error('Unterminated generic parameter list');
            return Object.assign(
              Object.assign(
                { type: 'JsdocTypeGeneric', left: k(m), elements: x },
                F ? { infer: !0 } : {},
              ),
              { meta: { brackets: 'angle', dot: b } },
            );
          }, 'parseInfix'),
        }),
        Ke = W({
          name: 'unionParslet',
          accept: O((l) => l === '|', 'accept'),
          precedence: D.UNION,
          parseInfix: O((l, m) => {
            l.consume('|');
            const b = [];
            do b.push(l.parseType(D.UNION));
            while (l.consume('|'));
            return { type: 'JsdocTypeUnion', elements: [k(m), ...b] };
          }, 'parseInfix'),
        }),
        $ = [se, ae, be, ue, ee, Ae, Oe({ allowTrailingComma: !0 }), He, Ke, ae];
      function Q({ allowSquareBracketsOnAnyType: l, allowJsdocNamePaths: m, pathGrammar: b }) {
        return O(function (F, z, Z) {
          if (Z == null || z >= D.NAME_PATH) return null;
          const ce = F.lexer.current.type,
            _e = F.lexer.next.type;
          if (
            !(
              (ce === '.' && _e !== '<') ||
              (ce === '[' && (l || Z.type === 'JsdocTypeName')) ||
              (m && (ce === '~' || ce === '#'))
            )
          )
            return null;
          let Me,
            dr = !1;
          F.consume('.')
            ? (Me = 'property')
            : F.consume('[')
              ? ((Me = 'property-brackets'), (dr = !0))
              : F.consume('~')
                ? (Me = 'inner')
                : (F.consume('#'), (Me = 'instance'));
          const ti = b !== null ? new X(b, F.lexer, F) : F,
            Qe = ti.parseIntermediateType(D.NAME_PATH);
          F.acceptLexerState(ti);
          let Jt;
          switch (Qe.type) {
            case 'JsdocTypeName':
              Jt = { type: 'JsdocTypeProperty', value: Qe.value, meta: { quote: void 0 } };
              break;
            case 'JsdocTypeNumber':
              Jt = {
                type: 'JsdocTypeProperty',
                value: Qe.value.toString(10),
                meta: { quote: void 0 },
              };
              break;
            case 'JsdocTypeStringValue':
              Jt = { type: 'JsdocTypeProperty', value: Qe.value, meta: { quote: Qe.meta.quote } };
              break;
            case 'JsdocTypeSpecialNamePath':
              if (Qe.specialType === 'event') Jt = Qe;
              else
                throw new u(
                  Qe,
                  "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'",
                );
              break;
            default:
              throw new u(
                Qe,
                "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'",
              );
          }
          if (dr && !F.consume(']')) {
            const ri = F.lexer.current;
            throw new Error(
              `Unterminated square brackets. Next token is '${ri.type}' with text '${ri.text}'`,
            );
          }
          return { type: 'JsdocTypeNamePath', left: k(Z), right: Jt, pathType: Me };
        }, 'namePathParslet');
      }
      O(Q, 'createNamePathParslet');
      function re({ allowedAdditionalTokens: l }) {
        return W({
          name: 'nameParslet',
          accept: O(
            (m) => m === 'Identifier' || m === 'this' || m === 'new' || l.includes(m),
            'accept',
          ),
          parsePrefix: O((m) => {
            const { type: b, text: x } = m.lexer.current;
            return (m.consume(b), { type: 'JsdocTypeName', value: x });
          }, 'parsePrefix'),
        });
      }
      O(re, 'createNameParslet');
      const oe = W({
        name: 'stringValueParslet',
        accept: O((l) => l === 'StringValue', 'accept'),
        parsePrefix: O((l) => {
          const m = l.lexer.current.text;
          return (
            l.consume('StringValue'),
            {
              type: 'JsdocTypeStringValue',
              value: m.slice(1, -1),
              meta: { quote: m[0] === "'" ? 'single' : 'double' },
            }
          );
        }, 'parsePrefix'),
      });
      function ne({ pathGrammar: l, allowedTypes: m }) {
        return W({
          name: 'specialNamePathParslet',
          accept: O((b) => m.includes(b), 'accept'),
          parsePrefix: O((b) => {
            const x = b.lexer.current.type;
            if ((b.consume(x), !b.consume(':'))) return { type: 'JsdocTypeName', value: x };
            let F,
              z = b.lexer.current;
            if (b.consume('StringValue'))
              F = {
                type: 'JsdocTypeSpecialNamePath',
                value: z.text.slice(1, -1),
                specialType: x,
                meta: { quote: z.text[0] === "'" ? 'single' : 'double' },
              };
            else {
              let _e = '';
              const Ee = ['Identifier', '@', '/'];
              for (; Ee.some((Me) => b.consume(Me)); ) ((_e += z.text), (z = b.lexer.current));
              F = {
                type: 'JsdocTypeSpecialNamePath',
                value: _e,
                specialType: x,
                meta: { quote: void 0 },
              };
            }
            const Z = new X(l, b.lexer, b),
              ce = Z.parseInfixIntermediateType(F, D.ALL);
            return (b.acceptLexerState(Z), k(ce));
          }, 'parsePrefix'),
        });
      }
      O(ne, 'createSpecialNamePathParslet');
      const de = [
          re({ allowedAdditionalTokens: ['external', 'module'] }),
          oe,
          be,
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: null }),
        ],
        ye = [...de, ne({ allowedTypes: ['event'], pathGrammar: de })];
      function pe(l) {
        let m;
        if (l.type === 'JsdocTypeParameterList') m = l.elements;
        else if (l.type === 'JsdocTypeParenthesis') m = [l.element];
        else throw new u(l);
        return m.map((b) => I(b));
      }
      O(pe, 'getParameters');
      function Je(l) {
        const m = pe(l);
        if (m.some((b) => b.type === 'JsdocTypeKeyValue'))
          throw new Error('No parameter should be named');
        return m;
      }
      O(Je, 'getUnnamedParameters');
      function ot({
        allowNamedParameters: l,
        allowNoReturnType: m,
        allowWithoutParenthesis: b,
        allowNewAsFunctionKeyword: x,
      }) {
        return W({
          name: 'functionParslet',
          accept: O((F, z) => F === 'function' || (x && F === 'new' && z === '('), 'accept'),
          parsePrefix: O((F) => {
            const z = F.consume('new');
            F.consume('function');
            const Z = F.lexer.current.type === '(';
            if (!Z) {
              if (!b) throw new Error('function is missing parameter list');
              return { type: 'JsdocTypeName', value: 'function' };
            }
            let ce = {
              type: 'JsdocTypeFunction',
              parameters: [],
              arrow: !1,
              constructor: z,
              parenthesis: Z,
            };
            const _e = F.parseIntermediateType(D.FUNCTION);
            if (l === void 0) ce.parameters = Je(_e);
            else {
              if (z && _e.type === 'JsdocTypeFunction' && _e.arrow)
                return ((ce = _e), (ce.constructor = !0), ce);
              ce.parameters = pe(_e);
              for (const Ee of ce.parameters)
                if (Ee.type === 'JsdocTypeKeyValue' && !l.includes(Ee.key))
                  throw new Error(
                    `only allowed named parameters are ${l.join(', ')} but got ${Ee.type}`,
                  );
            }
            if (F.consume(':')) ce.returnType = F.parseType(D.PREFIX);
            else if (!m) throw new Error('function is missing return type');
            return ce;
          }, 'parsePrefix'),
        });
      }
      O(ot, 'createFunctionParslet');
      function dt({ allowPostfix: l, allowEnclosingBrackets: m }) {
        return W({
          name: 'variadicParslet',
          accept: O((b) => b === '...', 'accept'),
          precedence: D.PREFIX,
          parsePrefix: O((b) => {
            b.consume('...');
            const x = m && b.consume('[');
            try {
              const F = b.parseType(D.PREFIX);
              if (x && !b.consume(']')) throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: 'JsdocTypeVariadic',
                element: k(F),
                meta: { position: 'prefix', squareBrackets: x },
              };
            } catch (F) {
              if (F instanceof s) {
                if (x) throw new Error('Empty square brackets for variadic are not allowed.');
                return {
                  type: 'JsdocTypeVariadic',
                  meta: { position: void 0, squareBrackets: !1 },
                };
              } else throw F;
            }
          }, 'parsePrefix'),
          parseInfix: l
            ? (b, x) => (
                b.consume('...'),
                {
                  type: 'JsdocTypeVariadic',
                  element: k(x),
                  meta: { position: 'suffix', squareBrackets: !1 },
                }
              )
            : void 0,
        });
      }
      O(dt, 'createVariadicParslet');
      const Tt = W({
          name: 'symbolParslet',
          accept: O((l) => l === '(', 'accept'),
          precedence: D.SYMBOL,
          parseInfix: O((l, m) => {
            if (m.type !== 'JsdocTypeName')
              throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
            l.consume('(');
            const b = { type: 'JsdocTypeSymbol', value: m.value };
            if (!l.consume(')')) {
              const x = l.parseIntermediateType(D.SYMBOL);
              if (((b.element = P(x)), !l.consume(')')))
                throw new Error('Symbol does not end after value');
            }
            return b;
          }, 'parseInfix'),
        }),
        it = W({
          name: 'arrayBracketsParslet',
          precedence: D.ARRAY_BRACKETS,
          accept: O((l, m) => l === '[' && m === ']', 'accept'),
          parseInfix: O(
            (l, m) => (
              l.consume('['),
              l.consume(']'),
              {
                type: 'JsdocTypeGeneric',
                left: { type: 'JsdocTypeName', value: 'Array' },
                elements: [k(m)],
                meta: { brackets: 'square', dot: !1 },
              }
            ),
            'parseInfix',
          ),
        });
      function pt({ objectFieldGrammar: l, allowKeyTypes: m }) {
        return W({
          name: 'objectParslet',
          accept: O((b) => b === '{', 'accept'),
          parsePrefix: O((b) => {
            b.consume('{');
            const x = { type: 'JsdocTypeObject', meta: { separator: 'comma' }, elements: [] };
            if (!b.consume('}')) {
              let F;
              const z = new X(l, b.lexer, b);
              for (;;) {
                z.acceptLexerState(b);
                let Z = z.parseIntermediateType(D.OBJECT);
                (b.acceptLexerState(z),
                  Z === void 0 && m && (Z = b.parseIntermediateType(D.OBJECT)));
                let ce = !1;
                if (
                  (Z.type === 'JsdocTypeNullable' && ((ce = !0), (Z = Z.element)),
                  Z.type === 'JsdocTypeNumber' ||
                    Z.type === 'JsdocTypeName' ||
                    Z.type === 'JsdocTypeStringValue')
                ) {
                  let Ee;
                  (Z.type === 'JsdocTypeStringValue' && (Ee = Z.meta.quote),
                    x.elements.push({
                      type: 'JsdocTypeObjectField',
                      key: Z.value.toString(),
                      right: void 0,
                      optional: ce,
                      readonly: !1,
                      meta: { quote: Ee },
                    }));
                } else if (
                  Z.type === 'JsdocTypeObjectField' ||
                  Z.type === 'JsdocTypeJsdocObjectField'
                )
                  x.elements.push(Z);
                else throw new u(Z);
                if (b.lexer.current.startOfLine)
                  ((F = 'linebreak'), b.consume(',') || b.consume(';'));
                else if (b.consume(',')) F = 'comma';
                else if (b.consume(';')) F = 'semicolon';
                else break;
                if (b.lexer.current.type === '}') break;
              }
              if (
                ((x.meta.separator = F ?? 'comma'),
                F === 'linebreak' && (x.meta.propertyIndent = '  '),
                !b.consume('}'))
              )
                throw new Error("Unterminated record type. Missing '}'");
            }
            return x;
          }, 'parsePrefix'),
        });
      }
      O(pt, 'createObjectParslet');
      function ft({
        allowSquaredProperties: l,
        allowKeyTypes: m,
        allowReadonly: b,
        allowOptional: x,
      }) {
        return W({
          name: 'objectFieldParslet',
          precedence: D.KEY_VALUE,
          accept: O((F) => F === ':', 'accept'),
          parseInfix: O((F, z) => {
            var Z;
            let ce = !1,
              _e = !1;
            (x && z.type === 'JsdocTypeNullable' && ((ce = !0), (z = z.element)),
              b && z.type === 'JsdocTypeReadonlyProperty' && ((_e = !0), (z = z.element)));
            const Ee = (Z = F.baseParser) !== null && Z !== void 0 ? Z : F;
            if (
              (Ee.acceptLexerState(F),
              z.type === 'JsdocTypeNumber' ||
                z.type === 'JsdocTypeName' ||
                z.type === 'JsdocTypeStringValue' ||
                B(z))
            ) {
              if (B(z) && !l) throw new u(z);
              Ee.consume(':');
              let Me;
              z.type === 'JsdocTypeStringValue' && (Me = z.meta.quote);
              const dr = Ee.parseType(D.KEY_VALUE);
              return (
                F.acceptLexerState(Ee),
                {
                  type: 'JsdocTypeObjectField',
                  key: B(z) ? z : z.value.toString(),
                  right: dr,
                  optional: ce,
                  readonly: _e,
                  meta: { quote: Me },
                }
              );
            } else {
              if (!m) throw new u(z);
              Ee.consume(':');
              const Me = Ee.parseType(D.KEY_VALUE);
              return (
                F.acceptLexerState(Ee),
                { type: 'JsdocTypeJsdocObjectField', left: k(z), right: Me }
              );
            }
          }, 'parseInfix'),
        });
      }
      O(ft, 'createObjectFieldParslet');
      function mt({ allowOptional: l, allowVariadic: m }) {
        return W({
          name: 'keyValueParslet',
          precedence: D.KEY_VALUE,
          accept: O((b) => b === ':', 'accept'),
          parseInfix: O((b, x) => {
            let F = !1,
              z = !1;
            if (
              (l && x.type === 'JsdocTypeNullable' && ((F = !0), (x = x.element)),
              m &&
                x.type === 'JsdocTypeVariadic' &&
                x.element !== void 0 &&
                ((z = !0), (x = x.element)),
              x.type !== 'JsdocTypeName')
            )
              throw new u(x);
            b.consume(':');
            const Z = b.parseType(D.KEY_VALUE);
            return { type: 'JsdocTypeKeyValue', key: x.value, right: Z, optional: F, variadic: z };
          }, 'parseInfix'),
        });
      }
      O(mt, 'createKeyValueParslet');
      const Qr = [
          ...$,
          ot({
            allowWithoutParenthesis: !0,
            allowNamedParameters: ['this', 'new'],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1,
          }),
          oe,
          ne({ allowedTypes: ['module', 'external', 'event'], pathGrammar: ye }),
          dt({ allowEnclosingBrackets: !0, allowPostfix: !0 }),
          re({ allowedAdditionalTokens: ['keyof'] }),
          Tt,
          it,
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
        ],
        Io = [
          ...Qr,
          pt({
            objectFieldGrammar: [
              re({ allowedAdditionalTokens: ['typeof', 'module', 'in'] }),
              ft({
                allowSquaredProperties: !1,
                allowKeyTypes: !0,
                allowOptional: !1,
                allowReadonly: !1,
              }),
              ...Qr,
            ],
            allowKeyTypes: !0,
          }),
          mt({ allowOptional: !0, allowVariadic: !0 }),
        ],
        Zr = W({
          name: 'typeOfParslet',
          accept: O((l) => l === 'typeof', 'accept'),
          parsePrefix: O(
            (l) => (
              l.consume('typeof'),
              { type: 'JsdocTypeTypeof', element: l.parseType(D.KEY_OF_TYPE_OF) }
            ),
            'parsePrefix',
          ),
        }),
        Mo = [
          re({ allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'] }),
          se,
          ae,
          oe,
          be,
          ft({
            allowSquaredProperties: !1,
            allowKeyTypes: !1,
            allowOptional: !1,
            allowReadonly: !1,
          }),
        ],
        qo = [
          ...$,
          pt({ allowKeyTypes: !1, objectFieldGrammar: Mo }),
          re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
          Zr,
          ot({
            allowWithoutParenthesis: !1,
            allowNamedParameters: ['this', 'new'],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1,
          }),
          dt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
          re({ allowedAdditionalTokens: ['keyof'] }),
          ne({ allowedTypes: ['module'], pathGrammar: ye }),
          Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
          mt({ allowOptional: !1, allowVariadic: !1 }),
          Tt,
        ],
        jo = W({
          name: 'assertsParslet',
          accept: O((l) => l === 'asserts', 'accept'),
          parsePrefix: O((l) => {
            l.consume('asserts');
            const m = l.parseIntermediateType(D.SYMBOL);
            if (m.type !== 'JsdocTypeName')
              throw new u(m, 'A typescript asserts always has to have a name on the left side.');
            return l.consume('is')
              ? { type: 'JsdocTypeAsserts', left: m, right: k(l.parseIntermediateType(D.INFIX)) }
              : { type: 'JsdocTypeAssertsPlain', element: m };
          }, 'parsePrefix'),
        });
      function en({ allowQuestionMark: l }) {
        return W({
          name: 'tupleParslet',
          accept: O((m) => m === '[', 'accept'),
          parsePrefix: O((m) => {
            m.consume('[');
            const b = { type: 'JsdocTypeTuple', elements: [] };
            if (m.consume(']')) return b;
            const x = m.parseIntermediateType(D.ALL);
            if (
              (x.type === 'JsdocTypeParameterList'
                ? x.elements[0].type === 'JsdocTypeKeyValue'
                  ? (b.elements = x.elements.map(H))
                  : (b.elements = x.elements.map(k))
                : x.type === 'JsdocTypeKeyValue'
                  ? (b.elements = [H(x)])
                  : (b.elements = [k(x)]),
              !m.consume(']'))
            )
              throw new Error("Unterminated '['");
            if (b.elements.some((F) => F.type === 'JsdocTypeUnknown'))
              throw new Error('Question mark in tuple not allowed');
            return b;
          }, 'parsePrefix'),
        });
      }
      O(en, 'createTupleParslet');
      const ko = W({
          name: 'keyOfParslet',
          accept: O((l) => l === 'keyof', 'accept'),
          parsePrefix: O(
            (l) => (
              l.consume('keyof'),
              { type: 'JsdocTypeKeyof', element: k(l.parseType(D.KEY_OF_TYPE_OF)) }
            ),
            'parsePrefix',
          ),
        }),
        Do = W({
          name: 'importParslet',
          accept: O((l) => l === 'import', 'accept'),
          parsePrefix: O((l) => {
            if ((l.consume('import'), !l.consume('(')))
              throw new Error('Missing parenthesis after import keyword');
            const m = l.parseType(D.PREFIX);
            if (m.type !== 'JsdocTypeStringValue')
              throw new Error('Only string values are allowed as paths for imports');
            if (!l.consume(')'))
              throw new Error('Missing closing parenthesis after import keyword');
            return { type: 'JsdocTypeImport', element: m };
          }, 'parsePrefix'),
        }),
        Lo = W({
          name: 'readonlyPropertyParslet',
          accept: O((l) => l === 'readonly', 'accept'),
          parsePrefix: O(
            (l) => (
              l.consume('readonly'),
              { type: 'JsdocTypeReadonlyProperty', element: l.parseIntermediateType(D.KEY_VALUE) }
            ),
            'parsePrefix',
          ),
        }),
        Fo = W({
          name: 'arrowFunctionParslet',
          precedence: D.ARROW,
          accept: O((l) => l === '=>', 'accept'),
          parseInfix: O(
            (l, m) => (
              l.consume('=>'),
              {
                type: 'JsdocTypeFunction',
                parameters: pe(m).map(V),
                arrow: !0,
                constructor: !1,
                parenthesis: !0,
                returnType: l.parseType(D.OBJECT),
              }
            ),
            'parseInfix',
          ),
        }),
        Bo = W({
          name: 'genericArrowFunctionParslet',
          accept: O((l) => l === '<', 'accept'),
          parsePrefix: O((l) => {
            const m = [];
            l.consume('<');
            do {
              let x,
                F = l.parseIntermediateType(D.SYMBOL);
              if (
                (F.type === 'JsdocTypeOptional' && ((F = F.element), (x = l.parseType(D.SYMBOL))),
                F.type !== 'JsdocTypeName')
              )
                throw new u(F);
              let z;
              l.consume('extends') &&
                ((z = l.parseType(D.SYMBOL)),
                z.type === 'JsdocTypeOptional' && ((z = z.element), (x = l.parseType(D.SYMBOL))));
              const Z = { type: 'JsdocTypeTypeParameter', name: F };
              if (
                (z !== void 0 && (Z.constraint = z),
                x !== void 0 && (Z.defaultValue = x),
                m.push(Z),
                l.consume('>'))
              )
                break;
            } while (l.consume(','));
            const b = l.parseIntermediateType(D.SYMBOL);
            return ((b.typeParameters = m), b);
          }, 'parsePrefix'),
        }),
        Jo = W({
          name: 'intersectionParslet',
          accept: O((l) => l === '&', 'accept'),
          precedence: D.INTERSECTION,
          parseInfix: O((l, m) => {
            l.consume('&');
            const b = [];
            do b.push(l.parseType(D.INTERSECTION));
            while (l.consume('&'));
            return { type: 'JsdocTypeIntersection', elements: [k(m), ...b] };
          }, 'parseInfix'),
        }),
        $o = W({
          name: 'predicateParslet',
          precedence: D.INFIX,
          accept: O((l) => l === 'is', 'accept'),
          parseInfix: O((l, m) => {
            if (m.type !== 'JsdocTypeName')
              throw new u(m, 'A typescript predicate always has to have a name on the left side.');
            return (
              l.consume('is'),
              { type: 'JsdocTypePredicate', left: m, right: k(l.parseIntermediateType(D.INFIX)) }
            );
          }, 'parseInfix'),
        }),
        Uo = W({
          name: 'objectSquareBracketPropertyParslet',
          accept: O((l) => l === '[', 'accept'),
          parsePrefix: O((l) => {
            if (l.baseParser === void 0) throw new Error('Only allowed inside object grammar');
            l.consume('[');
            const m = l.lexer.current.text;
            l.consume('Identifier');
            let b;
            if (l.consume(':')) {
              const x = l.baseParser;
              (x.acceptLexerState(l),
                (b = {
                  type: 'JsdocTypeIndexSignature',
                  key: m,
                  right: x.parseType(D.INDEX_BRACKETS),
                }),
                l.acceptLexerState(x));
            } else if (l.consume('in')) {
              const x = l.baseParser;
              (x.acceptLexerState(l),
                (b = { type: 'JsdocTypeMappedType', key: m, right: x.parseType(D.ARRAY_BRACKETS) }),
                l.acceptLexerState(x));
            } else throw new Error("Missing ':' or 'in' inside square bracketed property.");
            if (!l.consume(']')) throw new Error('Unterminated square brackets');
            return b;
          }, 'parsePrefix'),
        }),
        Vo = W({
          name: 'readonlyArrayParslet',
          accept: O((l) => l === 'readonly', 'accept'),
          parsePrefix: O(
            (l) => (
              l.consume('readonly'),
              { type: 'JsdocTypeReadonlyArray', element: L(l.parseIntermediateType(D.ALL)) }
            ),
            'parsePrefix',
          ),
        }),
        Ho = W({
          name: 'conditionalParslet',
          precedence: D.INFIX,
          accept: O((l) => l === 'extends', 'accept'),
          parseInfix: O((l, m) => {
            l.consume('extends');
            const b = l.parseType(D.KEY_OF_TYPE_OF).element,
              x = l.parseType(D.INFIX);
            return (
              l.consume(':'),
              {
                type: 'JsdocTypeConditional',
                checksType: k(m),
                extendsType: b,
                trueType: x,
                falseType: l.parseType(D.INFIX),
              }
            );
          }, 'parseInfix'),
        }),
        Go = [
          Lo,
          re({ allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in'] }),
          se,
          ae,
          oe,
          be,
          ft({
            allowSquaredProperties: !0,
            allowKeyTypes: !1,
            allowOptional: !0,
            allowReadonly: !0,
          }),
          Uo,
        ],
        zo = [
          ...$,
          pt({ allowKeyTypes: !1, objectFieldGrammar: Go }),
          Vo,
          Zr,
          ko,
          Do,
          oe,
          ot({
            allowWithoutParenthesis: !0,
            allowNoReturnType: !1,
            allowNamedParameters: ['this', 'new', 'args'],
            allowNewAsFunctionKeyword: !0,
          }),
          en({ allowQuestionMark: !1 }),
          dt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
          jo,
          Ho,
          re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
          ne({ allowedTypes: ['module'], pathGrammar: ye }),
          it,
          Fo,
          Bo,
          Q({ allowSquareBracketsOnAnyType: !0, allowJsdocNamePaths: !1, pathGrammar: ye }),
          Jo,
          $o,
          mt({ allowVariadic: !0, allowOptional: !0 }),
        ];
      function lr(l, m) {
        switch (m) {
          case 'closure':
            return new X(qo, l).parse();
          case 'jsdoc':
            return new X(Io, l).parse();
          case 'typescript':
            return new X(zo, l).parse();
        }
      }
      O(lr, 'parse');
      function tn(l, m = ['typescript', 'closure', 'jsdoc']) {
        let b;
        for (const x of m)
          try {
            return lr(l, x);
          } catch (F) {
            b = F;
          }
        throw b;
      }
      O(tn, 'tryParse');
      function Y(l, m) {
        const b = l[m.type];
        if (b === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${m.type}.`);
        return b(m, (x) => Y(l, x));
      }
      O(Y, 'transform');
      function le(l) {
        throw new Error(
          'This transform is not available. Are you trying the correct parsing mode?',
        );
      }
      O(le, 'notAvailableTransform');
      function Nt(l) {
        const m = { params: [] };
        for (const b of l.parameters)
          b.type === 'JsdocTypeKeyValue'
            ? b.key === 'this'
              ? (m.this = b.right)
              : b.key === 'new'
                ? (m.new = b.right)
                : m.params.push(b)
            : m.params.push(b);
        return m;
      }
      O(Nt, 'extractSpecialParams');
      function Bt(l, m, b) {
        return l === 'prefix' ? b + m : m + b;
      }
      O(Bt, 'applyPosition');
      function Ye(l, m) {
        switch (m) {
          case 'double':
            return `"${l}"`;
          case 'single':
            return `'${l}'`;
          case void 0:
            return l;
        }
      }
      O(Ye, 'quote');
      function rn() {
        return {
          JsdocTypeParenthesis: O(
            (l, m) => `(${l.element !== void 0 ? m(l.element) : ''})`,
            'JsdocTypeParenthesis',
          ),
          JsdocTypeKeyof: O((l, m) => `keyof ${m(l.element)}`, 'JsdocTypeKeyof'),
          JsdocTypeFunction: O((l, m) => {
            var b;
            if (l.arrow) {
              if (l.returnType === void 0) throw new Error('Arrow function needs a return type.');
              let x = `${l.typeParameters !== void 0 ? `<${(b = l.typeParameters.map(m).join(', ')) !== null && b !== void 0 ? b : ''}>` : ''}(${l.parameters.map(m).join(', ')}) => ${m(l.returnType)}`;
              return (l.constructor && (x = 'new ' + x), x);
            } else {
              let x = l.constructor ? 'new' : 'function';
              return (
                l.parenthesis &&
                  ((x += `(${l.parameters.map(m).join(', ')})`),
                  l.returnType !== void 0 && (x += `: ${m(l.returnType)}`)),
                x
              );
            }
          }, 'JsdocTypeFunction'),
          JsdocTypeName: O((l) => l.value, 'JsdocTypeName'),
          JsdocTypeTuple: O((l, m) => `[${l.elements.map(m).join(', ')}]`, 'JsdocTypeTuple'),
          JsdocTypeVariadic: O(
            (l, m) =>
              l.meta.position === void 0 ? '...' : Bt(l.meta.position, m(l.element), '...'),
            'JsdocTypeVariadic',
          ),
          JsdocTypeNamePath: O((l, m) => {
            const b = m(l.left),
              x = m(l.right);
            switch (l.pathType) {
              case 'inner':
                return `${b}~${x}`;
              case 'instance':
                return `${b}#${x}`;
              case 'property':
                return `${b}.${x}`;
              case 'property-brackets':
                return `${b}[${x}]`;
            }
          }, 'JsdocTypeNamePath'),
          JsdocTypeStringValue: O((l) => Ye(l.value, l.meta.quote), 'JsdocTypeStringValue'),
          JsdocTypeAny: O(() => '*', 'JsdocTypeAny'),
          JsdocTypeGeneric: O((l, m) => {
            if (l.meta.brackets === 'square') {
              const b = l.elements[0],
                x = m(b);
              return b.type === 'JsdocTypeUnion' || b.type === 'JsdocTypeIntersection'
                ? `(${x})[]`
                : `${x}[]`;
            } else
              return `${m(l.left)}${l.meta.dot ? '.' : ''}<${l.infer === !0 ? 'infer ' : ''}${l.elements.map(m).join(', ')}>`;
          }, 'JsdocTypeGeneric'),
          JsdocTypeImport: O((l, m) => `import(${m(l.element)})`, 'JsdocTypeImport'),
          JsdocTypeObjectField: O((l, m) => {
            let b = '';
            return (
              l.readonly && (b += 'readonly '),
              typeof l.key == 'string' ? (b += Ye(l.key, l.meta.quote)) : (b += m(l.key)),
              l.optional && (b += '?'),
              l.right === void 0 ? b : b + `: ${m(l.right)}`
            );
          }, 'JsdocTypeObjectField'),
          JsdocTypeJsdocObjectField: O(
            (l, m) => `${m(l.left)}: ${m(l.right)}`,
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeKeyValue: O((l, m) => {
            let b = l.key;
            return (
              l.optional && (b += '?'),
              l.variadic && (b = '...' + b),
              l.right === void 0 ? b : b + `: ${m(l.right)}`
            );
          }, 'JsdocTypeKeyValue'),
          JsdocTypeSpecialNamePath: O(
            (l) => `${l.specialType}:${Ye(l.value, l.meta.quote)}`,
            'JsdocTypeSpecialNamePath',
          ),
          JsdocTypeNotNullable: O(
            (l, m) => Bt(l.meta.position, m(l.element), '!'),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeNull: O(() => 'null', 'JsdocTypeNull'),
          JsdocTypeNullable: O(
            (l, m) => Bt(l.meta.position, m(l.element), '?'),
            'JsdocTypeNullable',
          ),
          JsdocTypeNumber: O((l) => l.value.toString(), 'JsdocTypeNumber'),
          JsdocTypeObject: O((l, m) => {
            var b, x;
            return `{${
              (l.meta.separator === 'linebreak' && l.elements.length > 1
                ? `
` + ((b = l.meta.propertyIndent) !== null && b !== void 0 ? b : '')
                : '') +
              l.elements.map(m).join(
                l.meta.separator === 'comma'
                  ? ', '
                  : l.meta.separator === 'linebreak'
                    ? `
` + ((x = l.meta.propertyIndent) !== null && x !== void 0 ? x : '')
                    : '; ',
              ) +
              (l.meta.separator === 'linebreak' && l.elements.length > 1
                ? `
`
                : '')
            }}`;
          }, 'JsdocTypeObject'),
          JsdocTypeOptional: O(
            (l, m) => Bt(l.meta.position, m(l.element), '='),
            'JsdocTypeOptional',
          ),
          JsdocTypeSymbol: O(
            (l, m) => `${l.value}(${l.element !== void 0 ? m(l.element) : ''})`,
            'JsdocTypeSymbol',
          ),
          JsdocTypeTypeof: O((l, m) => `typeof ${m(l.element)}`, 'JsdocTypeTypeof'),
          JsdocTypeUndefined: O(() => 'undefined', 'JsdocTypeUndefined'),
          JsdocTypeUnion: O((l, m) => l.elements.map(m).join(' | '), 'JsdocTypeUnion'),
          JsdocTypeUnknown: O(() => '?', 'JsdocTypeUnknown'),
          JsdocTypeIntersection: O(
            (l, m) => l.elements.map(m).join(' & '),
            'JsdocTypeIntersection',
          ),
          JsdocTypeProperty: O((l) => Ye(l.value, l.meta.quote), 'JsdocTypeProperty'),
          JsdocTypePredicate: O((l, m) => `${m(l.left)} is ${m(l.right)}`, 'JsdocTypePredicate'),
          JsdocTypeIndexSignature: O(
            (l, m) => `[${l.key}: ${m(l.right)}]`,
            'JsdocTypeIndexSignature',
          ),
          JsdocTypeMappedType: O((l, m) => `[${l.key} in ${m(l.right)}]`, 'JsdocTypeMappedType'),
          JsdocTypeAsserts: O(
            (l, m) => `asserts ${m(l.left)} is ${m(l.right)}`,
            'JsdocTypeAsserts',
          ),
          JsdocTypeReadonlyArray: O((l, m) => `readonly ${m(l.element)}`, 'JsdocTypeReadonlyArray'),
          JsdocTypeAssertsPlain: O((l, m) => `asserts ${m(l.element)}`, 'JsdocTypeAssertsPlain'),
          JsdocTypeConditional: O(
            (l, m) =>
              `${m(l.checksType)} extends ${m(l.extendsType)} ? ${m(l.trueType)} : ${m(l.falseType)}`,
            'JsdocTypeConditional',
          ),
          JsdocTypeTypeParameter: O(
            (l, m) =>
              `${m(l.name)}${l.constraint !== void 0 ? ` extends ${m(l.constraint)}` : ''}${l.defaultValue !== void 0 ? ` = ${m(l.defaultValue)}` : ''}`,
            'JsdocTypeTypeParameter',
          ),
        };
      }
      O(rn, 'stringifyRules');
      const uc = rn();
      function Wo(l) {
        return Y(uc, l);
      }
      O(Wo, 'stringify');
      const dc = [
        'null',
        'true',
        'false',
        'break',
        'case',
        'catch',
        'class',
        'const',
        'continue',
        'debugger',
        'default',
        'delete',
        'do',
        'else',
        'export',
        'extends',
        'finally',
        'for',
        'function',
        'if',
        'import',
        'in',
        'instanceof',
        'new',
        'return',
        'super',
        'switch',
        'this',
        'throw',
        'try',
        'typeof',
        'var',
        'void',
        'while',
        'with',
        'yield',
      ];
      function Xe(l) {
        const m = { type: 'NameExpression', name: l };
        return (dc.includes(l) && (m.reservedWord = !0), m);
      }
      O(Xe, 'makeName');
      const pc = {
        JsdocTypeOptional: O((l, m) => {
          const b = m(l.element);
          return ((b.optional = !0), b);
        }, 'JsdocTypeOptional'),
        JsdocTypeNullable: O((l, m) => {
          const b = m(l.element);
          return ((b.nullable = !0), b);
        }, 'JsdocTypeNullable'),
        JsdocTypeNotNullable: O((l, m) => {
          const b = m(l.element);
          return ((b.nullable = !1), b);
        }, 'JsdocTypeNotNullable'),
        JsdocTypeVariadic: O((l, m) => {
          if (l.element === void 0)
            throw new Error('dots without value are not allowed in catharsis mode');
          const b = m(l.element);
          return ((b.repeatable = !0), b);
        }, 'JsdocTypeVariadic'),
        JsdocTypeAny: O(() => ({ type: 'AllLiteral' }), 'JsdocTypeAny'),
        JsdocTypeNull: O(() => ({ type: 'NullLiteral' }), 'JsdocTypeNull'),
        JsdocTypeStringValue: O((l) => Xe(Ye(l.value, l.meta.quote)), 'JsdocTypeStringValue'),
        JsdocTypeUndefined: O(() => ({ type: 'UndefinedLiteral' }), 'JsdocTypeUndefined'),
        JsdocTypeUnknown: O(() => ({ type: 'UnknownLiteral' }), 'JsdocTypeUnknown'),
        JsdocTypeFunction: O((l, m) => {
          const b = Nt(l),
            x = { type: 'FunctionType', params: b.params.map(m) };
          return (
            b.this !== void 0 && (x.this = m(b.this)),
            b.new !== void 0 && (x.new = m(b.new)),
            l.returnType !== void 0 && (x.result = m(l.returnType)),
            x
          );
        }, 'JsdocTypeFunction'),
        JsdocTypeGeneric: O(
          (l, m) => ({
            type: 'TypeApplication',
            applications: l.elements.map((b) => m(b)),
            expression: m(l.left),
          }),
          'JsdocTypeGeneric',
        ),
        JsdocTypeSpecialNamePath: O(
          (l) => Xe(l.specialType + ':' + Ye(l.value, l.meta.quote)),
          'JsdocTypeSpecialNamePath',
        ),
        JsdocTypeName: O(
          (l) => (l.value !== 'function' ? Xe(l.value) : { type: 'FunctionType', params: [] }),
          'JsdocTypeName',
        ),
        JsdocTypeNumber: O((l) => Xe(l.value.toString()), 'JsdocTypeNumber'),
        JsdocTypeObject: O((l, m) => {
          const b = { type: 'RecordType', fields: [] };
          for (const x of l.elements)
            x.type !== 'JsdocTypeObjectField' && x.type !== 'JsdocTypeJsdocObjectField'
              ? b.fields.push({ type: 'FieldType', key: m(x), value: void 0 })
              : b.fields.push(m(x));
          return b;
        }, 'JsdocTypeObject'),
        JsdocTypeObjectField: O((l, m) => {
          if (typeof l.key != 'string')
            throw new Error('Index signatures and mapped types are not supported');
          return {
            type: 'FieldType',
            key: Xe(Ye(l.key, l.meta.quote)),
            value: l.right === void 0 ? void 0 : m(l.right),
          };
        }, 'JsdocTypeObjectField'),
        JsdocTypeJsdocObjectField: O(
          (l, m) => ({ type: 'FieldType', key: m(l.left), value: m(l.right) }),
          'JsdocTypeJsdocObjectField',
        ),
        JsdocTypeUnion: O(
          (l, m) => ({ type: 'TypeUnion', elements: l.elements.map((b) => m(b)) }),
          'JsdocTypeUnion',
        ),
        JsdocTypeKeyValue: O(
          (l, m) => ({
            type: 'FieldType',
            key: Xe(l.key),
            value: l.right === void 0 ? void 0 : m(l.right),
          }),
          'JsdocTypeKeyValue',
        ),
        JsdocTypeNamePath: O((l, m) => {
          const b = m(l.left);
          let x;
          l.right.type === 'JsdocTypeSpecialNamePath'
            ? (x = m(l.right).name)
            : (x = Ye(l.right.value, l.right.meta.quote));
          const F = l.pathType === 'inner' ? '~' : l.pathType === 'instance' ? '#' : '.';
          return Xe(`${b.name}${F}${x}`);
        }, 'JsdocTypeNamePath'),
        JsdocTypeSymbol: O((l) => {
          let m = '',
            b = l.element,
            x = !1;
          return (
            b?.type === 'JsdocTypeVariadic' &&
              (b.meta.position === 'prefix' ? (m = '...') : (x = !0), (b = b.element)),
            b?.type === 'JsdocTypeName'
              ? (m += b.value)
              : b?.type === 'JsdocTypeNumber' && (m += b.value.toString()),
            x && (m += '...'),
            Xe(`${l.value}(${m})`)
          );
        }, 'JsdocTypeSymbol'),
        JsdocTypeParenthesis: O((l, m) => m(k(l.element)), 'JsdocTypeParenthesis'),
        JsdocTypeMappedType: le,
        JsdocTypeIndexSignature: le,
        JsdocTypeImport: le,
        JsdocTypeKeyof: le,
        JsdocTypeTuple: le,
        JsdocTypeTypeof: le,
        JsdocTypeIntersection: le,
        JsdocTypeProperty: le,
        JsdocTypePredicate: le,
        JsdocTypeAsserts: le,
        JsdocTypeReadonlyArray: le,
        JsdocTypeAssertsPlain: le,
        JsdocTypeConditional: le,
        JsdocTypeTypeParameter: le,
      };
      function Ko(l) {
        return Y(pc, l);
      }
      O(Ko, 'catharsisTransform');
      function st(l) {
        switch (l) {
          case void 0:
            return 'none';
          case 'single':
            return 'single';
          case 'double':
            return 'double';
        }
      }
      O(st, 'getQuoteStyle');
      function Yo(l) {
        switch (l) {
          case 'inner':
            return 'INNER_MEMBER';
          case 'instance':
            return 'INSTANCE_MEMBER';
          case 'property':
            return 'MEMBER';
          case 'property-brackets':
            return 'MEMBER';
        }
      }
      O(Yo, 'getMemberType');
      function cr(l, m) {
        return m.length === 2
          ? { type: l, left: m[0], right: m[1] }
          : { type: l, left: m[0], right: cr(l, m.slice(1)) };
      }
      O(cr, 'nestResults');
      const fc = {
        JsdocTypeOptional: O(
          (l, m) => ({
            type: 'OPTIONAL',
            value: m(l.element),
            meta: {
              syntax: l.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN',
            },
          }),
          'JsdocTypeOptional',
        ),
        JsdocTypeNullable: O(
          (l, m) => ({
            type: 'NULLABLE',
            value: m(l.element),
            meta: {
              syntax:
                l.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK',
            },
          }),
          'JsdocTypeNullable',
        ),
        JsdocTypeNotNullable: O(
          (l, m) => ({
            type: 'NOT_NULLABLE',
            value: m(l.element),
            meta: { syntax: l.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG' },
          }),
          'JsdocTypeNotNullable',
        ),
        JsdocTypeVariadic: O((l, m) => {
          const b = {
            type: 'VARIADIC',
            meta: {
              syntax:
                l.meta.position === 'prefix'
                  ? 'PREFIX_DOTS'
                  : l.meta.position === 'suffix'
                    ? 'SUFFIX_DOTS'
                    : 'ONLY_DOTS',
            },
          };
          return (l.element !== void 0 && (b.value = m(l.element)), b);
        }, 'JsdocTypeVariadic'),
        JsdocTypeName: O((l) => ({ type: 'NAME', name: l.value }), 'JsdocTypeName'),
        JsdocTypeTypeof: O(
          (l, m) => ({ type: 'TYPE_QUERY', name: m(l.element) }),
          'JsdocTypeTypeof',
        ),
        JsdocTypeTuple: O(
          (l, m) => ({ type: 'TUPLE', entries: l.elements.map(m) }),
          'JsdocTypeTuple',
        ),
        JsdocTypeKeyof: O((l, m) => ({ type: 'KEY_QUERY', value: m(l.element) }), 'JsdocTypeKeyof'),
        JsdocTypeImport: O(
          (l) => ({
            type: 'IMPORT',
            path: {
              type: 'STRING_VALUE',
              quoteStyle: st(l.element.meta.quote),
              string: l.element.value,
            },
          }),
          'JsdocTypeImport',
        ),
        JsdocTypeUndefined: O(() => ({ type: 'NAME', name: 'undefined' }), 'JsdocTypeUndefined'),
        JsdocTypeAny: O(() => ({ type: 'ANY' }), 'JsdocTypeAny'),
        JsdocTypeFunction: O((l, m) => {
          const b = Nt(l),
            x = {
              type: l.arrow ? 'ARROW' : 'FUNCTION',
              params: b.params.map((F) => {
                if (F.type === 'JsdocTypeKeyValue') {
                  if (F.right === void 0)
                    throw new Error(
                      "Function parameter without ':' is not expected to be 'KEY_VALUE'",
                    );
                  return { type: 'NAMED_PARAMETER', name: F.key, typeName: m(F.right) };
                } else return m(F);
              }),
              new: null,
              returns: null,
            };
          return (
            b.this !== void 0 ? (x.this = m(b.this)) : l.arrow || (x.this = null),
            b.new !== void 0 && (x.new = m(b.new)),
            l.returnType !== void 0 && (x.returns = m(l.returnType)),
            x
          );
        }, 'JsdocTypeFunction'),
        JsdocTypeGeneric: O((l, m) => {
          const b = {
            type: 'GENERIC',
            subject: m(l.left),
            objects: l.elements.map(m),
            meta: {
              syntax:
                l.meta.brackets === 'square'
                  ? 'SQUARE_BRACKET'
                  : l.meta.dot
                    ? 'ANGLE_BRACKET_WITH_DOT'
                    : 'ANGLE_BRACKET',
            },
          };
          return (
            l.meta.brackets === 'square' &&
              l.elements[0].type === 'JsdocTypeFunction' &&
              !l.elements[0].parenthesis &&
              (b.objects[0] = { type: 'NAME', name: 'function' }),
            b
          );
        }, 'JsdocTypeGeneric'),
        JsdocTypeObjectField: O((l, m) => {
          if (typeof l.key != 'string')
            throw new Error('Index signatures and mapped types are not supported');
          if (l.right === void 0)
            return {
              type: 'RECORD_ENTRY',
              key: l.key,
              quoteStyle: st(l.meta.quote),
              value: null,
              readonly: !1,
            };
          let b = m(l.right);
          return (
            l.optional &&
              (b = { type: 'OPTIONAL', value: b, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
            {
              type: 'RECORD_ENTRY',
              key: l.key.toString(),
              quoteStyle: st(l.meta.quote),
              value: b,
              readonly: !1,
            }
          );
        }, 'JsdocTypeObjectField'),
        JsdocTypeJsdocObjectField: O(() => {
          throw new Error('Keys may not be typed in jsdoctypeparser.');
        }, 'JsdocTypeJsdocObjectField'),
        JsdocTypeKeyValue: O((l, m) => {
          if (l.right === void 0)
            return {
              type: 'RECORD_ENTRY',
              key: l.key,
              quoteStyle: 'none',
              value: null,
              readonly: !1,
            };
          let b = m(l.right);
          return (
            l.optional &&
              (b = { type: 'OPTIONAL', value: b, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
            { type: 'RECORD_ENTRY', key: l.key, quoteStyle: 'none', value: b, readonly: !1 }
          );
        }, 'JsdocTypeKeyValue'),
        JsdocTypeObject: O((l, m) => {
          const b = [];
          for (const x of l.elements)
            (x.type === 'JsdocTypeObjectField' || x.type === 'JsdocTypeJsdocObjectField') &&
              b.push(m(x));
          return { type: 'RECORD', entries: b };
        }, 'JsdocTypeObject'),
        JsdocTypeSpecialNamePath: O((l) => {
          if (l.specialType !== 'module')
            throw new Error(
              `jsdoctypeparser does not support type ${l.specialType} at this point.`,
            );
          return {
            type: 'MODULE',
            value: { type: 'FILE_PATH', quoteStyle: st(l.meta.quote), path: l.value },
          };
        }, 'JsdocTypeSpecialNamePath'),
        JsdocTypeNamePath: O((l, m) => {
          let b = !1,
            x,
            F;
          l.right.type === 'JsdocTypeSpecialNamePath' && l.right.specialType === 'event'
            ? ((b = !0), (x = l.right.value), (F = st(l.right.meta.quote)))
            : ((x = l.right.value), (F = st(l.right.meta.quote)));
          const z = {
            type: Yo(l.pathType),
            owner: m(l.left),
            name: x,
            quoteStyle: F,
            hasEventPrefix: b,
          };
          if (z.owner.type === 'MODULE') {
            const Z = z.owner;
            return ((z.owner = z.owner.value), (Z.value = z), Z);
          } else return z;
        }, 'JsdocTypeNamePath'),
        JsdocTypeUnion: O((l, m) => cr('UNION', l.elements.map(m)), 'JsdocTypeUnion'),
        JsdocTypeParenthesis: O(
          (l, m) => ({ type: 'PARENTHESIS', value: m(k(l.element)) }),
          'JsdocTypeParenthesis',
        ),
        JsdocTypeNull: O(() => ({ type: 'NAME', name: 'null' }), 'JsdocTypeNull'),
        JsdocTypeUnknown: O(() => ({ type: 'UNKNOWN' }), 'JsdocTypeUnknown'),
        JsdocTypeStringValue: O(
          (l) => ({ type: 'STRING_VALUE', quoteStyle: st(l.meta.quote), string: l.value }),
          'JsdocTypeStringValue',
        ),
        JsdocTypeIntersection: O(
          (l, m) => cr('INTERSECTION', l.elements.map(m)),
          'JsdocTypeIntersection',
        ),
        JsdocTypeNumber: O(
          (l) => ({ type: 'NUMBER_VALUE', number: l.value.toString() }),
          'JsdocTypeNumber',
        ),
        JsdocTypeSymbol: le,
        JsdocTypeProperty: le,
        JsdocTypePredicate: le,
        JsdocTypeMappedType: le,
        JsdocTypeIndexSignature: le,
        JsdocTypeAsserts: le,
        JsdocTypeReadonlyArray: le,
        JsdocTypeAssertsPlain: le,
        JsdocTypeConditional: le,
        JsdocTypeTypeParameter: le,
      };
      function Xo(l) {
        return Y(fc, l);
      }
      O(Xo, 'jtpTransform');
      function Qo() {
        return {
          JsdocTypeIntersection: O(
            (l, m) => ({ type: 'JsdocTypeIntersection', elements: l.elements.map(m) }),
            'JsdocTypeIntersection',
          ),
          JsdocTypeGeneric: O(
            (l, m) => ({
              type: 'JsdocTypeGeneric',
              left: m(l.left),
              elements: l.elements.map(m),
              meta: { dot: l.meta.dot, brackets: l.meta.brackets },
            }),
            'JsdocTypeGeneric',
          ),
          JsdocTypeNullable: O((l) => l, 'JsdocTypeNullable'),
          JsdocTypeUnion: O(
            (l, m) => ({ type: 'JsdocTypeUnion', elements: l.elements.map(m) }),
            'JsdocTypeUnion',
          ),
          JsdocTypeUnknown: O((l) => l, 'JsdocTypeUnknown'),
          JsdocTypeUndefined: O((l) => l, 'JsdocTypeUndefined'),
          JsdocTypeTypeof: O(
            (l, m) => ({ type: 'JsdocTypeTypeof', element: m(l.element) }),
            'JsdocTypeTypeof',
          ),
          JsdocTypeSymbol: O((l, m) => {
            const b = { type: 'JsdocTypeSymbol', value: l.value };
            return (l.element !== void 0 && (b.element = m(l.element)), b);
          }, 'JsdocTypeSymbol'),
          JsdocTypeOptional: O(
            (l, m) => ({
              type: 'JsdocTypeOptional',
              element: m(l.element),
              meta: { position: l.meta.position },
            }),
            'JsdocTypeOptional',
          ),
          JsdocTypeObject: O(
            (l, m) => ({
              type: 'JsdocTypeObject',
              meta: { separator: 'comma' },
              elements: l.elements.map(m),
            }),
            'JsdocTypeObject',
          ),
          JsdocTypeNumber: O((l) => l, 'JsdocTypeNumber'),
          JsdocTypeNull: O((l) => l, 'JsdocTypeNull'),
          JsdocTypeNotNullable: O(
            (l, m) => ({
              type: 'JsdocTypeNotNullable',
              element: m(l.element),
              meta: { position: l.meta.position },
            }),
            'JsdocTypeNotNullable',
          ),
          JsdocTypeSpecialNamePath: O((l) => l, 'JsdocTypeSpecialNamePath'),
          JsdocTypeObjectField: O(
            (l, m) => ({
              type: 'JsdocTypeObjectField',
              key: l.key,
              right: l.right === void 0 ? void 0 : m(l.right),
              optional: l.optional,
              readonly: l.readonly,
              meta: l.meta,
            }),
            'JsdocTypeObjectField',
          ),
          JsdocTypeJsdocObjectField: O(
            (l, m) => ({ type: 'JsdocTypeJsdocObjectField', left: m(l.left), right: m(l.right) }),
            'JsdocTypeJsdocObjectField',
          ),
          JsdocTypeKeyValue: O(
            (l, m) => ({
              type: 'JsdocTypeKeyValue',
              key: l.key,
              right: l.right === void 0 ? void 0 : m(l.right),
              optional: l.optional,
              variadic: l.variadic,
            }),
            'JsdocTypeKeyValue',
          ),
          JsdocTypeImport: O(
            (l, m) => ({ type: 'JsdocTypeImport', element: m(l.element) }),
            'JsdocTypeImport',
          ),
          JsdocTypeAny: O((l) => l, 'JsdocTypeAny'),
          JsdocTypeStringValue: O((l) => l, 'JsdocTypeStringValue'),
          JsdocTypeNamePath: O((l) => l, 'JsdocTypeNamePath'),
          JsdocTypeVariadic: O((l, m) => {
            const b = {
              type: 'JsdocTypeVariadic',
              meta: { position: l.meta.position, squareBrackets: l.meta.squareBrackets },
            };
            return (l.element !== void 0 && (b.element = m(l.element)), b);
          }, 'JsdocTypeVariadic'),
          JsdocTypeTuple: O(
            (l, m) => ({ type: 'JsdocTypeTuple', elements: l.elements.map(m) }),
            'JsdocTypeTuple',
          ),
          JsdocTypeName: O((l) => l, 'JsdocTypeName'),
          JsdocTypeFunction: O((l, m) => {
            const b = {
              type: 'JsdocTypeFunction',
              arrow: l.arrow,
              parameters: l.parameters.map(m),
              constructor: l.constructor,
              parenthesis: l.parenthesis,
            };
            return (l.returnType !== void 0 && (b.returnType = m(l.returnType)), b);
          }, 'JsdocTypeFunction'),
          JsdocTypeKeyof: O(
            (l, m) => ({ type: 'JsdocTypeKeyof', element: m(l.element) }),
            'JsdocTypeKeyof',
          ),
          JsdocTypeParenthesis: O(
            (l, m) => ({ type: 'JsdocTypeParenthesis', element: m(l.element) }),
            'JsdocTypeParenthesis',
          ),
          JsdocTypeProperty: O((l) => l, 'JsdocTypeProperty'),
          JsdocTypePredicate: O(
            (l, m) => ({ type: 'JsdocTypePredicate', left: m(l.left), right: m(l.right) }),
            'JsdocTypePredicate',
          ),
          JsdocTypeIndexSignature: O(
            (l, m) => ({ type: 'JsdocTypeIndexSignature', key: l.key, right: m(l.right) }),
            'JsdocTypeIndexSignature',
          ),
          JsdocTypeMappedType: O(
            (l, m) => ({ type: 'JsdocTypeMappedType', key: l.key, right: m(l.right) }),
            'JsdocTypeMappedType',
          ),
          JsdocTypeAsserts: O(
            (l, m) => ({ type: 'JsdocTypeAsserts', left: m(l.left), right: m(l.right) }),
            'JsdocTypeAsserts',
          ),
          JsdocTypeReadonlyArray: O(
            (l, m) => ({ type: 'JsdocTypeReadonlyArray', element: m(l.element) }),
            'JsdocTypeReadonlyArray',
          ),
          JsdocTypeAssertsPlain: O(
            (l, m) => ({ type: 'JsdocTypeAssertsPlain', element: m(l.element) }),
            'JsdocTypeAssertsPlain',
          ),
          JsdocTypeConditional: O(
            (l, m) => ({
              type: 'JsdocTypeConditional',
              checksType: m(l.checksType),
              extendsType: m(l.extendsType),
              trueType: m(l.trueType),
              falseType: m(l.falseType),
            }),
            'JsdocTypeConditional',
          ),
          JsdocTypeTypeParameter: O(
            (l, m) => ({
              type: 'JsdocTypeTypeParameter',
              name: m(l.name),
              constraint: l.constraint !== void 0 ? m(l.constraint) : void 0,
              defaultValue: l.defaultValue !== void 0 ? m(l.defaultValue) : void 0,
            }),
            'JsdocTypeTypeParameter',
          ),
        };
      }
      O(Qo, 'identityTransformRules');
      const Zo = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ['parameters', 'returnType'],
        JsdocTypeGeneric: ['left', 'elements'],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ['right'],
        JsdocTypeIntersection: ['elements'],
        JsdocTypeKeyof: ['element'],
        JsdocTypeKeyValue: ['right'],
        JsdocTypeMappedType: ['right'],
        JsdocTypeName: [],
        JsdocTypeNamePath: ['left', 'right'],
        JsdocTypeNotNullable: ['element'],
        JsdocTypeNull: [],
        JsdocTypeNullable: ['element'],
        JsdocTypeNumber: [],
        JsdocTypeObject: ['elements'],
        JsdocTypeObjectField: ['right'],
        JsdocTypeJsdocObjectField: ['left', 'right'],
        JsdocTypeOptional: ['element'],
        JsdocTypeParenthesis: ['element'],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ['element'],
        JsdocTypeTuple: ['elements'],
        JsdocTypeTypeof: ['element'],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ['elements'],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ['element'],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ['left', 'right'],
        JsdocTypeAsserts: ['left', 'right'],
        JsdocTypeReadonlyArray: ['element'],
        JsdocTypeAssertsPlain: ['element'],
        JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],
        JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue'],
      };
      function ur(l, m, b, x, F) {
        x?.(l, m, b);
        const z = Zo[l.type];
        for (const Z of z) {
          const ce = l[Z];
          if (ce !== void 0)
            if (Array.isArray(ce)) for (const _e of ce) ur(_e, l, Z, x, F);
            else ur(ce, l, Z, x, F);
        }
        F?.(l, m, b);
      }
      O(ur, '_traverse');
      function ei(l, m, b) {
        ur(l, void 0, void 0, m, b);
      }
      (O(ei, 'traverse'),
        (r.catharsisTransform = Ko),
        (r.identityTransformRules = Qo),
        (r.jtpTransform = Xo),
        (r.parse = lr),
        (r.stringify = Wo),
        (r.stringifyRules = rn),
        (r.transform = Y),
        (r.traverse = ei),
        (r.tryParse = tn),
        (r.visitorKeys = Zo));
    });
  },
});
const { UnknownArgTypesError: IG } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__,
  { UnknownArgTypesError: MG } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
var PH = ['null', 'undefined'];
function lc(e) {
  return PH.some((t) => t === e);
}
O(lc, 'isDefaultValueBlacklisted');
var AH = O((e) => {
  if (!e) return '';
  if (typeof e == 'string') return e;
  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);
}, 'str');
function rh(e) {
  return !!e.__docgenInfo;
}
O(rh, 'hasDocgen');
function OH(e) {
  return e != null && Object.keys(e).length > 0;
}
O(OH, 'isValidDocgenSection');
function CH(e, t) {
  return rh(e) ? e.__docgenInfo[t] : null;
}
O(CH, 'getDocgenSection');
function iN(e) {
  return rh(e) ? AH(e.__docgenInfo.description) : '';
}
O(iN, 'getDocgenDescription');
var Jr;
(function (e) {
  ((e.start = '/**'), (e.nostart = '/***'), (e.delim = '*'), (e.end = '*/'));
})((Jr = Jr || (Jr = {})));
function sN(e) {
  return /^\s+$/.test(e);
}
O(sN, 'isSpace');
function aN(e) {
  const t = e.match(/\r+$/);
  return t == null ? ['', e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];
}
O(aN, 'splitCR');
function hn(e) {
  const t = e.match(/^\s+/);
  return t == null ? ['', e] : [e.slice(0, t[0].length), e.slice(t[0].length)];
}
O(hn, 'splitSpace');
function lN(e) {
  return e.split(/\n/);
}
O(lN, 'splitLines');
function cN(e = {}) {
  return Object.assign(
    { tag: '', name: '', type: '', optional: !1, description: '', problems: [], source: [] },
    e,
  );
}
O(cN, 'seedSpec');
function uN(e = {}) {
  return Object.assign(
    {
      start: '',
      delimiter: '',
      postDelimiter: '',
      tag: '',
      postTag: '',
      name: '',
      postName: '',
      type: '',
      postType: '',
      description: '',
      end: '',
      lineEnd: '',
    },
    e,
  );
}
O(uN, 'seedTokens');
var xH = /^@\S+/;
function dN({ fence: e = '```' } = {}) {
  const t = pN(e),
    r = O((n, i) => (t(n) ? !i : i), 'toggleFence');
  return O(function (i) {
    const s = [[]];
    let a = !1;
    for (const c of i)
      (xH.test(c.tokens.description) && !a ? s.push([c]) : s[s.length - 1].push(c),
        (a = r(c.tokens.description, a)));
    return s;
  }, 'parseBlock');
}
O(dN, 'getParser');
function pN(e) {
  return typeof e == 'string' ? (t) => t.split(e).length % 2 === 0 : e;
}
O(pN, 'getFencer');
function fN({ startLine: e = 0, markers: t = Jr } = {}) {
  let r = null,
    n = e;
  return O(function (s) {
    let a = s;
    const c = uN();
    if (
      (([c.lineEnd, a] = aN(a)),
      ([c.start, a] = hn(a)),
      r === null &&
        a.startsWith(t.start) &&
        !a.startsWith(t.nostart) &&
        ((r = []),
        (c.delimiter = a.slice(0, t.start.length)),
        (a = a.slice(t.start.length)),
        ([c.postDelimiter, a] = hn(a))),
      r === null)
    )
      return (n++, null);
    const d = a.trimRight().endsWith(t.end);
    if (
      (c.delimiter === '' &&
        a.startsWith(t.delim) &&
        !a.startsWith(t.end) &&
        ((c.delimiter = t.delim), (a = a.slice(t.delim.length)), ([c.postDelimiter, a] = hn(a))),
      d)
    ) {
      const u = a.trimRight();
      ((c.end = a.slice(u.length - t.end.length)), (a = u.slice(0, -t.end.length)));
    }
    if (((c.description = a), r.push({ number: n, source: s, tokens: c }), n++, d)) {
      const u = r.slice();
      return ((r = null), u);
    }
    return null;
  }, 'parseSource');
}
O(fN, 'getParser');
function mN({ tokenizers: e }) {
  return O(function (r) {
    var n;
    let i = cN({ source: r });
    for (const s of e)
      if (
        ((i = s(i)),
        !((n = i.problems[i.problems.length - 1]) === null || n === void 0) && n.critical)
      )
        break;
    return i;
  }, 'parseSpec');
}
O(mN, 'getParser');
function yN() {
  return (e) => {
    const { tokens: t } = e.source[0],
      r = t.description.match(/\s*(@(\S+))(\s*)/);
    return r === null
      ? (e.problems.push({
          code: 'spec:tag:prefix',
          message: 'tag should start with "@" symbol',
          line: e.source[0].number,
          critical: !0,
        }),
        e)
      : ((t.tag = r[1]),
        (t.postTag = r[3]),
        (t.description = t.description.slice(r[0].length)),
        (e.tag = r[2]),
        e);
  };
}
O(yN, 'tagTokenizer');
function hN(e = 'compact') {
  const t = gN(e);
  return (r) => {
    let n = 0,
      i = [];
    for (const [c, { tokens: d }] of r.source.entries()) {
      let u = '';
      if (c === 0 && d.description[0] !== '{') return r;
      for (const p of d.description)
        if ((p === '{' && n++, p === '}' && n--, (u += p), n === 0)) break;
      if ((i.push([d, u]), n === 0)) break;
    }
    if (n !== 0)
      return (
        r.problems.push({
          code: 'spec:type:unpaired-curlies',
          message: 'unpaired curlies',
          line: r.source[0].number,
          critical: !0,
        }),
        r
      );
    const s = [],
      a = i[0][0].postDelimiter.length;
    for (const [c, [d, u]] of i.entries())
      ((d.type = u),
        c > 0 &&
          ((d.type = d.postDelimiter.slice(a) + u),
          (d.postDelimiter = d.postDelimiter.slice(0, a))),
        ([d.postType, d.description] = hn(d.description.slice(u.length))),
        s.push(d.type));
    return (
      (s[0] = s[0].slice(1)),
      (s[s.length - 1] = s[s.length - 1].slice(0, -1)),
      (r.type = t(s)),
      r
    );
  };
}
O(hN, 'typeTokenizer');
var NH = O((e) => e.trim(), 'trim');
function gN(e) {
  return e === 'compact'
    ? (t) => t.map(NH).join('')
    : e === 'preserve'
      ? (t) =>
          t.join(`
`)
      : e;
}
O(gN, 'getJoiner');
var IH = O((e) => e && e.startsWith('"') && e.endsWith('"'), 'isQuoted');
function bN() {
  const e = O((t, { tokens: r }, n) => (r.type === '' ? t : n), 'typeEnd');
  return (t) => {
    const { tokens: r } = t.source[t.source.reduce(e, 0)],
      n = r.description.trimLeft(),
      i = n.split('"');
    if (i.length > 1 && i[0] === '' && i.length % 2 === 1)
      return (
        (t.name = i[1]),
        (r.name = `"${i[1]}"`),
        ([r.postName, r.description] = hn(n.slice(r.name.length))),
        t
      );
    let s = 0,
      a = '',
      c = !1,
      d;
    for (const p of n) {
      if (s === 0 && sN(p)) break;
      (p === '[' && s++, p === ']' && s--, (a += p));
    }
    if (s !== 0)
      return (
        t.problems.push({
          code: 'spec:name:unpaired-brackets',
          message: 'unpaired brackets',
          line: t.source[0].number,
          critical: !0,
        }),
        t
      );
    const u = a;
    if (a[0] === '[' && a[a.length - 1] === ']') {
      ((c = !0), (a = a.slice(1, -1)));
      const p = a.split('=');
      if (((a = p[0].trim()), p[1] !== void 0 && (d = p.slice(1).join('=').trim()), a === ''))
        return (
          t.problems.push({
            code: 'spec:name:empty-name',
            message: 'empty name',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
      if (d === '')
        return (
          t.problems.push({
            code: 'spec:name:empty-default',
            message: 'empty default value',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
      if (!IH(d) && /=(?!>)/.test(d))
        return (
          t.problems.push({
            code: 'spec:name:invalid-default',
            message: 'invalid default value syntax',
            line: t.source[0].number,
            critical: !0,
          }),
          t
        );
    }
    return (
      (t.optional = c),
      (t.name = a),
      (r.name = u),
      d !== void 0 && (t.default = d),
      ([r.postName, r.description] = hn(n.slice(r.name.length))),
      t
    );
  };
}
O(bN, 'nameTokenizer');
function vN(e = 'compact', t = Jr) {
  const r = nh(e);
  return (n) => ((n.description = r(n.source, t)), n);
}
O(vN, 'descriptionTokenizer');
function nh(e) {
  return e === 'compact' ? EN : e === 'preserve' ? TN : e;
}
O(nh, 'getJoiner');
function EN(e, t = Jr) {
  return e
    .map(({ tokens: { description: r } }) => r.trim())
    .filter((r) => r !== '')
    .join(' ');
}
O(EN, 'compactJoiner');
var MH = O((e, { tokens: t }, r) => (t.type === '' ? e : r), 'lineNo'),
  qH = O(
    ({ tokens: e }) => (e.delimiter === '' ? e.start : e.postDelimiter.slice(1)) + e.description,
    'getDescription',
  );
function TN(e, t = Jr) {
  if (e.length === 0) return '';
  e[0].tokens.description === '' && e[0].tokens.delimiter === t.start && (e = e.slice(1));
  const r = e[e.length - 1];
  return (
    r !== void 0 &&
      r.tokens.description === '' &&
      r.tokens.end.endsWith(t.end) &&
      (e = e.slice(0, -1)),
    (e = e.slice(e.reduce(MH, 0))),
    e.map(qH).join(`
`)
  );
}
O(TN, 'preserveJoiner');
function wN({
  startLine: e = 0,
  fence: t = '```',
  spacing: r = 'compact',
  markers: n = Jr,
  tokenizers: i = [yN(), hN(r), bN(), vN(r)],
} = {}) {
  if (e < 0 || e % 1 > 0) throw new Error('Invalid startLine');
  const s = fN({ startLine: e, markers: n }),
    a = dN({ fence: t }),
    c = mN({ tokenizers: i }),
    d = nh(r);
  return function (u) {
    const p = [];
    for (const f of lN(u)) {
      const y = s(f);
      if (y === null) continue;
      const h = a(y),
        g = h.slice(1).map(c);
      p.push({
        description: d(h[0], n),
        tags: g,
        source: y,
        problems: g.reduce((T, E) => T.concat(E.problems), []),
      });
    }
    return p;
  };
}
O(wN, 'getParser');
function SN(e) {
  return (
    e.start +
    e.delimiter +
    e.postDelimiter +
    e.tag +
    e.postTag +
    e.type +
    e.postType +
    e.name +
    e.postName +
    e.description +
    e.end +
    e.lineEnd
  );
}
O(SN, 'join');
function jH() {
  return (e) =>
    e.source.map(({ tokens: t }) => SN(t)).join(`
`);
}
O(jH, 'getStringifier');
function _N(e, t = {}) {
  return wN(t)(e);
}
O(_N, 'parse');
var oh = EH(RH());
function RN(e) {
  return e != null && e.includes('@');
}
O(RN, 'containsJsDoc');
function PN(e) {
  const n =
      `/**
` +
      (e ?? '')
        .split(
          `
`,
        )
        .map((s) => ` * ${s}`).join(`
`) +
      `
*/`,
    i = _N(n, { spacing: 'preserve' });
  if (!i || i.length === 0) throw new Error('Cannot parse JSDoc tags.');
  return i[0];
}
O(PN, 'parse');
var kH = { tags: ['param', 'arg', 'argument', 'returns', 'ignore', 'deprecated'] },
  DH = O((e, t = kH) => {
    if (!RN(e)) return { includesJsDoc: !1, ignore: !1 };
    const r = PN(e),
      n = AN(r, t.tags);
    return n.ignore
      ? { includesJsDoc: !0, ignore: !0 }
      : { includesJsDoc: !0, ignore: !1, description: r.description.trim(), extractedTags: n };
  }, 'parseJsDoc');
function AN(e, t) {
  const r = { params: null, deprecated: null, returns: null, ignore: !1 };
  for (const n of e.tags)
    if (!(t !== void 0 && !t.includes(n.tag)))
      if (n.tag === 'ignore') {
        r.ignore = !0;
        break;
      } else
        switch (n.tag) {
          case 'param':
          case 'arg':
          case 'argument': {
            const i = CN(n);
            i != null && (r.params == null && (r.params = []), r.params.push(i));
            break;
          }
          case 'deprecated': {
            const i = xN(n);
            i != null && (r.deprecated = i);
            break;
          }
          case 'returns': {
            const i = NN(n);
            i != null && (r.returns = i);
            break;
          }
        }
  return r;
}
O(AN, 'extractJsDocTags');
function ON(e) {
  return e.replace(/[\.-]$/, '');
}
O(ON, 'normaliseParamName');
function CN(e) {
  if (!e.name || e.name === '-') return null;
  const t = ah(e.type);
  return {
    name: e.name,
    type: t,
    description: sh(e.description),
    getPrettyName: O(() => ON(e.name), 'getPrettyName'),
    getTypeName: O(() => (t ? lh(t) : null), 'getTypeName'),
  };
}
O(CN, 'extractParam');
function xN(e) {
  return e.name ? ih(e.name, e.description) : null;
}
O(xN, 'extractDeprecated');
function ih(e, t) {
  const r = e === '' ? t : `${e} ${t}`;
  return sh(r);
}
O(ih, 'joinNameAndDescription');
function sh(e) {
  const t = e.replace(/^- /g, '').trim();
  return t === '' ? null : t;
}
O(sh, 'normaliseDescription');
function NN(e) {
  const t = ah(e.type);
  return t
    ? {
        type: t,
        description: ih(e.name, e.description),
        getTypeName: O(() => lh(t), 'getTypeName'),
      }
    : null;
}
O(NN, 'extractReturns');
var Xr = (0, oh.stringifyRules)(),
  LH = Xr.JsdocTypeObject;
Xr.JsdocTypeAny = () => 'any';
Xr.JsdocTypeObject = (e, t) => `(${LH(e, t)})`;
Xr.JsdocTypeOptional = (e, t) => t(e.element);
Xr.JsdocTypeNullable = (e, t) => t(e.element);
Xr.JsdocTypeNotNullable = (e, t) => t(e.element);
Xr.JsdocTypeUnion = (e, t) => e.elements.map(t).join('|');
function ah(e) {
  try {
    return (0, oh.parse)(e, 'typescript');
  } catch {
    return null;
  }
}
O(ah, 'extractType');
function lh(e) {
  return (0, oh.transform)(Xr, e);
}
O(lh, 'extractTypeName');
var FH = 90,
  BH = 50;
function ch(e) {
  return e.length > FH;
}
O(ch, 'isTooLongForTypeSummary');
function IN(e) {
  return e.length > BH;
}
O(IN, 'isTooLongForDefaultValueSummary');
function nt(e, t) {
  return e === t ? { summary: e } : { summary: e, detail: t };
}
O(nt, 'createSummaryValue');
function JH(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!lc(r)) return IN(r) ? nt(t?.name, r) : nt(r);
  }
  return null;
}
O(JH, 'createDefaultValue');
function uh({ name: e, value: t, elements: r, raw: n }) {
  return t ?? (r != null ? r.map(uh).join(' | ') : (n ?? e));
}
O(uh, 'generateUnionElement');
function MN({ name: e, raw: t, elements: r }) {
  return r != null ? nt(r.map(uh).join(' | ')) : t != null ? nt(t.replace(/^\|\s*/, '')) : nt(e);
}
O(MN, 'generateUnion');
function qN({ type: e, raw: t }) {
  return t != null ? nt(t) : nt(e);
}
O(qN, 'generateFuncSignature');
function jN({ type: e, raw: t }) {
  return t != null ? (ch(t) ? nt(e, t) : nt(t)) : nt(e);
}
O(jN, 'generateObjectSignature');
function kN(e) {
  const { type: t } = e;
  return t === 'object' ? jN(e) : qN(e);
}
O(kN, 'generateSignature');
function DN({ name: e, raw: t }) {
  return t != null ? (ch(t) ? nt(e, t) : nt(t)) : nt(e);
}
O(DN, 'generateDefault');
function $H(e) {
  if (e == null) return null;
  switch (e.name) {
    case 'union':
      return MN(e);
    case 'signature':
      return kN(e);
    default:
      return DN(e);
  }
}
O($H, 'createType');
function UH({ defaultValue: e }) {
  if (e != null) {
    const { value: t } = e;
    if (!lc(t)) return nt(t);
  }
  return null;
}
O(UH, 'createDefaultValue');
function VH({ tsType: e, required: t }) {
  if (e == null) return null;
  let r = e.name;
  return (
    t || (r = r.replace(' | undefined', '')),
    nt(['Array', 'Record', 'signature'].includes(e.name) ? e.raw : r)
  );
}
O(VH, 'createType');
function LN(e) {
  return e != null ? nt(e.name) : null;
}
O(LN, 'createType');
function FN(e) {
  const { computed: t, func: r } = e;
  return typeof t > 'u' && typeof r > 'u';
}
O(FN, 'isReactDocgenTypescript');
function BN(e) {
  return e
    ? e.name === 'string'
      ? !0
      : e.name === 'enum'
        ? Array.isArray(e.value) &&
          e.value.every(
            ({ value: t }) => typeof t == 'string' && t[0] === '"' && t[t.length - 1] === '"',
          )
        : !1
    : !1;
}
O(BN, 'isStringValued');
function JN(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!lc(r)) return FN(e) && BN(t) ? nt(JSON.stringify(r)) : nt(r);
  }
  return null;
}
O(JN, 'createDefaultValue');
function HH(e, t, r) {
  const { description: n, required: i, defaultValue: s } = r;
  return { name: e, type: LN(t), required: i, description: n, defaultValue: JN(s, t) };
}
O(HH, 'createBasicPropDef');
function GH(e, t) {
  if (t?.includesJsDoc) {
    const { description: r, extractedTags: n } = t;
    r != null && (e.description = t.description);
    const i = {
      ...n,
      params: n?.params?.map((s) => ({ name: s.getPrettyName(), description: s.description })),
    };
    Object.values(i).filter(Boolean).length > 0 && (e.jsDocTags = i);
  }
  return e;
}
O(GH, 'applyJsDocResult');
function zH(e, t, r, n) {
  const i = DH(t.description);
  return i.includesJsDoc && i.ignore
    ? null
    : { propDef: n(e, t, i), jsDocTags: i.extractedTags, docgenInfo: t, typeSystem: r };
}
O(zH, 'extractProp');
function WH(e) {
  return e != null ? iN(e) : '';
}
O(WH, 'extractComponentDescription');
var $N = O((...e) => {
    const t = {},
      r = e.filter(Boolean),
      n = r.reduce(
        (i, s) => (
          Object.entries(s).forEach(([a, c]) => {
            const d = i[a];
            Array.isArray(c) || typeof d > 'u'
              ? (i[a] = c)
              : Js(c) && Js(d)
                ? (t[a] = !0)
                : typeof c < 'u' && (i[a] = c);
          }),
          i
        ),
        {},
      );
    return (
      Object.keys(t).forEach((i) => {
        const s = r
          .filter(Boolean)
          .map((a) => a[i])
          .filter((a) => typeof a < 'u');
        s.every((a) => Js(a)) ? (n[i] = $N(...s)) : (n[i] = s[s.length - 1]);
      }),
      n
    );
  }, 'combineParameters'),
  UN = O((e) => {
    const {
        component: t,
        argTypes: r,
        parameters: { docs: n = {} },
      } = e,
      { extractArgTypes: i } = n;
    if (!i || !t) return r;
    const s = i(t);
    return s ? $N(s, r) : r;
  }, 'enhanceArgTypes');
const { simulatePageLoad: KH } = __STORYBOOK_MODULE_PREVIEW_API__;
var YH = Object.defineProperty,
  XH = (e, t) => {
    for (var r in t) YH(e, r, { get: t[r], enumerable: !0 });
  };
const VN = (e, t) => {
  const { component: r, parameters: n } = t;
  if (Array.isArray(r))
    throw new Error(
      'If your story does not contain a render function, you must provide a component property!',
    );
  if (typeof r == 'string' && !customElements.get(r))
    throw new Error(
      'Stencil component not found. If you are not lazy loading your components with `defineCustomElements()` in preview.ts, pass a constructor value for component in your story `component: MyComponent`',
    );
  if (typeof r != 'string' && !customElements.getName(r))
    throw new Error(
      "Stencil component not found. If you are lazy loading your components with `defineCustomElements()` in preview.ts, pass a string value for component in your story `component: 'my-component'`",
    );
  const i = typeof r == 'string' ? r : customElements.getName(r),
    s = Object.entries(n.slots || []).map(([c, d]) => {
      const u = c === 'default' ? void 0 : c,
        p =
          typeof d == 'string'
            ? dh(void 0, { slot: u }, d)
            : { ...d, $attrs$: { ...d.$attrs$, slot: u } };
      return ((p.$tag$ = p.$tag$ || (u ? 'span' : null)), p.$tag$ ? p : p.$children$);
    }),
    a = `${i}`;
  return dh(a, { ...e }, s);
};
function HN({ storyFn: e, showMain: t, storyContext: r }, n) {
  const i = e();
  (t(),
    r.component &&
      r.component.is &&
      !customElements.get(r.component.is) &&
      customElements.define(r.component.is, r.component),
    n.firstChild && n.removeChild(n.firstChild));
  const s = document.createElement('div');
  (n.appendChild(s), ZN(i, s), KH(s));
}
var QH = {};
XH(QH, {
  argTypesEnhancers: () => zN,
  parameters: () => GN,
  render: () => VN,
  renderToCanvas: () => HN,
});
const GN = { renderer: 'stencil' },
  zN = [UN],
  qG = Object.freeze(
    Object.defineProperty(
      { __proto__: null, argTypesEnhancers: zN, parameters: GN, render: VN, renderToCanvas: HN },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  { global: Bd } = __STORYBOOK_MODULE_GLOBAL__,
  { setDefaultProjectAnnotations: jG, setProjectAnnotations: kG } =
    __STORYBOOK_MODULE_PREVIEW_API__;
function ZH(e) {
  if (!e) return !1;
  if (typeof e == 'string') return !0;
  throw new Error('Provided component needs to be a string. e.g. component: "my-element"');
}
function e3(e) {
  if (!e) return !1;
  if (e.components && Array.isArray(e.components)) return !0;
  throw new Error(
    'You need to setup valid meta data in your stencil.config.js via docs-json output target.',
  );
}
function DG(e) {
  Bd.__STORYBOOK_CUSTOM_ELEMENTS_MANIFEST__ = e;
}
function WN() {
  return Bd.__STORYBOOK_CUSTOM_ELEMENTS__ || Bd.__STORYBOOK_CUSTOM_ELEMENTS_MANIFEST__;
}
const { logger: t3 } = __STORYBOOK_MODULE_CLIENT_LOGGER__,
  r3 = (e) => {
    const t = ['string', 'number', 'boolean', 'symbol'];
    return e.type.toLowerCase() in t
      ? { name: e.type.toLowerCase(), raw: e.type, required: e.required }
      : /^\(.*\)\s*=>\s*.*$/.test(e.type)
        ? { name: 'function', raw: e.type, required: e.required }
        : { name: 'other', value: e.type, raw: e.type, required: e.required };
  },
  KN = (e) =>
    e.values.filter((t) => ['string', 'number'].includes(t.type)).map(({ value: t }) => t),
  n3 = (e) => {
    switch (e.type) {
      case 'string':
      case 'string | undefined':
        return { type: 'text' };
      case 'number':
      case 'number | undefined':
        return { type: 'number' };
      case 'boolean':
      case 'boolean | undefined':
        return { type: 'boolean' };
      case 'Date':
      case 'Date | string':
        return { type: 'date' };
      case 'function':
      case 'function | undefined':
      case 'void':
      case 'void | undefined':
        return null;
      default:
        const t = KN(e);
        return t.length === 0
          ? { type: 'object' }
          : t.length < 5
            ? { type: 'radio' }
            : { type: 'select' };
    }
  },
  cc = (e, t) => {
    if (!t || t.length === 0) return e;
    const r = [],
      n = [],
      i = t.filter((d) => d.name === 'deprecated');
    i.length > 0 &&
      i.forEach((d) => {
        d.text ? n.push(`** DEPRECATED:** ${d.text}`) : n.push('** DEPRECATED**');
      });
    const s = t.filter((d) => d.name === 'see');
    if (s.length > 0) {
      const d = s
        .map((u) => {
          const p = u.text?.trim();
          return p ? `[${p}](${p})` : '';
        })
        .filter(Boolean)
        .join(', ');
      d && r.push(`**See:** ${d}`);
    }
    const a = t.filter((d) => d.name === 'since');
    if (a.length > 0) {
      const d = a
        .map((u) => u.text)
        .filter(Boolean)
        .join(', ');
      d && r.push(`**Since:** ${d}`);
    }
    return [...n, e, ...r].filter(Boolean).join(`

`);
  },
  Jc = (e, t) =>
    e.reduce(
      (r, n) => (
        (r[n.name] = {
          name: n.name,
          description: cc(n.docs, n.docsTags),
          control: !1,
          table: { category: t },
        }),
        r
      ),
      {},
    ),
  o3 = (e) =>
    e.reduce(
      (t, r) => (
        (t[r.name] = {
          name: r.name,
          description: cc(r.docs, r.docsTags),
          control: null,
          type: { name: 'function' },
          table: { category: 'methods', type: { summary: r.signature } },
        }),
        t
      ),
      {},
    ),
  i3 = (e) =>
    e.reduce((t, r) => {
      let n = r.event
        .replace(/(-|_|:|\.|\s)+(.)?/g, (i, s, a) => (a ? a.toUpperCase() : ''))
        .replace(/^([A-Z])/, (i) => i.toLowerCase());
      return (
        (n = `on${n.charAt(0).toUpperCase() + n.slice(1)}`),
        (t[n] = {
          name: n,
          description: cc(r.docs, r.docsTags),
          control: null,
          table: { category: 'events', type: { summary: r.detail } },
          type: { name: 'function' },
        }),
        t
      );
    }, {}),
  s3 = (e) =>
    e.reduce(
      (t, r) => (
        (t[r.name] = {
          name: r.attr || r.name,
          description: cc(r.docs, r.docsTags),
          control: n3(r),
          table: {
            category: 'properties',
            type: { summary: r.complexType?.original },
            defaultValue: { summary: r.default },
          },
          options: KN(r),
          type: r3(r),
        }),
        t
      ),
      {},
    ),
  YN = (e, t) => {
    if (!ZH(e) || !e3(t)) return null;
    const r = t.components.find((n) => n.tag.toUpperCase() === e.toUpperCase());
    return (r || t3.warn(`Component not found in custom-elements.json: ${e}`), r);
  },
  a3 = (e, t) => {
    const r = YN(e, t);
    return (
      r && {
        ...s3(r.props),
        ...i3(r.events),
        ...o3(r.methods),
        ...Jc(r.slots, 'slots'),
        ...Jc(r.parts, 'parts'),
        ...Jc(r.styles, 'styles'),
      }
    );
  },
  l3 = (e) => {
    const t = WN(),
      r = typeof e == 'string' ? e : e?.is;
    return a3(r, t);
  },
  c3 = (e) => {
    const t = typeof e == 'string' ? e : e?.is,
      r = YN(t, WN());
    return r && r.docs;
  },
  u3 = { docs: { extractArgTypes: l3, extractComponentDescription: c3 } },
  d3 = [UN],
  LG = Object.freeze(
    Object.defineProperty(
      { __proto__: null, argTypesEnhancers: d3, parameters: u3 },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  );
export { eN as a, LG as b, qG as e, DG as s };
